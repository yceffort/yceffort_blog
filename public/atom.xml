<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yceffort</title>
  
  <subtitle>private blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.yceffort.kr/"/>
  <updated>2019-12-24T08:36:51.092Z</updated>
  <id>https://www.yceffort.kr/</id>
  
  <author>
    <name>yceffort</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tensorflow.js - 03. Linear Regression</title>
    <link href="https://www.yceffort.kr/2019/12/23/tensorflowjs-03-linear_regression/"/>
    <id>https://www.yceffort.kr/2019/12/23/tensorflowjs-03-linear_regression/</id>
    <published>2019-12-23T01:30:29.000Z</published>
    <updated>2019-12-24T08:36:51.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h1><p>몇 번째 선형 회귀인지 알 수 없다.</p><h2 id="01-2d-data로-예측해보기"><a href="#01-2d-data로-예측해보기" class="headerlink" title="01. 2d data로 예측해보기"></a>01. 2d data로 예측해보기</h2><p>이번 튜토리얼에서는 자동차 세트를 표현한 숫자 데이터로 예측하는 모델을 훈련시켜 봅니다.</p><p>이 연습에서는 다양한 종류의 모델을 훈련하는 공통적인 단계를 보여주고, 이에 따라 작은 데이터 세트와 간단한 모델을 사용합니다. 1차적인 목표는 Tensorflow.js의 훈련 모델과 관련된 기본적인 용어, 개념 및 신택스를 숙지하고, 추가 학습을 위한 발판을 마련하는 것입니다.</p><h2 id="02-Set-up"><a href="#02-Set-up" class="headerlink" title="02. Set up"></a>02. Set up</h2><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>TensorFlow.js Tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Import TensorFlow.js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Import tfjs-vis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.0.2/dist/tfjs-vis.umd.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Import the main script file --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Tensorflow.js<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"Hello TensorFlow"</span>);</span><br></pre></td></tr></table></figure><h2 id="03-데이터를-읽어오고-포맷팅하고-시각화-하기"><a href="#03-데이터를-읽어오고-포맷팅하고-시각화-하기" class="headerlink" title="03. 데이터를 읽어오고, 포맷팅하고, 시각화 하기"></a>03. 데이터를 읽어오고, 포맷팅하고, 시각화 하기</h2><p>가장 먼저, 데이터를 읽어오고 포맷팅하고, 시각화하여 우리가 훈련하기 좋은 모델 상태로 만들어 보자.</p><p>여기에서 <code>cars</code>데이터를 쓸 것이다. (<a href="https://storage.googleapis.com/tfjs-tutorials/carsData.json" target="_blank" rel="noopener">https://storage.googleapis.com/tfjs-tutorials/carsData.json</a>) 이 데이터에는 아주 다양한 자동차에 대한 기능들이 담겨 있다. 먼저 튜토리얼로, <code>Horsepower</code>와 <code>Miles per gallon</code> 데이터만 가져와 보고자 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the car data reduced to just the variables we are interested</span></span><br><span class="line"><span class="comment"> * and cleaned of missing data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> carsDataReq = <span class="keyword">await</span> fetch(</span><br><span class="line">    <span class="string">"https://storage.googleapis.com/tfjs-tutorials/carsData.json"</span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> carsData = <span class="keyword">await</span> carsDataReq.json();</span><br><span class="line">  <span class="keyword">const</span> cleaned = carsData</span><br><span class="line">    .map(<span class="function"><span class="params">car</span> =&gt;</span> (&#123;</span><br><span class="line">      mpg: car.Miles_per_Gallon,</span><br><span class="line">      horsepower: car.Horsepower</span><br><span class="line">    &#125;))</span><br><span class="line">    .filter(<span class="function"><span class="params">car</span> =&gt;</span> car.mpg != <span class="literal">null</span> &amp;&amp; car.horsepower != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cleaned;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>우리가 원하는 필드가 null 인 데이터들은 다 삭제했다. 이 데이터를 scatterplot에 표현해서 어떻게 나오는지 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Load and plot the original input data that we are going to train on.</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> getData();</span><br><span class="line">  <span class="keyword">const</span> values = data.map(<span class="function"><span class="params">d</span> =&gt;</span> (&#123;</span><br><span class="line">    x: d.horsepower,</span><br><span class="line">    y: d.mpg</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  tfvis.render.scatterplot(</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"Horsepower v MPG"</span> &#125;,</span><br><span class="line">    &#123; values &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      xLabel: <span class="string">"Horsepower"</span>,</span><br><span class="line">      yLabel: <span class="string">"MPG"</span>,</span><br><span class="line">      height: <span class="number">300</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// More code will be added below</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, run);</span><br></pre></td></tr></table></figure><p>페이지를 새로고침하면, 오른쪽에서 아래와 같은 <code>scatterplot</code>이 나타날 것이다. 그 데이터는 아래와 같은 형태를 띄고 있을 것이다.</p><img src="https://codelabs.developers.google.com/codelabs/tfjs-training-regression/img/6a7452e88f16d8e.png" width="800" height="600"><p>이 패널은 <code>visor</code>라고 불리우며, <a href="https://github.com/tensorflow/tfjs-vis" target="_blank" rel="noopener">tfjs-vis</a>에서 제공하는 것이다. 이 라이브러리는 데이터를 시각화하는데 도움을 준다.</p><p>일반적으로, 데이터를 다룰 때 데이터를 살펴보고 필요한 경우 정리하는 방법을 찾는 것이 좋다. 이번 데이터의 경우, 필요한 필드가 없는 데이터를 모두 제거해야 했다. 데이터를 시각화하면, 모델이 학습할 수 있는 데이터에 일정한 구조가 있는지 여부를 파악하는데 도움을 얻을 수 있다.</p><p>위 그래프에서, 마력과 MPG 사이에 부정적인 상관관계가 있음을 알 수 있었다. 즉 마력이 올라갈수록, 갤런당 마일 수가 줄어든다.</p><blockquote><p>기억하자. 데이터에 일정한 구조가 없다면 (패턴이 없다면) 그 데이터로 부터 얻을 수 있는 것은 없다.</p></blockquote><h3 id="작업의-개념화"><a href="#작업의-개념화" class="headerlink" title="작업의 개념화"></a>작업의 개념화</h3><p>방금 분석한 데이터는 아래과 같이 생겼다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mpg"</span>:<span class="number">15</span>,</span><br><span class="line">  <span class="attr">"horsepower"</span>:<span class="number">165</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mpg"</span>:<span class="number">18</span>,</span><br><span class="line">  <span class="attr">"horsepower"</span>:<span class="number">150</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mpg"</span>:<span class="number">16</span>,</span><br><span class="line">  <span class="attr">"horsepower"</span>:<span class="number">150</span>,</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>여기서 목표는 하나의 숫자, 즉 마력을 가지고 갤런당 마일수를 예측하는 것을 학습하는 것이다. 다음 섹션에서는 1:1 매핑이 중요하므로, 꼭 기억해두록 하자.</p><p>마력과 MPG로 부터 학습하여 예측하는 이러한 예제들을 해결할 수 있는 신경망을 만들어 볼 것이다. 이번 예제 에서 처럼, 정답을 가지고 있는 예제에서 학습 하는 것을 <a href="https://en.wikipedia.org/wiki/Supervised_learning" target="_blank" rel="noopener">Supervised Learning</a>이라고 한다.</p><h2 id="4-모델-아키텍쳐를-정의하기"><a href="#4-모델-아키텍쳐를-정의하기" class="headerlink" title="4. 모델 아키텍쳐를 정의하기"></a>4. 모델 아키텍쳐를 정의하기</h2><p>이 섹션에서 우리는 모델 아키텍처를 설명하는 코드를 작성할 것이다. 모델 구조는 단지 “모델이 실행 중일 때 어떤 기능이 실행될 것인가” 또는 대안적으로 “모델이 답을 계산하기 위해 어떤 알고리즘을 사용할 것인가” 정도로 이해해 두면 된다.</p><p>ML 모델은 입력을 받고 결과를 만들어 내는 알고리즘이다. 신경망을 사용할 때, 알고리즘은 결과 값을 조절하는 ‘가중치’ (숫자)를 가진 뉴런의 층이다. 훈련 과정은 그러한 무게에 대한 이상적인 ‘가중치’를 학습하게 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createModel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// sequential model 을 만든다.</span></span><br><span class="line">  <span class="keyword">const</span> model = tf.sequential();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 히든 레이어 하나를 추가한다.</span></span><br><span class="line">  model.add(tf.layers.dense(&#123; <span class="attr">inputShape</span>: [<span class="number">1</span>], <span class="attr">units</span>: <span class="number">1</span>, <span class="attr">useBias</span>: <span class="literal">true</span> &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 아웃 풋 레이어 하나를 추가한다.</span></span><br><span class="line">  model.add(tf.layers.dense(&#123; <span class="attr">units</span>: <span class="number">1</span>, <span class="attr">useBias</span>: <span class="literal">true</span> &#125;));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드는 tensorflowjs에서 만들 수 있는 가장 단순한 예제다. 코드 하나씩 살펴보자.</p><h3 id="모델-인스턴스화"><a href="#모델-인스턴스화" class="headerlink" title="모델 인스턴스화"></a>모델 인스턴스화</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> model = tf.sequential();</span><br></pre></td></tr></table></figure><p>이는 <a href="https://js.tensorflow.org/api/latest/#class:Model" target="_blank" rel="noopener">tf.Model</a>를 초기화 한다. 이 모델은 <a href="https://js.tensorflow.org/api/latest/#sequential" target="_blank" rel="noopener">sequential</a>인데, 그 이유는 입력값이 바로 출력값으로 이어지기 때문이다. 다른 종류의 모델의 경우에는 branch를 가질수 있으며, 혹은 여러개의 입력값과 출력값이 있을 수도 있다. 그러나 대부분의 경우에는 sequential일 가능성이 높다. Sequential Api는 사용하기도 더 쉽다.</p><h3 id="레이어-추가"><a href="#레이어-추가" class="headerlink" title="레이어 추가"></a>레이어 추가</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(tf.layers.dense(&#123; <span class="attr">inputShape</span>: [<span class="number">1</span>], <span class="attr">units</span>: <span class="number">1</span>, <span class="attr">useBias</span>: <span class="literal">true</span> &#125;));</span><br></pre></td></tr></table></figure><p>네트워크에 히든레이어를 추가한다. <code>dense</code> 레이어는 레이어의 일종으로, inputs에 matrix를 곱하고 (weight), 숫자를 더하는 (bias) 역할을 한다. 이 레이어가 네트워크에 첫번째에 위치하기 때문에, 우리의 입력값 <code>inputShape</code>를 정의할 필요가 있다. input으로 하나의 데이터가 들어가므로, <code>[1]</code>을 넣어둔다.</p><p><code>units</code>은 weight matrix가 얼마나 클지 정하는 역할을 한다. 여기에서 1로 설정해 두어서, 우리는 데이터의 각 데이터의 input에 1의 weight가 있다고 전달할 수 있다.</p><blockquote><p>알아두기: Dense Layer에서 useBias는 기본값으로 true이기 때문에 생략이 가능하다.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(tf.layers.dense(&#123; <span class="attr">units</span>: <span class="number">1</span> &#125;));</span><br></pre></td></tr></table></figure><p>위 코드는 아웃풋 레이어다. units을 1로 설정해서 한가지의 결과값만 나오게 한다.</p><blockquote><p>알아두기: 위 예제에서, 히든레이어는 1개의 unit이 있다고 설정해 두었기 때문에 사실 위 아웃풋 레이어는 추가할 필요가 없다. 그러나 아웃풋 레이어를 따로 정의해 둠으로써, 입력과 출력의 일대일 매핑을 유지하면서 히든 레이어 계층의 units 수를 조절할 수 있다.</p></blockquote><h3 id="인스턴스-만들기"><a href="#인스턴스-만들기" class="headerlink" title="인스턴스 만들기"></a>인스턴스 만들기</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the model</span></span><br><span class="line"><span class="keyword">const</span> model = createModel();</span><br><span class="line">tfvis.show.modelSummary(&#123; <span class="attr">name</span>: <span class="string">"Model Summary"</span> &#125;, model);</span><br></pre></td></tr></table></figure><p>위 코드를 통해서 모델을 만들고, 각 레이어별 summary를 볼 수 있다.</p><h2 id="5-학습을-위해-데이터를-준비하기"><a href="#5-학습을-위해-데이터를-준비하기" class="headerlink" title="5. 학습을 위해 데이터를 준비하기"></a>5. 학습을 위해 데이터를 준비하기</h2><p>Tensorflow.js 의 성능상으로 이점을 얻기 위해서는, 데이터를 <a href="https://developers.google.com/machine-learning/glossary/#tensor" target="_blank" rel="noopener">tensor</a>로 변환해야 한다. 또한 shuffling과 normalization를 활용하여 변환을 수행할 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 머신러닝을 위해 인풋값을 tensor로 변환한다.</span></span><br><span class="line"><span class="comment"> * 그리고 y축 데이터인 MPG 에 shuffling과 normalizing을 한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertToTensor</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// tidy를 활용하면 중간에 만들어진 tensor들을 바로 해제할 수 있다.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tf.tidy(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 데이터를 섞는다.</span></span><br><span class="line">    tf.util.shuffle(data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 데이터를 tensor로 변환한다.</span></span><br><span class="line">    <span class="keyword">const</span> inputs = data.map(<span class="function"><span class="params">d</span> =&gt;</span> d.horsepower);</span><br><span class="line">    <span class="keyword">const</span> labels = data.map(<span class="function"><span class="params">d</span> =&gt;</span> d.mpg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> inputTensor = tf.tensor2d(inputs, [inputs.length, <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> labelTensor = tf.tensor2d(labels, [labels.length, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. min-max scaling을 활용하여 데이터를 0-1사이로 만든다.</span></span><br><span class="line">    <span class="keyword">const</span> inputMax = inputTensor.max();</span><br><span class="line">    <span class="keyword">const</span> inputMin = inputTensor.min();</span><br><span class="line">    <span class="keyword">const</span> labelMax = labelTensor.max();</span><br><span class="line">    <span class="keyword">const</span> labelMin = labelTensor.min();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> normalizedInputs = inputTensor</span><br><span class="line">      .sub(inputMin)</span><br><span class="line">      .div(inputMax.sub(inputMin));</span><br><span class="line">    <span class="keyword">const</span> normalizedLabels = labelTensor</span><br><span class="line">      .sub(labelMin)</span><br><span class="line">      .div(labelMax.sub(labelMin));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      inputs: normalizedInputs,</span><br><span class="line">      labels: normalizedLabels,</span><br><span class="line">      <span class="comment">// min-max 를 반환하여 나중에도 쓸 수 있게 한다.</span></span><br><span class="line">      inputMax,</span><br><span class="line">      inputMin,</span><br><span class="line">      labelMax,</span><br><span class="line">      labelMin</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드를 살펴보자</p><h3 id="데이터-셔플"><a href="#데이터-셔플" class="headerlink" title="데이터 셔플"></a>데이터 셔플</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1. Shuffle the data</span></span><br><span class="line">tf.util.shuffle(data);</span><br></pre></td></tr></table></figure><p>학습 알고리즘에 제공할 데이터를 무작위로 섞었다. Shuffling은 모델이 실제로 훈련될때 데이터 셋이 작은 단위인 batch로 쪼개지기 때문에 매우 중요한 단계다. Shuffling은 batch에 다양한 데이터가 섞여 들어갈 수 있도록 도움을 준다. 이 과정을 거침으로써</p><ul><li>순서에 의존적이지 않는 데이터를 학습 시킬 수 있음</li><li>subgroup에 민감하지 않는 데이터를 만들 수 있음 (훈련 초기에 마력이 높은 차량만 학습할 경우, 나머지 데이터 세트 훈련에 영향을 끼치지 않는 상관관계를 학습할 수 있음)</li></ul><blockquote><p>Best Practice 1: Tensorflow.js에서 학습 알고리즘을 적용하기 전에 꼭 데이터를 셔플하도록 하자.</p></blockquote><h3 id="Tensor로-변환"><a href="#Tensor로-변환" class="headerlink" title="Tensor로 변환"></a>Tensor로 변환</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 2. Convert data to Tensor</span></span><br><span class="line"><span class="keyword">const</span> inputs = data.map(<span class="function"><span class="params">d</span> =&gt;</span> d.horsepower);</span><br><span class="line"><span class="keyword">const</span> labels = data.map(<span class="function"><span class="params">d</span> =&gt;</span> d.mpg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> inputTensor = tf.tensor2d(inputs, [inputs.length, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> labelTensor = tf.tensor2d(labels, [labels.length, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>여기서 두 개의 배열을 만들었는데, 하나는 input 이고 다른 하나는 ouput이다. 그리고 이를 각각 2d tensor로 변환하였다. 이 tensor는 각각 [num_examples, num_features_per_example]의 형태를 띌 것이다. 여기에서 inputs.length로 입력값의 개수를 넣을 수 있고, feature도 마력 하나 뿐이 므로, 1로 설정해둔다.</p><h3 id="데이터-정규화"><a href="#데이터-정규화" class="headerlink" title="데이터 정규화"></a>데이터 정규화</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inputMax = inputTensor.max();</span><br><span class="line"><span class="keyword">const</span> inputMin = inputTensor.min();</span><br><span class="line"><span class="keyword">const</span> labelMax = labelTensor.max();</span><br><span class="line"><span class="keyword">const</span> labelMin = labelTensor.min();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));</span><br><span class="line"><span class="keyword">const</span> normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));</span><br></pre></td></tr></table></figure><p>다음으로 머신러닝의 또다른 관례중 하나인 정규화를 할 것이다. <a href="https://en.wikipedia.org/wiki/Feature_scaling#Rescaling_(min-max_normalization" target="_blank" rel="noopener">min-max scaling</a>&gt;)을 활용하여 데이터를 정규화하고, 0~1 사이에 위치하도록 한다. tensorflow.js는 너무 크지 않는 숫자로 작업하도록 되어 있기 때문에 정규화가 중요하다. 데이터를 표준화하여 0~1 -1~1 사이에 위치하게 하는 것이 보통이다. 어느정도 합리적인 수준까지 데이터를 정규화 하는 습관을 갖는다면, 더욱더 성공적으로 데이터를 학습 시킬 수 있다.</p><blockquote><p>Best Practice 2: 학습 전에 꼭 데이터 정규화를 염두해둬라.몇 몇 데이터셋은 정규화가 필요없을 수 있지만, 데이터를 정규화하면 효과적인 학습을 방해하는 클래스 문제를 제거할 수 있는 경우가 많다.</p><p>데이터를 텐서로 바꾸기 전에 정규화할 수 있다. 나중에 Tensorflow.js의 벡터화를 이용하여, 루프에 대한 명시적인 코드 없이 스케일링작업을 최소화 할 수 있다.</p></blockquote><h3 id="데이터와-정규화-범위-리턴"><a href="#데이터와-정규화-범위-리턴" class="headerlink" title="데이터와 정규화 범위 리턴"></a>데이터와 정규화 범위 리턴</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  inputs: normalizedInputs,</span><br><span class="line">  labels: normalizedLabels,</span><br><span class="line">  <span class="comment">// Return the min/max bounds so we can use them later.</span></span><br><span class="line">  inputMax,</span><br><span class="line">  inputMin,</span><br><span class="line">  labelMax,</span><br><span class="line">  labelMin</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>정규화 한 값, 정규화 후 값의 범위, 그리고 정규화 이전 값의 범위 모두를 리턴한다.</p><h2 id="6-모델-훈련"><a href="#6-모델-훈련" class="headerlink" title="6. 모델 훈련"></a>6. 모델 훈련</h2><p>앞서 만든 모델과 tensor를 바탕으로 학습을 시켜보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">trainModel</span>(<span class="params">model, inputs, labels</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Prepare the model for training.</span></span><br><span class="line">  model.compile(&#123;</span><br><span class="line">    optimizer: tf.train.adam(),</span><br><span class="line">    loss: tf.losses.meanSquaredError,</span><br><span class="line">    metrics: [<span class="string">"mse"</span>]</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> batchSize = <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">const</span> epochs = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> model.fit(inputs, labels, &#123;</span><br><span class="line">    batchSize,</span><br><span class="line">    epochs,</span><br><span class="line">    shuffle: <span class="literal">true</span>,</span><br><span class="line">    callbacks: tfvis.show.fitCallbacks(</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">"Training Performance"</span> &#125;,</span><br><span class="line">      [<span class="string">"loss"</span>, <span class="string">"mse"</span>],</span><br><span class="line">      &#123; <span class="attr">height</span>: <span class="number">200</span>, <span class="attr">callbacks</span>: [<span class="string">"onEpochEnd"</span>] &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="학습-준비"><a href="#학습-준비" class="headerlink" title="학습 준비"></a>학습 준비</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare the model for training.</span></span><br><span class="line">model.compile(&#123;</span><br><span class="line">  optimizer: tf.train.adam(),</span><br><span class="line">  loss: tf.losses.meanSquaredError,</span><br><span class="line">  metrics: [<span class="string">"mse"</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>훈련 시키기에 앞서 모델을 컴파일 해야 한다. 이를 위해, 몇가지 중요한 사항을 짚고 넘어가야 한다.</p><ul><li><a href="https://developers.google.com/machine-learning/glossary/#optimizer" target="_blank" rel="noopener">optimizer</a>: 모델을 업데이트 할 때 이를 통제할 알고리즘 이다. Tensorflow.js에는 다양한 optimizer가 존재한다. 이 예제에서는 별도의 설정이 필요없고 빠르고 효과적인 adam optimizer를 사용한다.</li><li><a href="https://developers.google.com/machine-learning/glossary/#loss" target="_blank" rel="noopener">loss</a>: 이 함수는 각 배치를 얼마나 잘 학습하고 있는지 알려주는 기능을 한다. 여기에서는 <a href="https://developers.google.com/machine-learning/glossary/#MSE" target="_blank" rel="noopener">meanSquaredError</a>를 사용하여 예측과 실제가 참인지 비교한다.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> batchSize = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">const</span> epochs = <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>batchSize와 epcoch을 설정한다.</p><ul><li><a href="https://developers.google.com/machine-learning/glossary/#batch_size" target="_blank" rel="noopener">batchSize</a> 란 매 훈련시에 사용할 subset 데이터 사이즈를 의미한다. 일반적으로 32~512 정도의 사이즈를 둔다. 여기에 이상적인 크기란 따로 없으며, 다양한 배치 크기에 대한 수학적 함의는 본 튜토리얼의 범위를 벗어나는 주제다.</li><li><a href="https://developers.google.com/machine-learning/glossary/#epoch" target="_blank" rel="noopener">epoch</a> 는 모델이 전체 데이터넷을 얼마나 살펴볼 것인지 횟수를 의미한다. 여기에서는 50으로 설정하여 50회 훈련을 하도록 한다.</li></ul><h3 id="훈련-loop-시작"><a href="#훈련-loop-시작" class="headerlink" title="훈련 loop 시작"></a>훈련 loop 시작</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">await</span> model.fit(inputs, labels, &#123;</span><br><span class="line">  batchSize,</span><br><span class="line">  epochs,</span><br><span class="line">  callbacks: tfvis.show.fitCallbacks(</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"Training Performance"</span> &#125;,</span><br><span class="line">    [<span class="string">"loss"</span>, <span class="string">"mse"</span>],</span><br><span class="line">    &#123; <span class="attr">height</span>: <span class="number">200</span>, <span class="attr">callbacks</span>: [<span class="string">"onEpochEnd"</span>] &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>model.fit</code>은 훈련루프를 호출하는 함수다. 이는 비동기 함수이므로, promise가 리턴되며 호출하는 측에서는 언제 학습이 끝나는지 알 수 있다.</p><p>훈련과정을 모니터링 하기 위해, <code>model.fit</code>에 콜백함수를 넘길 수 있게 해준다. 여기에서는 <a href="https://js.tensorflow.org/api_vis/latest/#show.fitCallbacks" target="_blank" rel="noopener">tfvis.show.fitCallbacks</a> 를 활용하여 <code>loss</code>와 <code>mse</code>를 plot 차트로 그려본다.</p><h3 id="Put-it-all-together"><a href="#Put-it-all-together" class="headerlink" title="Put it all together"></a>Put it all together</h3><p>위에서 만든 함수들을 <code>run</code>함수에서 호출 하도록 해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Convert the data to a form we can use for training.</span></span><br><span class="line"><span class="keyword">const</span> tensorData = convertToTensor(data);</span><br><span class="line"><span class="keyword">const</span> &#123; inputs, labels &#125; = tensorData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Train the model</span></span><br><span class="line"><span class="keyword">await</span> trainModel(model, inputs, labels);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Done Training"</span>);</span><br></pre></td></tr></table></figure><p>새로고침하면, 아래와 같이 뜰 것이다.</p><p><img src="/images/2019/12/tfjs-training-preformance.gif" alt="tfjs-training-performance"></p><p>이는 앞서서 선언한 콜백의 작품이다. 매 epoch마다 전체 데이터의 loss와 mse의 평균을 보여주고 있다. 모델을 훈련시킬 때 마다, 점차 내려가고 있는 것을 알 수 있다. 이 경우 우리의 측정 지표는 error 이므로(mse) 점차 내려가는 것을 보아야 한다.</p><blockquote><p>경사하강에 대해 알고 싶으면, <a href="https://www.youtube.com/watch?v=IHZwWFHWa-w" target="_blank" rel="noopener">이 비디오</a>를 참고하라.</p></blockquote>]]></content>
    
    <summary type="html">
    
      Linear Regression
몇 번째 선형 회귀인지 알 수 없다.

01. 2d data로 예측해보기
이번 튜토리얼에서는 자동차 세트를 표현한 숫자 데이터로 예측하는 모델을 훈련시켜 봅니다.

이 연습에서는 다양한 종류의 모델을 훈련하는 공통적인 단계를 보여주고, 이에 따라 작은 데이터 세트와 간단한 모델을 사용합니다. 1차적인 목표는 Tensorflow.js의 훈련 모델과 관련된 기본적인 용어, 개념 및 신택스를 숙지하고, 추가 학습을 위한 발판을 마련하는 것입니다.

02. Set up
html

1
2
3
4
5
6
7
8
    
    </summary>
    
    
      <category term="machine-learning" scheme="https://www.yceffort.kr/tags/machine-learning/"/>
    
      <category term="ai" scheme="https://www.yceffort.kr/tags/ai/"/>
    
      <category term="tensorflow" scheme="https://www.yceffort.kr/tags/tensorflow/"/>
    
      <category term="tensrflowjs" scheme="https://www.yceffort.kr/tags/tensrflowjs/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js - 01. 시작하기</title>
    <link href="https://www.yceffort.kr/2019/12/20/tensorflowjs-01-get-started/"/>
    <id>https://www.yceffort.kr/2019/12/20/tensorflowjs-01-get-started/</id>
    <published>2019-12-20T04:49:06.000Z</published>
    <updated>2019-12-20T05:35:52.000Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h3 id="직접-Tensors를-사용하지-않고-머신러닝-프로그램을-작성하기"><a href="#직접-Tensors를-사용하지-않고-머신러닝-프로그램을-작성하기" class="headerlink" title="직접 Tensors를 사용하지 않고 머신러닝 프로그램을 작성하기"></a>직접 Tensors를 사용하지 않고 머신러닝 프로그램을 작성하기</h3><p>저레벨의 Tensors나 Optimizers 등을 고려하지 않고 머신러닝을 시작하고 싶나요? Tensorflow.js를 기반으로 구축한 ml5.js 라이브러리는 간결하고 접근 가능한 API 를 통해 브라우저 환경에서 머신러닝 알고리즘 및 모델에 접근할 수 있게 해줍니다.</p><p><a href="https://ml5js.org/" target="_blank" rel="noopener">ml5.js</a></p><h3 id="Tensorflow-js-설치하기"><a href="#Tensorflow-js-설치하기" class="headerlink" title="Tensorflow.js 설치하기"></a>Tensorflow.js 설치하기</h3><p>Tensors, layers, optimizers, loss functions 등의 개념에 익숙하신가요? Tensorflow.js는 자바스크립트 환경에서 신경망 네트워크 구축을 위한 유연함을 제공합니다.</p><p>Tensorflow.js를 브라우저와 node.js환경에서 어떻게 실행할 수 있는지 아래에서 확인해보세요.</p><p><a href="/2019/12/20/tensorflowjs-02-setup/">설치하기</a></p><h3 id="이미-훈련된-모델을-Tensorflow-js로-변환하기"><a href="#이미-훈련된-모델을-Tensorflow-js로-변환하기" class="headerlink" title="이미 훈련된 모델을 Tensorflow.js로 변환하기"></a>이미 훈련된 모델을 Tensorflow.js로 변환하기</h3><p>파이썬으로 사전에 훈련된 모델을 어떻게 Tensorflow.js로 변환할 수 있는지 알아보세요.</p><p><a href="https://www.tensorflow.org/js/tutorials/conversion/import_keras" target="_blank" rel="noopener">Keras Model (번역예정)</a><br><a href="https://www.tensorflow.org/js/tutorials/conversion/import_saved_model" target="_blank" rel="noopener">GraphDef Model (번역예정)</a></p><h3 id="이미-존재하는-Tensorflow-js-코드에서-배우기"><a href="#이미-존재하는-Tensorflow-js-코드에서-배우기" class="headerlink" title="이미 존재하는 Tensorflow.js 코드에서 배우기"></a>이미 존재하는 Tensorflow.js 코드에서 배우기</h3><p><code>tfjs-examples</code>는 다양한 머신러닝 과제들을 Tensorflow.js로 구현한 작은 코드 예제들을 보여줍니다.</p><p><a href="https://github.com/tensorflow/tfjs-examples" target="_blank" rel="noopener">Github에서 보기</a></p><h3 id="Tensorflow-js-모델을-시각화-하기"><a href="#Tensorflow-js-모델을-시각화-하기" class="headerlink" title="Tensorflow.js 모델을 시각화 하기"></a>Tensorflow.js 모델을 시각화 하기</h3><p><code>tfjs-vis</code> 는 브라우저에서 Tensorflow.js를 시각화 할 수 있는 작은 라이브러리 입니다.</p><h3 id="데이터를-Tensorflow-js에서-처리하기"><a href="#데이터를-Tensorflow-js에서-처리하기" class="headerlink" title="데이터를 Tensorflow.js에서 처리하기"></a>데이터를 Tensorflow.js에서 처리하기</h3><p><code>TensorFlow.js</code>는 머신러닝을 활용해 데이터를 처리할 수 있도록 도와줍니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/js/tutorials&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.tensorflow.org/js/tutorials&lt;/a&gt;을 개인적인 학습을 위해 번역한 글입니다. 정확한 번역을 위해서가 아니라, 개인적인 공부를 위해서 하는 것입니다. 오해 ㄴㄴ&lt;/p&gt;
&lt;h2 id=&quot;시작하기&quot;&gt;&lt;a href=&quot;#시작하기&quot; class=&quot;headerlink&quot; title=&quot;시작하기&quot;&gt;&lt;/a&gt;시작하기&lt;/h2&gt;&lt;p&gt;Tensorflow.js는 브라우저와 Node.js에서 머신러닝 모델을 사용하고 훈련시킬 수 있는 자바스크립트 라이브러리입니다.&lt;/p&gt;
&lt;p&gt;시작하는 다양한 방법은 아래 섹션들을 참고하세요.&lt;/p&gt;
    
    </summary>
    
    
      <category term="machine-learning" scheme="https://www.yceffort.kr/tags/machine-learning/"/>
    
      <category term="ai" scheme="https://www.yceffort.kr/tags/ai/"/>
    
      <category term="tensorflow" scheme="https://www.yceffort.kr/tags/tensorflow/"/>
    
      <category term="tensrflowjs" scheme="https://www.yceffort.kr/tags/tensrflowjs/"/>
    
  </entry>
  
  <entry>
    <title>Tensorflow.js - 02. 설치하기</title>
    <link href="https://www.yceffort.kr/2019/12/20/tensorflowjs-02-setup/"/>
    <id>https://www.yceffort.kr/2019/12/20/tensorflowjs-02-setup/</id>
    <published>2019-12-20T04:49:01.000Z</published>
    <updated>2019-12-20T05:35:46.258Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h4 id="스크립트-태그-사용하기"><a href="#스크립트-태그-사용하기" class="headerlink" title="스크립트 태그 사용하기"></a>스크립트 태그 사용하기</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linear regression 모델</span></span><br><span class="line"><span class="keyword">const</span> model = tf.sequential();</span><br><span class="line">model.add(tf.layers.dense(&#123; <span class="attr">units</span>: <span class="number">1</span>, <span class="attr">inputShape</span>: [<span class="number">1</span>] &#125;));</span><br><span class="line"></span><br><span class="line">model.compile(&#123; <span class="attr">loss</span>: <span class="string">"meanSquaredError"</span>, <span class="attr">optimizer</span>: <span class="string">"sgd"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 훈련을 위한 임의 데이터 생성</span></span><br><span class="line"><span class="keyword">const</span> xs = tf.tensor2d([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> ys = tf.tensor2d([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 기반으로 훈련시키기</span></span><br><span class="line">model.fit(xs, ys, &#123; <span class="attr">epochs</span>: <span class="number">10</span> &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 훈련한 모델을 기반으로 데이터 예측</span></span><br><span class="line">  model.predict(tf.tensor2d([<span class="number">5</span>], [<span class="number">1</span>, <span class="number">1</span>])).print();</span><br><span class="line">  <span class="comment">// dev tool에 결과 값이 나온다.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="npm을-이용해서-설치하기"><a href="#npm을-이용해서-설치하기" class="headerlink" title="npm을 이용해서 설치하기"></a>npm을 이용해서 설치하기</h3><p><code>npm cli</code>나 <code>yarn</code>둘다 활용할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @tensorflow/tfjs</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> tf <span class="keyword">from</span> <span class="string">"@tensorflow/tfjs"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linear regression 모델</span></span><br><span class="line"><span class="keyword">const</span> model = tf.sequential();</span><br><span class="line">model.add(tf.layers.dense(&#123; <span class="attr">units</span>: <span class="number">1</span>, <span class="attr">inputShape</span>: [<span class="number">1</span>] &#125;));</span><br><span class="line"></span><br><span class="line">model.compile(&#123; <span class="attr">loss</span>: <span class="string">"meanSquaredError"</span>, <span class="attr">optimizer</span>: <span class="string">"sgd"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 훈련을 위한 임의 데이터 생성</span></span><br><span class="line"><span class="keyword">const</span> xs = tf.tensor2d([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">4</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> ys = tf.tensor2d([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [<span class="number">4</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 기반으로 훈련시키기</span></span><br><span class="line">model.fit(xs, ys, &#123; <span class="attr">epochs</span>: <span class="number">10</span> &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 훈련한 모델을 기반으로 데이터 예측</span></span><br><span class="line">  model.predict(tf.tensor2d([<span class="number">5</span>], [<span class="number">1</span>, <span class="number">1</span>])).print();</span><br><span class="line">  <span class="comment">// 결과 값이 나온다.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Node-js-설치"><a href="#Node-js-설치" class="headerlink" title="Node.js 설치"></a>Node.js 설치</h3><p><code>npm cli</code>나 <code>yarn</code>둘다 활용할 수 있습니다.</p><p><strong>Option1</strong> native C++ 바인딩이 포함되어 있는 Tensorflow.js 설치</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @tensorflow/tfjs-node</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs-node</span><br></pre></td></tr></table></figure><p><strong>Option2</strong> (리눅스 만 가능) 만약 시스템에서 CUDA NVIDIA GPU를 활용 가능하다면, 더 고성능 퍼포먼스를 위해 GPU 패키지를 사용할 수도 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @tensorflow/tfjs-node-gpu</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs-node-gpu</span><br></pre></td></tr></table></figure><p><strong>Option3</strong> 순수 자바스크립트 버전 설치. 셋 중에 가장 느린 버전입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @tensorflow/tfjs</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @tensorflow/tfjs</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tf = <span class="built_in">require</span>(<span class="string">"@tensorflow/tfjs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 옵셔널</span></span><br><span class="line"><span class="comment">// '@tensorflow/tfjs-node-gpu' gpu와 사용하고 싶다면</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"@tensorflow/tfjs-node"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Train a simple model:</span></span><br><span class="line"><span class="keyword">const</span> model = tf.sequential();</span><br><span class="line">model.add(</span><br><span class="line">  tf.layers.dense(&#123; <span class="attr">units</span>: <span class="number">100</span>, <span class="attr">activation</span>: <span class="string">"relu"</span>, <span class="attr">inputShape</span>: [<span class="number">10</span>] &#125;)</span><br><span class="line">);</span><br><span class="line">model.add(tf.layers.dense(&#123; <span class="attr">units</span>: <span class="number">1</span>, <span class="attr">activation</span>: <span class="string">"linear"</span> &#125;));</span><br><span class="line">model.compile(&#123; <span class="attr">optimizer</span>: <span class="string">"sgd"</span>, <span class="attr">loss</span>: <span class="string">"meanSquaredError"</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xs = tf.randomNormal([<span class="number">100</span>, <span class="number">10</span>]);</span><br><span class="line"><span class="keyword">const</span> ys = tf.randomNormal([<span class="number">100</span>, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">model.fit(xs, ys, &#123;</span><br><span class="line">  epochs: <span class="number">100</span>,</span><br><span class="line">  callbacks: &#123;</span><br><span class="line">    onEpochEnd: <span class="function">(<span class="params">epoch, log</span>) =&gt;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Epoch <span class="subst">$&#123;epoch&#125;</span>: loss = <span class="subst">$&#123;log.loss&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>타입스크립트 환경에서 사용한다면, 그리고 프로젝트에서 strict null 체킹을 한다면<code>skipLibCheck: true</code> 을 <code>tsconfig.json</code>에 포함시켜서 컴파일 도중에 에러가 나지 않도록 처리해야 합니다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2019/12/20/tensorflowjs-01-get-started/&quot;&gt;이전글 보기&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;설치&quot;&gt;&lt;a href=&quot;#설치&quot; class=&quot;headerlink&quot; title=&quot;설치&quot;&gt;&lt;/a&gt;설치&lt;/h2&gt;&lt;h3 id=&quot;브라우저-설치&quot;&gt;&lt;a href=&quot;#브라우저-설치&quot; class=&quot;headerlink&quot; title=&quot;브라우저 설치&quot;&gt;&lt;/a&gt;브라우저 설치&lt;/h3&gt;&lt;p&gt;Tensorflow.js를 설치하는 방법은 두 가지가 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Script tag를 이용하는법&lt;/li&gt;
&lt;li&gt;npm을 이용해서 설치하고, Parcel, Webpack, Rollup 같은 빌드 툴을 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;뉴비 웹 개발자거나, 위 에서 언급한 패키지 들을 전혀 모른다면 스크립트 태그를 활용하세요. 혹은 조금 경험 이 있거나, 큰 규모의 프로그램을 계획하고 있다면 빌드 툴 활용을 검토해보세요.&lt;/p&gt;
    
    </summary>
    
    
      <category term="machine-learning" scheme="https://www.yceffort.kr/tags/machine-learning/"/>
    
      <category term="ai" scheme="https://www.yceffort.kr/tags/ai/"/>
    
      <category term="tensorflow" scheme="https://www.yceffort.kr/tags/tensorflow/"/>
    
      <category term="tensrflowjs" scheme="https://www.yceffort.kr/tags/tensrflowjs/"/>
    
  </entry>
  
  <entry>
    <title>2020년 목표</title>
    <link href="https://www.yceffort.kr/2019/12/18/goal-2020/"/>
    <id>https://www.yceffort.kr/2019/12/18/goal-2020/</id>
    <published>2019-12-18T07:38:23.000Z</published>
    <updated>2019-12-20T01:55:20.320Z</updated>
    
    <content type="html"><![CDATA[<p>Don’t do anything boring</p><h2 id="Tensorflow-JS"><a href="#Tensorflow-JS" class="headerlink" title="Tensorflow JS"></a>Tensorflow JS</h2><p>중요도: ★★★★★<br>난이도: ★★★★★</p><p>AI가 하고 싶어요 선생님… tensorflowjs 를 튜토리얼부터 따라하면서 배워보자.</p><h2 id="알고리즘-강의"><a href="#알고리즘-강의" class="headerlink" title="알고리즘 강의"></a>알고리즘 강의</h2><p><a href="https://code.plus/bundle/8" target="_blank" rel="noopener">백준강의</a></p><p>이제 알고리즘 정복할 때가 되었다. 자바스크립트와 파이썬으로 진행해볼 예정.</p><p>중요도: ★★★★<br>난이도: ★★</p><h2 id="Preference-패키지"><a href="#Preference-패키지" class="headerlink" title="Preference 패키지"></a>Preference 패키지</h2><p>terminal과 친숙해지기 위해 alias설정, git 설정 등을 모아 놓은 private repository를 만들어보고자 한다.</p><p><a href="https://blog.appkr.dev/work-n-play/dotfiles/" target="_blank" rel="noopener">https://blog.appkr.dev/work-n-play/dotfiles/</a><br><a href="https://github.com/inbeom/dotfiles" target="_blank" rel="noopener">https://github.com/inbeom/dotfiles</a><br><a href="https://github.com/boxersb/dotfiles" target="_blank" rel="noopener">https://github.com/boxersb/dotfiles</a></p><p>요런 거를 참고해보자. <code>dotfiles</code> 보다는 광범위한 영역을 커버해보고 싶다.</p><p>중요도: ★<br>난이도: ★★</p><h2 id="Resume-작성"><a href="#Resume-작성" class="headerlink" title="Resume 작성"></a>Resume 작성</h2><p>마크다운 문서로 Resume를 준비해두자. 그리고 꼭 이직은 아니더라도 한 두군데 이따금씩 넣어보면서 업계에서의 내 위치(?) 를 고민해보자.</p><p>중요도: ★★★★<br>난이도: ★</p><h2 id="Kindle"><a href="#Kindle" class="headerlink" title="Kindle"></a>Kindle</h2><p>이제 이 좁은 집에 더 이상 책 둘 곳도 없다. 이제 그냥 킨들로 읽자. 작년까지는 무식하게 많이 읽자 주의 였다면, 이제는 좀 한권씩 정독할 생각이다.</p><p>중요도: ★★★<br>난이도: ★★★★★</p><h2 id="영어-Speaking"><a href="#영어-Speaking" class="headerlink" title="영어 Speaking"></a>영어 Speaking</h2><p>영어 면접 대비인데… 당장 일하러갈일이 없어서 이건 안 할 수도 있겠다.</p><p>중요도: ★★★<br>난이도: ★</p><h2 id="앱-런칭"><a href="#앱-런칭" class="headerlink" title="앱 런칭"></a>앱 런칭</h2><p><code>flutter</code> 나 <code>react-native-app</code>으로 새롭게 앱 하나 만들어 보고 싶다. 근데 마땅히 뭘 만들어야 할지 아무생각이 없다.</p><p>중요도: ★<br>난이도: ★★★★</p>]]></content>
    
    <summary type="html">
    
      Don’t do anything boring

Tensorflow JS
중요도: ★★★★★
난이도: ★★★★★

AI가 하고 싶어요 선생님… tensorflowjs 를 튜토리얼부터 따라하면서 배워보자.

알고리즘 강의
백준강의

이제 알고리즘 정복할 때가 되었다. 자바스크립트와 파이썬으로 진행해볼 예정.

중요도: ★★★★
난이도: ★★

Preference 패키지
terminal과 친숙해지기 위해 alias설정, git 설정 등을 모아 놓은 private repository를 만들어보고자 한다.

https://blog.appkr
    
    </summary>
    
    
      <category term="diary" scheme="https://www.yceffort.kr/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>Github을 아름답게 관리하기</title>
    <link href="https://www.yceffort.kr/2019/12/18/lets-beautify-git/"/>
    <id>https://www.yceffort.kr/2019/12/18/lets-beautify-git/</id>
    <published>2019-12-18T05:31:17.000Z</published>
    <updated>2019-12-18T07:22:00.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Commit-Message"><a href="#Commit-Message" class="headerlink" title="Commit Message"></a>Commit Message</h2><p><a href="https://blog.ull.im/engineering/2019/03/10/logs-on-git.html" target="_blank" rel="noopener">좋은 git commit 메시지를 위한 영어사전</a></p><p><a href="https://meetup.toast.com/posts/106" target="_blank" rel="noopener">좋은 git 커밋 메시지를 작성하기 위한 7가지 약속</a></p><h3 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h3><p>Single Line</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[#issue number] :emoji: Commit Message</span><br></pre></td></tr></table></figure><p>Multi Line</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[#issue number] :emoji: Commit Message</span><br><span class="line">- change detail1</span><br><span class="line">- change detail2</span><br></pre></td></tr></table></figure><ul><li>Single Line 과 동일하지만, Multi Line 으로 가면 두 번째 라인은 반드시 비워둘 것</li><li>세 번째 라인부터 Change 상세를 리스트 형식으로 기술</li></ul><h2 id="Linear-History-in-git"><a href="#Linear-History-in-git" class="headerlink" title="Linear History in git"></a>Linear History in git</h2><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a>장점</h3><ol><li><strong>git bisect</strong></li><li><strong>possibility of submitting with history to another version control system like SVN</strong></li><li><strong>Documentation for the posterity</strong>. A linear history is typically easier to follow. This is similar to how you want your code to be well structured and documented: whenever someone needs to deal with it later (code or history) it is very valuable to be able to quickly understand what is going on.</li><li><strong>Improving code review efficiency and effectiveness</strong>. If a topic branch is divided into linear, logical steps, it is much easier to review it compared to reviewing a convoluted history or a squashed change-monolith (which can be overwhelming).</li><li><strong>When you need to modify the history at a later time</strong>. For instance when reverting or cherry-picking a feature in whole or in part.</li><li><strong>Scalability.</strong> Unless you strive to keep your history linear when your team grows larger (e.g. hundreds of contributors), your history can become very bloated with cross branch merges, and it can be hard for all the contributors to keep track of what is going on.</li></ol><p><a href="https://stackoverflow.com/questions/20348629/what-are-advantages-of-keeping-linear-history-in-git" target="_blank" rel="noopener">출처</a></p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>리베이스가 최고다</p><p><a href="https://dev.to/maxwell_dev/the-git-rebase-introduction-i-wish-id-had" target="_blank" rel="noopener">출처</a></p><p>간단히 요약하면, 내가 작업한 내용을 master의 최신 커밋 뒤에 이어서 붙이는 것이다.</p><p>우리의 목표</p><p><img src="https://git-scm.com/book/en/v2/images/perils-of-rebasing-5.png" alt="git-rebase"></p><ol><li>rebase 대상 브랜치 (보통은 master)를 checkout해서 pull</li><li>rebase 하려는 브랜치 (내가 작업한 브랜치)를 checkout해서 pull</li></ol><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-1.png" alt="git-rebase"><br>현재까지의 상태는 이럴 것이다.</p><ol><li><code>git rebase master</code> 를 때린다</li></ol><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-3.png" alt="git-rebase"></p><ol><li><p>컨플릭이 없다면 6번으로</p></li><li><p>컨플릭이 있다면 컨플릭을 해결한 후에 <code>git rebase --continue</code>를 한다.</p></li><li><p><code>git push origin &lt;branch&gt; --force</code>로 force push를 한다.</p></li></ol><p>리베이스는 과거 커밋을 지우고 뒤에 이어 붙인 새로운 커밋을 만들기 때문에, 저장소의 커밋 히스토리를 다시 쓰게 된다.</p>]]></content>
    
    <summary type="html">
    
      Commit Message
좋은 git commit 메시지를 위한 영어사전

좋은 git 커밋 메시지를 작성하기 위한 7가지 약속

요약
Single Line

1


[#issue number] :emoji: Commit Message


Multi Line

1
2
3


[#issue number] :emoji: Commit Message
- change detail1
- change detail2


 * Single Line 과 동일하지만, Multi Line 으로 가면 두 번째 라인은 반드시 비워둘 것
 * 세 번째 라인
    
    </summary>
    
    
      <category term="git" scheme="https://www.yceffort.kr/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>2019년 회고</title>
    <link href="https://www.yceffort.kr/2019/12/13/retrospective-2019/"/>
    <id>https://www.yceffort.kr/2019/12/13/retrospective-2019/</id>
    <published>2019-12-13T12:25:46.000Z</published>
    <updated>2019-12-18T07:22:09.928Z</updated>
    
    <content type="html"><![CDATA[<p>2019년도 이제 2주가 채 남지 않았습니다. 2019년에 대해 잠시 뒤돌아 보는 시간을 갖도록 하겠습니다.</p><h2 id="Achievement"><a href="#Achievement" class="headerlink" title="Achievement"></a>Achievement</h2><h3 id="1-퇴사-그리고-이직"><a href="#1-퇴사-그리고-이직" class="headerlink" title="1. 퇴사 그리고 이직"></a>1. 퇴사 그리고 이직</h3><p>사실 K사에 있었을 때에는, 나름에 그 다음 이직에 대한 몇가지 원칙이 있었습니다.</p><ul><li>3년을 채워서 꼭 안식월 1달을 누리기</li><li>더 돈을 많이 주고, 복지도 더 좋은 곳을 가기</li><li>웹 개발 그만 두고 다른 일하기 (Data 분석, AI frontend 등…)</li></ul><p>결론은 무엇하나 지키지 못했습니다.</p><ul><li>3년을 2달 앞두고 퇴사</li><li>돈은 더 많이 주는데, 복지가 더 좋지는 않음 (K사가 짱이었습니다)</li><li>웹 개발은 계속 (…)</li></ul><p>1번은 그다지 아쉽지 않았고 (쉬는 건 별로 좋아하지 않으므로),<br>2번도 반은 이뤘으니 그렇다 치더라도,<br>웹 개발을 계속할 줄은 몰랐습니다. 나름 웹 개발은 많이 해왔다고 자부하고 있었고, 진입장벽도 낮은 데다가 오래 일할 수 있는 분야는 아닌 거 같아서, 한참 눈돌아가던 인공지능을 하고싶어서 새로운 전환점을 갖고 싶었는데요. 시장은 만만치 않더군요. 그리고 제 스펙은 더 만만치 않았습니다.</p><p>결국 (꼬드김에 못이겨) 스타트업에 왔는데요.</p><p>얼마나 내가 개발을 못하고, 얼마나 배울 것이 많은지, 또 얼마나 잘난 사람들이 많은지 매일매일 깨닫고 있습니다.<br>솔직히, 개발자라고 말하는게 부끄러운 정도였습니다.</p><h3 id="2-석사"><a href="#2-석사" class="headerlink" title="2. 석사"></a>2. 석사</h3><p>K 대학에서 드디어 석사 졸업을 하게 되었습니다. 🚀🚀🚀🚀🚀</p><p>2년전 회사가 심심해서 &amp; 그리고 스스로 개발 경쟁력이 없는 것 같아서 시작한 기술경영과정. 나름 개발 외의 일에 머리를 굴려보고, 더 넓은 시야를 가지게 되었는데요. 2년간의 학비와 대전 교통비를 갈아넣은 결과 배운 것은 아래와 같습니다.</p><ol><li>개발이 2500배쯤은 더 재밌다</li><li>개발보다 PPT만들고 발표하는 걸 더 잘하는 거 같다 (ㄹㅇ)</li><li>인맥을 늘릴 기회는 인싸에게나 오는 것이다 (한번 아싸는 영원한 아싸)</li><li>연구하고 논문쓰는건 내가 할짓이 못된다</li></ol><p>효도의 연장선과 어줍잖은 학위부심을 얻었다는 데에서 의의를 두렵니다.</p><h3 id="3-블로그"><a href="#3-블로그" class="headerlink" title="3. 블로그"></a>3. 블로그</h3><p>2019년 막판 3달은 거지같은 졸업준비를 하느라 손 하나도 못댔는데, 블로그가 나름 유의미한 성과가 있었습니다.</p><p><img src="/images/2019/12/retro1.png" alt="retro1"></p><p>네이버 영화 댓글 크롤링하는 거에 대해 관심이 많으신가 보더라구요. 이메일로 물어보시는 분들도 있었고- 사실 이거 친구 대학원 과제 도와주려고 올린 포스팅인데, 이렇게 반응이 좋을 줄은 몰랐습니다.</p><p><a href="https://okky.kr/article/634588?note=1805107" target="_blank" rel="noopener">https://okky.kr/article/634588?note=1805107</a></p><p>이렇게 제 링크가 인용되는 것도 봤구요. 사실 별거 아닌 내용이었는데 뿌듯했습니다.</p><p>또 지난 1~2년 사이에 블록체인/비트코인을 조졌는데, 여기저기 관련해서 제 글이 떠다니더군요.</p><p><a href="http://wiki.hash.kr/index.php/%ED%99%9C%EB%8F%99%EC%A6%9D%EB%AA%85" target="_blank" rel="noopener">http://wiki.hash.kr/index.php/%ED%99%9C%EB%8F%99%EC%A6%9D%EB%AA%85</a><br><a href="http://wiki.hash.kr/index.php/%EC%A4%91%EC%9A%94%EB%8F%84%EC%A6%9D%EB%AA%85" target="_blank" rel="noopener">http://wiki.hash.kr/index.php/%EC%A4%91%EC%9A%94%EB%8F%84%EC%A6%9D%EB%AA%85</a><br><a href="https://www.moneynet.co.kr/free_board/20385461" target="_blank" rel="noopener">https://www.moneynet.co.kr/free_board/20385461</a><br><a href="https://medium.com/b-ock-chain/pow%EC%99%80-pos%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90-1851a2227074" target="_blank" rel="noopener">https://medium.com/b-ock-chain/pow%EC%99%80-pos%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90-1851a2227074</a></p><p>등 등 …</p><p>하지만 블록체인 쪽은 이제 손땠습니다. 제가 백수가 되지 않는 한에서는 다시 블록체인이나 비트코인을 쳐다볼 일은 없을 것 같습니다.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>2019년, 그래도 학교 공부만 하다가 끝장 난 줄알았는데 (실제로는 그렇지만) 다행이네요.<br>2019년 제 점수는 60점 드리겠습니다. 노력은 가상했지만, 발전했는가는 잘 모르는 한 해였습니다.</p>]]></content>
    
    <summary type="html">
    
      2019년도 이제 2주가 채 남지 않았습니다. 2019년에 대해 잠시 뒤돌아 보는 시간을 갖도록 하겠습니다.

Achievement
1. 퇴사 그리고 이직
사실 K사에 있었을 때에는, 나름에 그 다음 이직에 대한 몇가지 원칙이 있었습니다.

 * 3년을 채워서 꼭 안식월 1달을 누리기
 * 더 돈을 많이 주고, 복지도 더 좋은 곳을 가기
 * 웹 개발 그만 두고 다른 일하기 (Data 분석, AI frontend 등…)

결론은 무엇하나 지키지 못했습니다.

 * 3년을 2달 앞두고 퇴사
 * 돈은 더 많이 주는데, 복지가 더 좋지
    
    </summary>
    
    
      <category term="diary" scheme="https://www.yceffort.kr/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>리액트 텍스트 하이라이트 만들기</title>
    <link href="https://www.yceffort.kr/2019/10/15/react-text-highlight/"/>
    <id>https://www.yceffort.kr/2019/10/15/react-text-highlight/</id>
    <published>2019-10-15T01:51:36.000Z</published>
    <updated>2019-12-18T05:23:29.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="요구사항"><a href="#요구사항" class="headerlink" title="요구사항"></a>요구사항</h2><p>한 엘리먼트안에서 특정한 키워드를 다른 색싱으로 바꿔서 출력하는 것이다.</p><p>아래 예시를 살펴보자</p><h3 id="before"><a href="#before" class="headerlink" title="before"></a>before</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text&gt;카카오 페이지 카카오 스토리 카카오톡&lt;<span class="regexp">/Text&gt;</span></span><br></pre></td></tr></table></figure><h3 id="after"><a href="#after" class="headerlink" title="after"></a>after</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Text&gt;</span><br><span class="line">  &lt;Text color=<span class="string">"blue"</span>&gt;카카오 &lt;<span class="regexp">/Text&gt;페이지</span></span><br><span class="line"><span class="regexp">  &lt;Text color="blue"&gt;카카오 &lt;/</span>Text&gt;스토리</span><br><span class="line">  &lt;Text color=<span class="string">"blue"</span>&gt;카카오&lt;<span class="regexp">/Text&gt;톡</span></span><br><span class="line"><span class="regexp">&lt;/</span>Text&gt;</span><br></pre></td></tr></table></figure><h2 id="의식의-흐름"><a href="#의식의-흐름" class="headerlink" title="의식의 흐름"></a>의식의 흐름</h2><p>특정 키워드가 포함되어 있는지, 그리고 그것을 따로 뽑아 낼 수 있는 가장 간단한 방법은 무엇일까? 바로 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/split" target="_blank" rel="noopener">split</a> 일 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> splitResult = <span class="string">"카카오 페이지, 카카오 스토리, 카카오톡"</span>;</span><br><span class="line">splitResult.split(<span class="string">"카카오"</span>); <span class="comment">// ["", " 페이지, ", " 스토리, ", "톡"]</span></span><br></pre></td></tr></table></figure><p>그러나 여기서 두 가지 몰랐던 사실을 알게 된다.</p><ol><li>첫 문자에 seperator 가 동일하게 나올 경우, 앞에 “”가 무조건 나온다.</li><li>text === seperator 면 결과는 빈 문자열 두개다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> splitResult = <span class="string">"카카오"</span>;</span><br><span class="line">splitResult.split(<span class="string">"카카오"</span>); <span class="comment">//  ["", ""]</span></span><br></pre></td></tr></table></figure><blockquote><p>문자열에서 separator가 등장하면 해당 부분은 삭제되고 남은 문자열이 배열로 반환됩니다. separator가 등장하지 않거나 생략되었을 경우 배열은 원본 문자열을 유일한 원소로 가집니다. separator가 빈 문자열일 경우, str은 문자열의 모든 문자를 원소로 가지는 배열로 변환됩니다. separator가 원본 문자열의 처음이나 끝에 등장할 경우 반환되는 배열도 빈 문자열로 시작하거나 끝납니다. 그러므로 원본 문자열에 separator 하나만이 포함되어 있을 경우 빈 문자열 두 개를 원소로 가지는 배열이 반환됩니다.</p></blockquote><p>평소에 잘 몰랐던 split의 심오한 철학이 많이 있으니 가서 확인해보는 것도 좋을 듯 하다.</p><p>암튼 첫 번쨰 결과물은 이렇다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [initial, ...rest] = text.split(highlight)</span><br><span class="line">&lt;Text&gt;</span><br><span class="line">    &#123;rest.reduce(</span><br><span class="line">        (partialResult, current) =&gt;</span><br><span class="line">        [</span><br><span class="line">            ...partialResult,</span><br><span class="line">            &lt;Text</span><br><span class="line">            key=&#123;highlight + current&#125;</span><br><span class="line">            color=&#123;highlightColor&#125;</span><br><span class="line">            inlineBlock</span><br><span class="line">            size=&#123;fontSize&#125;</span><br><span class="line">            whiteSpace=<span class="string">"pre"</span></span><br><span class="line">            &gt;</span><br><span class="line">            &#123;highlight&#125;</span><br><span class="line">            &lt;<span class="regexp">/Text&gt;,</span></span><br><span class="line"><span class="regexp">            current,</span></span><br><span class="line"><span class="regexp">        ],</span></span><br><span class="line"><span class="regexp">        [initial],</span></span><br><span class="line"><span class="regexp">    )&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Text&gt;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noopener">reduce</a> 를 활용해서, 처리했다.</p><p>근데 어차피, map으로 돌면서 하는게 더 간단하지 않을까 하는 아이디어가 나왔다.</p><h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initial = text.split(highlight)</span><br><span class="line">&lt;Text&gt;</span><br><span class="line">    &#123;initial.map(<span class="function">(<span class="params">normal, i</span>) =&gt;</span></span><br><span class="line">    i &gt; <span class="number">0</span> ? (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        &lt;Text</span><br><span class="line">            key=&#123;highlight + i.toString()&#125;</span><br><span class="line">            color=&#123;highlightColor&#125;</span><br><span class="line">            inlineBlock</span><br><span class="line">            size=&#123;fontSize&#125;</span><br><span class="line">            whiteSpace=<span class="string">"pre"</span></span><br><span class="line">        &gt;</span><br><span class="line">            &#123;highlight&#125;</span><br><span class="line">        &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &#123;normal&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    ) : (</span><br><span class="line">        &lt;&gt;&#123;normal&#125;&lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    ),</span></span><br><span class="line"><span class="regexp">    )&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Text&gt;</span><br></pre></td></tr></table></figure><p><code>i &gt; 0</code> 을 처리한 이유는, 어차피 첫번째 엘리먼트는 무조건 하이라이트가 안되는 텍스트가 오기 때문이다! 첫단어가 일치하는 단어라면 “”가 올 것이고, 일치 하지 않는 단어라면 그 단어 그대로 올라오기 떄문에 첫번째 단어는 별도처리를 하지 않아도 된다.</p><p>그리고 두번째 엘리먼트 부터 해당 text가 있어서 쪼개진 단어가 올것이기 때문에, 앞에 하이라이트 텍스트를 붙여주고, 그 다음 평범한 단어를 붙여주면 된다.</p>]]></content>
    
    <summary type="html">
    
      요구사항
한 엘리먼트안에서 특정한 키워드를 다른 색싱으로 바꿔서 출력하는 것이다.

아래 예시를 살펴보자

before
1


&lt;Text&gt;카카오 페이지 카카오 스토리 카카오톡&lt;/Text&gt;


after
1
2
3
4
5


&lt;Text&gt;
  &lt;Text color=&quot;blue&quot;&gt;카카오 &lt;/Text&gt;페이지
  &lt;Text color=&quot;blue&quot;&gt;카카오 &lt;/Text&gt;스토리
  &lt;Text color=&quot;blue&quot;&gt;카카오&lt;/Text&gt;톡
&lt;/Text&gt;


의식의 흐름
특정 키워드가 포함되어 있는지, 그리고 그것을 따로 뽑아 낼 수 있는 가장 간단한 
    
    </summary>
    
    
      <category term="react" scheme="https://www.yceffort.kr/tags/react/"/>
    
      <category term="javascript" scheme="https://www.yceffort.kr/tags/javascript/"/>
    
      <category term="typescript" scheme="https://www.yceffort.kr/tags/typescript/"/>
    
      <category term="algorithm" scheme="https://www.yceffort.kr/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>typescript debounce</title>
    <link href="https://www.yceffort.kr/2019/10/14/debounce/"/>
    <id>https://www.yceffort.kr/2019/10/14/debounce/</id>
    <published>2019-10-14T00:17:00.000Z</published>
    <updated>2019-12-18T05:23:29.702Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Provide options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last func invocation.</p></blockquote><p><a href="https://lodash.com/docs/4.17.15#debounce" target="_blank" rel="noopener">출처</a></p><p>디바운스는 과다한 이벤트 로직이 실행되는 것을 방지하는 함수로, 호출이 반복되는 동안에는 반복해서 로직이 실행되는 것을 막고, 설정한 시간이 지나고 나서야 로직이 실행하게 하는 함수다. </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>&lt;<span class="title">Params</span> <span class="title">extends</span> <span class="title">any</span>[]&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  func: (...args: Params) =&gt; <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  timeout: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): (<span class="params">...args: Params</span>) =&gt; <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer: NodeJS.Timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args: Params</span>) =&gt;</span> &#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func(...args);</span><br><span class="line">    &#125;, timeout);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>즉, 반복되는 이벤트가 계속해서 실행될 때, 매번 그 이벤트를 실행하는 것이 아니라, timeout 만큼의 시간이 흐른뒤에, 이전의 이벤트를 무시하고 이벤트 하나만 실행하는 것이다.</p>]]></content>
    
    <summary type="html">
    
      Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Provide option
    
    </summary>
    
    
      <category term="typescript" scheme="https://www.yceffort.kr/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>브라우저 히스토리 조작</title>
    <link href="https://www.yceffort.kr/2019/09/30/handle-browser-history/"/>
    <id>https://www.yceffort.kr/2019/09/30/handle-browser-history/</id>
    <published>2019-09-30T00:28:48.000Z</published>
    <updated>2019-12-18T05:23:29.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="브라우저-히스토리"><a href="#브라우저-히스토리" class="headerlink" title="브라우저 히스토리"></a>브라우저 히스토리</h2><p>브라우저의 히스토리는 <code>window.history</code>안에 있다.</p><p><code>History {length: 3, scrollRestoration: &quot;auto&quot;, state: null}</code></p><p><code>length</code>만 가져올 수 있을 뿐, 실제 내부에 리스트는 가져올 수가 없는데 이는 보안상의 문제 때문이다.</p><p><code>window.history.back()</code> <code>window.history.forward()</code>는 각각 브라우저의 앞으로가기 뒤로 가기와 동일한 역할을 한다.</p><h2 id="특정-위치로-가기"><a href="#특정-위치로-가기" class="headerlink" title="특정 위치로 가기"></a>특정 위치로 가기</h2><p><code>window.history.go(n)</code> 현재 페이지의 index는 0 이라고 볼 수 있다. -1 은 바로 전 페이지, 1 은 다음 페이지라고 볼 수 있다.</p><h2 id="히스토리-추가-및-변경"><a href="#히스토리-추가-및-변경" class="headerlink" title="히스토리 추가 및 변경"></a>히스토리 추가 및 변경</h2><h3 id="pushState"><a href="#pushState" class="headerlink" title="pushState"></a>pushState</h3><p><code>window.pushState(state, title, url)</code></p><p>아래와 같이 한번 사용해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123; <span class="attr">hello</span>: <span class="string">"world"</span> &#125;, <span class="string">"title"</span>, <span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure><p>현재 있는 페이지 주소창에서 <code>hello</code>가 추가되었음을 알 수 있다. 그러나 브라우저는 이를 불러오지도 않고, 해당 주소의 존재여부도 파악하지 않는다. 그저 주소만 바뀐 것이다.</p><p>아래 프로세스를 살펴보자.</p><ol><li><code>www.google.com</code> 접속 -&gt; history: 1</li><li><code>history.pushState({ hello: &quot;world&quot; }, &quot;title&quot;, &quot;hello&quot;);</code> 입력 -&gt; 주소창: <code>google.com/hello</code> / history: 2</li><li><code>www.naver.com</code> 접속 -&gt; history: 3</li><li>뒤로가기 버튼 클릭</li><li><code>https://www.google.com/hello</code> 가 404를 띄움 -&gt; history.state에 hello: world 가 있음.</li><li>뒤로가기 버튼 클릭</li><li><code>www.google.com</code> 으로 돌아가지만, 여전히 404</li></ol><p>따라서 <code>pushState</code>는 history에 새로운 history만을 추가할 뿐, 실질적으로 페이지 이동은 일으키지 않는 다는 것을 볼 수 있다.</p><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><p>javascript object로, pushState로 새로운 히스토리를 만드는 것과 관련이 있다. 사용자가 새로운 상태로 이동할 때마다, <code>popState</code>이벤트가 발생해서, <code>state</code>의 사본을 가져온다. 파이어폭스의 경우 640k정도의 데이터를 저장할 수 있으며, 이는 브라우저를 재시작해도 사용할 수 있다. 즉, 해당 history state에서 필요한 값을 넣어두는 용도로 사용하면 좋다.</p><h4 id="title"><a href="#title" class="headerlink" title="title"></a>title</h4><p>현재 파이어폭스나 크롬에서 쓰지 않는 변수로 보인다. state의 명칭을 기록해 두는 용도로 사용하면 될 것 같다.</p><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p>새로운 history의 url을 지정한다. 이 전 예제에서도 봤던 것처럼, 브라우저는 해당 URL을 호출하지 않는다.</p><p>어째 돌아가는 모양, 주소는 바뀌지만 url을 로딩하지 않는 다는 것이 <code>window.location = &#39;#foo&#39;</code> 와 비슷해 보이는 측면이 있다. 이렇게 쓸모없어보이는 <code>pushState</code>는 아래와 같은 장점이 있다.</p><ul><li><code>pushState</code>로 생성한 URL은 현재 URL을 기준으로 한다. 반대로 window.location는 해쉬값을 지정할 경우에만 같은 document에 머물러 있다. (아무튼 URL로딩을 안함)</li><li>URL 변경이 필요 없다면, URL값을 안넣어서 변경을 안해주어도 된다. 반대로 해쉬값 지정의 경우에는 현재 해쉬값과 다른 경우에만 새로운 히스토리를 생성한다.</li><li><code>state</code> 오브젝트로 데이터를 저장할 수 있다. 반면 해쉬는 해쉬값을 활용해야 한다.</li></ul><h3 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState"></a>replaceState</h3><p><code>replaceState</code>는 <code>pushState</code>와 동작이 거의 비슷하다. 다만 히스토리를 추가하는 것이 아닌, 덮어 쓴다는 것에서 차이가 있다.</p>]]></content>
    
    <summary type="html">
    
      브라우저 히스토리
브라우저의 히스토리는 window.history안에 있다.

History {length: 3, scrollRestoration: &quot;auto&quot;, state: null}

length만 가져올 수 있을 뿐, 실제 내부에 리스트는 가져올 수가 없는데 이는 보안상의 문제 때문이다.

window.history.back() window.history.forward()는 각각 브라우저의 앞으로가기 뒤로 가기와 동일한 역할을 한다.

특정 위치로 가기
window.history.go(n) 현재 페이지의 index는 0 이라고
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.yceffort.kr/tags/javascript/"/>
    
      <category term="browser" scheme="https://www.yceffort.kr/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>타입스크립트 제네릭</title>
    <link href="https://www.yceffort.kr/2019/09/19/typescript-generic/"/>
    <id>https://www.yceffort.kr/2019/09/19/typescript-generic/</id>
    <published>2019-09-19T06:10:14.000Z</published>
    <updated>2019-09-19T07:11:02.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="제네릭이란"><a href="#제네릭이란" class="headerlink" title="제네릭이란"></a>제네릭이란</h2><p>제네릭은 클래스 내부에서 사용하는 데이터의 타입을 외부에서 지정하는 것을 의미한다. 어떤 타입의 데이터를 쓸지를, 클래스 선언부가 아니라 외부에서 결정하는 것이다. 일단 자바 코드로 한번 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&lt;String&gt; p1 = <span class="keyword">new</span> Person&lt;String&gt;();</span><br><span class="line">Person&lt;StringBuilder&gt; p1 = <span class="keyword">new</span> Person&lt;StringBuilder&gt;();</span><br></pre></td></tr></table></figure><p><code>T</code>라는 데이터 타입은 존재하지 않는다. <code>T</code>는 name의 타입으로, 아래 처럼 Person을 사용하는 곳에서 정해진다. 따라서 <code>string</code>이 될수도, <code>stringbuilder</code>가 될수도 있는 것이다.</p><p>하지만 자바스크립트에서는 제네릭을 쓸일이 없다. 타입이 없기 때문에, 타입에 맞지 않는 코딩을 한다면 런타임에서 에러가 발생한다. 하지만 타입스크립트는 정적타입 언어이기 때문에 제네릭이 필요하게 되었다.</p><h3 id="any를-그냥-쓰면-안되나"><a href="#any를-그냥-쓰면-안되나" class="headerlink" title="any를 그냥 쓰면 안되나?"></a>any를 그냥 쓰면 안되나?</h3><p>아래 코드를 살펴보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> School &#123;</span><br><span class="line">  <span class="keyword">private</span> students: <span class="built_in">any</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  go(student: <span class="built_in">any</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.students.push(student);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bye(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.students.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> school = <span class="keyword">new</span> School();</span><br><span class="line">stack.push(<span class="string">"라이오넬 멧시"</span>);</span><br><span class="line">stack.push(<span class="number">10</span>);</span><br><span class="line">stack.pop().substring(<span class="number">0</span>);</span><br><span class="line">stack.pop().substring(<span class="number">0</span>); <span class="comment">// 에러</span></span><br></pre></td></tr></table></figure><p><code>string</code>에 이어서 <code>number</code>도 일일이 대응하기 위해서는 <code>any</code>를 쓰거나, 상속을 받아야 할 것이다.</p><h3 id="typescript-문법"><a href="#typescript-문법" class="headerlink" title="typescript 문법"></a>typescript 문법</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> School&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> students: T[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  go(student: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.students.push(student);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bye(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.students.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;T&gt;</code>는 제네릭을 의미하며, 그안에 타입으로 사용될 <code>T</code>를 넣었다. 다른 문자도 되지만, 대게는 <code>T</code>를 쓰고 <code>Type Variables</code>라고 한다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberSchool = <span class="keyword">new</span> School&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> stringSchool = <span class="keyword">new</span> School&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> stringSchool = <span class="keyword">new</span> School&lt;<span class="built_in">boolean</span>&gt;();</span><br></pre></td></tr></table></figure><p>이제 각각의 타입이 선언되어 사용될 수 가 있다.</p><h3 id="함수에-써보기"><a href="#함수에-써보기" class="headerlink" title="함수에 써보기"></a>함수에 써보기</h3><p>다양한 타입의 array를 받아서 그 array의 첫번쨰를 리턴하는 함수를 만든다고 가정해보자. any를 사용한다면</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnFirstItem</span>(<span class="params">items: <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 제네릭을 쓴다면</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnFirstItem</span>&lt;<span class="title">T</span>&gt;(<span class="params">items: T[]</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">returnFirstItem&lt;<span class="built_in">number</span>&gt; [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>이 된다.</p><h3 id="여러개-Generic"><a href="#여러개-Generic" class="headerlink" title="여러개 Generic"></a>여러개 Generic</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multipleGeneric</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">a1: T, a2: U</span>): [<span class="title">T</span>, <span class="title">U</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a1, a2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multipleGeneric&lt;<span class="built_in">string</span>, <span class="built_in">boolean</span>&gt;(<span class="string">"true"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="rest에서-제네릭"><a href="#rest에서-제네릭" class="headerlink" title="rest에서 제네릭"></a>rest에서 제네릭</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> XYZ &#123;</span><br><span class="line">  x: <span class="built_in">any</span>;</span><br><span class="line">  y: <span class="built_in">any</span>;</span><br><span class="line">  z: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dropXYZ</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">XYZ</span>&gt;(<span class="params">obj: T</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; x, y, z, ...rest &#125; = obj;</span><br><span class="line">  <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체에서 x, y, z를 빼다가 나머지를 리턴하는 함수이다. 객체에서 x, y, z가 없다면 컴파일 단계에서 에러가 날 것이고, x, y, z 가 있다면 어떤 타입이든 상관없이 x, y, z를 제거하고 리턴해줄 것이다.</p><p>만약 x, y, z가 없는 리턴타입까지 정확하게 명사히고 싶다면 이런 짓도 가능하다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> XYZ &#123;</span><br><span class="line">  x: <span class="built_in">any</span>;</span><br><span class="line">  y: <span class="built_in">any</span>;</span><br><span class="line">  z: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pick&lt;T, a&gt;는 T에서 a만 받는 다는 것이다</span></span><br><span class="line"><span class="comment">// Exclude&lt;keyof T, keyof XYZ&gt;는 앞에 타입에서 뒤에 있는 타입을 제외해준다.</span></span><br><span class="line"><span class="keyword">type</span> DropXYZ&lt;T&gt; = Pick&lt;T, Exclude&lt;keyof T, keyof XYZ&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dropXYZ</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">XYZ</span>&gt;(<span class="params">obj: T</span>): <span class="title">DropXYZ</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; x, y, z, ...rest &#125; = obj;</span><br><span class="line">  <span class="keyword">return</span> rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>conditional types에 대해서도 알아봐야 겠다.</p>]]></content>
    
    <summary type="html">
    
      제네릭이란
제네릭은 클래스 내부에서 사용하는 데이터의 타입을 외부에서 지정하는 것을 의미한다. 어떤 타입의 데이터를 쓸지를, 클래스 선언부가 아니라 외부에서 결정하는 것이다. 일단 자바 코드로 한번 살펴보자.

1
2
3
4
5
6


class Person&lt;T&gt;{
    public T name;
}

Person&lt;String&gt; p1 = new Person&lt;String&gt;();
Person&lt;StringBuilder&gt; p1 = new Person&lt;StringBuilder&gt;();


T라는 데이터 타입은 존재하지 않는다. T는 name
    
    </summary>
    
    
      <category term="typescript" scheme="https://www.yceffort.kr/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>자바스크립트의 이벤트루프, 태스크, 그리고 마이크로 태스크</title>
    <link href="https://www.yceffort.kr/2019/09/06/javascript-event-loop/"/>
    <id>https://www.yceffort.kr/2019/09/06/javascript-event-loop/</id>
    <published>2019-09-06T00:51:26.000Z</published>
    <updated>2019-09-20T00:36:54.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="자바스크립트는-단일-스레드-기반의-언어"><a href="#자바스크립트는-단일-스레드-기반의-언어" class="headerlink" title="자바스크립트는 단일 스레드 기반의 언어"></a>자바스크립트는 단일 스레드 기반의 언어</h2><p>자바스크립트는 ‘단일 스레드’ 기반의 언어다. 즉, 스레드가 하나이기 때문에 동시에 하나의 작업만 처리할 수 있다. 그러나 자바스크립트가 사용되는 웹을 곰곰히 생각해보면 동시에 여러개의 작업을 처리하는 모습을 볼 수 있다. 스레드가 하나인 자바스크립트는 동시성을 어떻게 처리할까? 먼저 브라우저 구동환경을 살펴보자.</p><p><img src="https://miro.medium.com/max/1600/1*iHhUyO4DliDwa6x_cO5E3A.gif" alt="browser"></p><p><img src="https://image.toast.com/aaaadh/real/2018/techblog/Bt5ywJrIEAAKJQt.jpg" alt="nodejs"></p><p>위 이미지에서, 자바스크립트 엔진은 메모리 할당을 관리하는 heap과 call stack만 존재하는 것을 알 수 있다. 즉, 동시성에 대한 처리는 자바스크립트 외부에서 처리하고 있음을 알 수 있다. 즉, 정리해서 말하면 자바스크립트는 단일 스레드기반의 언어라서, 단일 호출 스택을 사용하지만, 실제로 자바스크립트를 이용하는 환경 (브라우저, Nodejs)에서는 여러개의 스레드를 활용하며, 이러한 환경을 자바스크립트 엔진과 상호 연동하기 위해서 사용하는 것이 바로 <strong>이벤트 루프</strong>다.</p><h2 id="단일-호출-스택-Run-to-Completion"><a href="#단일-호출-스택-Run-to-Completion" class="headerlink" title="단일 호출 스택, Run-to-Completion"></a>단일 호출 스택, Run-to-Completion</h2><p>자바스크립트의 함수가 실행되는 방식을 <code>Run-to-Completion</code>, 하나의 함수가 실행되면 이게 끝날 떄까지는 다른 어떤 작업도 끼어들지 못함을 의미한다. 자바스크립트는 하나의 호출 스택을 사용하며, 현재 스택에 쌓여있는 함수들이 모두 실행되기 전까지는 다른 어떠한 함수도 실행될 수 없다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  delay();</span><br><span class="line">  hi2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hi3!"</span>); <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  delay();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hi2!"</span>); <span class="comment">// (2)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hi1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hi1!"</span>); <span class="comment">// (4)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(hi1, <span class="number">10</span>); <span class="comment">// (1)</span></span><br><span class="line">hi3();</span><br></pre></td></tr></table></figure><p>이 함수들이 실행되는 순서를 살펴보자.</p><p><a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gZGVsYXkoKSB7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDAwMDsgaSsrKTsKfQpmdW5jdGlvbiBoaTMoKSB7CiAgZGVsYXkoKTsKICBoaTIoKTsKICBjb25zb2xlLmxvZygiaGkzISIpOyAvLyAoMykKfQpmdW5jdGlvbiBoaTIoKSB7CiAgZGVsYXkoKTsKICBjb25zb2xlLmxvZygiaGkyISIpOyAvLyAoMikKfQpmdW5jdGlvbiBoaTEoKSB7CiAgY29uc29sZS5sb2coImhpMSEiKTsgLy8gKDQpCn0KCnNldFRpbWVvdXQoaGkxLCAxMCk7IC8vICgxKQpoaTMoKTs%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" target="_blank" rel="noopener">여기</a>를 살펴보세용 .</p><p>setTimeout이 얼마나 일찍 끝났건 간에, 다른 작업들이 먼저 콜 스택에 들어갔으므로, <code>hi1</code>은 절대 먼저 실행되지 않는다. 근데 어디서 이 setTimout에 있는 <code>hi1()</code>를 잡아다가 다시 실행해줬을까? 이를 도와주는 것이 태스크 큐와 이벤트 루프다. 태스크 큐는 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열이고, 이벤트 루프는 콜 스택이 비워질 때 마다 콜백함수에서 꺼내와서 실행하는 역할을 한다.</p><p>10ms가 지난 후에, <code>hi1()</code>은 바로 실행되지 안혹, 태스크 큐에 추가한다. 이벤트루프는 현재 실행중인 모든 태스크가 끝나자마자 큐에서 대기중인 첫번째 태스크인 <code>hi1()</code>을 실행해서, 콜스택에 추가한다.</p><ul><li>비동기 api들은 작업이 완료되면 콜백함수를 태스크 큐에 추가한다</li><li>이벤트 루프는 현재 실행중인 태스크가 없을때 태스크 큐에서 FIFO형식으로 큐를 꺼내와서 실행한다.</li></ul><p>렌더링 엔진의 경우에도 마찬가지로, 자바스크립트 엔진과 동일한 태스크 큐를 사용한다.</p><h2 id="마이크로-태스크"><a href="#마이크로-태스크" class="headerlink" title="마이크로 태스크"></a>마이크로 태스크</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script end"</span>);</span><br></pre></td></tr></table></figure><p>여기서 <code>Promise</code>가 setTimeout보다 먼저 실행되는데, 그 이유는 <code>Promise</code>가 마이크로 태스크에 등록되기 떄문이다. 마이크로 태스크는 일반 태스크 보다 더 높은 우선순위를 갖으며, 태스크 큐에 대기중인 것이 있다고 하더라도 마이크로태스크에 있는 것이 우선해서 실행된다. 마이크로 태스크의 잡은 태스크 큐보다 우선하기 때문에, 시간이 오래 걸릴 경우 렌더링 엔진이 작동하지 못하고(일반 태스크에 있으므로) 렌더링이 느려지는 현상이 발생할 수도 있다.</p>]]></content>
    
    <summary type="html">
    
      자바스크립트는 단일 스레드 기반의 언어
자바스크립트는 ‘단일 스레드’ 기반의 언어다. 즉, 스레드가 하나이기 때문에 동시에 하나의 작업만 처리할 수 있다. 그러나 자바스크립트가 사용되는 웹을 곰곰히 생각해보면 동시에 여러개의 작업을 처리하는 모습을 볼 수 있다. 스레드가 하나인 자바스크립트는 동시성을 어떻게 처리할까? 먼저 브라우저 구동환경을 살펴보자.





위 이미지에서, 자바스크립트 엔진은 메모리 할당을 관리하는 heap과 call stack만 존재하는 것을 알 수 있다. 즉, 동시성에 대한 처리는 자바스크립트 외부에서 처리
    
    </summary>
    
    
      <category term="javascript" scheme="https://www.yceffort.kr/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>리액트 인터뷰 질문 &amp; 답 (2)</title>
    <link href="https://www.yceffort.kr/2019/08/21/reactjs-interview-questions-2/"/>
    <id>https://www.yceffort.kr/2019/08/21/reactjs-interview-questions-2/</id>
    <published>2019-08-21T01:17:16.000Z</published>
    <updated>2019-09-06T00:30:06.545Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2019/08/13/reactjs-interview-questions/">목차</a></p><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><div class="table-container"><table><thead><tr><th>No.</th><th>Questions</th></tr></thead><tbody><tr><td></td><td><strong>React Router</strong></td></tr><tr><td>129</td><td><a href="#what-is-react-router">What is React Router?</a></td></tr><tr><td>130</td><td><a href="#how-react-router-is-different-from-history-library">How React Router is different from history library?</a></td></tr><tr><td>131</td><td><a href="#what-are-the-router-components-of-react-router-v4">What are the \<router> components of React Router v4?</router></a></td></tr><tr><td>132</td><td><a href="#what-is-the-purpose-of-push-and-replace-methods-of-history">What is the purpose of push and replace methods of history?</a></td></tr><tr><td>133</td><td><a href="#how-do-you-programmatically-navigate-using-react-router-v4">How do you programmatically navigate using React router v4?</a></td></tr><tr><td>134</td><td><a href="#how-to-get-query-parameters-in-react-router-v4">How to get query parameters in React Router v4</a></td></tr><tr><td>135</td><td><a href="#why-you-get-router-may-have-only-one-child-element-warning">Why you get “Router may have only one child element” warning?</a></td></tr><tr><td>136</td><td><a href="#how-to-pass-params-to-historypush-method-in-react-router-v4">How to pass params to history.push method in React Router v4?</a></td></tr><tr><td>137</td><td><a href="#how-to-implement-default-or-notfound-page">How to implement default or NotFound page?</a></td></tr><tr><td>138</td><td><a href="#how-to-get-history-on-react-router-v4">How to get history on React Router v4?</a></td></tr><tr><td>139</td><td><a href="#how-to-perform-automatic-redirect-after-login">How to perform automatic redirect after login?</a></td></tr><tr><td></td><td><strong>React Internationalization</strong></td></tr><tr><td>140</td><td><a href="#what-is-react-intl">What is React-Intl?</a></td></tr><tr><td>141</td><td><a href="#what-are-the-main-features-of-react-intl">What are the main features of React Intl?</a></td></tr><tr><td>142</td><td><a href="#what-are-the-two-ways-of-formatting-in-react-intl">What are the two ways of formatting in React Intl?</a></td></tr><tr><td>143</td><td><a href="#how-to-use-formattedmessage-as-placeholder-using-react-intl">How to use FormattedMessage as placeholder using React Intl?</a></td></tr><tr><td>144</td><td><a href="#how-to-access-current-locale-with-react-intl">How to access current locale with React Intl</a></td></tr><tr><td>145</td><td><a href="#how-to-format-date-using-react-intl">How to format date using React Intl?</a></td></tr><tr><td></td><td><strong>React Testing</strong></td></tr><tr><td>146</td><td><a href="#what-is-shallow-renderer-in-react-testing">What is Shallow Renderer in React testing?</a></td></tr><tr><td>147</td><td><a href="#what-is-testrenderer-package-in-react">What is TestRenderer package in React?</a></td></tr><tr><td>148</td><td><a href="#what-is-the-purpose-of-reacttestutils-package">What is the purpose of ReactTestUtils package?</a></td></tr><tr><td>149</td><td><a href="#what-is-jest">What is Jest?</a></td></tr><tr><td>150</td><td><a href="#what-are-the-advantages-of-jest-over-jasmine">What are the advantages of Jest over Jasmine?</a></td></tr><tr><td>151</td><td><a href="#give-a-simple-example-of-jest-test-case">Give a simple example of Jest test case</a></td></tr><tr><td></td><td><strong>React Redux</strong></td></tr><tr><td>152</td><td><a href="#what-is-flux">What is Flux?</a></td></tr><tr><td>153</td><td><a href="#what-is-redux">What is Redux?</a></td></tr><tr><td>154</td><td><a href="#what-are-the-core-principles-of-redux">What are the core principles of Redux?</a></td></tr><tr><td>155</td><td><a href="#what-are-the-downsides-of-redux-compared-to-flux">What are the downsides of Redux compared to Flux?</a></td></tr><tr><td>156</td><td><a href="#what-is-the-difference-between-mapstatetoprops-and-mapdispatchtoprops">What is the difference between mapStateToProps() and mapDispatchToProps()?</a></td></tr><tr><td>157</td><td><a href="#can-i-dispatch-an-action-in-reducer">Can I dispatch an action in reducer?</a></td></tr><tr><td>158</td><td><a href="#how-to-access-redux-store-outside-a-component">How to access Redux store outside a component?</a></td></tr><tr><td>159</td><td><a href="#what-are-the-drawbacks-of-mvw-pattern">What are the drawbacks of MVW pattern</a></td></tr><tr><td>160</td><td><a href="#are-there-any-similarities-between-redux-and-rxjs">Are there any similarities between Redux and RxJS?</a></td></tr><tr><td>161</td><td><a href="#how-to-dispatch-an-action-on-load">How to dispatch an action on load?</a></td></tr><tr><td>162</td><td><a href="#how-to-use-connect-from-react-redux">How to use connect from React Redux?</a></td></tr><tr><td>163</td><td><a href="#how-to-reset-state-in-redux">How to reset state in Redux?</a></td></tr><tr><td>164</td><td><a href="#whats-the-purpose-of-at-symbol-in-the-redux-connect-decorator">Whats the purpose of at symbol in the redux connect decorator?</a></td></tr><tr><td>165</td><td><a href="#what-is-the-difference-between-react-context-and-react-redux">What is the difference between React context and React Redux?</a></td></tr><tr><td>166</td><td><a href="#why-are-redux-state-functions-called-reducers">Why are Redux state functions called reducers?</a></td></tr><tr><td>167</td><td><a href="#how-to-make-ajax-request-in-redux">How to make AJAX request in Redux?</a></td></tr><tr><td>168</td><td><a href="#should-i-keep-all-components-state-in-redux-store">Should I keep all component’s state in Redux store?</a></td></tr><tr><td>169</td><td><a href="#what-is-the-proper-way-to-access-redux-store">What is the proper way to access Redux store?</a></td></tr><tr><td>170</td><td><a href="#what-is-the-difference-between-component-and-container-in-react-redux">What is the difference between component and container in React Redux?</a></td></tr><tr><td>171</td><td><a href="#what-is-the-purpose-of-the-constants-in-redux">What is the purpose of the constants in Redux? </a></td></tr><tr><td>172</td><td><a href="#what-are-the-different-ways-to-write-mapdispatchtoprops">What are the different ways to write mapDispatchToProps()?</a></td></tr><tr><td>173</td><td><a href="#what-is-the-use-of-the-ownprops-parameter-in-mapstatetoprops-and-mapdispatchtoprops">What is the use of the ownProps parameter in mapStateToProps() and mapDispatchToProps()?</a></td></tr><tr><td>174</td><td><a href="#how-to-structure-redux-top-level-directories">How to structure Redux top level directories?</a></td></tr><tr><td>175</td><td><a href="#what-is-redux-saga">What is redux-saga?</a></td></tr><tr><td>176</td><td><a href="#what-is-the-mental-model-of-redux-saga">What is the mental model of redux-saga?</a></td></tr><tr><td>177</td><td><a href="#what-are-the-differences-between-call-and-put-in-redux-saga">What are the differences between call and put in redux-saga</a></td></tr><tr><td>178</td><td><a href="#what-is-redux-thunk">What is Redux Thunk?</a></td></tr><tr><td>179</td><td><a href="#what-are-the-differences-between-redux-saga-and-redux-thunk">What are the differences between redux-saga and redux-thunk</a></td></tr><tr><td>180</td><td><a href="#what-is-redux-devtools">What is Redux DevTools?</a></td></tr><tr><td>181</td><td><a href="#what-are-the-features-of-redux-devtools">What are the features of Redux DevTools?</a></td></tr><tr><td>182</td><td><a href="#what-are-redux-selectors-and-why-to-use-them">What are Redux selectors and Why to use them?</a></td></tr><tr><td>183</td><td><a href="#what-is-redux-form">What is Redux Form?</a></td></tr><tr><td>184</td><td><a href="#what-are-the-main-features-of-redux-form">What are the main features of Redux Form?</a></td></tr><tr><td>185</td><td><a href="#how-to-add-multiple-middlewares-to-redux">How to add multiple middlewares to Redux?</a></td></tr><tr><td>186</td><td><a href="#how-to-set-initial-state-in-redux">How to set initial state in Redux?</a></td></tr><tr><td>187</td><td><a href="#how-relay-is-different-from-redux">How Relay is different from Redux?</a></td></tr><tr><td></td><td><strong>React Native</strong></td></tr><tr><td>188</td><td><a href="#what-is-the-difference-between-react-native-and-react">What is the difference between React Native and React?</a></td></tr><tr><td>189</td><td><a href="#how-to-test-react-native-apps">How to test React Native apps?</a></td></tr><tr><td>190</td><td><a href="#how-to-do-logging-in-react-native">How to do logging in React Native?</a></td></tr><tr><td>191</td><td><a href="#how-to-debug-your-react-native">How to debug your React Native?</a></td></tr><tr><td></td><td><strong>React supported libraries and Integration</strong></td></tr><tr><td>192</td><td><a href="#what-is-reselect-and-how-it-works">What is reselect and how it works?</a></td></tr><tr><td>193</td><td><a href="#what-is-flow">What is Flow?</a></td></tr><tr><td>194</td><td><a href="#what-is-the-difference-between-flow-and-proptypes">What is the difference between Flow and PropTypes?</a></td></tr><tr><td>195</td><td><a href="#how-to-use-font-awesome-icons-in-react">How to use font-awesome icons in React?</a></td></tr><tr><td>196</td><td><a href="#what-is-react-dev-tools">What is React Dev Tools?</a></td></tr><tr><td>197</td><td><a href="#why-is-devtools-not-loading-in-chrome-for-local-files">Why is DevTools not loading in Chrome for local files?</a></td></tr><tr><td>198</td><td><a href="#how-to-use-polymer-in-react">How to use Polymer in React?</a></td></tr><tr><td>199</td><td><a href="#what-are-the-advantages-of-react-over-vuejs">What are the advantages of React over Vue.js?</a></td></tr><tr><td>200</td><td><a href="#what-is-the-difference-between-react-and-angular">What is the difference between React and Angular?</a></td></tr><tr><td>201</td><td><a href="#why-react-tab-is-not-showing-up-in-devtools">Why React tab is not showing up in DevTools?</a></td></tr><tr><td>202</td><td><a href="#what-are-styled-components">What are styled components?</a></td></tr><tr><td>203</td><td><a href="#give-an-example-of-styled-components">Give an example of Styled Components?</a></td></tr><tr><td>204</td><td><a href="#what-is-relay">What is Relay?</a></td></tr><tr><td>205</td><td><a href="#how-to-use-typescript-in-create-react-app-application">How to use TypeScript in create-react-app application?</a></td></tr></tbody></table></div><h2 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h2><h3 id="What-is-React-Router"><a href="#What-is-React-Router" class="headerlink" title="What is React Router?"></a>What is React Router?</h3><p>React Router는 리액트 최상단에 있는 강력한 라우팅 라이브러리로, 페이지에 보여주는 내용과 URL사이에 동기화를 유지해주고, 어플리케이션에 새로운 화면과 흐름을 추가할 수 있도록 도와준다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-React-Router-is-different-from-history-library"><a href="#How-React-Router-is-different-from-history-library" class="headerlink" title="How React Router is different from history library?"></a>How React Router is different from history library?</h3><p>React router는 history라이브러리를 감싼 래퍼로, 브라우저의 <code>window.history</code>와 상호작용하고, 브라우저 및 해쉬의 히스토리를 다룬다. 또한 모바일 앱 개발 (React Native) 및 Node의 unit testing처럼 global histroy가 없는 환경에 유용한 메모리 히스토리를 제공한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-lt-Router-gt-components-of-React-Router-v4"><a href="#What-are-the-lt-Router-gt-components-of-React-Router-v4" class="headerlink" title="What are the &lt;Router&gt; components of React Router v4?"></a>What are the <code>&lt;Router&gt;</code> components of React Router v4?</h3><p>v4는 새로운 3개의 <code>&lt;Router&gt;</code> 컴포넌트를 제공한다.</p><ol><li><code>&lt;BrowserRouter&gt;</code></li><li><code>&lt;HashRouter&gt;</code></li><li><code>&lt;MemoryRouter&gt;</code></li></ol><p>위 컴포넌트는 각각 브라우저, 해쉬, 메모리 히스토리 인스턴스를 만들어준다. React Router v4는 Router Object의 context를 통해, history 인스턴스의 속성과 메소드를 활용할 수 있게 해준다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-purpose-of-push-and-replace-methods-of-history"><a href="#What-is-the-purpose-of-push-and-replace-methods-of-history" class="headerlink" title="What is the purpose of push() and replace() methods of history?"></a>What is the purpose of <code>push()</code> and <code>replace()</code> methods of <code>history</code>?</h3><p>히스토리 인스턴스에는 네비게이션 목적으로 두개의 메소드를 제공한다.</p><ol><li><code>push()</code></li><li><code>replace()</code></li></ol><p>만약 히스토리가 방문했던 곳들의 배열이라고 생각한다면, <code>push()</code>가 그 역할을 할 것이고, 현재 위치를 덮어쓰는 느낌을 원한다면 <code>replace()</code>가 맞을 것이다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-do-you-programmatically-navigate-using-React-Router-v4"><a href="#How-do-you-programmatically-navigate-using-React-Router-v4" class="headerlink" title="How do you programmatically navigate using React Router v4?"></a>How do you programmatically navigate using React Router v4?</h3><p>Component 내에서 프로그래밍으로 라우팅/네비게이팅 하는 방법에는 3가지가 있다.</p><ol><li>HOF에서 <code>withRouter()</code>를 쓰는법<br>HOF의 <code>withRouter()</code>는 컴포넌트의 prop에 히스토리 오브젝트를 인젝트 한다. 이 오브젝트는 <code>push()</code> <code>replace()</code>를 제공하여 context의 사용을 피하게 해준다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>; <span class="comment">// this also works with 'react-router-native'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = withRouter(<span class="function">(<span class="params">&#123; history &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;button</span><br><span class="line">    type=<span class="string">"button"</span></span><br><span class="line">    onClick=&#123;() =&gt; &#123;</span><br><span class="line">      history.push(<span class="string">"/new-location"</span>);</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;<span class="string">"Click Me!"</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br></pre></td></tr></table></figure><ol><li><code>&lt;Route&gt;</code> 컴포넌트와 render props 패턴을 사용하는 법<br><code>&lt;Route&gt;</code>는 <code>withRouter()</code>와 같은 props를 넘기므로, history prop을 통해 histoy 메서드에 접근할 수 있을 것이다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Route &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Route</span><br><span class="line">    render=&#123;(&#123; history &#125;) =&gt; (</span><br><span class="line">      &lt;button</span><br><span class="line">        type=<span class="string">"button"</span></span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          history.push(<span class="string">"/new-location"</span>);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;<span class="string">"Click Me!"</span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    )&#125;</span></span><br><span class="line"><span class="regexp">  /</span>&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>Context<br>이 방식은 딱히 추천되지 않고, 불안정한 API 활용으로 간주된다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props, context</span>) =&gt;</span> (</span><br><span class="line">  &lt;button</span><br><span class="line">    type=<span class="string">"button"</span></span><br><span class="line">    onClick=&#123;() =&gt; &#123;</span><br><span class="line">      context.history.push(<span class="string">"/new-location"</span>);</span><br><span class="line">    &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">    &#123;<span class="string">"Click Me!"</span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Button.contextTypes = &#123;</span></span><br><span class="line"><span class="regexp">  history: React.PropTypes.shape(&#123;</span></span><br><span class="line"><span class="regexp">    push: React.PropTypes.func.isRequired</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-get-query-parameters-in-React-Router-v4"><a href="#How-to-get-query-parameters-in-React-Router-v4" class="headerlink" title="How to get query parameters in React Router v4?"></a>How to get query parameters in React Router v4?</h3><p>수년간 다른 구현 지원에 대한 사용자들의 많은 요청 때문에, React Router v4에서는 query string을 parsing 하는 방법은 사라졌다. 이는 유저가 원하는 대로 구현할 수 있는 자유도를 주었다. 추천하는 방법은, query string 라이브러리를 사용하는 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">"query-string"</span>);</span><br><span class="line"><span class="keyword">const</span> parsed = queryString.parse(props.location.search);</span><br></pre></td></tr></table></figure><p>native 방식을 선호한다면 <code>URLSearchParam</code>을 사용할 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> URLSearchParams(props.location.search);</span><br><span class="line"><span class="keyword">const</span> foo = params.get(<span class="string">"name"</span>);</span><br></pre></td></tr></table></figure><p>다만 IE11에서는 폴리필이 필요하다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="Why-you-get-“Router-may-have-only-one-child-element”-warning"><a href="#Why-you-get-“Router-may-have-only-one-child-element”-warning" class="headerlink" title="Why you get “Router may have only one child element” warning?"></a>Why you get “Router may have only one child element” warning?</h3><p>Route는 <code>&lt;Switch&gt;</code> 블록으로 감싸줘야 하는데, 왜냐하면 <code>&lt;Switch&gt;</code>는 라우트를 베타적으로 감싸기 때문이다. 먼저 <code>Switch</code>를 임포트 해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Switch, Router, Route &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br></pre></td></tr></table></figure><p>그리고 route를 <code>&lt;Switch&gt;</code> 블록에 넣어햐 한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Route</span> &#123;/* <span class="attr">...</span> */&#125; /&gt;</span> <span class="tag">&lt;<span class="name">Route</span> &#123;/* <span class="attr">...</span> */&#125; /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-pass-params-to-history-push-method-in-React-Router-v4"><a href="#How-to-pass-params-to-history-push-method-in-React-Router-v4" class="headerlink" title="How to pass params to history.push method in React Router v4?"></a>How to pass params to <code>history.push</code> method in React Router v4?</h3><p>history 객체에 props를 보낼 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.history.push(&#123;</span><br><span class="line">  pathname: <span class="string">"/template"</span>,</span><br><span class="line">  search: <span class="string">"?name=sudheer"</span>,</span><br><span class="line">  state: &#123; <span class="attr">detail</span>: response.data &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>search</code> 속성은 <code>push()</code>에서 query param을 보낼 때 사용된다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-implement-default-or-NotFound-page"><a href="#How-to-implement-default-or-NotFound-page" class="headerlink" title="How to implement default or NotFound page?"></a>How to implement <em>default</em> or <em>NotFound</em> page?</h3><p><code>&lt;Switch&gt;</code>는 첫번째로 일치하는 <code>&lt;Route&gt;</code>를 렌더링한다. path가 없는 route는 항상 매치하게 되어 있다. 따라서, path를 제거한 route를 하나 추가하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/user"</span> component=&#123;User&#125; /&gt;</span><br><span class="line">  &lt;Route component=&#123;NotFound&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/Switch&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-get-history-on-React-Router-v4"><a href="#How-to-get-history-on-React-Router-v4" class="headerlink" title="How to get history on React Router v4?"></a>How to get history on React Router v4?</h3><ol><li>history 오브젝트를 익스포트 하는 모듈을 만들고, 프로젝트 전체에서 해당 모듈을 임포트 한다. 예를들어,</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory &#125; <span class="keyword">from</span> <span class="string">"history"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createBrowserHistory(&#123;</span><br><span class="line">  <span class="comment">/* pass a configuration object here if needed */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol><li>빌트인 라우터 대신에, <code>&lt;Router&gt;</code> 컴포넌트를 쓴다. 위에서 만든 <code>history.js</code>를 <code>index.js</code>에 임포트 한다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">"react-router-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> history <span class="keyword">from</span> <span class="string">"./history"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./App"</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Router&gt;,</span></span><br><span class="line"><span class="regexp">  holder</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><ol><li>빌트인 히스토리 오브젝트와 비슷하게, history의 push메소드를 쓸수도 있다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some-other-file.js</span></span><br><span class="line"><span class="keyword">import</span> history <span class="keyword">from</span> <span class="string">"./history"</span>;</span><br><span class="line"></span><br><span class="line">history.push(<span class="string">"/go-here"</span>);</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-perform-automatic-redirect-after-login"><a href="#How-to-perform-automatic-redirect-after-login" class="headerlink" title="How to perform automatic redirect after login?"></a>How to perform automatic redirect after login?</h3><p><code>react-router</code>sms <code>&lt;Redirect&gt;</code> 컴포넌트를 제공한다. <code>&lt;Redirect&gt;</code>를 렌더링 하면 새로운 위치로 이동하게 된다. 서버사이드 리다이렉트와 마찬가지로, 새로운 위치는 현재 히스토리 스택에 있는 현재 위치를 덮어쓰게 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Redirect &#125; <span class="keyword">from</span> <span class="string">"react-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.isLoggedIn === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">"/your/redirect/page"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125; else &#123;</span></span><br><span class="line"><span class="xml">      return <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;"Login Please"&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h2 id="React-Internationalization"><a href="#React-Internationalization" class="headerlink" title="React Internationalization"></a>React Internationalization</h2><h3 id="What-is-React-Intl"><a href="#What-is-React-Intl" class="headerlink" title="What is React Intl?"></a>What is React Intl?</h3><p>React Intl string, dates, numbers, 복수 표현 등을 다국어로 포맷팅할 수 있는 컴포넌트와 API를 제공한다. React Intl는 components 와 API 를 바탕으로 Reac를 바인딩하는 FormatJS 의 일부분이다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-main-features-of-React-Intl"><a href="#What-are-the-main-features-of-React-Intl" class="headerlink" title="What are the main features of React Intl?"></a>What are the main features of React Intl?</h3><ol><li>숫자를 , 와 함께 표현</li><li>날짜와 시간을 올바르게 표현</li><li>현재시간을 기준으로 날자를 표현</li><li>string의 복수표현</li><li>150+개의 언어 지원</li><li>브라우저와 노드에서 실행</li><li>표준에 맞춰 제작</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-two-ways-of-formatting-in-React-Intl"><a href="#What-are-the-two-ways-of-formatting-in-React-Intl" class="headerlink" title="What are the two ways of formatting in React Intl?"></a>What are the two ways of formatting in React Intl?</h3><p>string, number, date를 포맷팅하는 방법은 react 컴포넌트 또는 api를 사용하는 두가지 방법이 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedMessage</span><br><span class="line">  id=&#123;<span class="string">"account"</span>&#125;</span><br><span class="line">  defaultMessage=&#123;<span class="string">"The amount is less than minimum balance."</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> messages = defineMessages(&#123;</span><br><span class="line">  accountMessage: &#123;</span><br><span class="line">    id: <span class="string">"account"</span>,</span><br><span class="line">    defaultMessage: <span class="string">"The amount is less than minimum balance."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">formatMessage(messages.accountMessage);</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-use-lt-FormattedMessage-gt-as-placeholder-using-React-Intl"><a href="#How-to-use-lt-FormattedMessage-gt-as-placeholder-using-React-Intl" class="headerlink" title="How to use &lt;FormattedMessage&gt; as placeholder using React Intl?"></a>How to use <code>&lt;FormattedMessage&gt;</code> as placeholder using React Intl?</h3><p><code>&lt;Formatted... /&gt;</code> 컴포넌트는 plain text가 아닌 elements를 반환하므로, placeholder, alt text처럼 string이 필요한 곳에는 쓸 수 없다. 따라서 여기에서는 <code>formatMessage()</code>를 사용해야한다. higher-order component인 injectIntl()을 사용하여, 컴포넌트에 intl 객체를 주입하고, 객체에서 사용할 수 있는 <code>formatMessage()</code>를 사용하여 message를 포맷팅할 수 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; injectIntl, intlShape &#125; <span class="keyword">from</span> <span class="string">"react-intl"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; intl &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> placeholder = intl.formatMessage(&#123; <span class="attr">id</span>: <span class="string">"messageId"</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">MyComponent.propTypes = &#123;</span></span><br><span class="line"><span class="xml">  intl: intlShape.isRequired</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default injectIntl(MyComponent);</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-access-current-locale-with-React-Intl"><a href="#How-to-access-current-locale-with-React-Intl" class="headerlink" title="How to access current locale with React Intl?"></a>How to access current locale with React Intl?</h3><p>어느 어플리케이션에서든 <code>injectIntl()</code>를 사용하면 현재 로케일을 얻을 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-format-date-using-React-Intl"><a href="#How-to-format-date-using-React-Intl" class="headerlink" title="How to format date using React Intl?"></a>How to format date using React Intl?</h3><p>higher-order 컴포넌트 <code>injectIntl()</code>는 컴포넌트의 props에 <code>formatDate()</code>메서드를 제공한다. 이 메서드는 내부적으로 <code>FormattedDate</code>인스턴스를 활용하고, 이는 포맷된 날짜를 string으로 제공한다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; injectIntl, intlShape &#125; <span class="keyword">from</span> <span class="string">"react-intl"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stringDate = <span class="keyword">this</span>.props.intl.formatDate(date, &#123;</span><br><span class="line">  year: <span class="string">"numeric"</span>,</span><br><span class="line">  month: <span class="string">"numeric"</span>,</span><br><span class="line">  day: <span class="string">"numeric"</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; intl &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;&#123;<span class="string">`The formatted date is <span class="subst">$&#123;stringDate&#125;</span>`</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">MyComponent.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">  intl: intlShape.isRequired</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default injectIntl(MyComponent);</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h2 id="React-Testing"><a href="#React-Testing" class="headerlink" title="React Testing"></a>React Testing</h2><h3 id="What-is-Shallow-Renderer-in-React-testing"><a href="#What-is-Shallow-Renderer-in-React-testing" class="headerlink" title="What is Shallow Renderer in React testing?"></a>What is Shallow Renderer in React testing?</h3><p><code>Shallow rendering</code>는 React에서 유닛테스트 케이스를 작성할 때 유용하다. 이는 컴포넌트를 한단계 더 깊이 렌더링하며, 렌더링되지 않은 하위 컴포넌트에 대한 고민 ㅇ벗이 렌더링 메서드가 반환하는 것에 대해 asset를 수행할 수 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span className=&#123;<span class="string">"heading"</span>&#125;&gt;&#123;<span class="string">"Title"</span>&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span className=&#123;"description"&#125;&gt;&#123;"Description"&#125;&lt;/</span>span&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ShallowRenderer <span class="keyword">from</span> <span class="string">"react-test-renderer/shallow"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> ShallowRenderer();</span><br><span class="line">renderer.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const result = renderer.getRenderOutput();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">expect(result.type).toBe("div");</span></span><br><span class="line"><span class="xml">expect(result.props.children).toEqual([</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;</span>"<span class="attr">heading</span>"&#125;&gt;</span>&#123;"Title"&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;</span>"<span class="attr">description</span>"&#125;&gt;</span>&#123;"Description"&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">]);</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-TestRenderer-package-in-React"><a href="#What-is-TestRenderer-package-in-React" class="headerlink" title="What is TestRenderer package in React?"></a>What is <code>TestRenderer</code> package in React?</h3><p><code>TestRenderer</code> 패키지는 component 를 DOM 또는 Native mobile 환경에 의존없이 순수 Javascript Object 로 렌더링 할 수 있는 renderer 를 제공한다. 이 패키지를 사용하면 브라우저 또는 jsdom 의 사용없이 ReactDOM 또는 React Native 에서 렌더링 되는 플랫폼의 뷰 계층구조 (DOM 트리와 유사) 의 스냅샷을 쉽게 가져올 수 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> TestRenderer <span class="keyword">from</span> <span class="string">"react-test-renderer"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Link = <span class="function">(<span class="params">&#123; page, children &#125;</span>) =&gt;</span> &lt;a href=&#123;page&#125;&gt;&#123;children&#125;&lt;<span class="regexp">/a&gt;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const testRenderer = TestRenderer.create(</span></span><br><span class="line"><span class="regexp">  &lt;Link page=&#123;"https:/</span><span class="regexp">/www.facebook.com/</span><span class="string">"&#125;&gt;&#123;"</span>Facebook<span class="string">"&#125;&lt;/Link&gt;</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">console.log(testRenderer.toJSON());</span></span><br><span class="line"><span class="string">// &#123;</span></span><br><span class="line"><span class="string">//   type: 'a',</span></span><br><span class="line"><span class="string">//   props: &#123; href: 'https://www.facebook.com/' &#125;,</span></span><br><span class="line"><span class="string">//   children: [ 'Facebook' ]</span></span><br><span class="line"><span class="string">// &#125;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-purpose-of-ReactTestUtils-package"><a href="#What-is-the-purpose-of-ReactTestUtils-package" class="headerlink" title="What is the purpose of ReactTestUtils package?"></a>What is the purpose of ReactTestUtils package?</h3><p><code>ReactTestUtils</code>는 유닛테스트를 목적으로 DOM을 조작할 수 있는 <code>with-addons</code>패키지를 제공한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-Jest"><a href="#What-is-Jest" class="headerlink" title="What is Jest?"></a>What is Jest?</h3><p>Jest는 페이스북이 만든 자바스크립트 유닛테스트 프레임워크로, Jasmine을 기반으로 만들어 졌으며 자동 mock 생성, <code>jsdom</code> 환경 제공 등의 기능을 제공한다. 컴포넌트를 테스트 하는데 사용 된다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-advantages-of-Jest-over-Jasmine"><a href="#What-are-the-advantages-of-Jest-over-Jasmine" class="headerlink" title="What are the advantages of Jest over Jasmine?"></a>What are the advantages of Jest over Jasmine?</h3><p>Jasmine보다 Jest가 더 좋은 점은</p><ul><li>소스코드에서 자동으로 테스트 코드를 찾아서 테스트</li><li>테스트 시 자동으로 mock 의 존성 참고</li><li>동기로 작성된 코드를 비동기로 테스트</li><li>fake Dom implementation으로 테스트 하여, 명령줄에서도 테스트 가능</li><li>병렬 프로세스로 테스트 하여 테스트가 더욱 빠르게 수행됨</li></ul><p><a href="#table-of-contents">👆</a></p><h3 id="Give-a-simple-example-of-Jest-test-case"><a href="#Give-a-simple-example-of-Jest-test-case" class="headerlink" title="Give a simple example of Jest test case"></a>Give a simple example of Jest test case</h3><p>두 숫자를 더하는 <code>sum.js</code>를 작성한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum;</span><br></pre></td></tr></table></figure><p>테스트를 수행하는 <code>sum.test.js</code>를 작성</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">"./sum"</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">"adds 1 + 2 to equal 3"</span>, () =&gt; &#123;</span><br><span class="line">  expect(sum(<span class="number">1</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>package.json</code>에 테스트를 실행하는 코드 추가</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"jest"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>yarn test</code> <code>npm test</code>로 테스트 실행 및 결과 확인</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yarn <span class="built_in">test</span></span></span><br><span class="line">PASS ./sum.test.js</span><br><span class="line">✓ adds 1 + 2 to equal 3 (2ms)</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h2 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React Redux"></a>React Redux</h2><h3 id="What-is-flux"><a href="#What-is-flux" class="headerlink" title="What is flux?"></a>What is flux?</h3><p>Flux는 어플리케이션 디자인 패러다임으로, 전통적인 모델인 MVC pattern을 대체하기 위해 나왔다. Flux는 프레임워크나 라이브러리가 아닌, React와 양방향 데이터 흐름을 기반으로 하는 새로운 아키텍쳐다. 페이스북이 React를 사용할 때 내부적으로 이 패턴을 활용한다.</p><p>dispatcher, sotres, views 컴포넌트 사이 작업흐름은 아래처럼 input과 output이 구별되어 나타난다.</p><p><img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/flux.png" alt="flux-diagram"></p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-Redux"><a href="#What-is-Redux" class="headerlink" title="What is Redux?"></a>What is Redux?</h3><p>Redux는 flux 디자인 패턴을 기반으로 한 자바스크립트 앱의 예측가능한 state container다. Redux는 React또는 다른 어떤 뷰 라이브러리와 함께 사용할 수 있다. Redux는 크기가 매우 작고 (2kb), 다른 디펜던시를 갖고 있지 않다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-core-principles-of-Redux"><a href="#What-are-the-core-principles-of-Redux" class="headerlink" title="What are the core principles of Redux?"></a>What are the core principles of Redux?</h3><p>Redux는 다음 세가지 기본 원칙을 가지고 있다.</p><ol><li>신뢰할 수 있는 단일 출처: 어플리케이션의 state는 단일 store에 객체트리 형태로 저장되어 있다. 단일 state tree는 변화를 쉽게 추적ㄷ할 수 있게 해주며, 어플리케이션을 디버그하고 검사하는 것을 쉽게 만들어 준다.</li><li>state는 읽기 전용: state를 변경할 수 있는 방법은 단한가지로, 객체가 어떤 일이 일어났는지 묘사하는 액션을 보내는 것이다. 이는 views나 네트워크 콜백이 직접 state를 수정하지 않도록 한다.</li><li>변화는 순수 함수로만 이루어진다: 액션별로 state 트리가 어떻게 변화하는지 명세하기 위해, reducer를 사용해야 한다.</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-downsides-of-Redux-compared-to-Flux"><a href="#What-are-the-downsides-of-Redux-compared-to-Flux" class="headerlink" title="What are the downsides of Redux compared to Flux?"></a>What are the downsides of Redux compared to Flux?</h3><p>Flux와 비교했을 때, Redux는 몇가지 단점을 가지고 있다.</p><ol><li>변이를 피하는 법을 배워야 한다: Flux는 데이터 변이에 대해 특별한 의견이 없지만, Redux는 데이터 변이를 선호하지 않으며, 다른 추가 보완 패키지를 활용하여 이를 유지한다. dev-only 패지지인 <code>redux-immutable-state-invariant</code>나 <code>Immutable.js</code>를 활용하거나, 팀원들에게 변이 없는 코드에 대해 방법론을 확산해야 한다.</li><li>패키지를 고를때 신중해진다: Flux는 undo/redo, 지속성, 폼 관련 문제에 대해 무관심하지만, Redux 는 미들웨어 및 Store 개선 등 확장된 포인트들을 가지고 풍부한 생태계를 만들어 냈기 때문에, 패키지 선택에 주의가 필요하다.</li><li>타입체크: Flux는 정적 타입 체크를 할 수 있는 방법이 있지만, Redux는 아직 지원하고 있지 않다.</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-mapStateToProps-and-mapDispatchToProps"><a href="#What-is-the-difference-between-mapStateToProps-and-mapDispatchToProps" class="headerlink" title="What is the difference between mapStateToProps() and mapDispatchToProps()?"></a>What is the difference between <code>mapStateToProps()</code> and <code>mapDispatchToProps()</code>?</h3><p><code>mapStateToProps()</code>는 컴포넌트에서 다른 컴포넌트에 의해 업데이트된 state를 가져올수 있도록 도와주는 유틸리티다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mapDispatchToProps()</code>는 컴포넌트가 이벤트를 발생시킬 수 있도록 도와주는 유틸리티다. (이 이벤트는 어플리케이션의 state에 변화를 가져올 수 있음)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onTodoClick: <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(toggleTodo(id));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mapDispatchToProps</code>에서는 항상 객체를 파라미터로 보내기를 권장한다.</p><p>Redux는 <code>(…args) =&gt; dispatch(onTodoClick(…args))</code>와 같은 형태의 다른 함수로 감싸고, 이렇게 감싼 함수를 컴포넌트의 prop로 전달한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  onTodoClick</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Can-I-dispatch-an-action-in-reducer"><a href="#Can-I-dispatch-an-action-in-reducer" class="headerlink" title="Can I dispatch an action in reducer?"></a>Can I dispatch an action in reducer?</h3><p>Reducer안에서 액션을 보내는 것은 안티패턴이다. Reducer는 사이드이펙트를 최소화 하기 위하여, 단순히 액션에 대한 처리와 새로운 state를 가진 object를 반환하기만 해야 한다. Reducer내에서 리스너를 달고, 액션을 보내는 것은 다른 액션과 연쇄작용을 일으킬 수도 있으며, 사이드 이펙트를 야기할 수도 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-access-Redux-store-outside-a-component"><a href="#How-to-access-Redux-store-outside-a-component" class="headerlink" title="How to access Redux store outside a component?"></a>How to access Redux store outside a component?</h3><p><code>createStore()</code>로 만들어진 모듈을 export 하면 된다. 그리고 global 객체인 window를 사용해서는 안된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store = createStore(myReducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-drawbacks-of-MVW-pattern"><a href="#What-are-the-drawbacks-of-MVW-pattern" class="headerlink" title="What are the drawbacks of MVW pattern?"></a>What are the drawbacks of MVW pattern?</h3><ol><li>DOM 조작은, 많은 비용을 지불해야 하고, 어플리케이션을 느리고 비효율적으로 만든다.</li><li>순환 참조로 인해, 복잡한 모델이 모델과 뷰주변에 만들어질 수 있다.</li><li>구글 docs와 같은 협업 어플리케이션에서는 많은 양의 데이터 변경이 일어날 수 있다.</li><li>추가적으로 많은 코드를 쓰지 않고 undo를 쉽게 할 수 없다.</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="Are-there-any-similarities-between-Redux-and-RxJS"><a href="#Are-there-any-similarities-between-Redux-and-RxJS" class="headerlink" title="Are there any similarities between Redux and RxJS?"></a>Are there any similarities between Redux and RxJS?</h3><p>두 라이브러리는 목적부터 완전히 다르지만, 약간의 비슷한점을 가지고있다.</p><p>Redux는 어플리케이션 전반에서 state를 관리할 수 있게 도와주는 툴이다. 이는 보통 UI 아키텍쳐에서 ㅁ낳이 사용된다. Angular의 대체재라고 볼 수 있다. 반면 Rxjs는 반응형 프로그래밍 라이브러리다. RxJS는 자바스크립트에서 비동기 작업을 수행하기 위해 사용된다. Promise의 대체재라고 볼 수있다. Redux는 Store가 반응형이기 때문에 반응형 패러다임을 사용한다. Store는 액션을 어느정도 거리에서 관찰하다가, 스스로 변화한다. RxJS 또한 반응형 패러다임을 사용하는 반면, 아키텍쳐를 제공하지 않고 Observable 과 같은 블록을 제공한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-dispatch-an-action-on-load"><a href="#How-to-dispatch-an-action-on-load" class="headerlink" title="How to dispatch an action on load?"></a>How to dispatch an action on load?</h3><p><code>componentDidMount()</code>와 <code>render()</code>메서드에서 데이터를 확인하는 액션을 전닥ㄹ할 수 있고 데이터를 확인할 수 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.props.fetchData();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.isLoaded ? (</span><br><span class="line">      &lt;div&gt;&#123;<span class="string">"Loaded"</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    ) : (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;&#123;"Not Loaded"&#125;&lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">  isLoaded: state.isLoaded</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123; fetchData &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(App);</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-use-connect-from-React-Redux"><a href="#How-to-use-connect-from-React-Redux" class="headerlink" title="How to use connect() from React Redux?"></a>How to use <code>connect()</code> from React Redux?</h3><p>container에서 store를 사용하기 위해서는 아래 두단계를 따라야 한다.</p><ol><li><code>mapStateToProps()</code>를 사용: state의 값을 props에서 지정한 store에 맵핑시킨다.</li><li>위 props를 Container 와 연결: <code>mapStateToProps()</code>에 의해 리턴되는 객체들은 컨테이너와 연결된다. 이를 <code>react-redux</code>의 <code>connect</code>로 import 할 수 있다.</li></ol><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.containerData&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">containerData</span>: state.data &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(App);</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-reset-state-in-Redux"><a href="#How-to-reset-state-in-Redux" class="headerlink" title="How to reset state in Redux?"></a>How to reset state in Redux?</h3><p><code>combineReducers()</code>로 생성된 reducer 에게 action 을 위임하도록 application 단에서 root reducer 를 작성해야 한다.</p><p>예를 들어, <code>USER_LOGOUT</code> 액션에 초기 state값을 리턴하는 <code>rootReducer()</code>를 예로 들어보자. 알다시피, reducer는 action에 상관없이 첫 번째 매개변수가 undefined로 호출된다면, 초기 상태값을 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> appReducer = combineReducers(&#123;</span><br><span class="line">  <span class="comment">/* your app's top-level reducers */</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootReducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">"USER_LOGOUT"</span>) &#123;</span><br><span class="line">    state = <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> appReducer(state, action);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>redux-persist</code>를 사용하는 경우, 스토리지를 비워야 할 수도 있다. <code>redux-persist</code>에서는 스토리지 안진에 있는 state의 사본을 보관해둔다. 먼저, 적절한 스토리지 엔진을 임포트 한다음, 상태를 undefined로 설정하기 전에 storage state key를 비워주어야 한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="Whats-the-purpose-of-at-symbol-in-the-Redux-connect-decorator"><a href="#Whats-the-purpose-of-at-symbol-in-the-Redux-connect-decorator" class="headerlink" title="Whats the purpose of at symbol in the Redux connect decorator?"></a>Whats the purpose of <code>at</code> symbol in the Redux connect decorator?</h3><p><code>@</code>는 자바스크립트에서 데코레이터를 나타낼 떄 쓰는 표현식이다. 데코레이터는 class와 속성에 주석을 달고, 이를 수정할 수 있게 해준다.</p><p>데코레이터가 없는 redux를 예로 들어보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">"./actionCreators"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">actions</span>: bindActionCreators(actionCreators, dispatch) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...define your main app here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(MyApp);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">"./actionCreators"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">actions</span>: bindActionCreators(actionCreators, dispatch) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...define your main app here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 예제는 데코레이터를 사용한 것을 제외하고는 비슷하다. 데코레이터는 아직 자바스크립트 런타임에 구현되어 있지 않다. 여전히 실험적인 내용이기 때문에 수정될 여지가 있다. 바벨을 사용하면 이 데코레이터를 쓸 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-React-context-and-React-Redux"><a href="#What-is-the-difference-between-React-context-and-React-Redux" class="headerlink" title="What is the difference between React context and React Redux?"></a>What is the difference between React context and React Redux?</h3><p>Context는 어플리케이션에서 다이렉트로 사용할 수 있으며, 깊게 중첩된 컴포넌트에 데이터를 전달하는데 유용하다. 반면 Redux는 훨씬 더 강력하며, Context API가 제공하지 않는 기능을 제공한다. 또한, React Redux 는 내부적으로 context를 활용하지만, public api에 공개하지는 않는다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="Why-are-Redux-state-functions-called-reducers"><a href="#Why-are-Redux-state-functions-called-reducers" class="headerlink" title="Why are Redux state functions called reducers?"></a>Why are Redux state functions called reducers?</h3><p>Reducers 는 항상 모든 이전과 현재의 action을 기반으로한 상태값을 반환한다. Redux reducer 가 호출 될 때 마다 상태와 액션이 파라미터로 전달된다. 상태는 action 에 따라 감소되거나 누적되어 다음 상태를 반환한다. 최종 상태를 얻기 위한 action을 실행하는데 action 단위와 store 의 초기 상태 값을 줄일 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-make-AJAX-request-in-Redux"><a href="#How-to-make-AJAX-request-in-Redux" class="headerlink" title="How to make AJAX request in Redux?"></a>How to make AJAX request in Redux?</h3><p>비동기 액션을 허용하는 미들웨어인 <code>redux-thunk</code>를 사용하면 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchAccount</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    dispatch(setLoadingAccountState()); <span class="comment">// Show a loading spinner</span></span><br><span class="line">    fetch(<span class="string">`/account/<span class="subst">$&#123;id&#125;</span>`</span>, response =&gt; &#123;</span><br><span class="line">      dispatch(doneFetchingAccount()); <span class="comment">// Hide loading spinner</span></span><br><span class="line">      <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</span><br><span class="line">        dispatch(setAccount(response.json)); <span class="comment">// Use a normal function to set the received state</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch(someError);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAccount</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="string">"SET_Account"</span>, <span class="attr">data</span>: data &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Should-I-keep-all-component’s-state-in-Redux-store"><a href="#Should-I-keep-all-component’s-state-in-Redux-store" class="headerlink" title="Should I keep all component’s state in Redux store?"></a>Should I keep all component’s state in Redux store?</h3><p>Redux Store 에서는 Data를 저장하고, 컴포넌트 내부에서는 UI 에 관련된 상태들을 저장한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-proper-way-to-access-Redux-store"><a href="#What-is-the-proper-way-to-access-Redux-store" class="headerlink" title="What is the proper way to access Redux store?"></a>What is the proper way to access Redux store?</h3><p>컴포넌트에서 스토어에 접근하는 좋은 방법은 <code>connect()</code>함수를 이용하는 것이다. 이 함수는 이미 존재하는 컴포넌트를 감싸 새로운 컴포넌트를 만든다. 이러한 방식을 HOC(Higher Order Component)라고 하는데, 이는 리액트에서 컴포넌트의 기능을 확장할 때 주로 사용한다. 이 방법은 상태와 action 생성자를 컴포넌트에 매핑하고, store가 업데이트 되면 자동적으로 컴포넌트에 state와 action 생성자를 전달 할 수 있도록 해준다.</p><p>conenct를 사용한 <code>&lt;FilterLink&gt;</code> component예제를 아래에서 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; setVisibilityFilter &#125; <span class="keyword">from</span> <span class="string">"../actions"</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">"../components/Link"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> (&#123;</span><br><span class="line">  active: ownProps.filter === state.visibilityFilter</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch, ownProps</span>) =&gt;</span> (&#123;</span><br><span class="line">  onClick: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(setVisibilityFilter(ownProps.filter))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FilterLink = connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(Link);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FilterLink;</span><br></pre></td></tr></table></figure><p>이미 성능최적화가 되어 있고, 버그를 발생할 여지도 적기 때문에 개발자들은 context api로 바로 스토어에 접근하는 것 보다는 <code>connect()</code>를 사용하는 것을 더 선호한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-component-and-container-in-React-Redux"><a href="#What-is-the-difference-between-component-and-container-in-React-Redux" class="headerlink" title="What is the difference between component and container in React Redux?"></a>What is the difference between component and container in React Redux?</h3><p><code>Component</code>는 어플리케이션의 일부분을 표시하는 함수 또는 클래스 컴포넌트를 의미한다.</p><p><code>Container</code>는 비공식적인 용어로, Redux Store와 연결된 컴포넌트를 지칭한다. Container 는 Redux 의 state update 와 action 을 구독하며, DOM element 를 렌더링하지 않는다. 이러한 rendering응ㄴ 하위 component 들에게 위임한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-purpose-of-the-constants-in-Redux"><a href="#What-is-the-purpose-of-the-constants-in-Redux" class="headerlink" title="What is the purpose of the constants in Redux?"></a>What is the purpose of the constants in Redux?</h3><p>상수를 사용하면 IDE를 사용할 때 프로젝트 전체에서 특정한 기능의 모든 사용내역을 쉽게 찾을 수 있다. 또한 오타로 인한 버그도 방지할 수 있다. 오타가 난다면 즉시 <code>ReferenceError</code>를 낸다.</p><p>일반적으로 <code>constant.js</code>또는 <code>actionTypes.js</code>에 저장한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO = <span class="string">"ADD_TODO"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DELETE_TODO = <span class="string">"DELETE_TODO"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EDIT_TODO = <span class="string">"EDIT_TODO"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> COMPLETE_TODO = <span class="string">"COMPLETE_TODO"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> COMPLETE_ALL = <span class="string">"COMPLETE_ALL"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CLEAR_COMPLETED = <span class="string">"CLEAR_COMPLETED"</span>;</span><br></pre></td></tr></table></figure><p>이 파일은 두 군데에서 사용된다.</p><ol><li>액션 생성시</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ADD_TODO &#125; <span class="keyword">from</span> <span class="string">"./actionTypes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: ADD_TODO, text &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>리듀서</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ADD_TODO &#125; <span class="keyword">from</span> <span class="string">"./actionTypes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = [], action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO:</span><br><span class="line">      <span class="keyword">return</span> [</span><br><span class="line">        ...state,</span><br><span class="line">        &#123;</span><br><span class="line">          text: action.text,</span><br><span class="line">          completed: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      ];</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-different-ways-to-write-mapDispatchToProps"><a href="#What-are-the-different-ways-to-write-mapDispatchToProps" class="headerlink" title="What are the different ways to write mapDispatchToProps()?"></a>What are the different ways to write <code>mapDispatchToProps()</code>?</h3><p><code>mapDispatchToProps()</code> 안에서 dispatch() 를 사용하여 action creators를 바인딩하는 방법은 몇가지가 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  action: <span class="function"><span class="params">()</span> =&gt;</span> dispatch(action())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  action: bindActionCreators(action, dispatch)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123; action &#125;;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-use-of-the-ownProps-parameter-in-mapStateToProps-and-mapDispatchToProps"><a href="#What-is-the-use-of-the-ownProps-parameter-in-mapStateToProps-and-mapDispatchToProps" class="headerlink" title="What is the use of the ownProps parameter in mapStateToProps() and mapDispatchToProps()?"></a>What is the use of the <code>ownProps</code> parameter in <code>mapStateToProps()</code> and <code>mapDispatchToProps()</code>?</h3><p><code>ownProps</code> 파라미터가 명시되어 있다면, React Redux는 component로 전달된 props를 연결된 함수로 전달한다. 그래서 만약 connected component를 사용한다면,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ConnectedComponent <span class="keyword">from</span> <span class="string">"./containers/ConnectedComponent"</span>;</span><br><span class="line"></span><br><span class="line">&lt;ConnectedComponent user=&#123;<span class="string">"john"</span>&#125; /&gt;;</span><br></pre></td></tr></table></figure><p><code>mapStateToProps()</code>와 <code>mapDispatchToProps()</code>안의 <code>ownProps</code>는 객체가 될 것이다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">"user"</span>: <span class="string">"john"</span> &#125;</span><br></pre></td></tr></table></figure><p>이 객체를 활용하여 함수에서 무엇을 반환할지 결정할 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-structure-Redux-top-level-directories"><a href="#How-to-structure-Redux-top-level-directories" class="headerlink" title="How to structure Redux top level directories?"></a>How to structure Redux top level directories?</h3><p>대부분의 어플리케이션이 아래와 같은 상위구조 레벨을 가지고 있다.</p><ol><li>Components: Redux를 모르는 컴포넌트</li><li>Container: Redux와 연결된 컴포넌트</li><li>Actions: 파일의 이름이 앱의 일부와 일치하는 액션을 생성하는 모든 것</li><li>Reducer: 상태 키와 일치파는 파일명을 가진 모든 리듀서</li><li>Store: 스토어 초기화를 위해 사용</li></ol><p>이러한 구조는 중소규모의 어플리케이션에 적합하다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-redux-saga"><a href="#What-is-redux-saga" class="headerlink" title="What is redux-saga?"></a>What is redux-saga?</h3><p>redux-saga 는 side effects (데이터를 가져오는 비동기적인 작업이나 browser cache 에 접근하는 것등)를 React/Redux applications에서 더 쉽게 만들도록 도와주는 라이브러리다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-mental-model-of-redux-saga"><a href="#What-is-the-mental-model-of-redux-saga" class="headerlink" title="What is the mental model of redux-saga?"></a>What is the mental model of redux-saga?</h3><p><code>Saga</code>는 어플리케이션과 분리된 스레드와 같은것으로, 부수적인 역할을 담당하기 위한 책임을 가지고 있다. redux-saga는 redux의 미들웨어로, 메인 application 에서 Redux actions 과 함께 쓰레드를 시작, 중지, 취소 할 수 있으며 전체의 Redux application 상태에 접근할 수 있으며 Redux actions 도 전달할 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-differences-between-call-and-put-in-redux-saga"><a href="#What-are-the-differences-between-call-and-put-in-redux-saga" class="headerlink" title="What are the differences between call() and put() in redux-saga?"></a>What are the differences between <code>call()</code> and <code>put()</code> in redux-saga?</h3><p><code>call()</code> <code>put()</code> 모두 effect creator 함수다. <code>call()</code>은 함수는 middleware 가 promise 를 어떻게 호출할지를 설명하는 effect 을 생성하는데 사용된다. <code>put()</code> 함수는 store 에 action 을 통하여 전달하도록 미들웨어에게 가르치는 effect 를 생성한다.</p><p>사용자의 데이터를 가져오는 예제를 보고 effects 가 어떻게 동작하는지 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchUserSaga</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `call` function accepts rest arguments, which will be passed to `api.fetchUser` function.</span></span><br><span class="line">  <span class="comment">// Instructing middleware to call promise, it resolved value will be assigned to `userData` variable</span></span><br><span class="line">  <span class="keyword">const</span> userData = <span class="keyword">yield</span> call(api.fetchUser, action.userId);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instructing middleware to dispatch corresponding action.</span></span><br><span class="line">  <span class="keyword">yield</span> put(&#123;</span><br><span class="line">    type: <span class="string">"FETCH_USER_SUCCESS"</span>,</span><br><span class="line">    userData</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-Redux-Thunk"><a href="#What-is-Redux-Thunk" class="headerlink" title="What is Redux Thunk?"></a>What is Redux Thunk?</h3><p>Redux Thunk 는 action 대신 함수를 반환하는 action 생성자를 작성 할 수 있는 미들웨어다. Thunk 는 action dispatch 를 지연 시키거나, 특정한 조건이 성립되는 경우에만 dispatch 하도록 할 수 있다. 내부 함수는 파라미터로로 <code>dispatch()</code> <code>getState()</code>를 받는다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-differences-between-redux-saga-and-redux-thunk"><a href="#What-are-the-differences-between-redux-saga-and-redux-thunk" class="headerlink" title="What are the differences between redux-saga and redux-thunk?"></a>What are the differences between <code>redux-saga</code> and <code>redux-thunk</code>?</h3><p>Redux Thunk 와 Redux Saga 는 모두 side effect 를 다룬다. 대부분의 시나리오에서 Thunk 는 Promise 를 사용하여 처리하고 Saga 는 Generators 를 사용한다. Promise 는 많은 개발자들에게 친숙하기 때문에 Thunk 는 비교적 다루기 쉽고, Sagas와 Generator 는 기능은 강력한 반면에 러닝커브가 존재한다. 두 미들웨어 모두 공존 할 수 있다. Thunk 로 시작하여도 만약 Saga 가 필요하다면 도입 할 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-Redux-DevTools"><a href="#What-is-Redux-DevTools" class="headerlink" title="What is Redux DevTools?"></a>What is Redux DevTools?</h3><p>Redux DevTools 은 Redux 를 위한 hot reload 기능을 가진 실시간 편집이 가능한 툴이다. 액션을 다시 재현하거나 UI 를 사용자 정의에 맞게 만들 수 있다. Redux DevTools 을 프로젝트에 설치하여 사용하고 싶지 않다면 Chrome 또는 Firefox 용 Extension 사용을 고려해 볼 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-features-of-Redux-DevTools"><a href="#What-are-the-features-of-Redux-DevTools" class="headerlink" title="What are the features of Redux DevTools?"></a>What are the features of Redux DevTools?</h3><ol><li>모든 상태와 액션을 검사</li><li>action 을 취소하여 작업을 되돌리기</li><li>reducer 의 코드를 변경 시 staged된 액션을 재평가</li><li>action 에서 어떤 일이 일어났는지, 오류가 발생하였는지 확인</li><li><code>persistState()</code> store enhancer 을 사용하면 page reload 에서 debug session을 유지할 수 있음</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-Redux-selectors-and-why-to-use-them"><a href="#What-are-Redux-selectors-and-why-to-use-them" class="headerlink" title="What are Redux selectors and why to use them?"></a>What are Redux selectors and why to use them?</h3><p>Selectors 는 Redux state 를 인수로받고 데이터를 반환하여 component 로 전달하는 함수다.</p><p>예를 들어, state에서 유저 상태정보를 받는다면 아래와 같이 처리할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUserData = <span class="function"><span class="params">state</span> =&gt;</span> state.user.data;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-Redux-Form"><a href="#What-is-Redux-Form" class="headerlink" title="What is Redux Form?"></a>What is Redux Form?</h3><p>Redux Form은 React와 Redux와 동시에 작동하며, React 폼 내에서 Redux의 모든 상태를 저장할 수 있다. Redux Form은 HTML5 input요소들과 사용가능하며, Material UI, React Widget, React bootstrap 과 같은 UI 프레임워크와도 동작이 가능하다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-main-features-of-Redux-Form"><a href="#What-are-the-main-features-of-Redux-Form" class="headerlink" title="What are the main features of Redux Form?"></a>What are the main features of Redux Form?</h3><ol><li>Redux store를 통한 필드 값 유지</li><li>값 유효성 검사 (동기, 비동기)</li><li>포맷팅, 파싱, 정규화</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-add-multiple-middlewares-to-Redux"><a href="#How-to-add-multiple-middlewares-to-Redux" class="headerlink" title="How to add multiple middlewares to Redux?"></a>How to add multiple middlewares to Redux?</h3><p><code>applyMiddleware()</code>를 사용하면 된다. 예를 들어, <code>applyMiddleware()</code>를 사용하여 <code>redux-thunk</code>와 <code>logger</code>를 추가할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">const</span> createStoreWithMiddleware = applyMiddleware(ReduxThunk, logger)(</span><br><span class="line">  createStore</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-set-initial-state-in-Redux"><a href="#How-to-set-initial-state-in-Redux" class="headerlink" title="How to set initial state in Redux?"></a>How to set initial state in Redux?</h3><p><code>createStore</code>에 두번째 인자로 초기 state값을 넘겨주면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootReducer = combineReducers(&#123;</span><br><span class="line">  todos: todos,</span><br><span class="line">  visibilityFilter: visibilityFilter</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  todos: [&#123; <span class="attr">id</span>: <span class="number">123</span>, <span class="attr">name</span>: <span class="string">"example"</span>, <span class="attr">completed</span>: <span class="literal">false</span> &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(rootReducer, initialState);</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-Relay-is-different-from-Redux"><a href="#How-Relay-is-different-from-Redux" class="headerlink" title="How Relay is different from Redux?"></a>How Relay is different from Redux?</h3><p>Relay와 Redux모두 하나의 스토어를 쓴다는 점에서 같다. 가장 큰 차이점은, 서버로 붙어 받은 메시지만 릴레이 한다는 점, 그리고 상태값을 모두 GraphQL 쿼리로 받는다는 것이다. Relay는 변경된 데이터만 가져온다는 점에서 데이터를 캐싱하거나 최적화할 수 있다.</p><h2 id="React-Native"><a href="#React-Native" class="headerlink" title="React Native"></a>React Native</h2><h3 id="What-is-the-difference-between-React-Native-and-React"><a href="#What-is-the-difference-between-React-Native-and-React" class="headerlink" title="What is the difference between React Native and React?"></a>What is the difference between React Native and React?</h3><p>React는 자바스크립트 라이브러리로, 프론트엔드와 서버에서 동작하며, 유저인터페이스나 웹 어플리케이션을 만들기 위해 사용된다.</p><p>React Native는 네이티브 앱 컴포넌트를 컴파일하기 위한 모바일 프레임워크로, 자바스크립트 기반 React로 iOS, Android와 같은 네이티브 어플리케이션을 만들 수 있게 해준다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-test-React-Native-apps"><a href="#How-to-test-React-Native-apps" class="headerlink" title="How to test React Native apps?"></a>How to test React Native apps?</h3><p>React Native는 iOS나 안드로이드와 같은 시뮬레이터로만 테스트가 가능하다. <a href="https://expo.io" target="_blank" rel="noopener">expo app</a>를 활용한다면, qr코드를 활용하여 무선 네트워크 상에서도 모바일과 컴퓨터로 싱크를 맞출 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-do-logging-in-React-Native"><a href="#How-to-do-logging-in-React-Native" class="headerlink" title="How to do logging in React Native?"></a>How to do logging in React Native?</h3><p><code>console.log</code> <code>console.warn</code>을 사용할 수 있다. React Native v0.29에서는 아래 명령어로도 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ react-native log-ios</span><br><span class="line">$ react-native log-android</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-debug-your-React-Native"><a href="#How-to-debug-your-React-Native" class="headerlink" title="How to debug your React Native?"></a>How to debug your React Native?</h3><ol><li>iOS 시뮬레이터로 어플리케이션을 실행한다.</li><li><code>Command + D</code>를 눌러서 웹페이지가 <code>http://localhost:8081/debugger-ui</code>에서 실행되게 한다.</li><li>Pause On Caught Exceptions을 활성화 하면 원활하게 디버그가 가능하다.</li><li><code>Command + Option + I</code> 또는 <code>View</code> -&gt; <code>Developer</code> -&gt; <code>Developer Tools</code>로 크롬 개발자 도구를 띄운다.</li><li>디버그가 가능하다.</li></ol><p><a href="#table-of-contents">👆</a></p>]]></content>
    
    <summary type="html">
    
      목차

Table of Contents
No.QuestionsReact Router129What is React Router?130How React Router is different from history library?131What are the \ components of React Router v4?132What is the purpose of push and replace methods of history?133How do you programmatically navigate using React router v4?134H
    
    </summary>
    
    
      <category term="react" scheme="https://www.yceffort.kr/tags/react/"/>
    
      <category term="javascript" scheme="https://www.yceffort.kr/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>리액트 인터뷰 질문 &amp; 답 (1)</title>
    <link href="https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/"/>
    <id>https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/</id>
    <published>2019-08-20T07:22:35.000Z</published>
    <updated>2019-08-28T07:44:01.157Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2019/08/13/reactjs-interview-questions/">목차</a></p><div class="table-container"><table><thead><tr><th>No.</th><th>Questions</th></tr></thead><tbody><tr><td></td><td><strong>Core React</strong></td></tr><tr><td>1</td><td><a href="#what-is-react">리액트란 무엇인가?</a></td></tr><tr><td>2</td><td><a href="#what-are-the-major-features-of-react">리액트의 주요 기능은 무엇인가?</a></td></tr><tr><td>3</td><td><a href="#what-is-jsx">JSX란 무엇인가?</a></td></tr><tr><td>4</td><td><a href="#what-is-the-difference-between-element-and-component">element와 component의 차이점은 무엇인가?</a></td></tr><tr><td>5</td><td><a href="#how-to-create-components-in-react">리액트에서 컴포넌트를 어떻게 만드는가?</a></td></tr><tr><td>6</td><td><a href="#when-to-use-a-class-component-over-a-function-component">클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가?</a></td></tr><tr><td>7</td><td><a href="#what-are-pure-components">순수한 컴포넌트는 무엇인가?</a></td></tr><tr><td>8</td><td><a href="#what-is-state-in-react">state는 무엇인가?</a></td></tr><tr><td>9</td><td><a href="#what-are-props-in-react">props는 무엇인가?</a></td></tr><tr><td>10</td><td><a href="#what-is-the-difference-between-state-and-props">state와 props의 차이는 무엇인가?</a></td></tr><tr><td>11</td><td><a href="#why-should-we-not-update-the-state-directly">왜 state를 바로 업데이트 하면 안되는가?</a></td></tr><tr><td>12</td><td><a href="#what-is-the-purpose-of-callback-function-as-an-argument-of-setstate">setState() 콜백의 용도는 무엇인가?</a></td></tr><tr><td>13</td><td><a href="#what-is-the-difference-between-html-and-react-event-handling">HTML과 React의 이벤트 핸들링 차이는 무엇인가?</a></td></tr><tr><td>14</td><td><a href="#how-to-bind-methods-or-event-handlers-in-jsx-callbacks">JSX 콜백에 메소드나 이벤트 핸들러를 바인딩하는 방법은 무엇인가?</a></td></tr><tr><td>15</td><td><a href="#how-to-pass-a-parameter-to-an-event-handler-or-callback">이벤트 핸들러나 콜백에 파라미터를 전달하는 방법은?</a></td></tr><tr><td>16</td><td><a href="#what-are-synthetic-events-in-react">리액트의 synthetic event는 무엇인가?</a></td></tr><tr><td>17</td><td><a href="#what-is-inline-conditional-expressions">인라인 조건식은 무엇인가?</a></td></tr><tr><td>18</td><td><a href="#what-are-key-props-and-what-is-the-benefit-of-using-them-in-arrays-of-elements"><code>key</code> props는 무엇이며, 배열의 요소에서 사용함으로써 얻을 수 있는 이점은 무엇인가?</a></td></tr><tr><td>19</td><td><a href="#what-is-the-use-of-refs"><code>ref</code>의 목적은 무엇인가?</a></td></tr><tr><td>20</td><td><a href="#how-to-create-refs"><code>ref</code>는 어떻게 생성하는가?</a></td></tr><tr><td>21</td><td><a href="#what-are-forward-refs">forward refs란 무엇이인가?</a></td></tr><tr><td>22</td><td><a href="#which-is-preferred-option-with-in-callback-refs-and-finddomnode">callback ref와 findDOMNode중 어떤것이 더 선호되는가?</a></td></tr><tr><td>23</td><td><a href="#why-are-string-refs-legacy">string ref가 왜 legacy가 되었는가?</a></td></tr><tr><td>24</td><td><a href="#what-is-virtual-dom">Virtual DOM 은 무엇인가?</a></td></tr><tr><td>25</td><td><a href="#how-virtual-dom-works">Virtual DOM은 어떻게 작동하는가?</a></td></tr><tr><td>26</td><td><a href="#what-is-the-difference-between-shadow-dom-and-virtual-dom">Shadow DOM과 Virtual DOM의 차이는 무엇인가?</a></td></tr><tr><td>27</td><td><a href="#what-is-react-fiber">What is React Fiber?</a></td></tr><tr><td>28</td><td><a href="#what-is-the-main-goal-of-react-fiber">React Fiber의 목적은 무엇인가?</a></td></tr><tr><td>29</td><td><a href="#what-are-controlled-components">controlled components는 무엇인가?</a></td></tr><tr><td>30</td><td><a href="#what-are-uncontrolled-components">uncontrolled components는 무엇인가?</a></td></tr><tr><td>31</td><td><a href="#what-is-the-difference-between-createelement-and-cloneelement"><code>createElement</code>와 <code>cloneElement</code>의 차이는 무엇인가?</a></td></tr><tr><td>32</td><td><a href="#what-is-lifting-state-up-in-react">React에서 lifting state up은 무엇인가?</a></td></tr><tr><td>33</td><td><a href="#what-are-the-different-phases-of-component-lifecycle">Component Lifecycle의 각 phase에는 어떤 차이가 있는가?</a></td></tr><tr><td>34</td><td><a href="#what-are-the-lifecycle-methods-of-react">Component Lifecycle에는 어떤 method가 있는가?</a></td></tr><tr><td>35</td><td><a href="#what-are-higher-order-components">Higher-Order 컴포넌트는 무엇인가?</a></td></tr><tr><td>36</td><td><a href="#how-to-create-props-proxy-for-hoc-component">HOC 컴포넌트에서 props proxy를 어떻게 만드는가?</a></td></tr><tr><td>37</td><td><a href="#what-is-context">Context란 무엇인가?</a></td></tr><tr><td>38</td><td><a href="#what-is-children-prop">자식 prop는 무엇인가?</a></td></tr><tr><td>39</td><td><a href="#how-to-write-comments-in-react">React에서 주석을 어떻게 쓰는가?</a></td></tr><tr><td>40</td><td><a href="#what-is-the-purpose-of-using-super-constructor-with-props-argument">props 변수가 있는 super 생성자의 목적은 무엇인가?</a></td></tr><tr><td>41</td><td><a href="#what-is-reconciliation">reconciliation은 무엇인가??</a></td></tr><tr><td>42</td><td><a href="#how-to-set-state-with-a-dynamic-key-name">동적 key name으로 setState하는 방법은?</a></td></tr><tr><td>43</td><td><a href="#what-would-be-the-common-mistake-of-function-being-called-every-time-the-component-renders">렌더가 될 때 마다 호출되는 function의 일반적인 실수는 무엇인가?</a></td></tr><tr><td>44</td><td><a href="#is-lazy-function-supports-named-exports">lazy함수가 named exports를 지원하는가?</a></td></tr><tr><td>45</td><td><a href="#why-react-uses-classname-over-class-attribute">리액트가 class 속성에 class 대신 className을 쓰는가?</a></td></tr><tr><td>46</td><td><a href="#what-are-fragments">fragments란 무엇인가?</a></td></tr><tr><td>47</td><td><a href="#why-fragments-are-better-than-container-divs">fragment가 div 컨테이너보다 좋은 이유는?</a></td></tr><tr><td>48</td><td><a href="#what-are-portals-in-react">react에서 portals란 무엇인가?</a></td></tr><tr><td>49</td><td><a href="#what-are-stateless-components">stateless 컴포넌트란?</a></td></tr><tr><td>50</td><td><a href="#what-are-stateful-components">stateful 컴포넌트란?</a></td></tr><tr><td>51</td><td><a href="#how-to-apply-validation-on-props-in-react">React props에서 유효성 검사를 하는 방법은?</a></td></tr><tr><td>52</td><td><a href="#what-are-the-advantages-of-react">React의 장점은?</a></td></tr><tr><td>53</td><td><a href="#what-are-the-limitations-of-react">React의 한계는?</a></td></tr><tr><td>54</td><td><a href="#what-are-error-boundaries-in-react-v16">React v16에서 error boundaries는?</a></td></tr><tr><td>55</td><td><a href="#how-error-boundaries-handled-in-react-v15">React v15에서 error boundaries는?</a></td></tr><tr><td>56</td><td><a href="#what-are-the-recommended-ways-for-static-type-checking">정적 타입 체킹을 하는 최선의 방법은?</a></td></tr><tr><td>57</td><td><a href="#what-is-the-use-of-react-dom-package">react-dom package의 쓰임새는?</a></td></tr><tr><td>58</td><td><a href="#what-is-the-purpose-of-render-method-of-react-dom">react-dom의 render 메서드의 목적?</a></td></tr><tr><td>59</td><td><a href="#what-is-reactdomserver">ReactDOMServer란?</a></td></tr><tr><td>60</td><td><a href="#how-to-use-innerhtml-in-react">React에서 InnerHtml를 쓰는 방법은?</a></td></tr><tr><td>61</td><td><a href="#how-to-use-styles-in-react">React에서 스타일을 쓰는 방법은?</a></td></tr><tr><td>62</td><td><a href="#how-events-are-different-in-react">React에서 이벤트는 어떻게 다른가?</a></td></tr><tr><td>63</td><td><a href="#what-will-happen-if-you-use-setstate-in-constructor">constructor에서 setState를 쓴다면?</a></td></tr><tr><td>64</td><td><a href="#what-is-the-impact-of-indexes-as-keys">index를 키로 쓸 경우 어떤 일이 벌어지는가?</a></td></tr><tr><td>65</td><td><a href="#is-it-good-to-use-setstate-in-componentwillmount-method">componentWillMount() method안에서 setState()를 쓰는 것이 바람직한가?</a></td></tr><tr><td>66</td><td><a href="#what-will-happen-if-you-use-props-in-initial-state">initial state에서 props를 쓰면 어떻게 되는가?</a></td></tr><tr><td>67</td><td><a href="#how-do-you-conditionally-render-components">어떻게 조건부로 컴포넌트를 렌더링하는가?</a></td></tr><tr><td>68</td><td><a href="#why-we-need-to-be-careful-when-spreading-props-on-dom-elements">DOM 엘리먼트에서 스프레드 props를 쓸 때 주의해야 할 점은?</a></td></tr><tr><td>69</td><td><a href="#how-you-use-decorators-in-react">React에서 decorator를 쓰는 방법은?</a></td></tr><tr><td>70</td><td><a href="#how-do-you-memoize-a-component">컴포넌트를 메모이제이션 하는 법은?</a></td></tr><tr><td>71</td><td><a href="#how-you-implement-server-side-rendering-or-ssr">서버사이드렌더링을 하는 방법은?</a></td></tr><tr><td>72</td><td><a href="#how-to-enable-production-mode-in-react">React에서 프로덕션 모드를 키는 방법은?</a></td></tr><tr><td>73</td><td><a href="#what-is-cra-and-its-benefits">CRA는 무엇이고 이점은 무엇인가?</a></td></tr><tr><td>74</td><td><a href="#what-is-the-lifecycle-methods-order-in-mounting">마운팅시 라이프사이클 메서드의 순서는?</a></td></tr><tr><td>75</td><td><a href="#what-are-the-lifecycle-methods-going-to-be-deprecated-in-react-v16">React v16에서 deprecated된 라이프 사이클 메서드는?</a></td></tr><tr><td>76</td><td><a href="#what-is-the-purpose-of-getderivedstatefromprops-lifecycle-method">getDerivedStateFromProps() 의 목적은?</a></td></tr><tr><td>77</td><td><a href="#what-is-the-purpose-of-getsnapshotbeforeupdate-lifecycle-method">getSnapshotBeforeUpdate()의 목적은?</a></td></tr><tr><td>78</td><td><a href="#do-hooks-replace-render-props-and-higher-order-components">Hooks api가 render props와 HOC를 대체하는가?</a></td></tr><tr><td>79</td><td><a href="#what-is-the-recommended-way-for-naming-components">네이밍 컴포넌트를 위한 최상의 방법은?</a></td></tr><tr><td>80</td><td><a href="#what-is-the-recommended-ordering-of-methods-in-component-class">컴포넌트 클래스에서 메소더의 순서를 정하는 방법은?</a></td></tr><tr><td>81</td><td><a href="#what-is-a-switching-component">스위칭 컴포넌트란 무엇인가?</a></td></tr><tr><td>82</td><td><a href="#why-we-need-to-pass-a-function-to-setstate">왜 setState에 함수를 넘겨야 하는가?</a></td></tr><tr><td>83</td><td><a href="#what-is-strict-mode-in-react">React에서 strict mode란 무엇인가?</a></td></tr><tr><td>84</td><td><a href="#what-are-react-mixins">React 믹스인이란?</a></td></tr><tr><td>85</td><td><a href="#why-is-ismounted-an-anti-pattern-and-what-is-the-proper-solution">왜 isMounted()가 안티패턴이고, 이를 위한 올바른 해결책이 무엇인가?</a></td></tr><tr><td>86</td><td><a href="#what-are-the-pointer-events-supported-in-react">React에서 지원하는 포인터 이벤트는 무엇인가?</a></td></tr><tr><td>87</td><td><a href="#why-should-component-names-start-with-capital-letter">왜 컴포넌트 명은 대문자로 시작해야 하는가?</a></td></tr><tr><td>88</td><td><a href="#are-custom-dom-attributes-supported-in-react-v16">React v16에서 커스텀 DOM 속성을 지원하는가?</a></td></tr><tr><td>89</td><td><a href="#what-is-the-difference-between-constructor-and-getinitialstate">constructor와 getInitialState의 차이점은?</a></td></tr><tr><td>90</td><td><a href="#can-you-force-a-component-to-re-render-without-calling-setstate">setState를 호출하지 않고 강제로 컴포넌트를 리렌더링하는 방법은?</a></td></tr><tr><td>91</td><td><a href="#what-is-the-difference-between-super-and-superprops-in-react-using-es6-classes">React에서 es6클래스를 쓸 때 super()와 super(props)의 차이점은?</a></td></tr><tr><td>92</td><td><a href="#how-to-loop-inside-jsx">JSX에서 반복문을 도는 방법은?</a></td></tr><tr><td>93</td><td><a href="#how-do-you-access-props-in-attribute-quotes">HTML속성에서 props에 접근하는 방법은?</a></td></tr><tr><td>94</td><td><a href="#what-is-react-proptype-array-with-shape">React의 Prop array에 특정형식의 array를 넘기는 방법은?</a></td></tr><tr><td>95</td><td><a href="#how-to-conditionally-apply-class-attributes">조건부로 클래스 속성을 추가하는 방법은?</a></td></tr><tr><td>96</td><td><a href="#what-is-the-difference-between-react-and-reactdom">React과 ReactDOM의 차이는?</a></td></tr><tr><td>97</td><td><a href="#why-reactdom-is-separated-from-react">왜 React-DOM은 React에서 분리되었는가?</a></td></tr><tr><td>98</td><td><a href="#how-to-use-react-label-element">React 라벨 엘리먼트를 사용하는 방법은?</a></td></tr><tr><td>99</td><td><a href="#how-to-combine-multiple-inline-style-objects">여러개의 인라인 스타일을 한꺼번에 쓰는 방법은?</a></td></tr><tr><td>100</td><td><a href="#how-to-re-render-the-view-when-the-browser-is-resized">브라우저 리사이즈 시 뷰를 리렌더링하는 방법은?</a></td></tr><tr><td>101</td><td><a href="#what-is-the-difference-between-setstate-and-replacestate-methods">setState와 replaceState의 차이점은?</a></td></tr><tr><td>102</td><td><a href="#how-to-listen-to-state-changes">state의 변경을 listen하는 방법은?</a></td></tr><tr><td>103</td><td><a href="#what-is-the-recommended-approach-of-removing-an-array-element-in-react-state">React state에서 배열의 특정 엘리먼트를 지우는 올바른 방법은?</a></td></tr><tr><td>104</td><td><a href="#is-it-possible-to-use-react-without-rendering-html">HTML 렌더링 없이 React를 사용하는 방법은?</a></td></tr><tr><td>105</td><td><a href="#how-to-pretty-print-json-with-react">React에서 json을 pretty하게 프린트 하는 방법은?</a></td></tr><tr><td>106</td><td><a href="#why-you-cant-update-props-in-react">왜 React에서 props를 업데이트 하지 못하는가?</a></td></tr><tr><td>107</td><td><a href="#how-to-focus-an-input-element-on-page-load">페이지 로딩 중에 input 엘리먼트에 포커스를 주는 방법은?</a></td></tr><tr><td>108</td><td><a href="#what-are-the-possible-ways-of-updating-objects-in-state">state에 있는 객체를 업데이트하는 방법은?</a></td></tr><tr><td>109</td><td><a href="#why-function-is-preferred-over-object-for-setstate">왜 setState()에 object보다 function이 더 나은가?</a></td></tr><tr><td>110</td><td><a href="#how-can-we-find-the-version-of-react-at-runtime-in-the-browser">브라우저에서 React 런타임의 버전을 알아내는 방법은?</a></td></tr><tr><td>111</td><td><a href="#what-are-the-approaches-to-include-polyfills-in-your-create-react-app">CTA에서 폴리필을 추가하는 일반적인 방법은?</a></td></tr><tr><td>112</td><td><a href="#how-to-use-https-instead-of-http-in-create-react-app">CTA에서 http대신 https를 쓰는 법은?</a></td></tr><tr><td>113</td><td><a href="#how-to-avoid-using-relative-path-imports-in-create-react-app">CTA에서 상대경로 import를 피하는 방법은?</a></td></tr><tr><td>114</td><td><a href="#how-to-add-google-analytics-for-react-router">React 라우터에 구글 애널리틱스를 붙이는 방법은?</a></td></tr><tr><td>115</td><td><a href="#how-to-update-a-component-every-second">매 초마다 컴포넌트를 업데이트 하는 방법은?</a></td></tr><tr><td>116</td><td><a href="#how-do-you-apply-vendor-prefixes-to-inline-styles-in-react">React에서 인라인 스타일로 vendor prefixes를 붙이는 방법은?</a></td></tr><tr><td>117</td><td><a href="#how-to-import-and-export-components-using-react-and-es6">React와 ES6를 활용해서 컴포넌트를 import &amp; export 하는 방법은?</a></td></tr><tr><td>118</td><td><a href="#what-are-the-exceptions-on-react-component-naming?">React 컴포넌트 명에서 주의해야 할 점은?</a></td></tr><tr><td>119</td><td><a href="#why-is-a-component-constructor-called-only-once">왜 컴포넌트 생성자는 단 한번만 호출되는가?</a></td></tr><tr><td>120</td><td><a href="#how-to-define-constants-in-react">React에서 상수를 선언하는 방법은?</a></td></tr><tr><td>121</td><td><a href="#how-to-programmatically-trigger-click-event-in-react">React에서는 어떻게 클릭이벤트가 트리거 되는가?</a></td></tr><tr><td>122</td><td><a href="#is-it-possible-to-use-asyncawait-in-plain-react">React에서 async await을 쓰는 것이 가능한가?</a></td></tr><tr><td>123</td><td><a href="#what-are-the-common-folder-structures-for-react">React의 일반적인 디렉토리 구조는?</a></td></tr><tr><td>124</td><td><a href="#what-are-the-popular-packages-for-animation">유명한 애니메이션을 위한 패키지는?</a></td></tr><tr><td>125</td><td><a href="#what-is-the-benefit-of-styles-modules">style 모듈의 이점은 무엇인가?</a></td></tr><tr><td>126</td><td><a href="#what-are-the-popular-react-specific-linters">React에 특화된 linter엔 무엇이 있는가?</a></td></tr><tr><td>127</td><td><a href="#how-to-make-ajax-call-and-in-which-component-lifecycle-methods-should-i-make-an-ajax-call">Ajax call은 어떻게 만들고, 어느 라이프사이클 메소드에서 실행해야 하는가?</a></td></tr><tr><td>128</td><td><a href="#what-are-render-props">render props란 무엇인가?</a></td></tr></tbody></table></div><hr><h2 id="Core-React"><a href="#Core-React" class="headerlink" title="Core React"></a>Core React</h2><h3 id="What-is-React"><a href="#What-is-React" class="headerlink" title="What is React"></a>What is React</h3><p>리액트는 오픈소스 프론트엔드 자바스크립트 라이브러리로, 특히 싱글 페이지 어플리케이션의 사용자 인터페이스 구축을 위해 사용된다. 웹가 모바일 앱의 뷰단을 다르기 위하여 사용되고 있다. 리액트는 페이스북에서 일아흔 Jordan Walke가 만들었다. 최초로 리액트 기반으로 만들어진 서비스는 2011년에 페이스북 뉴스 피드이며, 2012년에는 인스타그램도 리액트로 만들어 졌다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-major-features-of-React"><a href="#What-are-the-major-features-of-React" class="headerlink" title="What are the major features of React?"></a>What are the major features of React?</h3><p>리액트의 주요 기능은 무엇인가?</p><ul><li>RealDOM을 조작하는데 많은 비용이 소모되어 대신 VirtualDOM을 활용하고 있다.</li><li>서버사이드렌더링을 지원한다</li><li>단방향 데이터흐름 또는 단방향 데이터 바인딩을 따른다</li><li>뷰를 개발하는데 있어 재사용 가능한 컴포넌트 사용</li></ul><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-JSX"><a href="#What-is-JSX" class="headerlink" title="What is JSX?"></a>What is JSX?</h3><p>JSX는 ECMA Script의 XML 신택스 확장 표기법이다. (Javascript XML의 약자다.) 기본적으로, <code>React.createElement()</code>함수에 문법 슈가를 제공하며,HTML 스타일의 템플릿 구문화함께 javascript를 표현할 수 있다.</p><p>아래 예제에서, <code>return</code>안에 있는 <code>&lt;h1&gt;</code> 구문이 자바스크립트 함수의 render function 으로 제공된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="string">"Welcome to React world!"</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-Element-and-Component"><a href="#What-is-the-difference-between-Element-and-Component" class="headerlink" title="What is the difference between Element and Component?"></a>What is the difference between Element and Component?</h3><p><code>element</code>는 DOM노드나 컴포넌트 단에서 화면에 보여주고 싶은 요소를 그리는 하나의 오브젝트를 의미한다. <code>element</code>는 <code>element</code>의 props에서 포함될 수 있다. 리액트에서 <code>element</code>를 만드는건 많은 비용이 들지 않는다. 한번 만들고 나면, 더이상 변경이 불가능하다.</p><p>리액트에서 <code>element</code>를 만드는 예시는 아래와 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(<span class="string">"div"</span>, &#123; <span class="attr">id</span>: <span class="string">"login-btn"</span> &#125;, <span class="string">"Login"</span>);</span><br></pre></td></tr></table></figure><p>위 함수는 아래와 같은 object를 리턴한다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    children: <span class="string">'Login'</span>,</span><br><span class="line">    id: <span class="string">'login-btn'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>ReactDOM.render()</code>이 아래와 같은 DOM을 만들어 줄 것이다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"login-btn"</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>반면에 컴포넌트는 다양한 방식으로 선언가능하다. 컴포넌트는 <code>render()</code>와 함께 쓴다면 클래스가 될 수도 있다. 좀더 단순한 방법으로, 함수로도 선언이 될 수 있다. 두 방식 모두 <code>props</code>를 input으로 받으며, <code>JSX</code>를 리턴한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123; onLogin &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div id=&#123;<span class="string">"login-btn"</span>&#125; onClick=&#123;onLogin&#125;&gt;</span><br><span class="line">    Login</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>JSX는 이를 <code>React.createElement()</code> 함수로 트랜스파일 시킬 것이다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Button = (&#123; onLogin &#125;) =&gt; React.createElement( 'div', &#123; id: 'login-btn',</span><br><span class="line">onClick: onLogin &#125;, 'Login' )</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-create-components-in-React"><a href="#How-to-create-components-in-React" class="headerlink" title="How to create components in React?"></a>How to create components in React?</h3><p>두 가지 방법이 존재한다.</p><ol><li>함수형 컴포넌트: 컴포넌트를 만드는 가장 심플한 방식이다. <code>props</code>를 첫번째 파라미터로 받는 받는 순수 자바스크립트 함수를 만들고, React Element를 반환하면 된다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">&#123; message &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello, $&#123;message&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>클래스 컴포넌트: ES6의 클래스를 활용하여 컴포넌트를 정의할 수도 있다. 위 컴포넌트를 클래스 컴포넌트로 바꾼다면 이렇게 될 것이다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello, $&#123;this.props.message&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="When-to-use-a-Class-Component-over-a-Function-Component"><a href="#When-to-use-a-Class-Component-over-a-Function-Component" class="headerlink" title="When to use a Class Component over a Function Component?"></a>When to use a Class Component over a Function Component?</h3><p>컴포넌트가 <strong>state나 라이프 사이클 메소드를</strong> 필요로 할 때 클래스 컴포넌트를, 그렇지 않으면 함수형 컴포넌트를 활용하면 된다.</p><blockquote><p>근데 요즘은 <code>useState</code>을 사용하면 함수형 컴포넌트에서도 state사용이 가능하다</p></blockquote><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-Pure-Components"><a href="#What-are-Pure-Components" class="headerlink" title="What are Pure Components?"></a>What are Pure Components?</h3><p><code>React.PureComponent</code>는 <code>React.Component</code>에서 <code>shouldComponentUpdate</code>가 없다는 것만 제외하면 동일하다. <code>props</code>나 <code>state</code>에 변화가 있을 경우, <code>PureComponent</code>는 두 변수에 대해서 <a href="https://reactjs.org/docs/shallow-compare.html" target="_blank" rel="noopener">얕은 비교</a>를 한다. 반면 <code>Component</code>는 그런 비교를 하지 않는다. 따라서 <code>Component</code>는 <code>shouldComponentUpdate</code>가 호출 될 때마다 다시 render한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-state-in-React"><a href="#What-is-state-in-React" class="headerlink" title="What is state in React?"></a>What is state in React?</h3><p><code>state</code>란 컴포넌트가 살아있는 동안에 걸쳐 변화할 수도 있는 값을 가지고 있는 object다. 따라서 state를 가능한 간단하게, 그리고 state의 구성요소를 최소화하는 노력을 기울여야 한다. 다음은 User Component에 message state를 관리하는 예제다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      message: <span class="string">"Welcome to React world"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="keyword">this</span>.state.message&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>state</code>는 <code>props</code>와 비슷하지만, 컴포넌트가 완전히 소유권을 쥐고 있다는 것이 다르다.다른 어떤 컴포넌트도 한 컴포넌트가 소유하고 있는 <code>state</code>에 접근할 수 없다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-props-in-React"><a href="#What-are-props-in-React" class="headerlink" title="What are props in React?"></a>What are props in React?</h3><p><code>props</code>는 컴포넌트의 input 값이다. HTML 태그 속성과 유사한 규칙을 사용하여 ReactComponent에 전달할 수 있는 단일 값 또는 객체 다. 이런 데이터 들은 부모 컴포넌트에서 자식 컴포넌트로 보낼 수 있다.</p><p>리액트에서 <code>props</code>를 쓰는 주요 목적은 컴포넌트에 아래와 같은 기능을 제공하기 위해서다.</p><ul><li>컴포넌트에 custom data를 넘기기 위해</li><li><code>state</code>의 변화를 trigger 하기 위해</li><li>Component의 render메소드 안에서 this.props.*** 로 사용하기 위함</li></ul><p>예를 들어, <code>reactProp</code> 을 만들어서 쓴다고 가정해 보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Element reactProp=&#123;<span class="string">"1"</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p><code>reactProp</code>은 (뭐라고 정의했던 지 간에) React를 사용하여 생성된 component에서 접근이 가능하고, React native props에서 접근하여 사용할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.reactProp;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-state-and-props"><a href="#What-is-the-difference-between-state-and-props" class="headerlink" title="What is the difference between state and props?"></a>What is the difference between state and props?</h3><p><code>props</code>와 <code>state</code>는 모두 순수 자바스크립트 오브젝트다. 두 객체 모두 <code>render</code>의 output에 영향을 줄 수 있는 정보를 가지고 있지만, 컴포넌트의 기능적인 측면에서는 약간 다르다. <code>props</code>는 함수의 파라미터와 비슷한 방식으로 작동하는 반면, <code>state</code>는 컴포넌트 내에서 선언된 변수와 비슷하다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="Why-should-we-not-update-the-state-directly"><a href="#Why-should-we-not-update-the-state-directly" class="headerlink" title="Why should we not update the state directly?"></a>Why should we not update the state directly?</h3><p><code>state</code>를 아래와 같이 바로 업데이트 하면 렌더링이 일어나지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.message = <span class="string">"Hello world"</span>;</span><br></pre></td></tr></table></figure><p>대신에 <code>setState()</code> 메서드를 사용하자.이는 <code>state</code>의 변경이 있을 때 <code>component</code>를 업데이트 해준다. <code>state</code>에 변화가 있을 경우, 컴포넌트는 리렌더링으로 응답한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">message</span>: <span class="string">"Hello World"</span> &#125;);</span><br></pre></td></tr></table></figure><p>주의: state를 직접 할당할 수 있는 곳은 <code>constructor</code> 혹은 자바스크립트 클래스의 필드를 선언하는 syntax 뿐이다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-purpose-of-callback-function-as-an-argument-of-setState"><a href="#What-is-the-purpose-of-callback-function-as-an-argument-of-setState" class="headerlink" title="What is the purpose of callback function as an argument of setState()?"></a>What is the purpose of callback function as an argument of <code>setState()</code>?</h3><p>콜백함수는 setState가 끝나고 컴포넌트가 렌더링 된 이후에 실행된다.<code>setState</code>는 비동기로 이루어지기 때문에 callback에서는 어떤 액션이든 취할 수 있다.</p><p>주의: 콜백함수를 사용하는 것보다 라이프사이클 메서드를 사용하는게 더 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setState(&#123; <span class="attr">name</span>: <span class="string">"John"</span> &#125;, () =&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The name has updated and component re-rendered"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="What-is-the-difference-between-HTML-and-React-event-handling"><a href="#What-is-the-difference-between-HTML-and-React-event-handling" class="headerlink" title="What is the difference between HTML and React event handling?"></a>What is the difference between HTML and React event handling?</h3><ol><li>HTML에서는 이벤트명은 소문자로 작성되어야 한다.</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"activateLasers()"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React는 camelCase를 사용한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">"&#123;activateLasers&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>HTML에서는, <code>false</code>를 리턴하면 이후 기본 액션을 막을 수 있다.</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">'console.log("The link was clicked."); return false;'</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>하지만 react에서는 <code>preventDefault()</code>를 명시적으로 사용해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The link was clicked."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="How-to-bind-methods-or-event-handlers-in-JSX-callbacks"><a href="#How-to-bind-methods-or-event-handlers-in-JSX-callbacks" class="headerlink" title="How to bind methods or event handlers in JSX callbacks?"></a>How to bind methods or event handlers in JSX callbacks?</h3><ol><li>생성자에서 바인딩하기: 자바스크립트 클래스에서는, 메소드들이 기본적으로 바인딩 되어 있지 않다. 이는 클래스 메서드로 정의된 리액트 이벤트 핸들러와 마찬가지다. 보통, 생성자에서 바인딩한다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Componenet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>퍼블리기 클래스 필드 구문: 생성자에서 바인딩 되기를 원치 않는다면, 퍼블릭 클래스의 필드 구문을 이용하여 callback을 올바르게 바인딩 할 수 있다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"this is:"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt; Click me &lt;<span class="regexp">/button&gt;;</span></span><br></pre></td></tr></table></figure><blockquote><p>클래스 필드(class field)<br>클래스 내부의 캡슐화된 변수를 말한다. 데이터 멤버 또는 멤버 변수라고도 부른다. 클래스 필드는 인스턴스의 프로퍼티 또는 정적 프로퍼티가 될 수 있다. 쉽게 말해, 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티를 클래스 기반 객체지향 언어에서는 클래스 필드라고 부른다.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  name = <span class="string">""</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>constructor 내부에서 선언한 클래스 필드는 클래스가 생성할 인스턴스를 가리키는 this에 바인딩한다. 이로써 클래스 필드는 클래스가 생성할 인스턴스의 프로퍼티가 되며, 클래스의 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. 즉, 언제나 public이다.<br>ES6의 클래스는 다른 객체지향 언어처럼 private, public, protected 키워드와 같은 접근 제한자(access modifier)를 지원하지 않는다.</p></blockquote><ol><li>화살표함수: 콜백에 화살표 함수를 사용할 수도 있다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;event =&gt; <span class="keyword">this</span>.handleClick(event)&#125;&gt;&#123;<span class="string">"Click me"</span>&#125;&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>주의: 콜백이 하위 컴포넌트에 <code>prop</code>으로 전달된다면, component가 리렌더링 될 수도 있다. 이러한 경우에는, 성능을 고려해서 1, 2번의 예제를 활용하는 것이 낫다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-pass-a-parameter-to-an-event-handler-or-callback"><a href="#How-to-pass-a-parameter-to-an-event-handler-or-callback" class="headerlink" title="How to pass a parameter to an event handler or callback?"></a>How to pass a parameter to an event handler or callback?</h3><p>이벤트 핸들러와 파라미터 전달을ㅇ 화살표 함수로 감쌀 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick(id)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>이는 <code>.bind</code>와 같다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">"&#123;this.handleClick.bind(this,"</span> <span class="attr">id</span>)&#125; /&gt;</span></span><br></pre></td></tr></table></figure><p>두 방식 이외에도, 아래와 같은 배열 함수 방식으로 정의해서 전달할 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick(id)&#125; /&gt;;</span><br><span class="line">handleClick = <span class="function"><span class="params">id</span> =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, your ticket number is"</span>, id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-synthetic-events-in-React"><a href="#What-are-synthetic-events-in-React" class="headerlink" title="What are synthetic events in React?"></a>What are synthetic events in React?</h3><p>synthetic event (합성함수) 는 브라우저의 네이티브 이벤트를 위한 크로스 브라우저 래퍼다. 이 api는 브라우저의 네이티브 이벤트와 동일하며, 마찬가지로 <code>stopPropagation()</code> <code>preventDefault()</code>도 포함하고 있지만, 모든 브라우저에서 동일하게 작동한다는 점이 다르다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-inline-conditional-expressions"><a href="#What-is-inline-conditional-expressions" class="headerlink" title="What is inline conditional expressions?"></a>What is inline conditional expressions?</h3><p>조건부 렌더 표현을 위해 javascript의 if문이나 삼항연산자를 사용할 수 있다. 이외에도 중괄호로 묶어서 javascript의 논리식인 &amp;&amp;을 붙여서 jsx에서도 사용할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">; &#123; messages.length &gt; 0 &amp;&amp; !isLogin ? (</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>You have &#123;messages.length&#125; unread messages.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">) : (</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>You don't have unread messages.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">); &#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-“key”-props-and-what-is-the-benefit-of-using-them-in-arrays-of-elements"><a href="#What-are-“key”-props-and-what-is-the-benefit-of-using-them-in-arrays-of-elements" class="headerlink" title="What are “key” props and what is the benefit of using them in arrays of elements?"></a>What are “key” props and what is the benefit of using them in arrays of elements?</h3><p><code>key</code>는 특별한 string 속성으로, 배열을 사용할 때 이용해야 한다. <code>key</code>는 리액트에서 어떤 item이 변화하고, 추가되고, 삭제되었는지 구별하는데 도움을 준다. 대부분 key로 id를 사용한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map(todo =&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"&#123;todo.id&#125;"</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>만약 이런 ID가 없다면, index를 사용할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo, index) =&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"&#123;index&#125;"</span>&gt;</span></span><br><span class="line">  &#123;todo.text&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>주의</p><ol><li>index를 key로 사용하는 방식은, 아이템의 순서가 바뀌는 경우가 발생할 수 있는 케이스에는 별로 추천할만하지 못하다. 이는 퍼포먼스에 악영향을 미치고, component state에 악영향을 미칠 수 있다.</li><li>list를 별도 컴포넌트로 뽑아서 사용하는 경우, key를 리스트 컴포넌트가 아닌 <code>li</code> 태그에 사용해야 한다.</li><li>리스트 아이템에 <code>key</code>가 없으면 콘솔에 경고 메시지가 뜬다.</li></ol><h3 id="What-is-the-use-of-refs"><a href="#What-is-the-use-of-refs" class="headerlink" title="What is the use of refs?"></a>What is the use of refs?</h3><p><code>ref</code>는 element의 참조값을 반환한다. 대부분 이러한 경우는 피해야 하지만, DOM이나 component에 다이렉트로 접근해야할 때 유용하다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-create-refs"><a href="#How-to-create-refs" class="headerlink" title="How to create refs?"></a>How to create refs?</h3><ol><li>최근에 추가된 방식으로, <code>React.createRef()</code> 메소들를 사용하면, React element는 <code>ref</code>를 통해서 접근할 수 있다. <code>ref</code>를 컴포넌트에서 접근하기 위해서는, 생성자 안에 <code>ref</code>를 instance property로 할당하면 된다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><ol><li>React 버전과 상관없이 ref 콜백을 활용하는 방식이 있다. 예를 들어, SearchBar 컴포넌트의 인풋 요소들은 아래와 같은 방식으로 접근 가능하다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchBar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.txtSearch = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">term</span>: <span class="string">""</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.setInputSearchRef = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.txtSearch = e;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  onInputChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">term</span>: <span class="keyword">this</span>.txtSearch.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input</span><br><span class="line">        value=&#123;<span class="keyword">this</span>.state.term&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>.onInputChange.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">        ref=&#123;<span class="keyword">this</span>.setInputSearchRef&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또한 컴포넌트의 함수 내에서 클로져를 <code>ref</code>를 사용할 수도 있다.</p><p>주의: 추천할만한 방법은 아니지만, 인라인 <code>ref</code> callback을 이용하는 방식도 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-forward-refs"><a href="#What-are-forward-refs" class="headerlink" title="What are forward refs?"></a>What are forward refs?</h3><p>Ref forwarding은 일부 컴포넌트에서 ref를 받아서 자식 컴포넌트에게 전달하는 것을 의미한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ButtonElement = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">"CustomButton"</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Create ref to the DOM button:</span></span><br><span class="line"><span class="regexp">const ref = React.createRef();</span></span><br><span class="line"><span class="regexp">&lt;ButtonElement ref=&#123;ref&#125;&gt;&#123;"Forward Ref"&#125;&lt;/</span>ButtonElement&gt;;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Which-is-preferred-option-with-in-callback-refs-and-findDOMNode"><a href="#Which-is-preferred-option-with-in-callback-refs-and-findDOMNode" class="headerlink" title="Which is preferred option with in callback refs and findDOMNode()?"></a>Which is preferred option with in callback refs and findDOMNode()?</h3><p>callback ref를 쓰는 것이 더 선호된다. 왜냐하면 <code>findDOMNode()</code>는 향후에 있을 리액트의 개선사항이 반영되지 않기 때문이다.</p><p>레거시에서 <code>findDOMNode</code>를 사용하는 방법이 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    findDOMNode(<span class="keyword">this</span>).scrollIntoView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>그래서 선호하는 방법은 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.node = createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.node.current.scrollIntoView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.node&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Why-are-String-Refs-legacy"><a href="#Why-are-String-Refs-legacy" class="headerlink" title="Why are String Refs legacy?"></a>Why are String Refs legacy?</h3><p>예전에 React를 다뤄보았다면, 옛날 방식인 <code>ref</code>를 string으로 쓰는, <code>ref={&#39;textInput&#39;}</code> 와 같이 ref속성이 string이고, DOM Node인 <code>refs.textInput</code>로 접근하는 방법에 익숙할 것이다. 그러나 이러한 string ref는 하단에서 언급할 문제들 때문에, 레거시로 보는 것이 맞다. 그리고 string ref는 React v16에서 제거 되었다.</p><ol><li>String ref는 실행중인 component 요소를 추적하도록 강제한다. 그리고 React Module을 stateful하게 만들기 때문에, 이는 번들시 react module이 중복 되는 경우 이상한 오류를 발생시킨다.</li><li>라이브러리를 추가하여 String ref를 child component에 전달한다면, 사용자는 다른 ref를 추가할 수 없다. 그러나 callback ref를 사용하면 이런 문제를 해결할 수 있다.</li><li>Flow와 같은 정적 분석에서는 동작하지 않는다. Flow는 string ref를 this.refs와 같은 형태로 표시하도록 만드는 트릭을 추적할 수 없다. callback ref는 string ref보다 flow에 더 잘맞다.</li><li>대부분이 render callback 패턴으로 동작하기를 기대하지만, 그렇게 동작하지 않는다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  renderRow = <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 동작하지 않는다. ref는 MyComponent가 아닌 DataTable에 연결될 것이다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;</span>"<span class="attr">input-</span>" + <span class="attr">index</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // 이거는 동작한다. callback ref가 짱이다.</span></span><br><span class="line">    return &lt;input ref=&#123;input =&gt; (this["input-" + index] = input)&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;DataTable data=&#123;this.props.data&#125; renderRow=&#123;this.renderRow&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-Virtual-DOM"><a href="#What-is-Virtual-DOM" class="headerlink" title="What is Virtual DOM?"></a>What is Virtual DOM?</h3><p>Virtual DOM은 메모리 내에서 표현되는 Real DOM 이다. UI는 메모리 상에서 표현되며, 그리고 real DOM과 동기화 된다. 이는 렌더 함수 호출과 화면에 elements 표시 하는 사이에 일어난다. 이 모든 과정을 <code>reconciliation</code>이라고 한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-Virtual-DOM-works"><a href="#How-Virtual-DOM-works" class="headerlink" title="How Virtual DOM works?"></a>How Virtual DOM works?</h3><ol><li><p>어디서든 데이터가 편하면, Virtual DOM내에서 전체 UI가 다시 렌덜이 된다.<br><img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom1.png" alt="virtual-dom-1"></p></li><li><p>그런 다음 이전 DOM과 새로운 DOM을 비교한다.<br><img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom2.png" alt="virtual-dom-2"></p></li><li><p>계산이 끝나면, Real DOM 중에서 실제로 업데이트가 있었던 부분 만 변경을 가한다.<br><img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom3.png" alt="virtual-dom-3"></p></li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-Shadow-DOM-and-Virtual-DOM"><a href="#What-is-the-difference-between-Shadow-DOM-and-Virtual-DOM" class="headerlink" title="What is the difference between Shadow DOM and Virtual DOM?"></a>What is the difference between Shadow DOM and Virtual DOM?</h3><p>Shadow DOM은 web component의 scope및 CSS scope 지정을 위해 설계된 web browser 기술이다. Virtual DOM은 브라우저 API 위에 자바스크립트에서 구현되는 개념이다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-React-Fiber"><a href="#What-is-React-Fiber" class="headerlink" title="What is React Fiber?"></a>What is React Fiber?</h3><p>Fiber는 React v16에서 새로운 reconciliation 엔진, 그리고 코어 알고리즘을 새로 작성한 것으로 볼 수 있다. React Fiber의 목적은 애니메이션, 레이아웃, 제스쳐, 작업일시정지 및 중단, 여려 유형의 업데이트 우선순위 조절, 동시성 등 여러가지 기본 사항에 대한 성능을 높이는 것이다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-main-goal-of-React-Fiber"><a href="#What-is-the-main-goal-of-React-Fiber" class="headerlink" title="What is the main goal of React Fiber?"></a>What is the main goal of React Fiber?</h3><p>React Fiber 의 목표는 애니메이션, 레이아웃, 제스처등의 성능을 높이는 것이다. 렌더링 작업을 chunk별로 작업하고, 여러 프레임 별로 이를 펼치면서 작업하는 점진적 렌더링을 통해 이를 구현했다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-controlled-components"><a href="#What-are-controlled-components" class="headerlink" title="What are controlled components?"></a>What are controlled components?</h3><p>입력요소를 제어하는 component를 controlled components라고 부른다. 모든 상태변경에 연관뢴 handler function이 존재한다.</p><p>예를 들어, 모든 이름을 대문자로 쓰기 위해서는, <code>handleChange</code>를 아래와 같이 쓰게 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange(event) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value.toUpperCase()&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-uncontrolled-components"><a href="#What-are-uncontrolled-components" class="headerlink" title="What are uncontrolled components?"></a>What are uncontrolled components?</h3><p>uncontrolled components란 내부적으로 자기 자신의 state를 가지고 있는 component다. 현재 필요한 값을 찾기 위해 ref를 사용하여 DOM query를 할 수 있다. 이는 전통적인 HTML 과 비슷하다.</p><p><code>UserProfile</code> Component를 아래에서 보자면, <code>name</code> input이 ref를 통해서 접근할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProfile</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.input = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">"A name was submitted: "</span> + <span class="keyword">this</span>.input.current.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          &#123;<span class="string">"Name:"</span>&#125;</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.input&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>대부분의 경우, 폼에서는 controlled component를 사용하기를 추천한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-createElement-and-cloneElement"><a href="#What-is-the-difference-between-createElement-and-cloneElement" class="headerlink" title="What is the difference between createElement and cloneElement?"></a>What is the difference between createElement and cloneElement?</h3><p>JSX는 <code>React.createElement()</code> 함수로 UI에 나타낼 React element를 생성한다. 반면 <code>cloneElement</code>는 element를 props로 보낼 때 사용한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-Lifting-State-Up-in-React"><a href="#What-is-Lifting-State-Up-in-React" class="headerlink" title="What is Lifting State Up in React?"></a>What is Lifting State Up in React?</h3><p>여러 component 들이 동일한 변경 데이터를 공유해야하는 경우 가까운 부모 component 로 state를 올리는 것이 좋다. 즉, 두개의 자식 component가 부모에 있는 동일한 데이터를 공유할 때. 두개의 자식 component 들은 local state를 유지하는 대신, 부모로 state를 올려야 한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-different-phases-of-component-lifecycle"><a href="#What-are-the-different-phases-of-component-lifecycle" class="headerlink" title="What are the different phases of component lifecycle?"></a>What are the different phases of component lifecycle?</h3><p>React lifecycle에는 세 개의 phase가 있다.</p><ol><li><code>mounting</code>: 컴포넌트가 browser DOM에 마운트 될 준비가 된 상태다. 이 phase에는 <code>constructor()</code> <code>getDerivedStateFromProps()</code> <code>render()</code> <code>componentDidMount()</code>가 있다</li><li><code>updating</code>: 이 단계에서는, 컴포넌트가 두가지 방법으로 업데이트 된다. 새로운 <code>props</code>를 보내거나, <code>setState()</code> <code>forceUpdate()</code>를 통해서 state를 업데이트 하는 방법이 있다. 이 단계에서는, <code>getDerivedStateFromProps()</code> <code>shouldComponentUpdate()</code> <code>render()</code> <code>getSnapshotBeforeUpdate()</code> <code>componentDidUpdate()</code> 가 포함된다.</li><li><code>unmounting</code>: 이단계에서는, browser DOM이 더 이 더이상 필요 없어지거나 unmount된다. 여기에는 <code>componentWillUnmount()</code>가 포함된다.</li></ol><p>DOM에서의 변경을 적용할 때, 내부에서 어떤 과정을 거치는지 알아볼 필요가 있다. 각 단계는 아래와 같다.</p><ol><li><code>Render</code> 컴포넌트가 어떠한 사이드 이펙트 없이 렌더링 된다. 이는 Pure Component에 적용되며, 이 단계에서는 일시정지, 중단, 렌더 재시작등이 가능하다.</li><li><code>Pre-commit</code>: 컴포넌트가 실제 변화를 DOM에 반영하기 전에, 리액트가 DOM을 <code>getSnapshotBeforeUpdate()</code> 통해서 DOM 을 읽을 수도 있다.</li><li><p><code>Commit</code>: React는 DOM과 함꼐 작동하며, 각각의 라이프 사이클 마지막에 실행되는 것들이 포함된다. <code>componentDidMount()</code> <code>componentDidUpdate()</code> <code>componentWillUnmount()</code></p><p>16.3 이후</p></li></ol><p><img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/phases16.3.jpg?raw=true" alt="react-16.3-phases"></p><p>16.3 이전</p><p><img src="https://github.com/sudheerj/reactjs-interview-questions/blob/master/images/phases.png?raw=true" alt="before-react-16.3"></p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-lifecycle-methods-of-React"><a href="#What-are-the-lifecycle-methods-of-React" class="headerlink" title="What are the lifecycle methods of React?"></a>What are the lifecycle methods of React?</h3><p>React 16.3+</p><ul><li><code>getDerivedStateFromProps</code>: 모든 <code>render()</code>가 실행되기 바로 직전에 호출된다. props의 변화의 결과로 내부 state 변화를 가능하게 해주는 메서드로, 굉장히 드물게 사용된다.</li><li><code>componentDidMount</code>: 첫렌더링이 다 끝나고, 모든 ajax 요청이 완료, DOM이나 state 변화, 그리고 이벤트 리스너가 모두 설정된 다음에 호출된다.</li><li><code>shouldComponentUpdate</code>: 컴포넌트가 업데이트 될지 말지를 결정한다. default로 true를 리턴한다. 만약 state나 props 업데이트 이후에 컴포넌트가 업데이트 될 필요가 없다고 생각한다면, false를 리턴하면 된다. 컴포넌트가 새로운 props를 받은 후에, 리 렌더링을 방지해서 성능을 향상시키기에 가장 좋은 위치다.</li><li><code>getSnapshotBeforeUpdate</code>: 렌더 결과물이 DOM에 커밋되기 직전에 호출된다. 여기서 리턴된 모든 값은 <code>componentDidUpdate()</code>로 넘겨진다. 스크롤 포지션 등, DOM에서 필요한 정보를 사용할 때 유용하다.</li><li><code>componentDidUpdate</code>: prop/state의 변화d의 응답으로 DOM을 업데이트 할 때 필요하다. 이 메소드는 만약 <code>shouldComponentUpdate()</code>가 <code>false</code>를 리턴하면 호출되지 않는다.</li><li><code>componentWillUnmount</code>: 네트워크 요청을 취소하거나, 컴포넌트와 관련된 이벤트 리스너를 삭제할 때 쓰인다.</li></ul><blockquote><p>before 16.3은 따로 번역하지 않겠습니다.</p></blockquote><ul><li><code>componentWillMount</code>: Executed before rendering and is used for App level configuration in your root component.</li><li><code>componentDidMount</code>: Executed after first rendering and here all AJAX requests, DOM or state updates, and set up event listeners should occur.<br>componentWillReceiveProps: Executed when particular prop updates to trigger state transitions.</li><li><code>shouldComponentUpdate</code>: Determines if the component will be updated or not. By default it returns true. If you are sure that the component doesn’t need to render after state or props are updated, you can return false value. It is a great place to improve performance as it allows you to prevent a re-render if component receives new prop.</li><li><code>componentWillUpdate</code>: Executed before re-rendering the component when there are props &amp; state changes confirmed by shouldComponentUpdate() which returns true.</li><li><code>componentDidUpdate</code>: Mostly it is used to update the DOM in response to prop or state changes.</li><li><code>componentWillUnmount</code>: It will be used to cancel any outgoing network requests, or remove all event listeners associated with the component.</li></ul><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-Higher-Order-Components"><a href="#What-are-Higher-Order-Components" class="headerlink" title="What are Higher-Order Components?"></a>What are Higher-Order Components?</h3><p>Higher-order Component (이하 HOC)는 컴포넌트를 받아서 새로운 컴포넌트를 리턴하는 컴포넌트다. 기본적으로, 이러한 패턴은 리액트의 컴포넌트적인 특성에서 유래되었다.</p><p>이를 <code>Pure Component</code>라고 부르는데, 동적으로 제공되는 하위 component를 그대로 사용하지만, 입력받은 component를 수정/복사하지 않기 때문이다.</p><p>HOC는 아래와 같은 use case에서 사용할 수 있다.</p><ul><li>코드 재사용, 로직 추상화</li><li>render 하이재킹</li><li>state 추상화 또는 조작</li><li>props 조작</li></ul><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-create-props-proxy-for-HOC-component"><a href="#How-to-create-props-proxy-for-HOC-component" class="headerlink" title="How to create props proxy for HOC component?"></a>How to create props proxy for HOC component?</h3><p><code>props proxy pattern</code>을 아래와 같이 사용한다면, 컴포넌트에 넘겨진 props를 추가/수정할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        title: <span class="string">"New Header"</span>,</span><br><span class="line">        footer: <span class="literal">false</span>,</span><br><span class="line">        showFeatureX: <span class="literal">false</span>,</span><br><span class="line">        showFeatureY: <span class="literal">true</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-context"><a href="#What-is-context" class="headerlink" title="What is context?"></a>What is context?</h3><p>Context는 props을 탑다운으로 주지 않고도, 어느 레벨에서든 데이터를 컴포넌트 트리에 넘기는 방법이다. 예를 들어 인증받은 사용자, 언어 설정, UI theme 등 어플리케이션 단위에서 다양한 컴포넌트가 사용해야 하는 데이터를 context를 통해서 줄 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-children-prop"><a href="#What-is-children-prop" class="headerlink" title="What is children prop?"></a>What is children prop?</h3><p>Children은 prop (<code>this.prop.children</code>) 으로, 다른 컴포넌트에 컴포넌트를 넘길 수 있는 방법으로, 다른 prop를 사용하는 것과 동일하다. 컴포넌트 트리는 이 children을 여닫는 태그 사이에 두며, 이는 컴포넌트를 <code>children prop</code>으로 건내게 된다.</p><p>React API에서 이러한 형태로 다양한 prop을 제공하고 있다. <code>React.Children.map</code> <code>React.Children.forEach</code> <code>React.Children.count</code> <code>React.Children.only</code> <code>React.Children.toArray</code> 사용예제는 아래와 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyDiv = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyDiv&gt;</span><br><span class="line">    &lt;span&gt;&#123;<span class="string">"Hello"</span>&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;&#123;"World"&#125;&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/MyDiv&gt;,</span></span><br><span class="line"><span class="regexp">  node</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-write-comments-in-React"><a href="#How-to-write-comments-in-React" class="headerlink" title="How to write comments in React?"></a>How to write comments in React?</h3><p>React/JSX의 주석은 자바스크립트의 다중 주석과 비슷하지만, <code>{ }</code>에 쌓여있다는 것이 다르다.</p><p>한 줄</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;/* Single-line comments(In vanilla JavaScript, the single-line comments are</span><br><span class="line">  represented by double slash(//)) */&#125; &#123;`Welcome $&#123;user&#125;, let's play React`&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>여러 줄</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;/* Multi-line comments for more than one line */&#125; &#123;`Welcome $&#123;user&#125;, let's</span><br><span class="line">  play React`&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-purpose-of-using-super-constructor-with-props-argument"><a href="#What-is-the-purpose-of-using-super-constructor-with-props-argument" class="headerlink" title="What is the purpose of using super constructor with props argument?"></a>What is the purpose of using super constructor with props argument?</h3><p>자식 클래스 생성자는 <code>super()</code>메소드가 호출되기 전까지 <code>this</code> 레퍼런스를 쓸 수 없다. 이와 동일한것이 es6의 서브 클래스에 구현되어 있다. <code>super()</code> 메소드에 props를 파라미터로 호출하는 주요 이유는 <code>this.props</code>를 자식 생성자에서 쓰기 위해서다.</p><p>props 넘기는 경우</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// prints &#123; name: 'John', age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props 안 넘기는 경우</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// prints undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// but props parameter is still available</span></span><br><span class="line">    <span class="built_in">console</span>.log(props); <span class="comment">// prints &#123; name: 'John', age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// no difference outside constructor</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// prints &#123; name: 'John', age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-reconciliation"><a href="#What-is-reconciliation" class="headerlink" title="What is reconciliation?"></a>What is reconciliation?</h3><p>컴포넌트의 props나 state에 변경이 있을때, React는 이전에 렌더링 된 element와 새롭게 렌더링된 것을 비교하여 실제 DOM이 업데이트 되어야 할지를 결정한다. 똑같지 않을때, React는 DOM을 업데이트 한다. 이 과정을 <code>reconciliation</code>이라고 한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-set-state-with-a-dynamic-key-name"><a href="#How-to-set-state-with-a-dynamic-key-name" class="headerlink" title="How to set state with a dynamic key name?"></a>How to set state with a dynamic key name?</h3><p>JSX코드 내에서 es6또는 바벨 트랜스파일러를 쓰고 있다면, computed property 명을 쓸 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleInputChange(event) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; [event.target.id]: event.target.value &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-would-be-the-common-mistake-of-function-being-called-every-time-the-component-renders"><a href="#What-would-be-the-common-mistake-of-function-being-called-every-time-the-component-renders" class="headerlink" title="What would be the common mistake of function being called every time the component renders?"></a>What would be the common mistake of function being called every time the component renders?</h3><p>함수를 파라미터로 넘기는 과정에서 함수가 호출되지 않는지 확인해야 한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="Is-lazy-function-supports-named-exports"><a href="#Is-lazy-function-supports-named-exports" class="headerlink" title="Is lazy function supports named exports?"></a>Is lazy function supports named exports?</h3><p>아니다. 현재 <code>React.lazy</code>함수는 default export만 지원한다. named exports된 모듈을 import 하고 싶을 경우에는, 사이에 디폴트로 reexports 하는 모듈을 만들수 있다. 이는 트리쉐이킹을 도와주고, 사용하지 않는 컴포넌트를 pull하지 않을 수 있다. 밑에서 예를 살펴보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MoreComponents.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SomeComponent = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnusedComponent = <span class="comment">/* ... */</span>;</span><br></pre></td></tr></table></figure><p>이 컴포넌트 중간에 <code>IntermediateComponent.js</code>를 만들어서 다시 export 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntermediateComponent.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; SomeComponent <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">"./MoreComponents.js"</span>;</span><br></pre></td></tr></table></figure><p>그리고 lazy 함수를 이용해서 아래와 같이 임포트 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; lazy &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> SomeComponent = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./IntermediateComponent.js"</span>));</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Why-React-uses-className-over-class-attribute"><a href="#Why-React-uses-className-over-class-attribute" class="headerlink" title="Why React uses className over class attribute?"></a>Why React uses <code>className</code> over <code>class</code> attribute?</h3><p><code>class</code>는 자바스크립트의 예약어 이고, JSX는 javascript를 확장해 만든 것이다. 따라서 <code>class</code>를 쓰면 충돌이 일어나기 자바스크립트 예약어와 충동리 발생하기 때문에 <code>className</code>을 사용한다. <code>className</code> prop에 <code>string</code>을 넘겨 주면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;</span>'<span class="attr">menu</span> <span class="attr">navigation-menu</span>'&#125;&gt;</span>&#123;'Menu'&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-fragments"><a href="#What-are-fragments" class="headerlink" title="What are fragments?"></a>What are fragments?</h3><p>React에서는 하나의 컴포넌트가 여러개의 elements를 리턴하는 것이 일반적인 패턴이다. Fragments는 추가로 DOM 노드를 사용하지 않더라도 여러개의 노드들을 묶을 수 있게 해준다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">      &lt;ChildC /&gt;</span><br><span class="line">    &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">      &lt;ChildC /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Why-fragments-are-better-than-container-divs"><a href="#Why-fragments-are-better-than-container-divs" class="headerlink" title="Why fragments are better than container divs?"></a>Why fragments are better than container divs?</h3><ol><li>Fragment는 실제로 추가적인 DOM을 만들지 않기 때문에 더 빠르고 메모리 사용량도 적다. 이는 매우 크고 깊은 트리를 만들 때 상당한 이점으로 작용한다.</li><li>CSS Grid나 firefox같은 일부 특수한 CSS 메커니즘은 특별한 부모-자식 관계를 가지고 있는데, div를 중간에 추가하는 것은 원하는 레이아웃을 그리기 어렵게 한다.</li><li>DOM Inspector를 사용할 때 덜 혼잡스럽다.</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-portals-in-React"><a href="#What-are-portals-in-React" class="headerlink" title="What are portals in React?"></a>What are portals in React?</h3><p>portals 은 상위 Component 의 DOM 계층 구조 외부에 존재하는 DOM 노드로, 자식을 render 하는데 권장되는 방법이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container);</span><br></pre></td></tr></table></figure><p>첫번째 인자는 React Child에서만 렌더링이 가능하며, 여기에는 element, string, fragment 가 포함된다. 두번째 인자는 DOM 엘리먼트다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-stateless-components"><a href="#What-are-stateless-components" class="headerlink" title="What are stateless components?"></a>What are stateless components?</h3><p>컴포넌트의 동작이 state와 독립되어 있다면, 이는 stateless 컴포넌트다. 함수나 클래스를 이용해서 stateless 컴포넌트를 만들 수 있다. 하지만 컴포넌트의 라이프 사이클 훅이 필요하지 않다면, 함수형으로 가는 것이 좋다. 함수형 컴포넌트를 선택한다면 많은 이점을 가져갈 수 있다. 코드 사용 및 이해가 쉽고, 조금더 빠르며, 그리고 <code>this</code> 키워드의 충돌을 막을 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-stateful-components"><a href="#What-are-stateful-components" class="headerlink" title="What are stateful components?"></a>What are stateful components?</h3><p>state의 사용에 종속적인 컴포넌트를 stateful component라고 한다. 이 컴포넌트는 항상 class 컴포넌트로 만들어 져야 하며, <code>constructor</code>를 통해서 초기화 되어야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-apply-validation-on-props-in-React"><a href="#How-to-apply-validation-on-props-in-React" class="headerlink" title="How to apply validation on props in React?"></a>How to apply validation on props in React?</h3><p>React가 development로 실행한다면, 자동으로 컴포넌트에 있는 props의 타입을 올바르게 체크해 준다. 만약 타입이 올바르지 않다면, React는 콘솔에 경고 메시지를 띄운다. 성능 상의 이슈를 위해 production에서는 이 기능이 꺼져 있다. 필수적인 prop은 <code>isRequired</code>다. 사용할 수 있는 prop type의 종류는 아래와 같다.</p><ol><li><code>PropTypes.number</code></li><li><code>PropTypes.string</code></li><li><code>PropTypes.array</code></li><li><code>PropTypes.object</code></li><li><code>PropTypes.func</code></li><li><code>PropTypes.node</code></li><li><code>PropTypes.element</code></li><li><code>PropTypes.bool</code></li><li><code>PropTypes.symbol</code></li><li><code>PropTypes.any</code></li></ol><p>아래와 같이 쓸수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: PropTypes.string.isRequired,</span><br><span class="line">    age: PropTypes.number.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="string">`Welcome, <span class="subst">$&#123;<span class="keyword">this</span>.props.name&#125;</span>`</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;&#123;`Age, $&#123;this.props.age&#125;`&#125;&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>주의: 리액트 v15.5부터 PropType이 <code>React.PropTypes</code>에서 <code>prop-types</code>로 이동했다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-advantages-of-React"><a href="#What-are-the-advantages-of-React" class="headerlink" title="What are the advantages of React?"></a>What are the advantages of React?</h3><ol><li>Virtual DOM으로 어플리케이션의 성능을 향상시킬 수 있음</li><li>JSX를 통해 코들르 쉽게 읽고 쓸수 있음</li><li>클라이언트와 서버사이드 양쪽에서 렌더링 라능</li><li>뷰만 다루는 라이브러리이기 때문에, 다른 프레임워크 (Angular, Backbone) 등과 쉽게 연동 가능</li><li>Jest와 같은 툴로 쉽게 유닛/인티그레이션 테스트 가능</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-limitations-of-React"><a href="#What-are-the-limitations-of-React" class="headerlink" title="What are the limitations of React?"></a>What are the limitations of React?</h3><ol><li>풀 프레임워크가 아니라, view만 다루고 있음.</li><li>뉴비 웹 개발자들에게 러닝 커브가 존재</li><li>전통적인 MVC 프레임워크와 인터그레이팅을 하기 위해서는 추가적인 설정이 필요</li><li>inline 템플릿과 JSX로 인해 코드의 복잡성 증가</li><li>오버엔지니어링/보일러플레이팅을 야기하는 작은 단위의 컴포넌트가 너무 많이 존재</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-error-boundaries-in-React-v16"><a href="#What-are-error-boundaries-in-React-v16" class="headerlink" title="What are error boundaries in React v16?"></a>What are error boundaries in React v16?</h3><p>Error boundaries란 하위 component tree 에서 자바스크립트 에러 를 catch 하고, 기록하고, 에가 발생한 component tree가 아닌 대체 UI를 표현해 주는 component를 말한다.</p><p>새롭게 추가된 라이프사이클 메서드인 <code>componentDidCatch(error, info)</code>나 <code>static getDerivedStateFromError()</code>를 사용한다면, 클래스 컴포넌트는 error boundary가 될 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// 에러 리포틍 서비스를 위해 로그를 기록할 수도 있고</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// fallback UI를 표현하기 위해여 state를 업데이트 할 수도 있다.</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// custom Fallback UI를 그릴 수 있다.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;"Something went wrong."&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 이 컴포넌트는 아래와 같이 사용할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MyWidget</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-error-boundaries-handled-in-React-v15"><a href="#How-error-boundaries-handled-in-React-v15" class="headerlink" title="How error boundaries handled in React v15?"></a>How error boundaries handled in React v15?</h3><p><code>unstable_handleError</code> 메서드를 활용한 기본적인 error boundaries만 제공하고 있다. 그리고 v16에서 <code>componentDidCatch</code>로 변경되었다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-recommended-ways-for-static-type-checking"><a href="#What-are-the-recommended-ways-for-static-type-checking" class="headerlink" title="What are the recommended ways for static type checking?"></a>What are the recommended ways for static type checking?</h3><p>보통 <code>PropTypes</code>를 많이 사용한다. 그러나 크기가 큰 어플리케이션의 경우에는, Flow나 타입스크립트같은, 컴파일 단계에서 타입체킹을 제공하고 자동완성을 지원해주는 정적 타입 체커를 사용하는 것이 좋다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-use-of-react-dom-package"><a href="#What-is-the-use-of-react-dom-package" class="headerlink" title="What is the use of react-dom package?"></a>What is the use of <code>react-dom</code> package?</h3><p><code>react-dom</code>은 앱 최 상단 레벨에서 사용되는, DOM을 다루는데 필요한 메서드를 제공한다. 대부분의 컴포넌트는 이 모듈을 필요로 하지 않는다. 여기에 있는 메소드를 몇가지 나열하면</p><ol><li><code>render()</code></li><li><code>hydrate()</code></li><li><code>unmountComponentAtNode()</code></li><li><code>findDOMNode()</code></li><li><code>createPortal()</code></li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-purpose-of-render-method-of-react-dom"><a href="#What-is-the-purpose-of-render-method-of-react-dom" class="headerlink" title="What is the purpose of render method of react-dom?"></a>What is the purpose of render method of <code>react-dom</code>?</h3><p>render 메서드는 제공된 컨테이너의 DOM에 있는 React element를 render 하고 Component에 대한 참조를 반환하는데 사용된다. React element가 이전에 렌더링 되었다면 update 를 수행하고 최근의 변경사항을 반영하기 위해 필요에 따라 DOM을 변경하기도 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(element, container[, callback])</span><br></pre></td></tr></table></figure><p>옵셔널 콜백이 있따면, 컴포넌트가 렌더링/업데이트 된 이후로 실행된다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-ReactDOMServer"><a href="#What-is-ReactDOMServer" class="headerlink" title="What is ReactDOMServer?"></a>What is ReactDOMServer?</h3><p><code>ReactDOMServer</code>는 컴포넌트를 정적 마크업으로 렌더링할 수 있게 해준다. (보통 노드 서버에서 많이 사용 된다) 이 오브젝트는 서버사이드 렌더링을 할 때 사용된다. 아래 메서드들은 서버와 브라우저 환경 모두에서 사용할 수 있다.</p><ol><li><code>renderToString()</code></li><li><code>renderToStaticMarkup()</code></li></ol><p>예를 들어, 노드 베이스 웹서버인 Express, Hapi, Koa 등에서 서버를 실행한다면, <code>renderToString</code>메서드를 호출하여 이에 대한 응답으로 루트 컴포넌트를 string으로 렌더링할 수 있다.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using Express</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">"react-dom/server"</span>;</span><br><span class="line"><span class="keyword">import</span> MyPage <span class="keyword">from</span> <span class="string">"./MyPage"</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.write(<span class="string">"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"</span>);</span><br><span class="line">  res.write(<span class="string">'&lt;div id="content"&gt;'</span>);</span><br><span class="line">  res.write(renderToString(<span class="xml"><span class="tag">&lt;<span class="name">MyPage</span> /&gt;</span>));</span></span><br><span class="line"><span class="xml">  res.write("<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><span class="string">");</span></span><br><span class="line"><span class="string">  res.end();</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-use-innerHTML-in-React"><a href="#How-to-use-innerHTML-in-React" class="headerlink" title="How to use innerHTML in React?"></a>How to use innerHTML in React?</h3><p>browser DOM에서 <code>innerHTML</code>대신 <code>dangerouslySetInnerHTML</code>를 사용할 수 있다. <code>innerHTML</code>과 마찬가지로, 이 속성 또한 크로스 사이트 스크립팅 공격 (XSS)에 취약하다. <code>__html</code>을 키로 하고 HTML text를 값으로 가지는 object를 리턴하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMarkup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">__html</span>: <span class="string">"First &amp;middot; Second"</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;createMarkup()&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-use-styles-in-React"><a href="#How-to-use-styles-in-React" class="headerlink" title="How to use styles in React?"></a>How to use styles in React?</h3><p>style 속성은 css 문자열 대신 camelCased속성이 있는 자바스크립트 오브젝트를 허용한다. 이는 DOM 스타일 자바스크립트 속성과 일치하며, 효율적이고, XSS 보안 허점을 막아준다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-events-are-different-in-React"><a href="#How-events-are-different-in-React" class="headerlink" title="How events are different in React?"></a>How events are different in React?</h3><p>React 엘리먼트에서 이벤트를 다루는 것은 문법상 약간의 차이가 있다.</p><ol><li>리액트 이벤트 핸들러는 lowerCase가 아닌 camelCase로 써야한다.</li><li>JSX에서는 문자열이 아닌, 함수 이벤트 핸들러를 파라미터로 보낸다.</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-will-happen-if-you-use-setState-in-constructor"><a href="#What-will-happen-if-you-use-setState-in-constructor" class="headerlink" title="What will happen if you use setState() in constructor?"></a>What will happen if you use <code>setState()</code> in constructor?</h3><p><code>setState()</code>를 사용하면, 객체 상태가 할당되고, 자식을 포함한 모든 컴포넌트가 다시 렌더링된다. 그리고 아래와 같은 에러메시지가 나타난다. <strong>Can only update a mounted or mounting component.</strong> 따라서 <code>this.state</code>를 사용하여 생성자내에서 변수를 초기화 해야 한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-impact-of-indexes-as-keys"><a href="#What-is-the-impact-of-indexes-as-keys" class="headerlink" title="What is the impact of indexes as keys?"></a>What is the impact of indexes as keys?</h3><p>키는 리액트에서 엘리먼트를 추적할 수 있도록 안정적이어야 하고, 예측가능해야 하고, 유니크해야 한다.</p><p>아래 코드에서 각 엘리먼트의 키는 데이터를 따르는 것이 아니라 단순히 순서에 따라 결정된다. 이는 React가 하는 최적화를 제한한다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &lt;Todo &#123;...todo&#125; key=&#123;index&#125; /&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>만약 데이터를 유니크 키로 사용한다면 위의 조건을 만족하기 때문에, React는 다시 연산할 필요 없이 재정렬할 수 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> &lt;Todo &#123;...todo&#125; key=&#123;todo.id&#125; /&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Is-it-good-to-use-setState-in-componentWillMount-method"><a href="#Is-it-good-to-use-setState-in-componentWillMount-method" class="headerlink" title="Is it good to use setState() in componentWillMount() method?"></a>Is it good to use <code>setState()</code> in <code>componentWillMount()</code> method?</h3><p><code>componentWillMount()</code>에서 비동기 초기화를 하는 것은 피하도록 권장한다. <code>componentWillMount()</code>는 마운팅이 일어나기 직전에 바로 실행된다. 이는 <code>render()</code>함수가 불리우기 직전이며, 따라서 여기에서 state를 새로 값을 할당 한다 하더라도 리렌더링을 트리거 하지 않는다. 이 메소드 내에서는 사이드 이펙트나 subscription등은 피해야 한다. 따라서 비동기 초기화는 <code>componentDidMount()</code>에서 하는 것이 좋다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  axios.get(<span class="string">`api/todos`</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        messages: [...result.data]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-will-happen-if-you-use-props-in-initial-state"><a href="#What-will-happen-if-you-use-props-in-initial-state" class="headerlink" title="What will happen if you use props in initial state?"></a>What will happen if you use props in initial state?</h3><p>컴포넌트의 새로고칩 없이 props가 변경된다면, 현재 상태의 컴포넌트는 절대로 업데이트 하지 않기 때문에 새로운 prop값이 화면에 표시되지 않을 것이다. props를 통한 state값의 초기화는 컴포넌트가 딱 초기화 되었을 때만 실행된다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      records: [],</span><br><span class="line">      inputValue: <span class="keyword">this</span>.props.inputValue</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.inputValue&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props를 render 함수 내에서 쓰면 값을 업데이트 한다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      record: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.inputValue&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-do-you-conditionally-render-components"><a href="#How-do-you-conditionally-render-components" class="headerlink" title="How do you conditionally render components?"></a>How do you conditionally render components?</h3><p>때로는 어떤 상태값에 따라서 렌더링을 다르게 해야하는 경우가 발생한다. JSX는 <code>false</code>나 <code>undefined</code>는 렌더링하지 않으므로, 특정 조건에 true를 주는 형식으로 조건부 렌더링을 할 수 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, address &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;name&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &#123;address &amp;&amp; &lt;p&gt;&#123;address&#125;&lt;/</span>p&gt;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>if-else도 삼항연산자를 활용하면 아래와 같이 할 수 있다.</p><figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, address &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;name&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &#123;address ? &lt;p&gt;&#123;address&#125;&lt;/</span>p&gt; : <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;"Address is not available"&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Why-we-need-to-be-careful-when-spreading-props-on-DOM-elements"><a href="#Why-we-need-to-be-careful-when-spreading-props-on-DOM-elements" class="headerlink" title="Why we need to be careful when spreading props on DOM elements?"></a>Why we need to be careful when spreading props on DOM elements?</h3><p>spread prop를 쓴다면, HTML에 알수없는 속성을 추가할 수 있는 위험이 있기 때문에 좋지 못하다. 대신 <code>...rest</code> 연산자를 쓴다면, 필요한 props만 추가해서 넣을 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ComponentA = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;ComponentB isDisplay=&#123;<span class="literal">true</span>&#125; className=&#123;<span class="string">"componentStyle"</span>&#125; /&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ComponentB = <span class="function">(<span class="params">&#123; isDisplay, ...domProps &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div &#123;...domProps&#125;&gt;&#123;<span class="string">"ComponentB"</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-you-use-decorators-in-React"><a href="#How-you-use-decorators-in-React" class="headerlink" title="How you use decorators in React?"></a>How you use decorators in React?</h3><p>클래스 컴포넌트에 데코레이터를 쓸 수 있으며, 이는 함수에 컴포넌트를 넘기는 것과 동일하다. 데코레이터는 유연하고 읽기 쉬운 방법으로 컴포넌트를 기능적으로 수정할 수 있도록 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@setTitle(<span class="string">"Profile"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profile</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setTitle = <span class="function"><span class="params">title</span> =&gt;</span> WrappedComponent =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure><p>주의: 데코레이터는 es7 문법에 포함되지 못하고 현재 stage2 단계에 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-do-you-memoize-a-component"><a href="#How-do-you-memoize-a-component" class="headerlink" title="How do you memoize a component?"></a>How do you memoize a component?</h3><p>함수형 컴포넌트를 기반으로한 메모이제이션이 가능한 라이브러리가 있다. 예를 들어, <code>moize</code>라이브러리를 활용하면, 다른 컴포넌트 내에서 컴포넌트를 메모이제이션 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moize <span class="keyword">from</span> <span class="string">"moize"</span>;</span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">"./components/Component"</span>; <span class="comment">// this module exports a non-memoized component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoizedFoo = moize.react(Component);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Consumer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;<span class="string">"I will memoize the following entry:"</span>&#125;</span><br><span class="line">    &lt;MemoizedFoo /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-you-implement-Server-Side-Rendering-or-SSR"><a href="#How-you-implement-Server-Side-Rendering-or-SSR" class="headerlink" title="How you implement Server Side Rendering or SSR?"></a>How you implement Server Side Rendering or SSR?</h3><p>React는 이미 노드 서버에서 렌더링을 다룰 수 있도록 지원되고 있다. 클라이언트 사이드와 동일하게 렌더링할 수 있는 특수한 버전의 DOM renderer가 제공되고 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">"react-dom/server"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./App"</span>;</span><br><span class="line"></span><br><span class="line">ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>);</span></span><br></pre></td></tr></table></figure><p>이 메소드는 일반적인 HTML을 string으로 내보내며, 이는 서버의 응답 일부를 페이지 본문 내부에 위치시킬 수 있다. 클라이언트 사이드에서, 리액트는 미리 렌더링된 컨텐츠를 감지하고 나머지를 원활하게 렌더링할 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-enable-production-mode-in-React"><a href="#How-to-enable-production-mode-in-React" class="headerlink" title="How to enable production mode in React?"></a>How to enable production mode in React?</h3><p>Webpack의 <code>DefinePlugin</code> 메서드를 활용하여, <code>NODE_ENV</code>를 <code>production</code>으로 설정해야 propType의 유효성 검사 같은 추가적인 경고를 제거할 수 있다.</p><p>production 모드와 별도로, 주석을 제거하고 코드르 압축시키는 uglify의 dead-code 코드를 사용하여 minify하면 번들링 사이즈를 줄일 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-CRA-and-its-benefits"><a href="#What-is-CRA-and-its-benefits" class="headerlink" title="What is CRA and its benefits?"></a>What is CRA and its benefits?</h3><p>CRA(<code>create-react-app</code>)는 특별한 설정없이도 빠르고 간편하게 리액트 어플리케이션을 만들수 있도록 해주는 Cli tool이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Installation</span><br><span class="line">$ npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"># Create new project</span><br><span class="line">$ create-react-app todo-app</span><br><span class="line">$ cd todo-app</span><br><span class="line"></span><br><span class="line"># Build, test and run</span><br><span class="line">$ npm run build</span><br><span class="line">$ npm run test</span><br><span class="line">$ npm start`</span><br></pre></td></tr></table></figure><p>여기에는 리액트 앱을 만드는데 필요한 모든 것이 담겨져 있다.</p><ol><li>React, JSX, ES6, 문법 지원을 위한 Flow</li><li>spread operator와 같은 es6 문법</li><li>auto prefixed css를 통해, -web-kit` 과 같은 접두어를 붙이지 않아도 됨</li><li>빠른 인터렉티브 유닛 테스트 러너와 함께 커버리지 리포팅</li><li>일반적인 실수에 대해 경고하는 라이브 dev 서버</li><li>배포를 위해 소스맵, 해쉬와 함께 제공되는 JS, CSS, 이미지 번들링 해주는 빌드 스크립트</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-lifecycle-methods-order-in-mounting"><a href="#What-is-the-lifecycle-methods-order-in-mounting" class="headerlink" title="What is the lifecycle methods order in mounting?"></a>What is the lifecycle methods order in mounting?</h3><p>컴포넌트가 생성되고, DOM에 들어가는 과정에서 아래와 같은 라이프 사이클 메서드가 순서대로 호출된다.</p><ol><li><code>constructor()</code></li><li><code>static getDerivedStateFromProps()</code></li><li><code>render()</code></li><li><code>componentDidMount()</code></li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-lifecycle-methods-going-to-be-deprecated-in-React-v16"><a href="#What-are-the-lifecycle-methods-going-to-be-deprecated-in-React-v16" class="headerlink" title="What are the lifecycle methods going to be deprecated in React v16?"></a>What are the lifecycle methods going to be deprecated in React v16?</h3><p>다음 lifecycle메서드는 안전하지 않은 코딩법이 될 수 있고, 비동기 렌더링시 문제가 발생할 수 있다.</p><ol><li><code>componentWillMount()</code></li><li><code>componentWillReceiveProps()</code></li><li><code>componentWillUpdate()</code></li></ol><p>v16.3 부터 <code>UNSAFE_</code> prefix가 붙고, v17에서는 삭제된다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-purpose-of-getDerivedStateFromProps-lifecycle-method"><a href="#What-is-the-purpose-of-getDerivedStateFromProps-lifecycle-method" class="headerlink" title="What is the purpose of getDerivedStateFromProps() lifecycle method?"></a>What is the purpose of <code>getDerivedStateFromProps()</code> lifecycle method?</h3><p>새로운 라이프 사이클 메서드 <code>getDerivedStateFromProps()</code>는 component가 인스턴스화 된 후, 다시 렌더링 되기전에 호출된다. object를 반환하여 state를 업데이트 하거나, null을 리턴하ㅕㅇ 새로운 props에서 state update가 필요하지 않도록 나타낼 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 메서드는 <code>componentDidUpdate()</code>와 함께 쓴다면, <code>componentWillReceiveProps()</code>의 모든 유즈케이스에 적용할 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-purpose-of-getSnapshotBeforeUpdate-lifecycle-method"><a href="#What-is-the-purpose-of-getSnapshotBeforeUpdate-lifecycle-method" class="headerlink" title="What is the purpose of getSnapshotBeforeUpdate() lifecycle method?"></a>What is the purpose of <code>getSnapshotBeforeUpdate()</code> lifecycle method?</h3><p>새로운 메서드 <code>getSnapshotBeforeUpdate()</code>는 DOM 업데이트 직전에 호출된다. 이 메서드의 반환값은 <code>componentDidUpdate()</code>의 세번째 파라미터로 전달된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 메서드는 <code>componentDidUpdate()</code>와 함께 쓴다면, <code>componentWillUpdate()</code>의 모든 유즈케이스에 적용할 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="Do-Hooks-replace-render-props-and-higher-order-components"><a href="#Do-Hooks-replace-render-props-and-higher-order-components" class="headerlink" title="Do Hooks replace render props and higher order components?"></a>Do Hooks replace render props and higher order components?</h3><p>render props와 HOC 모두 한개의 자식만 렌더링 하지만, 대부분의 경우 Hooks API를 아용하면 트리에 의존성을 줄이면서 간단하게 구현할 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-recommended-way-for-naming-components"><a href="#What-is-the-recommended-way-for-naming-components" class="headerlink" title="What is the recommended way for naming components?"></a>What is the recommended way for naming components?</h3><p><code>displayName</code>을 쓰는 것 보다 컴포넌트에 레퍼런스를 주는 방법이 더 좋다.</p><p><code>displayName</code>을 쓰는 법 보다</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line">  displayName: <span class="string">"TodoApp"</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>이렇게 하는게 더 좋다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoApp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-recommended-ordering-of-methods-in-component-class"><a href="#What-is-the-recommended-ordering-of-methods-in-component-class" class="headerlink" title="What is the recommended ordering of methods in component class?"></a>What is the recommended ordering of methods in component class?</h3><p>마운팅에서 렌더링까지 아래와 같은 순서로 나열하길 권장한다.</p><ol><li><code>static</code> 메서드</li><li><code>constructor()</code></li><li><code>getChildContext()</code></li><li><code>componentWillMount()</code></li><li><code>componentDidMount()</code></li><li><code>componentWillReceiveProps()</code></li><li><code>shouldComponentUpdate()</code></li><li><code>componentWillUpdate()</code></li><li><code>componentDidUpdate()</code></li><li><code>componentWillUnmount()</code></li><li>클릭 또는 이벤트 핸들러 <code>onClickSubmit()</code> <code>onChangeDescription()</code></li><li>렌더를 위한 <code>getter</code> 메서드 <code>getSelectReason()</code> <code>getFooterContent()</code></li><li>옵셔널 렌더 메서드 <code>renderNavigation()</code> <code>renderProfilePicture()</code></li><li><code>render()</code></li></ol><h3 id="What-is-a-switching-component"><a href="#What-is-a-switching-component" class="headerlink" title="What is a switching component?"></a>What is a switching component?</h3><p>스위칭 컴포넌트란 하나 이상의 컴포넌트를 렌더링하는 컴포넌트를 의미한다. prop을 map으로 받아서 해당하는 컴포넌트를 보여주면 된다.</p><p>아래 코드 참조.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HomePage <span class="keyword">from</span> <span class="string">"./HomePage"</span>;</span><br><span class="line"><span class="keyword">import</span> AboutPage <span class="keyword">from</span> <span class="string">"./AboutPage"</span>;</span><br><span class="line"><span class="keyword">import</span> ServicesPage <span class="keyword">from</span> <span class="string">"./ServicesPage"</span>;</span><br><span class="line"><span class="keyword">import</span> ContactPage <span class="keyword">from</span> <span class="string">"./ContactPage"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PAGES = &#123;</span><br><span class="line">  home: HomePage,</span><br><span class="line">  about: AboutPage,</span><br><span class="line">  services: ServicesPage,</span><br><span class="line">  contact: ContactPage</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Page = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Handler = PAGES[props.page] || ContactPage;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Handler</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Page.propTypes = &#123;</span></span><br><span class="line"><span class="xml">  page: PropTypes.oneOf(Object.keys(PAGES)).isRequired</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Why-we-need-to-pass-a-function-to-setState"><a href="#Why-we-need-to-pass-a-function-to-setState" class="headerlink" title="Why we need to pass a function to setState()?"></a>Why we need to pass a function to setState()?</h3><p>그 이유는 <code>setState()</code>가 비동기로 작동하는데에 있다. React는 성능상의 문제로 인해, state의 변경작업을 배치로 하는데, 이 때문에 <code>setState()</code>를 바로 호출한다고 해서 바로 반영되지 않는다. 이 말은, <code>setState()</code>를 호출 할 때 그 당시 <code>state</code>의 값에 의존하면 안된다는 뜻이다. 따라서 <code>setState()</code>에는 이전 값에 접근할 수 있는 함수를 사용하는 것이 좋다. 이는 사용자가 비동기로 작동하는 <code>setState()</code>의 특징으로 인해 이전 값에 접근하는 것을 방지해 준다.</p><p>초기 값이 0 이라고 가정하자. 여기 1 씩 올리는 동작을 하는 코드가 세개 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assuming this.state.count === 0</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="comment">// this.state.count === 1, not 3</span></span><br></pre></td></tr></table></figure><p>만약 <code>setState()</code>에 함수를 넘겨준다면, 올바르게 동작할 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  count: prevState.count + props.increment</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// this.state.count === 3 as expected</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-strict-mode-in-React"><a href="#What-is-strict-mode-in-React" class="headerlink" title="What is strict mode in React?"></a>What is strict mode in React?</h3><p><code>React.StrictMode</code>는 어플리케이션의 잠재적인 문제를 하이라이팅 해주는 유용한 컴포넌트다. <code>&lt;Fragment&gt;</code>와 마찬가지로, <code>&lt;StrictMode&gt;</code>는 추가적으로 DOM을 렌더링하지 않는다. 이는 단지 자식 컴포넌트의 추가적인 체크와 경고를 할 뿐이다. 그리고 이러한 체크는 development 에서만 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;React.StrictMode&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ComponentOne /&gt;</span><br><span class="line">          &lt;ComponentTwo /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>React.StrictMode&gt;</span><br><span class="line">      &lt;Footer /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>위 예에서, <code>ComponentOne</code> <code>ComponentTwo</code>만 체크할 것이다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-React-Mixins"><a href="#What-are-React-Mixins" class="headerlink" title="What are React Mixins?"></a>What are React Mixins?</h3><p><code>Mixins</code>은 공통적인 기능을 가질 수 있도록 컴포넌트를 분리하는 방법이다. 그러나 사용하지 말아야 한다. HOC 나 데레이터를 사용하면 된다.</p><p>가장 유명한 사용법중 하나는 <code>PureRenderMixin</code>이다. 이전 props또는 state와 얕은 비교를 했을 때 일치하는 경우, 리렌더링을 막아주는 역할을 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">"react-addons-pure-render-mixin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Why-is-isMounted-an-anti-pattern-and-what-is-the-proper-solution"><a href="#Why-is-isMounted-an-anti-pattern-and-what-is-the-proper-solution" class="headerlink" title="Why is isMounted() an anti-pattern and what is the proper solution?"></a>Why is <code>isMounted()</code> an anti-pattern and what is the proper solution?</h3><p><code>isMounted()</code>의 일반적인 사용사례는 컴포넌트가 언마운트 된 후에 <code>setState()</code>를 호출하는 것을 방지하기 위함이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isMounted()) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setState()</code>를 호출하기 전에 <code>isMounted()</code>를 검사하면 경고를 없앨수있지만, 경고의 목적을 잃어버리는 꼴이 된다. 컴포넌트의 마운트가 해제된 후에 reference를 가지고 있다고 판단하므로 이는 일종의 코드 스멜이라고 볼 수 있다.</p><p>좋은 해결책은 컴포넌트의 마운트가 해제된 후 <code>setState()</code>가 호출될 수 있는 위치를 찾아 수정하는 것이다. 이러한 상황은 대게 컴포넌트가 데이터를 기다리고 있다가 데이터의 도착전 마운트가 해제 되는, 콜백 상황에서 많이 발생된다. 콜백은 마운트가 해제되기 전에 <code>componentWillUnMount</code>에서 취소되어야 한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-Pointer-Events-supported-in-React"><a href="#What-are-the-Pointer-Events-supported-in-React" class="headerlink" title="What are the Pointer Events supported in React?"></a>What are the Pointer Events supported in React?</h3><p>포인터 이벤트는 모든 입력 이벤트를 다루는 통일된 방법을 제공한다. 과거에는 마우스 및 각각의 이벤트 리스너를 달았지만, 요즘에는 핸드폰 터치, 서피스, 펜 등 마우스 외에 다양한 입력기기가 나타나기 시작했다. 한가지 명심해야 할 점은 이러한 이벤트들이 포인트 이벤트 명세를 지원하는 브라우저에서만 동작할 것이라는 점이다.</p><p>아래의 이벤트 타입들이 React DOM에서 지원하는 것이다.</p><ol><li>onPointerDown</li><li>onPointerMove</li><li>onPointerUp</li><li>onPointerCancel</li><li>onGotPointerCapture</li><li>onLostPointerCaptur</li><li>onPointerEnter</li><li>onPointerLeave</li><li>onPointerOver</li><li>onPointerOut</li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="Why-should-component-names-start-with-capital-letter"><a href="#Why-should-component-names-start-with-capital-letter" class="headerlink" title="Why should component names start with capital letter?"></a>Why should component names start with capital letter?</h3><p>JSX를 이용해서 렌더링을 하다보면, 컴포넌트의 명이 대문자가 아닐 경우 태그 인식에 실패했다는 에러메시지를 뱉는다. 그 이유는 오직 HTML 엘리먼트와 SGV 태그만이 소문자로 시작하기 때문이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Code goes here</span></span><br><span class="line">&#125;<span class="string">`</span></span><br></pre></td></tr></table></figure><p>클래스 명을 소문자로 시작하게 컴포넌트를 만들 수 있지만, import 할 때는 대문자로 하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default myComponent;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">"./MyComponent"</span>;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Are-custom-DOM-attributes-supported-in-React-v16"><a href="#Are-custom-DOM-attributes-supported-in-React-v16" class="headerlink" title="Are custom DOM attributes supported in React v16?"></a>Are custom DOM attributes supported in React v16?</h3><p>가능하다. 과거 React는 알수없는 DOM 속성을 무시했다. JSX에 리액트가 알수 없는 속성을 넣었다면, 리액트는 이를 무시했다.</p><p>예를 들어, 과거에는 아래와 같이 동작했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div mycustomattribute=&#123;<span class="string">"something"</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>그러나 React v16부터는 알수없는 속성도 결국 DOM에 반영된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">mycustomattribute</span>=<span class="string">"something"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>이는 브라우저에 특화된 비표준 속성, 새로운 DOM api, 서드파티 라이브러리 등을 사용할 때 유용하다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-constructor-and-getInitialState"><a href="#What-is-the-difference-between-constructor-and-getInitialState" class="headerlink" title="What is the difference between constructor and getInitialState?"></a>What is the difference between constructor and getInitialState?</h3><p>es6 클래스에서는 <code>constructor</code>로 state를 초기화 하고, <code>React.createClass</code>를 사용할 때는 <code>getInitialState()</code>으로 초기화 한다.</p><p>es6</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      <span class="comment">/* initial state */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>React.createClass()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.createClass(&#123;</span><br><span class="line">  getInitialState() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">/* initial state */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Can-you-force-a-component-to-re-render-without-calling-setState"><a href="#Can-you-force-a-component-to-re-render-without-calling-setState" class="headerlink" title="Can you force a component to re-render without calling setState?"></a>Can you force a component to re-render without calling setState?</h3><p>기본적으로, state나 prop의 변화가 있을 때만 컴포넌트가 리렌더링 된다. 만약 <code>render()</code> 메서드가 외부의 다른 데이터에 의존적이라면, <code>forceUpdate()</code>를 통해서 컴포넌트를 리렌더링 할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.forceUpdate(callback);</span><br></pre></td></tr></table></figure><p>다만 이러한 방법은 권장되지 않으며, <code>render()</code>메소드에서 <code>this.props</code>나 <code>this.state</code>를 참조하는 것이 권장된다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-super-and-super-props-in-React-using-ES6-classes"><a href="#What-is-the-difference-between-super-and-super-props-in-React-using-ES6-classes" class="headerlink" title="What is the difference between super() and super(props) in React using ES6 classes?"></a>What is the difference between <code>super()</code> and <code>super(props)</code> in React using ES6 classes?</h3><p><code>constructor()</code>에서 <code>this.props</code>에 접근하고 싶다면, <code>super()</code>메서드에 <code>this.props</code>를 넘겨야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// &#123; name: 'John', ... &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-loop-inside-JSX"><a href="#How-to-loop-inside-JSX" class="headerlink" title="How to loop inside JSX?"></a>How to loop inside JSX?</h3><p><code>Array.prototype.map</code>을 es6의 화살표 함수 문법과 사용하면 된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">  &#123;items.map(item =&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">key</span>=<span class="string">"&#123;item.id&#125;"</span> <span class="attr">name</span>=<span class="string">"&#123;item.name&#125;"</span> /&gt;</span>)&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>for</code>루프는 사용할 수 없다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">  for (let i = 0; i <span class="tag">&lt; <span class="attr">items.length</span>; <span class="attr">i</span>++) &#123;</span></span><br><span class="line">  &lt;SomeComponent key="&#123;items[i].id&#125;" name="&#123;items[i].name&#125;" /&gt;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JSX 태그는 함수호출로 트랜스파일이 되는데, 이 경우 표현식내에 제어문을 사용할 수 없다. 다만 이는 stage1에 있는 <a href="https://github.com/tc39/proposal-do-expressions" target="_blank" rel="noopener">do</a> proposal로 해결 될 수도 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-do-you-access-props-in-attribute-quotes"><a href="#How-do-you-access-props-in-attribute-quotes" class="headerlink" title="How do you access props in attribute quotes?"></a>How do you access props in attribute quotes?</h3><p>React와 JSX는 속성 값에 string interpolation을 지원하지 않는다. 따라서 아래 코드는 작동하지 않는다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"images/&#123;this.props.image&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>하지만 <code>{}</code>와 함께 javascript 표현식을 넣으면 가능하다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">'image'</span> <span class="attr">src</span>=<span class="string">&#123;</span>'<span class="attr">images</span>/' + <span class="attr">this.props.image</span>&#125; /&gt;</span> <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag"><span class="attr">className</span>=<span class="string">'image'</span> <span class="attr">src</span>=<span class="string">&#123;</span>`<span class="attr">images</span>/$&#123;<span class="attr">this.props.image</span>&#125;`&#125; /&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-React-proptype-array-with-shape"><a href="#What-is-React-proptype-array-with-shape" class="headerlink" title="What is React proptype array with shape?"></a>What is React proptype array with shape?</h3><p>만약 특정 object를 가진 array를 넘기고 싶다면, <code>React.PropTypes.arrayOf()</code>와 함께 <code>React.PropTypes.shape()</code>를 쓰면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.propTypes = &#123;</span><br><span class="line">  arrayWithShape: React.PropTypes.arrayOf(</span><br><span class="line">    React.PropTypes.shape(&#123;</span><br><span class="line">      color: React.PropTypes.string.isRequired,</span><br><span class="line">      fontSize: React.PropTypes.number.isRequired</span><br><span class="line">    &#125;)</span><br><span class="line">  ).isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-conditionally-apply-class-attributes"><a href="#How-to-conditionally-apply-class-attributes" class="headerlink" title="How to conditionally apply class attributes?"></a>How to conditionally apply class attributes?</h3><p>따옴표 안에 내용은 모두 string으로 인식하기 때문에 <code>{}</code>를 쓸 수 없다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"btn-panel &#123;this.props.visible ? 'show' : 'hidden'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>다만 <code>{}</code>안에 모든 식을 넣으면 가능하다. (공백은 반드시 있어야 한다)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>'<span class="attr">btn-panel</span> ' + (<span class="attr">this.props.visible</span> ? '<span class="attr">show</span>' <span class="attr">:</span> '<span class="attr">hidden</span>')&#125;&gt;</span></span><br></pre></td></tr></table></figure><p>템플릿 string도 가능하다</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">btn-panel</span> $&#123;<span class="attr">this.props.visible</span> ? '<span class="attr">show</span>' <span class="attr">:</span> '<span class="attr">hidden</span>'&#125;`&#125;&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-React-and-ReactDOM"><a href="#What-is-the-difference-between-React-and-ReactDOM" class="headerlink" title="What is the difference between React and ReactDOM?"></a>What is the difference between React and ReactDOM?</h3><p>React 패키지내에는 엘리먼트와 컴포넌트 클래스에 도움을 줄 수 있는 <code>React.createElement()</code> <code>React.Component</code> <code>React.children</code>등을 가지고 있다. React 패키지 내에는 컴포넌트를 만드는데 도움이 되는 이러한 요소들이 있다고 보면 된다. 반면 <code>React-dom</code>패키지는 <code>ReactDOM.render()</code> 서버사이드 렌더링에 필요한 <code>react-dom/server</code>에 속한 <code>ReactDOMServer.renderToString()</code> <code>ReactDOMServer.renderToStaticMarkUp()</code> 이 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="Why-ReactDOM-is-separated-from-React"><a href="#Why-ReactDOM-is-separated-from-React" class="headerlink" title="Why ReactDOM is separated from React?"></a>Why ReactDOM is separated from React?</h3><p>React 팀은 DOM조작과 관련된 모든 기능을 <code>ReactDOM</code> 라이브러리로 옮겼다. 이는 React v0.14에서 처음으로 분리되었다. 이 때 패키지를 보자면, <code>react-native</code> <code>react-art</code> <code>react-canvas</code> <code>react-three</code>등 패키지 분리가 깔끔해졌으며, <code>React</code>패키지 자체에는 브라우저 DOM 조작과 관련된 라이브러리가 없다는 것이 명확해졌다. React가 다수의 환경에서 렌더링을 지원하기 위해, React팀은 React와 React-dom을 분리할 계획을 수립햇다. 이러한 방법론은 웹 버전에서 쓰이는 React와 React-Native사이에 컴포넌트를 쓰는 방법론을 공유할 수 있도록 해준다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-use-React-label-element"><a href="#How-to-use-React-label-element" class="headerlink" title="How to use React label element?"></a>How to use React label element?</h3><p>표준 <code>for</code> 속성을 사용하는 <code>text input</code>에 바인드된 <code>&lt;label&gt;</code>을 사용하려고 하면, 속성이 없는 HTML이 생성되고 콘솔에 경고가 출력된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&#123;</span>'<span class="attr">user</span>'&#125;&gt;</span>&#123;'User'&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#123;</span>'<span class="attr">text</span>'&#125; <span class="attr">id</span>=<span class="string">&#123;</span>'<span class="attr">user</span>'&#125; /&gt;</span></span><br></pre></td></tr></table></figure><p>for는 자바스크립트의 예약어이므로, <code>htmlFor</code>를 사용해야 한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&#123;</span>'<span class="attr">user</span>'&#125;&gt;</span>&#123;'User'&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#123;</span>'<span class="attr">text</span>'&#125; <span class="attr">id</span>=<span class="string">&#123;</span>'<span class="attr">user</span>'&#125; /&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-combine-multiple-inline-style-objects"><a href="#How-to-combine-multiple-inline-style-objects" class="headerlink" title="How to combine multiple inline style objects?"></a>How to combine multiple inline style objects?</h3><p>spread 연산자를 사용하면 된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;...styles.panel.button,</span> <span class="attr">...styles.panel.submitButton</span>&#125;&#125;&gt;</span>&#123;'Submit'&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>React Native라면 array를 사용하면 된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;[styles.panel.button,</span> <span class="attr">styles.panel.submitButton</span>]&#125;&gt;</span>&#123;'Submit'&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-re-render-the-view-when-the-browser-is-resized"><a href="#How-to-re-render-the-view-when-the-browser-is-resized" class="headerlink" title="How to re-render the view when the browser is resized?"></a>How to re-render the view when the browser is resized?</h3><p><code>componentDidMount()</code>에서 <code>resize</code>이벤트를 걸어두고, width와 height를 업데이트 하면 된다. 그리고 이 이벤트는 <code>componentWillUnmount()</code>에서 제거해줘야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowDimensions</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.updateDimensions = <span class="keyword">this</span>.updateDimensions.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateDimensions()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateDimensions)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateDimensions)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateDimensions() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">width</span>: <span class="built_in">window</span>.innerWidth, <span class="attr">height</span>: <span class="built_in">window</span>.innerHeight&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.state.width&#125; x &#123;this.state.height&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-difference-between-setState-and-replaceState-methods"><a href="#What-is-the-difference-between-setState-and-replaceState-methods" class="headerlink" title="What is the difference between setState() and replaceState() methods?"></a>What is the difference between <code>setState()</code> and <code>replaceState()</code> methods?</h3><p><code>setState()</code>는 과거의 state값을 현재 값으로 합친다. 반면 <code>replaceState()</code>는 현재 state를 버리고 넘어오는 <code>state</code>로 바꾼다. 이전 key를 모두 제거하는 경우가 아니라면 보통 <code>useState()</code>를 사용한다. <code>replaceState()</code>대신 <code>setState()</code>에서 <code>false/null</code>을 사용할 수도 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-listen-to-state-changes"><a href="#How-to-listen-to-state-changes" class="headerlink" title="How to listen to state changes?"></a>How to listen to state changes?</h3><p>아래 라이프사이클 메서드는 state의 변화가 있을 때 호출된다. 여기에서 이전 state와 props과 현재 state/props 값을 비교하여 의미있는 변화가 있었는지 추적할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(object nextProps, object nextState)</span><br><span class="line">componentDidUpdate(object prevProps, object prevState)</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-recommended-approach-of-removing-an-array-element-in-React-state"><a href="#What-is-the-recommended-approach-of-removing-an-array-element-in-React-state" class="headerlink" title="What is the recommended approach of removing an array element in React state?"></a>What is the recommended approach of removing an array element in React state?</h3><p><code>Array.prototype.filter()</code>메서드가 올바른 방법이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">removeItem(index) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    data: <span class="keyword">this</span>.state.data.filter(<span class="function">(<span class="params">item, i</span>) =&gt;</span> i !== index)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Is-it-possible-to-use-React-without-rendering-HTML"><a href="#Is-it-possible-to-use-React-without-rendering-HTML" class="headerlink" title="Is it possible to use React without rendering HTML?"></a>Is it possible to use React without rendering HTML?</h3><p>16.2 이상의 버전에서는 가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span><span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span><span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p><code>undefined</code>의 경우에는 작동하지 않는다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-pretty-print-JSON-with-React"><a href="#How-to-pretty-print-JSON-with-React" class="headerlink" title="How to pretty print JSON with React?"></a>How to pretty print JSON with React?</h3><p><code>&lt;pre&gt;</code> 태그안에 <code>JSON.stringify()</code>를 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">42</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;pre&gt;</span><br><span class="line">        &#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/pre&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">React.render(&lt;User /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>))</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Why-you-can’t-update-props-in-React"><a href="#Why-you-can’t-update-props-in-React" class="headerlink" title="Why you can’t update props in React?"></a>Why you can’t update props in React?</h3><p>props은 불변이며, 하향식으로 전달되는 것이 <code>React</code>의 철학이다. 이 말인 즉, 부모는 어떤 prop값이든 자식에세 보낼 수 있지만, 자식은 그 prop값을 수정할 수 없다는 것이다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-focus-an-input-element-on-page-load"><a href="#How-to-focus-an-input-element-on-page-load" class="headerlink" title="How to focus an input element on page load?"></a>How to focus an input element on page load?</h3><p><code>input</code> 엘리먼트에 ref를 만들고, 이를 <code>componentDidMount()</code>에서 쓰면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.nameInput.focus()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          defaultValue=&#123;<span class="string">'Won\'t focus'</span>&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          ref=&#123;(input) =&gt; <span class="keyword">this</span>.nameInput = input&#125;</span><br><span class="line">          defaultValue=&#123;<span class="string">'Will focus'</span>&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-possible-ways-of-updating-objects-in-state"><a href="#What-are-the-possible-ways-of-updating-objects-in-state" class="headerlink" title="What are the possible ways of updating objects in state?"></a>What are the possible ways of updating objects in state?</h3><ol><li><p>state를 병합할 object를 <code>setState()</code>에 서 사용하는 법</p><ul><li><p>`Object.assign()로 Object의 복사본을 만든다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.state.user, &#123; <span class="attr">age</span>: <span class="number">42</span> &#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; user &#125;)-</span><br></pre></td></tr></table></figure></li><li><p>spread 연산자를 사용하는 법 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; ...this.state.user, <span class="attr">age</span>: <span class="number">42</span> &#125;</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; user &#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>setState()</code>와 함수를 사용하는 법</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    ...prevState.user,</span><br><span class="line">    age: <span class="number">42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Why-function-is-preferred-over-object-for-setState"><a href="#Why-function-is-preferred-over-object-for-setState" class="headerlink" title="Why function is preferred over object for setState()?"></a>Why function is preferred over object for <code>setState()</code>?</h3><p>React는 성능의 문제로 인해 여러개의 <code>setState()</code>를 배치 형태로 호출하게 된다. 왜냐하면 <code>this.props</code>와 <code>this.state</code>는 비동기로 업데이트 될 수 있기 때문이다. 다음 state를 계산할 때 이전에 계산된 값을 신뢰하면 안된다.</p><p>아래 예제는 제대로 작동하지 않는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>이를 위해 함수로 <code>setState()</code>를 호출하는 것이 권장된다. 함수로 호출시 이전 state값을 받을 수 있고, 업데이트할 때 사용할 <code>prop</code>도 받아올 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-can-we-find-the-version-of-React-at-runtime-in-the-browser"><a href="#How-can-we-find-the-version-of-React-at-runtime-in-the-browser" class="headerlink" title="How can we find the version of React at runtime in the browser?"></a>How can we find the version of React at runtime in the browser?</h3><p><code>React.version</code>을 사용하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REACT_VERSION = React.version</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;&#123;<span class="string">`React version: <span class="subst">$&#123;REACT_VERSION&#125;</span>`</span>&#125;&lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-approaches-to-include-polyfills-in-your-create-react-app"><a href="#What-are-the-approaches-to-include-polyfills-in-your-create-react-app" class="headerlink" title="What are the approaches to include polyfills in your create-react-app?"></a>What are the approaches to include polyfills in your <code>create-react-app</code>?</h3><ol><li><p><code>core-js</code>를 수동으로 임포트하는 법<br><code>polyfills.js</code>과 같은 파일을 만들고, 이를 루트인 <code>index.js</code>에서 임포트 한다. 그리고 <code>core-js</code>를 설치하여 필요한 기능을 임포트 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/fn/array/find'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js/fn/array/includes'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js/fn/number/is-nan'</span></span><br></pre></td></tr></table></figure></li><li><p>폴리필 서비스를 이용하는 방법<br><code>polyfill.io</code>를 CDN으로 가져와서, <code>index.html</code>에 추가하는 방법</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-use-https-instead-of-http-in-create-react-app"><a href="#How-to-use-https-instead-of-http-in-create-react-app" class="headerlink" title="How to use https instead of http in create-react-app?"></a>How to use https instead of http in create-react-app?</h3><p>환경설정에 <code>HTTPS=true</code>를 세팅하면 된다. </p><p>pacakge.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "set HTTPS=true &amp;&amp; react-scripts start"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아니면 <code>set HTTPS=true &amp;&amp; npm start</code>로 실행하면 된다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-avoid-using-relative-path-imports-in-create-react-app"><a href="#How-to-avoid-using-relative-path-imports-in-create-react-app" class="headerlink" title="How to avoid using relative path imports in create-react-app?"></a>How to avoid using relative path imports in create-react-app?</h3><p>루트 디렉토리에 <code>.env</code>를 만들고, 임포트 경로를 작성한다.</p><p><code>NODE_PATH=src/app</code></p><p>개발서벌르 재시작하면, 상대경로 없이 <code>src/app</code>에 있는 파일을 import 할 수 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-add-Google-Analytics-for-React-Router"><a href="#How-to-add-Google-Analytics-for-React-Router" class="headerlink" title="How to add Google Analytics for React Router?"></a>How to add Google Analytics for React Router?</h3><p>history 객체에 리스너를 추가하여 각 페이지 뷰에 달아 둔다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.listen(<span class="function"><span class="keyword">function</span> (<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.ga(<span class="string">'set'</span>, <span class="string">'page'</span>, location.pathname + location.search)</span><br><span class="line">  <span class="built_in">window</span>.ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>, location.pathname + location.search)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-update-a-component-every-second"><a href="#How-to-update-a-component-every-second" class="headerlink" title="How to update a component every second?"></a>How to update a component every second?</h3><p><code>setInterval()</code>에 트리거를 걸어두면 되지만, unmount시에 이를 해제하여 메모리 누수와 에러를 방지해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="built_in">Date</span>.now() &#125;), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.interval)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-do-you-apply-vendor-prefixes-to-inline-styles-in-React"><a href="#How-do-you-apply-vendor-prefixes-to-inline-styles-in-React" class="headerlink" title="How do you apply vendor prefixes to inline styles in React?"></a>How do you apply vendor prefixes to inline styles in React?</h3><p>react는 자동으로 vender prefix를 붙여주지 않으므로, 수동으로 붙여야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;</span><br><span class="line">  transform: <span class="string">'rotate(90deg)'</span>,</span><br><span class="line">  WebkitTransform: <span class="string">'rotate(90deg)'</span>, <span class="comment">// note the capital 'W' here</span></span><br><span class="line">  msTransform: <span class="string">'rotate(90deg)'</span> <span class="comment">// 'ms' is the only lowercase vendor prefix</span></span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-import-and-export-components-using-React-and-ES6"><a href="#How-to-import-and-export-components-using-React-and-ES6" class="headerlink" title="How to import and export components using React and ES6?"></a>How to import and export components using React and ES6?</h3><p><code>default</code>키워드를 사용하여 컴포넌트를 익스포트 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'user'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProfile</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;User type=<span class="string">"customer"</span>&gt;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &lt;<span class="regexp">/User&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>위 예제에서는 MyProfile이 멤버가 되어 모듈로 익스포트 되는데, 이는 다른 컴포넌트에서 굳이 이름을 명세하지 않더라도 임포트 할 수 있게 해준다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-exceptions-on-React-component-naming"><a href="#What-are-the-exceptions-on-React-component-naming" class="headerlink" title="What are the exceptions on React component naming?"></a>What are the exceptions on React component naming?</h3><p>몇가지 예외적인 경우를 제외하고, 컴포넌트 명은 대문자로 시작해야 한다. 소문자와 . (속성 접근자)을 사용하는 경우 유효한 컴포넌트 명이다. 아래의 예가 그러한 유효한 경우다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">       &lt;obj.component /&gt; <span class="comment">// `React.createElement(obj.component)`</span></span><br><span class="line">      )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="Why-is-a-component-constructor-called-only-once"><a href="#Why-is-a-component-constructor-called-only-once" class="headerlink" title="Why is a component constructor called only once?"></a>Why is a component constructor called only once?</h3><p>React의 reconciliation 알고리즘은 후속 렌더링 과정에서 사용자 정의 컴포넌트가 똒같은 위치에 나타나면, 이전과 동일 한 요소이므로 새로운 인스턴스를 만드는 대신 이전 인스턴스를 재사용한다고 가정한다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-define-constants-in-React"><a href="#How-to-define-constants-in-React" class="headerlink" title="How to define constants in React?"></a>How to define constants in React?</h3><p>es7의 static 필드를 사용하여 상수를 정의할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> DEFAULT_PAGINATION = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>현재 static 필드는 stage3에 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-programmatically-trigger-click-event-in-React"><a href="#How-to-programmatically-trigger-click-event-in-React" class="headerlink" title="How to programmatically trigger click event in React?"></a>How to programmatically trigger click event in React?</h3><p>callback을 통한 ref prop를 사용하여 HTMLInputElement 객체에 대한 참조를 가져와서 class property 로 저장한 다음, 이렇게 저장된 참조를 활용하여 <code>HTMLElement.click</code> 메서드를 사용해 이벤트 핸들러에서 클릭 이벤트를 트리거 할 수 있다.</p><ol><li>render 메서드에서 ref를 생성한다.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;input =&gt; <span class="keyword">this</span>.inputElement = input&#125; /&gt;</span><br></pre></td></tr></table></figure><ol><li>이벤트 핸들러에서 클릭 이벤트를 트리거 한다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.inputElement.click()</span><br></pre></td></tr></table></figure></li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="Is-it-possible-to-use-async-await-in-plain-React"><a href="#Is-it-possible-to-use-async-await-in-plain-React" class="headerlink" title="Is it possible to use async/await in plain React?"></a>Is it possible to use async/await in plain React?</h3><p>React 에서 async/await 을 사용하고 싶다면 Babel 과 transform-async-to-generator 플러그인이 필요하다. React Native에서는 기본적으로 지원하고 있다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-common-folder-structures-for-React"><a href="#What-are-the-common-folder-structures-for-React" class="headerlink" title="What are the common folder structures for React?"></a>What are the common folder structures for React?</h3><p>크게 두가지 종류가 있다.</p><ol><li>기능 또는 라우팅으로 분류하는 방법</li></ol><p>기능과 라우팅에 따라서 css, js, 테스트 코드를 묶는 방법이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">common/</span><br><span class="line">├─ Avatar.js</span><br><span class="line">├─ Avatar.css</span><br><span class="line">├─ APIUtils.js</span><br><span class="line">└─ APIUtils.test.js</span><br><span class="line">feed/</span><br><span class="line">├─ index.js</span><br><span class="line">├─ Feed.js</span><br><span class="line">├─ Feed.css</span><br><span class="line">├─ FeedStory.js</span><br><span class="line">├─ FeedStory.test.js</span><br><span class="line">└─ FeedAPI.js</span><br><span class="line">profile/</span><br><span class="line">├─ index.js</span><br><span class="line">├─ Profile.js</span><br><span class="line">├─ ProfileHeader.js</span><br><span class="line">├─ ProfileHeader.css</span><br><span class="line">└─ ProfileAPI.js</span><br></pre></td></tr></table></figure><ol><li>파일 타입 별로 분류하는 법<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">api/</span><br><span class="line">├─ APIUtils.js</span><br><span class="line">├─ APIUtils.test.js</span><br><span class="line">├─ ProfileAPI.js</span><br><span class="line">└─ UserAPI.js</span><br><span class="line">components/</span><br><span class="line">├─ Avatar.js</span><br><span class="line">├─ Avatar.css</span><br><span class="line">├─ Feed.js</span><br><span class="line">├─ Feed.css</span><br><span class="line">├─ FeedStory.js</span><br><span class="line">├─ FeedStory.test.js</span><br><span class="line">├─ Profile.js</span><br><span class="line">├─ ProfileHeader.js</span><br><span class="line">└─ ProfileHeader.css</span><br></pre></td></tr></table></figure></li></ol><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-popular-packages-for-animation"><a href="#What-are-the-popular-packages-for-animation" class="headerlink" title="What are the popular packages for animation?"></a>What are the popular packages for animation?</h3><p>React Transition Group과 React Motion이 React 생태계에서 유명한 애니메이션 패키지다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="What-is-the-benefit-of-styles-modules"><a href="#What-is-the-benefit-of-styles-modules" class="headerlink" title="What is the benefit of styles modules?"></a>What is the benefit of styles modules?</h3><p>스타일 값을 하드코딩 하는 것은 권장하지 않는 방식이다. 서로다른 UI 컴포넌트에서 넓게 사용되는 값은 하나의 모듈에서 추출해서 쓰는 것이 좋다.</p><p>아래와 같은 방식을 사용하면, 서로다른 컴포넌트에서 동일한 스타일을 가져올 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> colors = &#123;</span><br><span class="line">  white,</span><br><span class="line">  black,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> space = [</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">8</span>,</span><br><span class="line">  <span class="number">16</span>,</span><br><span class="line">  <span class="number">32</span>,</span><br><span class="line">  <span class="number">64</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>그리고 각각의 컴포넌트에서 이를 임포트 하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; space, colors &#125; <span class="keyword">from</span> <span class="string">'./styles'</span></span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-the-popular-React-specific-linters"><a href="#What-are-the-popular-React-specific-linters" class="headerlink" title="What are the popular React-specific linters?"></a>What are the popular React-specific linters?</h3><p>자바스크립트 lint로는 eslint가 유명하다. 코드 스타일을 분석할 수 있는 다양한 플러그인이 있다. React에서 가장 유명한 것은 <code>eslint-plugin-react</code>다. 기본적으로 몇가지 베스트 프랙티스를 확인하여, 이 규칙을 바탕으로 iterator의 키에서 부터 prop type까지 확인해 준다. 다른 유명한 플러그인으로는 <code>eslint-plugin-jsx-a11y</code>가 있는데, 이는 접근성과 관련된 일반적인 문제를 해결하는데 도움을 준다. JSX는 <code>alt</code> <code>tabindex</code>와 같은 HTML과 약간 다른 문법을 제공하므로, 일반적인 플러그인으로 는 확인이 어렵다.</p><p><a href="#table-of-contents">👆</a></p><h3 id="How-to-make-AJAX-call-and-in-which-component-lifecycle-methods-should-I-make-an-AJAX-call"><a href="#How-to-make-AJAX-call-and-in-which-component-lifecycle-methods-should-I-make-an-AJAX-call" class="headerlink" title="How to make AJAX call and in which component lifecycle methods should I make an AJAX call?"></a>How to make AJAX call and in which component lifecycle methods should I make an AJAX call?</h3><p>Axios, jQuery Ajax, 브라우저 빌트인 <code>fetch</code>등을 활용하여 ajax를 활용할 수 있다. 이렇게 데이터를 가져오는 것은 반드시 <code>componentDidMount()</code>내에서 해야 한다. 이는 데이터를 받어온 뒤에 <code>setState()</code>로 컴포넌트를 업데이트 할 수 있게 해준다.</p><p>예를 들어, 아래 코드에서 employee 목록을 가져오고 state를 업데이트 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      employees: [],</span><br><span class="line">      error: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch(<span class="string">'https://api.example.com/items'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">      .then(</span><br><span class="line">        (result) =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            employees: result.employees</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        (error) =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123; error &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; error, employees &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;employees.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;employee.name&#125;&gt;</span><br><span class="line">              &#123;employee.name&#125;-&#123;employees.experience&#125;</span><br><span class="line">            &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#table-of-contents">👆</a></p><h3 id="What-are-render-props"><a href="#What-are-render-props" class="headerlink" title="What are render props?"></a>What are render props?</h3><p><strong>Render Props</strong>는 값이 함수인 prop을 활용하여 컴포넌트 간에 코드를 share할 수 있게 해주는 방법이다. 아래 컴포넌트는 <code>render prop</code>을 활용하여 React element를 리턴한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;&#123;<span class="string">`Hello <span class="subst">$&#123;data.target&#125;</span>`</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">)&#125;/</span>&gt;</span><br></pre></td></tr></table></figure><p>React Router 와 DownShift 라이브러리가 이 패턴을 사용한다.</p><p><a href="#table-of-contents">👆</a></p>]]></content>
    
    <summary type="html">
    
      목차

No.QuestionsCore React1리액트란 무엇인가?2리액트의 주요 기능은 무엇인가?3JSX란 무엇인가?4element와 component의 차이점은 무엇인가?5리액트에서 컴포넌트를 어떻게 만드는가?6클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가?7순수한 컴포넌트는 무엇인가?8state는 무엇인가?9props는 무엇인가?10state와 props의 차이는 무엇인가?11왜 state를 바로 업데이트 하면 안되는가?12setState() 콜백의 용도는 무엇인가?13HTML과 React의 이벤트 핸들링 차이는 무엇인
    
    </summary>
    
    
      <category term="react" scheme="https://www.yceffort.kr/tags/react/"/>
    
      <category term="javascript" scheme="https://www.yceffort.kr/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>타입스크립트 타입 단언</title>
    <link href="https://www.yceffort.kr/2019/08/20/typescript-type-assertion/"/>
    <id>https://www.yceffort.kr/2019/08/20/typescript-type-assertion/</id>
    <published>2019-08-20T00:30:52.000Z</published>
    <updated>2019-08-20T01:45:44.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="문제의-시작"><a href="#문제의-시작" class="headerlink" title="문제의 시작"></a>문제의 시작</h2><p>문제의 시작은 <a href="/2019/06/17/typescript-type-enum-partial-record/">여기</a> 였다.</p><p>내가 사용하는 코드는 아래와 같았다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GlobalColors = <span class="string">"Red"</span> | <span class="string">"Blue"</span> | <span class="string">"Green"</span> | <span class="string">"Black"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 기본값으로 색상을 선언한다.</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> ConstGlobalColorSet &#123;</span><br><span class="line">  Red = <span class="string">"11, 11, 11"</span>,</span><br><span class="line">  Blue = <span class="string">"22, 22, 22"</span>,</span><br><span class="line">  Green = <span class="string">"33, 33, 33"</span>,</span><br><span class="line">  Black = <span class="string">"44, 44, 44"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// red, blue, green, black에 대해서는 글로벌하게 지정해둔 컬러를 사용하되,</span></span><br><span class="line"><span class="comment">// 그밖의 string이 오면 그냥 그 string을 리턴한다</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetGlobalColor</span>(<span class="params">colorString: GlobalColors | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> GlobalColorSet[colorString] || colorString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그러나 다른 프로젝트에서 아래와 같은 에러가 발생했다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Element implicitly has an 'any' type because index expression is not of type 'number'.</span></span><br><span class="line"><span class="keyword">return</span> GlobalColorSet[colorString] || colorString;</span><br></pre></td></tr></table></figure><p>파라미터로오는 <code>colorString</code> 이 enum의 키가 아닐 수도 있기 때문에 발생하는 에러 였다. 기존 lint 룰에서는 any를 accept했기 때문에 에러가 발생하지 않았던 것이다.</p><h2 id="해결"><a href="#해결" class="headerlink" title="해결"></a>해결</h2><p><code>as</code> 키워드를 써서 문제를 해결했다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetGlobalColor</span>(<span class="params">colorString: GlobalColors | <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> GlobalColorSet[colorString <span class="keyword">as</span> GlobalColors] || colorString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="타입-단언"><a href="#타입-단언" class="headerlink" title="타입 단언"></a>타입 단언</h2><p>타입스크립트의 타입 추론은 매우 좋고 강력한 기능이지만, 어쩔수 없이 한계가 존재하는 경우가 더러 있다. 이를 보완하기 위해, 타입 단언은 컴파일러가 실제 런타임에 존재할 변수와 다르게 추론하거나, 너무 보수적으로 추론하는 경우에 개발자가 수동으로 컴파일러에 대해 타입의 힌트를 주는 것이다.</p><p>위의 코드로 돌아와 보자.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ConstGlobalColorSet &#123;</span><br><span class="line">  Red = <span class="string">"11, 11, 11"</span>,</span><br><span class="line">  Blue = <span class="string">"22, 22, 22"</span>,</span><br><span class="line">  Green = <span class="string">"33, 33, 33"</span>,</span><br><span class="line">  Black = <span class="string">"44, 44, 44"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위코드는 컴파일을 거치고 나면 다음과 같이 해석된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ConstGlobalColorSet;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">ConstGlobalColorSet</span>) </span>&#123;</span><br><span class="line">  ConstGlobalColorSet[<span class="string">"Red"</span>] = <span class="string">"11, 11, 11"</span>;</span><br><span class="line">  ConstGlobalColorSet[<span class="string">"Blue"</span>] = <span class="string">"22, 22, 22"</span>;</span><br><span class="line">  ConstGlobalColorSet[<span class="string">"Green"</span>] = <span class="string">"33, 33, 33"</span>;</span><br><span class="line">  ConstGlobalColorSet[<span class="string">"Black"</span>] = <span class="string">"44, 44, 44"</span>;</span><br><span class="line">&#125;)(ConstGlobalColorSet || (ConstGlobalColorSet = &#123;&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;Red: "11, 11, 11", Blue: "22, 22, 22", Green: "33, 33, 33", Black: "44, 44, 44"&#125;</span></span><br></pre></td></tr></table></figure><p>당연하지만 <code>Red</code> <code>Blue</code> <code>Green</code> <code>Black</code>에 대해서는 올바르게 리턴할테지만, 다른 string에 대해서는 null을 리턴할 것이다. 즉, 컴파일 에러가 날 일은 없을 것이다. 이런 경우, <code>as</code> 키워드를 통해서 타입단언을 해주면 컴파일 에러 없이 사용할 수 있다.</p><p>대부분의 경우 <code>as any</code>와 같은 치트키로 컴파일 문제를 해결할 수 있다. 그러나 이런 키워드가 득실 거릴수록 타입스크립트로 얻을 수 있는 장점이 사라지기 때문에, 가능한 적게 사용해야 한다.</p><h2 id="타입선언과-타입-캐스팅의-차이"><a href="#타입선언과-타입-캐스팅의-차이" class="headerlink" title="타입선언과 타입 캐스팅의 차이"></a>타입선언과 타입 캐스팅의 차이</h2><p><strong>타입 단언은 런타임에 영향을 미치지 않는다. 그러나 타입 캐스팅은 컴파일 타임과 런타임 모두 타입을 변경 시킨다. 타입 단언은 컴파일러에서만 타입을 변경 시킨다</strong></p><p>타입 단언은 두가지로 사용될 수 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colorString <span class="keyword">as</span> GlobalColors;</span><br><span class="line">&lt;GlobalColors&gt;colorString;</span><br></pre></td></tr></table></figure><p><code>&lt;Type&gt;</code>은 리액트의 JSX 문법과 겹치는 느낌이 있어서 보통 <code>as type</code>을 더 많이 쓴다.</p><h2 id="타입-가드"><a href="#타입-가드" class="headerlink" title="타입 가드"></a>타입 가드</h2><p>타입 가드는 타입스크립트 컴파일러에 타입 체크를 알려주는 기능이다. 자바스크립트에서는 이런 느낌으로 처리했을 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">x: number | string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="comment">// string 만 들어오게 처리 해줬기 때문에 에러가 날 수 없음</span></span><br><span class="line">    <span class="built_in">console</span>.log(x.substr(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  x.substr(<span class="number">1</span>); <span class="comment">// 에러 날 수도 있음</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  foo = <span class="number">123</span>;</span><br><span class="line">  common = <span class="string">"123"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  bar = <span class="number">123</span>;</span><br><span class="line">  common = <span class="string">"123"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Foo) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> Bar) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(arg.common); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg.foo); <span class="comment">// undefined?</span></span><br><span class="line">  <span class="built_in">console</span>.log(arg.bar); <span class="comment">// undefined?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doStuff(<span class="keyword">new</span> Foo());</span><br><span class="line">doStuff(<span class="keyword">new</span> Bar());</span><br></pre></td></tr></table></figure><p>이를 타입스크립트에서 처리하려면 어떻게 해야할까?</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  y: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">q: A | B</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"x"</span> <span class="keyword">in</span> q) &#123;</span><br><span class="line">    <span class="comment">// q: A</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// q: B</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>in</code>키워드를 사용하거나 아래 처럼 <code>is</code>키워드를 사용할 수도 있다.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">  foo: <span class="built_in">number</span>;</span><br><span class="line">  common: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Bar &#123;</span><br><span class="line">  bar: <span class="built_in">number</span>;</span><br><span class="line">  common: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arg를 Foo라고 타입 가드를 선언</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFoo</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">arg</span> <span class="title">is</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arg.foo !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span>(<span class="params">arg: Foo | Bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isFoo(arg)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// OK</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// Error!</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.foo); <span class="comment">// Error!</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg.bar); <span class="comment">// OK</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doStuff(&#123; foo: <span class="number">123</span>, common: <span class="string">"123"</span> &#125;);</span><br><span class="line">doStuff(&#123; bar: <span class="number">123</span>, common: <span class="string">"123"</span> &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      문제의 시작
문제의 시작은 여기 였다.

내가 사용하는 코드는 아래와 같았다.

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15


type GlobalColors = &quot;Red&quot; | &quot;Blue&quot; | &quot;Green&quot; | &quot;Black&quot;;

// 기본값으로 색상을 선언한다.
const enum ConstGlobalColorSet {
  Red = &quot;11, 11, 11&quot;,
  Blue = &quot;22, 22, 22&quot;,
  Green = &quot;33, 33, 33&quot;,
  Black = &quot;44, 44, 44&quot;
}

// red, blue,
    
    </summary>
    
    
      <category term="react" scheme="https://www.yceffort.kr/tags/react/"/>
    
      <category term="javascript" scheme="https://www.yceffort.kr/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>리액트 인터뷰 질문 &amp; 답</title>
    <link href="https://www.yceffort.kr/2019/08/13/reactjs-interview-questions/"/>
    <id>https://www.yceffort.kr/2019/08/13/reactjs-interview-questions/</id>
    <published>2019-08-13T00:27:31.000Z</published>
    <updated>2019-09-06T00:30:12.749Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/sudheerj/reactjs-interview-questions" target="_blank" rel="noopener">원문-reactjs-interview-questions</a></p><p><a href="/2019/08/20/reactjs-interview-questions-1/">1. Core React</a><br><a href="/2019/08/21/reactjs-interview-questions-2/">2. React - Router, Internationalization, Redux, Native and supported libraries and Integration</a><br></p>]]></content>
    
    <summary type="html">
    
      원문-reactjs-interview-questions

1. Core React
2. React - Router, Internationalization, Redux, Native and supported libraries and Integration

    
    </summary>
    
    
      <category term="react" scheme="https://www.yceffort.kr/tags/react/"/>
    
      <category term="javascript" scheme="https://www.yceffort.kr/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>koa-nextjs-react-typescript-boilerplate</title>
    <link href="https://www.yceffort.kr/2019/08/12/koa-nextjs-react-typescript-bolierplate/"/>
    <id>https://www.yceffort.kr/2019/08/12/koa-nextjs-react-typescript-bolierplate/</id>
    <published>2019-08-12T04:42:22.000Z</published>
    <updated>2019-08-13T08:28:42.915Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/yceffort/koa-nextjs-react-typescript-boilerplate" target="_blank" rel="noopener">github repository</a></p><p>nextjs와 react 만 깔끔하게 쓰고 싶지만, 그러기엔 현실적인 문제가 몇가지 있다</p>]]></content>
    
    <summary type="html">
    
      github repository

nextjs와 react 만 깔끔하게 쓰고 싶지만, 그러기엔 현실적인 문제가 몇가지 있다
    
    </summary>
    
    
      <category term="browser" scheme="https://www.yceffort.kr/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>브라우저는 어떻게 동작하는가? - 모던 웹브라우저가 동작하는 방법</title>
    <link href="https://www.yceffort.kr/2019/08/12/how-browser-work/"/>
    <id>https://www.yceffort.kr/2019/08/12/how-browser-work/</id>
    <published>2019-08-12T04:42:22.000Z</published>
    <updated>2019-08-19T10:24:26.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="🚧작성중-🚧"><a href="#🚧작성중-🚧" class="headerlink" title="🚧작성중 🚧"></a>🚧작성중 🚧</h3><p><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">원문-How Browsers Work: Behind the scenes of modern web browsers</a></p><blockquote><p>이 글을 요약/번역한 더 좋은 글이 <a href="https://d2.naver.com/helloworld/59361" target="_blank" rel="noopener">네이버 d2</a>에 있습니다. 개인적인 공부 차원에서 이 원문을 fully 한글로 번역하고 있습니다.</p></blockquote><h1 id="소개"><a href="#소개" class="headerlink" title="소개"></a>소개</h1><p>웹 브라우저는 가장 널리 쓰이는 소프트웨어다. 이 글에서는, 브라우저가 어떻게 동작하는지 소개할 것이다. 이 글을 읽고 나면, <code>google.com</code>을 타이핑 한 시점 부터 구글페이지가 브라우저에 보이기 까지, 어떤 일련의 과정이 있는지 알게 될 것이다.</p><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li>소개<ol><li>이 글에서 소개하는 브라우저</li><li>브라우저의 주요 기능</li><li>브라우저의 상위 레벨 구조</li></ol></li><li>렌더링 엔진<ol><li>렌더링 엔진들</li><li>주요 흐름</li><li>주요 흐름 예제</li></ol></li><li>파싱과 DOM 트리 구축<ol><li>파싱: 일반<ol><li>문법들</li><li>Parser-Lexer 조합</li><li>변환</li><li>파싱 예제</li><li>어휘와 구문에 대한 공식적인 정의</li><li>파서의 종류</li><li>자동으로 파서 생성</li></ol></li><li>HTML 파서<ol><li>HTML 문법 정의</li><li>문맥으로 부터 자유롭지 못함</li><li>HTML DTD</li><li>DOM</li><li>파싱 알고리즘</li><li>토큰화 알고리즘</li><li>트리구조 알고리즘</li><li>파싱이 끝났을 경우 액션</li><li>브라우저 에러 처리</li></ol></li><li>CSS 파싱<ol><li>웹킷 css 파서</li></ol></li><li>스크립트와 스타일시트를 프로세싱하는 순서<ol><li>스크립트</li><li>예측 파싱</li><li>스타일 시트</li></ol></li></ol></li><li>렌더 트리 구축<ol><li>돔 트리와 렌더 트리와의 관계</li><li>트리를 구축하는 순서</li><li>스타일 연산<ol><li>스타일 데이터 공유</li><li>파이어폭스 규칙 트리<ol><li>구조체로 분리</li><li>규칙 트리를 활용하여 스타일 컨택스트 연산</li></ol></li><li>쉬운 매칭을 위한 규칙 다루기</li><li>다단계 순서에 따라 규칙 적용하기<ol><li>스타일 시트 다단계 순서</li><li>특정성</li><li>규칙정렬</li></ol></li><li>점진적 프로세스</li></ol></li></ol></li><li>레이아웃<ol><li>Dirty bit system</li><li>글로벌 및 incremental 레이아웃</li><li>동기 및 비동기 레이아웃</li><li>최적화</li><li>레이아웃 프로세스</li><li>너비 계산</li><li>라인 브레이킹</li></ol></li><li>페인팅<ol><li>글로벌 및 incremental</li><li>페인팅 순서</li><li>파이어폭스 디스플레이 리스트</li><li>웹킷 사각형 저장소</li></ol></li><li>다이나믹 변화</li><li>렌더링 엔진의 스레드<ol><li>이벤트 루프</li></ol></li><li>CSS2 비쥬얼 모델<ol><li>캔버스</li><li>CSS box model</li><li>포지셔닝 스킴</li><li>박스 타입</li><li>포지셔닝<ol><li>relative</li><li>floats</li><li>absolute &amp; fixed</li></ol></li><li>층표현</li></ol></li><li>리소스</li></ol><h2 id="1-소개"><a href="#1-소개" class="headerlink" title="1. 소개"></a>1. 소개</h2><h3 id="1-1-이-글에서-소개하는-브라우저"><a href="#1-1-이-글에서-소개하는-브라우저" class="headerlink" title="1-1. 이 글에서 소개하는 브라우저"></a>1-1. 이 글에서 소개하는 브라우저</h3><p>오늘날에는 5개의 메인 브라우저가 존재한다: 크롬, 익스플로러, 파이어폭스, 사파리 그리고 오페라. 모바일에서, 안드로이드 브라우저, 아이폰, 오페라 미니, 오페라 모바일, UC 브라우저 등등이 존재하는데, 웹킷을 베이스로 하는 오페라를 제외하고는 대부분이 크롬을 기반으로 하고 있다. 여기에서는 오픈소스 브라우저인 파이어폭스, 크롬, 사파리 (부분적으로 오픈소스)를 예로 들 것이다. stat counter에 따르면 2013년 6월 기준 이 세 브라우저가 차지하는 글로벌 데스크톱 브라우저 비중이 71%에 육박한다. 모바일에서는, 안드로이드 브라우저, 아이폰과 크롬 베이스 프라우저가 54%정도를 차지한다.</p><blockquote><p>2019년 7월 현재 세 브라우저의 시장 점유율은 83% 정도를 차지한다.</p></blockquote><h3 id="1-2-브라우저의-주요-기능"><a href="#1-2-브라우저의-주요-기능" class="headerlink" title="1-2. 브라우저의 주요 기능"></a>1-2. 브라우저의 주요 기능</h3><p>브라우저의 주요 기능은 사용자가 선택한 웹리소스를 서버에 요청하고, 브라우저 윈도우에 디스플레이하여 표현하는 것이다.일반적으로 리소스는 HTML 문서지만, 여기에는 PDF, 이미지, 혹은 기타 다른 유형이 있을 수도 있다. 이런 리소스의 위치는 사용자가 사용하는 URI(Uniform Resource Identifier)에 의해서 정해진다.</p><p>브라우저가 HTML 파일을 해석하고 표시하는 방법은 HTML과 CSS 명세에 따라서 정해진다. 이러한 명세는 웹 표준화 기구인 W3C(World Wide Web Consortium) 에서 정해진다. 수년 간 일부 브라우저는 사양의 일부만을 준수하고 자체 익스텐션을 개발했다. 이로인해 웹 개발자들 사이에서 심각한 호환성 문제가 발생했다. 오늘날 대부분의 브라우저는 이러한 명세를 거의 지킨다.</p><blockquote><p>샤앙을 어긴 브라우저는… ^^</p></blockquote><p>브라우저의 UI는 서로 대부분의 공통점을 가지고 있다. 이러한 공통점들을 예로 들자면</p><ul><li>URI를 넣을 수 있는 주소창</li><li>뒤로가기/앞으로가기 버튼</li><li>북마크 옵션</li><li>현재 문서를 새로 고치거나 멈출 수 있는 새로고침/멈춤 버튼</li><li>사용자의 홈페이지로 가는 홈버튼</li></ul><p>이상하게도 이러한 공통점들은, 공식적인 명세로 지정된 것이 아님에도 불구하고 수년 동안 형성된 좋은 관행과 서로를 모방하는 브라우저의 특징에서 비롯된 것이다. HTML5 명세는 브라우저가 가져야하는 UI 요소를 정의하고 있지는 않지만, 일부 공통된 요소들을 나열한다. 그 중에는 주소 표시줄, 상태 표시줄, 도구 표시줄 등이 있다. 물론 파이어폭스나 크롬의 다운로드 관리자와 같은 특정 브라우저에만 있는 기능도 있다.</p><h3 id="1-3-브라우저의-상위레벨-구조"><a href="#1-3-브라우저의-상위레벨-구조" class="headerlink" title="1-3 브라우저의 상위레벨 구조"></a>1-3 브라우저의 상위레벨 구조</h3><ol><li>유저 인터페이스: 주소창, 앞/뒤 버튼, 북마크 메뉴 등, 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분을 칭한다.</li><li>브라우저 엔진: 유저 인터페이스와 렌더링 엔진 사이의 동작을 제어</li><li>렌더링 엔진: 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다.</li><li>네트워킹: HTTP 요청과 같은 네트워크 통신에 사용된다. 여기는 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.</li><li>UI 백엔드: 콤보 박츠, 창과 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로, OS 사용자 인터페이스 체계를 사용한다.</li><li>자바스크립트 인터프리터: 자바스크립트 코드를 파싱하고 실행을 위해 사용한다.</li><li>데이터 스토리지: 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이, 모든 종류의 자원을 하드디스크에 저장할 때 사용한다. HTML5 명세에는 브라우저가 지원해야하는 <a href="https://www.html5rocks.com/en/features/storage" target="_blank" rel="noopener">웹 데이터 베이스</a>가 정의 되어 있다.</li></ol><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/layers.png" alt="브라우저의 주요 구성요소"></p><p>크롬과 같은 경우에는 각 탭마다 별도의 렌더링 엔진을 사용한다. 각 탭은 다른 프로세스에서 실행된다.</p><h2 id="2-랜더링-엔진"><a href="#2-랜더링-엔진" class="headerlink" title="2. 랜더링 엔진"></a>2. 랜더링 엔진</h2><p>렌더링 엔진의 역할은… 말그대로 렌더링이다. 렌더링은 여기서 요청받은 콘텐츠를 브라우저 화면에 보여주는 역할이다.</p><p>기본적으로 렌더링엔진은 HTML, XML, 그리고 이미지를 표시할 수 있다. 플러그인이나 익스텐션을 활용한다면, 다양한 데이터 타입, 예를 들어 PDF 등 도 표시할 수 있다. 그러나, 이번 챕터에서는 일반적인 활용 예제인 CSS로 포맷된 HTML과 이미지를 표시하는 법에 대해서 다룰 것이다.</p><h3 id="2-1-렌더링-엔진들"><a href="#2-1-렌더링-엔진들" class="headerlink" title="2-1. 렌더링 엔진들"></a>2-1. 렌더링 엔진들</h3><p>브라우저 마다 서로다른 렌더링 엔진을 사용하고 있다. 익스프롤러는 Trident를, 파이어폭스는 Gecko를 사용하며 사파리는 Webkit을 사용한다. 그리고 크롬과 15버전 부터 오페라는 Webkit에서 포크된 Blink를 사용한다.</p><p>Webkit은 오픈소스 렌더링 엔진으로, 리눅스 플랫폼에서 사용될 엔진으로 만들어졌다가 애플에 의해서 맥과 윈도우도 지원하게 되었다. 자세한 것은 <a href="https://webkit.org/" target="_blank" rel="noopener">webkit.org</a>를 참조하면 된다.</p><h3 id="2-2-주요-흐름"><a href="#2-2-주요-흐름" class="headerlink" title="2-2. 주요 흐름"></a>2-2. 주요 흐름</h3><p>렌더링 엔진은 통신을 통해 요청한 문서의 내용을 얻는 것부터 시작한다. 보통 문서내용은 8kb 단위로 전송된다. 렌더링 엔진의 기본적인 동작과정은 아래와 같다.</p><ol><li>DOM 트리 구축을 위한 HTML 파싱</li><li>렌더 트리 구축</li><li>렌더 트리 배치</li><li>렌더 트리 그리기</li></ol><p>렌더링 엔진은 HTML 문서를 파싱하기 시작하며, 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환한다.그리고 엔진은 CSS파일과 스타일 요소를 파싱하기 시작한다. 스타일 정보와 HTML 표시 규칙은 ‘렌더트리’ 라고 부르는 또다른 트리를 생성한다.</p><p>렌더 트리는 색상 또는 면적과 같은 시각적 속성이 있는 사각형을 포함하고 잇는데, 정해진 순서대로 화면에 표시된다.</p><p>렌더 트리 구축 이후에는, 레이아웃 프로세스로 넘어간다. 이 말은, 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 모양을 만들어 내는 그리기 과정이다.</p><h3 id="2-3-주요-흐름-예제"><a href="#2-3-주요-흐름-예제" class="headerlink" title="2-3. 주요 흐름 예제"></a>2-3. 주요 흐름 예제</h3><p>웹킷의 주요 흐름</p><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/webkitflow.png" alt="webkit-main-flow"></p><p>모질라 게코의 렌더링 엔진 주요 흐름</p><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/image008.jpg" alt="gecko-rendering-engine"></p><p>그림에서 보다시피, 웹킷과 게코가 약간 다른 용어를 쓰고 있지만 기본적인 흐름은 동일하다.</p><p>게코는 시각적으로 처리되는 렌더 트리를 프레임트리 라고 부르고, 각 요소를 프레임이라고 부르는 반면, 웹킷은 렌더 객체로 구성되어 있는 렌더 트리라는 용어를 사용한다. 웹킷은 요소를 배치하는데 레이아웃이라는 용어를 사용하지만, 개코는 리플로우라는 용어를 사용한다. attachment는 웹킷이 렌드 트리를 생성하기 위해 DOM노드와 시각정보를 연결하는 과정을 의미한다. 반면에 게코는 HTML과 DOM트리 사이에 콘텐츠 싱크라고 부르는 과정을 두는데, 이는 DOM 요소를 생성하는 과정으로 웹킷과 비슷하여 큰 의미 있는 차이점으로 보지는 않는다.</p><h2 id="3-파싱과-DOM-트리-구축"><a href="#3-파싱과-DOM-트리-구축" class="headerlink" title="3. 파싱과 DOM 트리 구축"></a>3. 파싱과 DOM 트리 구축</h2><h3 id="3-1-파싱-일반"><a href="#3-1-파싱-일반" class="headerlink" title="3-1. 파싱 일반"></a>3-1. 파싱 일반</h3><p>파싱은 렌더링 엔진에서 아주 중요한 작업이라서, 파싱에 대해서 아주 깊게 다룰 예쩡이다. 파싱에 대한 짧은 소개와 함께 시작한다.</p><p>문서를 파싱한다는 것은 문서 구조를 읽을 수 있는 코드로 변환한다는 것을 의미한다. 파싱의 결과는 보통 노드의 트리로 나타나는데, 이 노드의 트리는 문서의 구조를 나타낸다. 이것을 파스트리 또는 신택스 트리 라고 한다.</p><p>예를 들어, <code>2+3-1</code>은 아래와 같은 트리구조로 나타낼 수 있다.</p><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/image009.png" alt="mathematical-expression-tree-node"></p><h4 id="3-1-1-문법들"><a href="#3-1-1-문법들" class="headerlink" title="3-1-1. 문법들"></a>3-1-1. 문법들</h4><p>파싱은 문서에 작성된 언어 또는 형식의 규칙을 따른다. 파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야 한다. 이것을 문맥 자유 문법이라고 한다. 인간의 언어는 이런 모습과는 다르기 때문에 기계적으로 파싱이 불가능하다.</p><h4 id="3-1-2-Parser-Lexer-조합"><a href="#3-1-2-Parser-Lexer-조합" class="headerlink" title="3-1-2. Parser-Lexer 조합"></a>3-1-2. Parser-Lexer 조합</h4><p>파싱은 두가지 서브 프로세스로 나눌수 있다. 렉시컬 분석과 신택스 분석.</p><p>렉시컬 분석은 입력값을 토큰으로 나누는 과정이다. 토큰은 유효하게 구성된 단위의 집합이라고 볼 수 있다. 인간의 언어에서는 사전적으로 뜻이 있는 단어들을 의미한다.</p><p>신택스 분석은 언어를 신택스 규칙에 적용하는 것이다.</p><p>파서는 보통 두가지 일을 하는데 렉서 (토크나이저라고도 한다)는 입력값을 유효한 토큰 값으로 나누는 일을 하고, 파서는 언어 규칙에 따라 문서구조를 분석하여 파싱트리를 생성한다. 렉서는 공백, 줄바꿈 같은 의미 없는 문자를 제거한다.</p><blockquote><p>D2에서는 렉서를 어휘분석으로, 파서는 구문분석으로 정의했다.</p></blockquote><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/image011.png" alt="from-source-document-to-parse-tress"></p><p>파싱과정은 반복된다. 파서는 렉어세 새로운 토큰이 있는지 질의하고, 토큰을 신택스 규칙에 맞추려고 한다. 만약 맞는 규칙이 있다면, 토큰에 해당하는 노드가 파싱트리에 추가되고, 파서는 또다른 토큰을 요청하게 된다.</p><p>만약 일치하는 규칙이 없다면, 파서는 토큰을 내부에 저장하고 토큰과 일치하는 규칙이 발견될때 까지 요청한다. 맞는 규칙이 계속해서 없다면 예외처리를 하는데, 이는 문서가 유효하지 않고 신택스 오류가 있다는 것을 의미한다.</p><h4 id="3-1-3-변환"><a href="#3-1-3-변환" class="headerlink" title="3-1-3. 변환"></a>3-1-3. 변환</h4><p>대부분의 경우 파스 트리가 마지막 결과물이 아니다. 파싱은 보통 변환과정에서 사용되는데, 이 과정은 입력된 문서를 다른 형식으로 변환하는 과정을 의미한다. 이와 같은 예로 컴파일이 있다. 소스 코드를 기계 코드로 만드는 컴파일러는, 파싱트리 생성후 기계 코드 문서로 변환한다.</p><p><img src="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/image013.png" alt="compilation-flow"></p><h4 id="3-1-4-파싱-예제"><a href="#3-1-4-파싱-예제" class="headerlink" title="3-1-4. 파싱 예제"></a>3-1-4. 파싱 예제</h4><p>이전 그림에서 수학식을 파스 트리로 만들어 보았다. 간단한 수학 언어를 정의하고, 파싱과정을 살펴보자.</p><p>언어: 이 수학언어에는 정수, 더하기, 빼기가 있다.</p><p>신택스:</p><ol><li>기본적인 요소로는 표현식, 항, 연산자가 있다</li><li>언어에 포함되는 표현식 갯수에 제한이 없다</li><li>항 뒤에 연산자, 그뒤에 또다른 항이 나오는 형태로 정의한다</li><li>연산자는 더하기 토큰 또는 빼기 토큰이다</li><li>정수 토큰 또는 하나의 표현식은 항이다.</li></ol><p>이제 아까 예제인 <code>2+3-1</code>을 분석해보자.</p><p>규칙에 맞는 첫 번째 문자열은 2다. 규칙 5에 따르면 이것은 하나의 항으로 볼 수 있다. 두 번째로 맞는 것은 2+3 인데 이것은 항 뒤에 연산자와 또 다른 항이 등장한다는 세 번째 규칙과 일치한다. 입력 값의 마지막 부분까지 진행하면 또 다른 일치를 발견할 수 있다. 2+3은 항과 연산자와 항으로 구성된 하나의 새로운 항이라는 것을 알고 있기 때문에 2+3-1은 하나의 표현식이 된다. 2++은 어떤 규칙과도 맞지 않기 때문에 유효하지 않은 입력이 된다.</p><h4 id="3-1-5-어휘와-구문에-대한-공식적인-정의"><a href="#3-1-5-어휘와-구문에-대한-공식적인-정의" class="headerlink" title="3-1-5. 어휘와 구문에 대한 공식적인 정의"></a>3-1-5. 어휘와 구문에 대한 공식적인 정의</h4><p>어휘는 보통 정규표현식을 활용한다.</p><p>예를 들어 이 수학언어는 아래처럼 표현할 수 있을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INTEGER: 0|[1-9][0-9]*</span><br><span class="line">PLUS: +</span><br><span class="line">MINUS: -</span><br></pre></td></tr></table></figure><p>보시다시피, 정수도 정규표현식으로 정의했다.</p><p>신택스는 보통 <a href="https://ko.wikipedia.org/wiki/%EB%B0%B0%EC%BB%A4%EC%8A%A4-%EB%82%98%EC%9A%B0%EB%A5%B4_%ED%91%9C%EA%B8%B0%EB%B2%95" target="_blank" rel="noopener">BNF</a>라고 부르는 형식을 따라서 정의한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expression := term operation term</span><br><span class="line">operation := PLUS | MINUS</span><br><span class="line">term := INTEGER | expression</span><br></pre></td></tr></table></figure><p>문법이 <a href="https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EC%9E%90%EC%9C%A0_%EB%AC%B8%EB%B2%95" target="_blank" rel="noopener">문맥 자유 문법</a>이라면 언어는 정규 파서로 파싱할 수 있다. 문맥 자유 문법은 완전히 BNF로 표현 가능한 문법으로 보면 된다.</p><h4 id="3-1-6-파서의-종류"><a href="#3-1-6-파서의-종류" class="headerlink" title="3-1-6. 파서의 종류"></a>3-1-6. 파서의 종류</h4><p>파서는 top-down 파서와 bottom up 파서 이렇게 두가지로 나누어진다. 직관적으로 설명하자면, top-down 파서는 위에서 부터 상위구조에서 부터 일치하는 부분을 찾기 시작하지만, bottom-up의 경우에는 밑에서 부터 점차 높은 수준으로 찾는다.</p><p>두 종류 파서가 예제를 어떻게 파싱하는지 살펴보자.</p><p>top-down 파서는 상위 구조에서 부터 시작한다. <code>2+3</code>에 해당하는 표현식을 찾는다. 그리고 <code>2+3-1</code>를 찾을 것이다. 표현식을 찾는 과정은, 다른 규칙을 점진적으로 계속해서 찾는 방식인데 가장 높은 수준의 규칙을 먼저 찾는 것을 시작한다.</p><p>반면에 bottom-up은 입력값이 규칙에 맞을때 까지 찾아서 맞는 입력값 규칙으로 바꾸는데, 이는 입력값의 끝까지 진행된다. 부분적으로 일치하는 표현식은 파서의 스택에 쌓인다.</p><div class="table-container"><table><thead><tr><th>Stack</th><th>input</th></tr></thead><tbody><tr><td></td><td>2 + 3 - 1</td></tr><tr><td>항</td><td>+ 3 - 1</td></tr><tr><td>항 연산자</td><td>3 -1</td></tr><tr><td>표현식</td><td>-1</td></tr><tr><td>표현식 연산자</td><td>1</td></tr><tr><td>표현식</td></tr></tbody></table></div><p>bottom up 파서는 shift-reduce 파서라고도 불리우는데, 왜냐하면 입력값이 오른쪽으로 이동하면서 신택스 규칙으로 남는 것이 점차 감소하기 때문이다.</p><h4 id="3-1-7-파서-자동-생성"><a href="#3-1-7-파서-자동-생성" class="headerlink" title="3-1-7. 파서 자동 생성"></a>3-1-7. 파서 자동 생성</h4><p>파서를 생성해 줄 수 있는 도구를 파서 생성기라고 한다. 이 생성기에 문법을 제공하고, 어휘와 신택스 규칙을 적용하여 파서를 생성한다. 파서를 작성하려면 파싱에 대한 깊은 이해가 필요하며, 수작업으로 최적화된 파서를 제공하는 것은 쉽지 않으므로 파서 생성기가 유용할 수 있다.</p><p>Webkit의 경우에는 flex라고 불리우는 lexer와 bison이라고 불리우는 파서 생성기를 사용한다. Flex는 토큰의 정규 표현식 정의를 포함하는 파일을 입력값으로 받고, bison은 BNF형식의 언어 신택스 규칙을 입력 받는다.</p>]]></content>
    
    <summary type="html">
    
      🚧작성중 🚧
원문-How Browsers Work: Behind the scenes of modern web browsers

이 글을 요약/번역한 더 좋은 글이 네이버 d2에 있습니다. 개인적인 공부 차원에서 이 원문을 fully 한글로 번역하고 있습니다.

소개
웹 브라우저는 가장 널리 쓰이는 소프트웨어다. 이 글에서는, 브라우저가 어떻게 동작하는지 소개할 것이다. 이 글을 읽고 나면, google.com을 타이핑 한 시점 부터 구글페이지가 브라우저에 보이기 까지, 어떤 일련의 과정이 있는지 알게 될 것이다.

목차
 1. 
    
    </summary>
    
    
      <category term="browser" scheme="https://www.yceffort.kr/tags/browser/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks Api (2)</title>
    <link href="https://www.yceffort.kr/2019/08/12/react-hooks-api-2/"/>
    <id>https://www.yceffort.kr/2019/08/12/react-hooks-api-2/</id>
    <published>2019-08-12T02:03:51.000Z</published>
    <updated>2019-08-14T02:05:21.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure><p><code>useState</code>의 대체 함수다. 다수의 하윗 값을 만드는 복잡한 로직, 혹은 다음 state가 이전 state의 의존적인 경우에 쓴다. 뭐가 뭔지 모르겠으니까 예제를 보자.</p><p>useState를 쓰기전</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; initialCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount - <span class="number">1</span>)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"increment"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"decrement"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"increment"</span> &#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"decrement"</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">count</span>: initialCount &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"increment"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"decrement"</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">count</span>: state.count - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"reset"</span>:</span><br><span class="line">      <span class="keyword">return</span> init(action.payload);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; initialCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialCount, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"reset"</span>, <span class="attr">payload</span>: initialCount &#125;)&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        Reset</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: "increment" &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">"decrement"</span> &#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>예제를 보니 대충 감이 온다. dispatch를 통해서 state값에 변화를 주지 않고 state값 변화에 트리거를 줄 수 있고, 이 트리거를 이용해 여러개의 state에 변화를 줄 수도 있다.</p><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>메모이제이션된 콜백을 반환한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  doSomething(a, b);</span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></figure><p>동일한 콜백을 바라봐야하는 자식 컴포넌트에게 사용할 때 유용하다.</p><h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure><p>메모이제이션된 값을 반환한다. <code>useMemo</code>는 의존성이 변경되었을 때만, 메모제이션된 값을 다시 계산할 것이다.</p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// `current` points to the mounted text input element</span></span><br><span class="line">    inputEl.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span> /&gt;</span><br><span class="line">      &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>useRef</code>는 <code>.current</code>에 변경가능한 ref값을 담을 수 있다. 부모 클래스에서 특정 dom객체를 계속 추적해야할 때 유용하다. 다만 <code>.current</code>를 변경한다고 해서 리렌더링이 일어나지는 않는다.</p>]]></content>
    
    <summary type="html">
    
      useReducer
1


const [state, dispatch] = useReducer(reducer, initialArg, init);


useState의 대체 함수다. 다수의 하윗 값을 만드는 복잡한 로직, 혹은 다음 state가 이전 state의 의존적인 경우에 쓴다. 뭐가 뭔지 모르겠으니까 예제를 보자.

useState를 쓰기전

1
2
3
4
5
6
7
8
9
10
11


function Counter({ initialCount }) {
  const [count, setCount] = useState(initi
    
    </summary>
    
    
      <category term="react" scheme="https://www.yceffort.kr/tags/react/"/>
    
      <category term="javascript" scheme="https://www.yceffort.kr/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks Api (1)</title>
    <link href="https://www.yceffort.kr/2019/08/08/react-hooks-api-1/"/>
    <id>https://www.yceffort.kr/2019/08/08/react-hooks-api-1/</id>
    <published>2019-08-08T08:01:07.000Z</published>
    <updated>2019-08-14T02:05:21.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hooks-API"><a href="#Hooks-API" class="headerlink" title="Hooks API"></a>Hooks API</h1><p>Hook은 react 16.8에서 추가된 개념으로, Hook을 시용하면 class를 갖성하지 않아도 state관리와 같은 react의 기능을 사용할 수 있다.</p><h2 id="기본-Hook"><a href="#기본-Hook" class="headerlink" title="기본 Hook"></a>기본 Hook</h2><h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(initialState);</span><br><span class="line">setState(newState);</span><br></pre></td></tr></table></figure><p>상태 유지값, 그리고 그 값을 수정하는 함수를 반환한다. 이전의 <code>state</code>값을 받아다가 수정할 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123; initialCount &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(initialCount);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;count&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setCount(<span class="function"><span class="params">prevCount</span> =&gt;</span> prevCount - <span class="number">1</span>)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>동일한 값으로 갱신하는 경우(<code>Object.is</code>) 값이 업데이트 하지 않고 처리를 종료한다.</p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(didUpdate);</span><br></pre></td></tr></table></figure><p>화면에 렌더링이 완료된 이후에 수행한다. 또한, 컴포넌트가 화면에서 제거 될 때 정리 해야할 리소스도 선언할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>unsubscribe</code>는 이제 ui에서 컴포넌트를 제거하기 직전에 수행한다. 그리고 만약, 컴포넌트가 여러번 렌더링 된다면 다음 effect가 수행되기 전에 이전 effect가 정리된다.</p><p>만약 조건부로 실행하기 위해서는 아래와 같은 방법을 활용할 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [props.source]);</span><br></pre></td></tr></table></figure><p>그럼 이제 <code>props.source</code>값이 변경 될때 만 <code>useEffect</code>가 발생하게 된다.</p><h3 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h3><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p><code>context</code>를 이용하면, 매번 일일이 props를 넘겨주지 않아도, 컴포넌트 트리전체에 데이터를 제공할 수 있다. 즉, context는 react 컴포넌트 트리안에서 전역적으로 대이터를 공유할 수 있도록 고안된 방법이다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Page</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PageLayout</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">NavigationBar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">avatarSize</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Link</span> <span class="attr">href</span>=<span class="string">&#123;user.permalink&#125;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Avatar</span> <span class="attr">user</span>=<span class="string">&#123;user&#125;</span> <span class="attr">size</span>=<span class="string">&#123;avatarSize&#125;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">NavigatorBar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PageLayout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Page</span>&gt;</span></span><br></pre></td></tr></table></figure><p>실제로 <code>user</code>와 <code>avatarSize</code>를 사용하는 곳은 <code>Link</code>컴포넌트 인데, page 온갖 컴포넌트를 거치면서 값을 내려주는 것을 볼 수 있다. 이게 더 심해지는 경우, 같은 데이터를 트리안의 여러 레벨의 컴포넌트에게 주어야 할 때도 있다. 이렇게 <strong>데이터가 변할 때 마다 모든 하위 컴포넌트에게 해당 값을 알려주는 것이 <code>context</code>이다.</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyContext = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure><p>Context객체를 만든다. Context 객체를 구독하고, 컴포넌트를 렌더링 할 때 트리 상위에서 가장 가까이 짝이 맞는 <code>Provider</code>로 부터 현재 값을 읽는다. 여기서 선언된 <code>defaultValue</code>는 트리안에서 적절한 Provider를 찾지 못했을 때에만 쓰는 값이다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyContext.provider</span> <span class="attr">value</span>=<span class="string">"&#123;someValue&#125;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">SomeComponent</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MyContext.provider</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Provider</code>는 context를 구독하는 컴포넌트들에게 context의 변화를 알리는 역할을 한다. <code>Provider</code>는 value에 있는 <code>prop</code>을 받아서 이 값을 하위 컴포넌트에 전달한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyContext.Consumer</span>&gt;</span></span><br><span class="line">  &#123;value =&gt; /* context 값을 이용한 렌더링 */&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">MyContext.Consumer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>context 변화를 구독하는 React Component다. 반드시 <code>Context.Consumer</code>의 자식은 함수여야만 한다. 이 함수는 context의 현재 값을 받고, React 노드를 반환해야 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext);</span><br></pre></td></tr></table></figure><p>를 사용하면, context객체를 받아서, 현재 context의 값을 반환한다.</p>]]></content>
    
    <summary type="html">
    
      Hooks API
Hook은 react 16.8에서 추가된 개념으로, Hook을 시용하면 class를 갖성하지 않아도 state관리와 같은 react의 기능을 사용할 수 있다.

기본 Hook
useState
1
2


const [state, setState] = useState(initialState);
setState(newState);


상태 유지값, 그리고 그 값을 수정하는 함수를 반환한다. 이전의 state값을 받아다가 수정할 수도 있다.

1
2
3
4
5
6
7
8
9
10
11


function Counter({
    
    </summary>
    
    
      <category term="react" scheme="https://www.yceffort.kr/tags/react/"/>
    
      <category term="javascript" scheme="https://www.yceffort.kr/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>HAProxy</title>
    <link href="https://www.yceffort.kr/2019/08/07/haproxy/"/>
    <id>https://www.yceffort.kr/2019/08/07/haproxy/</id>
    <published>2019-08-07T00:39:20.000Z</published>
    <updated>2019-08-08T01:31:17.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="로드밸런서"><a href="#로드밸런서" class="headerlink" title="로드밸런서"></a>로드밸런서</h2><blockquote><p>로드 밸런싱이란, 부하 분산을 위해서 가상 IP를 통해 여러 서버에 접속하도록 분배하는 기능을 말한다.</p></blockquote><p>로드 밸런싱에서 사용하는 주요 기술은</p><ul><li>NAT(Network Address Translation): 사설 IP 주소를 공인 IP 주소로 바꾸는 데 사용하는 통신망의 주소 변조기이다.</li><li>DSR(Dynamic Source Routing protocol): 로드 밸런서 사용 시 서버에서 클라이언트로 되돌아가는 경우 목적지 주소를 스위치의 IP 주소가 아닌 클라이언트의 IP 주소로 전달해서 네트워크 스위치를 거치지 않고 바로 클라이언트를 찾아가는 개념이다.</li><li>Tunneling: 인터넷상에서 눈에 보이지 않는 통로를 만들어 통신할 수 있게 하는 개념으로, 데이터를 캡슐화해서 연결된 상호 간에만 캡슐화된 패킷을 구별해 캡슐화를 해제할 수 있다.</li></ul><p>로드 밸런서는, 네트워크에서 IP 주소와 MAC주소를 바탕으로 목적지 IP주소를 찾아가고, 다시 출발지를 되돌아 오는 구조로 작동된다.</p><p><a href="https://d2.naver.com/helloworld/284659" target="_blank" rel="noopener">출처: naver d2</a></p><h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p><img src="https://i0.wp.com/foxutech.com/wp-content/uploads/2019/01/What-is-HAProxy-and-how-to-install-and-configure-in-Linux.png?fit=2000%2C1000&amp;ssl=1" alt="ha-proxy"></p><p>HAProxy는 reserve proxy형태로 작동한다. 흔히 브라우저에서 사용하는 proxy는 클라이언트 앞에서 처리하는데, 이를 forward proxy라고 한다. 반대로 reserve proxy는 실제 서버 요청에 대해 서버 앞단에 존재하면서, 서버로 들어오는 요청을 대신 받아 서버에 전달하고, 요청한 곳에 그 결과를 다시 전달한다.</p><h3 id="작동-흐름"><a href="#작동-흐름" class="headerlink" title="작동 흐름"></a>작동 흐름</h3><ol><li>최초 접근 시 서버에 요청 전달</li><li>응답 시 쿠키(cookie)에 서버 정보 추가 후 반환</li><li>재요청 시 proxy에서 쿠키 정보 확인 &gt; 최초 요청 서버로 전달</li><li>다시 접근 시 쿠키 추가 없이 전달 &gt; 클라이언트에 쿠키 정보가 계속 존재함(쿠키 재사용)</li></ol><p><img src="https://d2.naver.com/content/images/2015/06/helloworld-284659-1.png" alt="haproxy-flow"></p>]]></content>
    
    <summary type="html">
    
      로드밸런서
로드 밸런싱이란, 부하 분산을 위해서 가상 IP를 통해 여러 서버에 접속하도록 분배하는 기능을 말한다.

로드 밸런싱에서 사용하는 주요 기술은

 * NAT(Network Address Translation): 사설 IP 주소를 공인 IP 주소로 바꾸는 데 사용하는 통신망의 주소 변조기이다.
 * DSR(Dynamic Source Routing protocol): 로드 밸런서 사용 시 서버에서 클라이언트로 되돌아가는 경우 목적지 주소를 스위치의 IP 주소가 아닌 클라이언트의 IP 주소로 전달해서 네트워크 스위치를 거치지 
    
    </summary>
    
    
      <category term="infrastructure" scheme="https://www.yceffort.kr/tags/infrastructure/"/>
    
      <category term="proxy" scheme="https://www.yceffort.kr/tags/proxy/"/>
    
  </entry>
  
</feed>
