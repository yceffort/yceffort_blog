
<!DOCTYPE html>
<html lang="en">
    

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="yceffort">
    <meta name="google-site-verification" content="TRGuZGQqLhBScdz5opOQ5vD2jLwfHmWrWdze_xY0EbQ" />

    <title>리액트 인터뷰 질문 &amp; 답 (1) - yceffort</title>
    <meta name="author" content="yceffort">
    
    <meta name="keywords" content="programming,innovation,technology,">
    
    <link rel="apple-touch-icon" sizes="57x57" href="/images/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/images/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon-16x16.png">
    <link rel="manifest" href="/images/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/images/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    
    <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"yceffort","sameAs":["https://github.com/yceffort","mailto: root@yceffort.kr"],"image":"https://www.gravatar.com/avatar/f24f66c6311c477d8ac26a9ef346560c"},"articleBody":"목차\n\n\n\nNo.\nQuestions\n\n\n\n\n\nCore React\n\n\n1\n리액트란 무엇인가?\n\n\n2\n리액트의 주요 기능은 무엇인가?\n\n\n3\nJSX란 무엇인가?\n\n\n4\nelement와 component의 차이점은 무엇인가?\n\n\n5\n리액트에서 컴포넌트를 어떻게 만드는가?\n\n\n6\n클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가?\n\n\n7\n순수한 컴포넌트는 무엇인가?\n\n\n8\nstate는 무엇인가?\n\n\n9\nprops는 무엇인가?\n\n\n10\nstate와 props의 차이는 무엇인가?\n\n\n11\n왜 state를 바로 업데이트 하면 안되는가?\n\n\n12\nsetState() 콜백의 용도는 무엇인가?\n\n\n13\nHTML과 React의 이벤트 핸들링 차이는 무엇인가?\n\n\n14\nJSX 콜백에 메소드나 이벤트 핸들러를 바인딩하는 방법은 무엇인가?\n\n\n15\n이벤트 핸들러나 콜백에 파라미터를 전달하는 방법은?\n\n\n16\n리액트의 synthetic event는 무엇인가?\n\n\n17\n인라인 조건식은 무엇인가?\n\n\n18\nkey props는 무엇이며, 배열의 요소에서 사용함으로써 얻을 수 있는 이점은 무엇인가?\n\n\n19\nref의 목적은 무엇인가?\n\n\n20\nref는 어떻게 생성하는가?\n\n\n21\nforward refs란 무엇이인가?\n\n\n22\ncallback ref와 findDOMNode중 어떤것이 더 선호되는가?\n\n\n23\nstring ref가 왜 legacy가 되었는가?\n\n\n24\nVirtual DOM 은 무엇인가?\n\n\n25\nVirtual DOM은 어떻게 작동하는가?\n\n\n26\nShadow DOM과 Virtual DOM의 차이는 무엇인가?\n\n\n27\nWhat is React Fiber?\n\n\n28\nReact Fiber의 목적은 무엇인가?\n\n\n29\ncontrolled components는 무엇인가?\n\n\n30\nuncontrolled components는 무엇인가?\n\n\n31\ncreateElement와 cloneElement의 차이는 무엇인가?\n\n\n32\nReact에서 lifting state up은 무엇인가?\n\n\n33\nComponent Lifecycle의 각 phase에는 어떤 차이가 있는가?\n\n\n34\nComponent Lifecycle에는 어떤 method가 있는가?\n\n\n35\nHigher-Order 컴포넌트는 무엇인가?\n\n\n36\nHOC 컴포넌트에서 props proxy를 어떻게 만드는가?\n\n\n37\nContext란 무엇인가?\n\n\n38\n자식 prop는 무엇인가?\n\n\n39\nReact에서 주석을 어떻게 쓰는가?\n\n\n40\nprops 변수가 있는 super 생성자의 목적은 무엇인가?\n\n\n41\nreconciliation은 무엇인가??\n\n\n42\n동적 key name으로 setState하는 방법은?\n\n\n43\n렌더가 될 때 마다 호출되는 function의 일반적인 실수는 무엇인가?\n\n\n44\nlazy함수가 named exports를 지원하는가?\n\n\n45\n리액트가 class 속성에 class 대신 className을 쓰는가?\n\n\n46\nfragments란 무엇인가?\n\n\n47\nfragment가 div 컨테이너보다 좋은 이유는?\n\n\n48\nreact에서 portals란 무엇인가?\n\n\n49\nstateless 컴포넌트란?\n\n\n50\nstateful 컴포넌트란?\n\n\n51\nReact props에서 유효성 검사를 하는 방법은?\n\n\n52\nReact의 장점은?\n\n\n53\nReact의 한계는?\n\n\n54\nReact v16에서 error boundaries는?\n\n\n55\nReact v15에서 error boundaries는?\n\n\n56\n정적 타입 체킹을 하는 최선의 방법은?\n\n\n57\nreact-dom package의 쓰임새는?\n\n\n58\nreact-dom의 render 메서드의 목적?\n\n\n59\nReactDOMServer란?\n\n\n60\nReact에서 InnerHtml를 쓰는 방법은?\n\n\n61\nReact에서 스타일을 쓰는 방법은?\n\n\n62\nReact에서 이벤트는 어떻게 다른가?\n\n\n63\nconstructor에서 setState를 쓴다면?\n\n\n64\nindex를 키로 쓸 경우 어떤 일이 벌어지는가?\n\n\n65\ncomponentWillMount() method안에서 setState()를 쓰는 것이 바람직한가?\n\n\n66\ninitial state에서 props를 쓰면 어떻게 되는가?\n\n\n67\n어떻게 조건부로 컴포넌트를 렌더링하는가?\n\n\n68\nDOM 엘리먼트에서 스프레드 props를 쓸 때 주의해야 할 점은?\n\n\n69\nReact에서 decorator를 쓰는 방법은?\n\n\n70\n컴포넌트를 메모이제이션 하는 법은?\n\n\n71\n서버사이드렌더링을 하는 방법은?\n\n\n72\nReact에서 프로덕션 모드를 키는 방법은?\n\n\n73\nCRA는 무엇이고 이점은 무엇인가?\n\n\n74\n마운팅시 라이프사이클 메서드의 순서는?\n\n\n75\nReact v16에서 deprecated된 라이프 사이클 메서드는?\n\n\n76\ngetDerivedStateFromProps() 의 목적은?\n\n\n77\ngetSnapshotBeforeUpdate()의 목적은?\n\n\n78\nHooks api가 render props와 HOC를 대체하는가?\n\n\n79\n네이밍 컴포넌트를 위한 최상의 방법은?\n\n\n80\n컴포넌트 클래스에서 메소더의 순서를 정하는 방법은?\n\n\n81\n스위칭 컴포넌트란 무엇인가?\n\n\n82\n왜 setState에 함수를 넘겨야 하는가?\n\n\n83\nReact에서 strict mode란 무엇인가?\n\n\n84\nReact 믹스인이란?\n\n\n85\n왜 isMounted()가 안티패턴이고, 이를 위한 올바른 해결책이 무엇인가?\n\n\n86\nReact에서 지원하는 포인터 이벤트는 무엇인가?\n\n\n87\n왜 컴포넌트 명은 대문자로 시작해야 하는가?\n\n\n88\nReact v16에서 커스텀 DOM 속성을 지원하는가?\n\n\n89\nconstructor와 getInitialState의 차이점은?\n\n\n90\nsetState를 호출하지 않고 강제로 컴포넌트를 리렌더링하는 방법은?\n\n\n91\nReact에서 es6클래스를 쓸 때 super()와 super(props)의 차이점은?\n\n\n92\nJSX에서 반복문을 도는 방법은?\n\n\n93\nHTML속성에서 props에 접근하는 방법은?\n\n\n94\nReact의 Prop array에 특정형식의 array를 넘기는 방법은?\n\n\n95\n조건부로 클래스 속성을 추가하는 방법은?\n\n\n96\nReact과 ReactDOM의 차이는?\n\n\n97\n왜 React-DOM은 React에서 분리되었는가?\n\n\n98\nReact 라벨 엘리먼트를 사용하는 방법은?\n\n\n99\n여러개의 인라인 스타일을 한꺼번에 쓰는 방법은?\n\n\n100\n브라우저 리사이즈 시 뷰를 리렌더링하는 방법은?\n\n\n101\nsetState와 replaceState의 차이점은?\n\n\n102\nstate의 변경을 listen하는 방법은?\n\n\n103\nReact state에서 배열의 특정 엘리먼트를 지우는 올바른 방법은?\n\n\n104\nHTML 렌더링 없이 React를 사용하는 방법은?\n\n\n105\nReact에서 json을 pretty하게 프린트 하는 방법은?\n\n\n106\n왜 React에서 props를 업데이트 하지 못하는가?\n\n\n107\n페이지 로딩 중에 input 엘리먼트에 포커스를 주는 방법은?\n\n\n108\nstate에 있는 객체를 업데이트하는 방법은?\n\n\n109\n왜 setState()에 object보다 function이 더 나은가?\n\n\n110\n브라우저에서 React 런타임의 버전을 알아내는 방법은?\n\n\n111\nCTA에서 폴리필을 추가하는 일반적인 방법은?\n\n\n112\nCTA에서 http대신 https를 쓰는 법은?\n\n\n113\nCTA에서 상대경로 import를 피하는 방법은?\n\n\n114\nReact 라우터에 구글 애널리틱스를 붙이는 방법은?\n\n\n115\n매 초마다 컴포넌트를 업데이트 하는 방법은?\n\n\n116\nReact에서 인라인 스타일로 vendor prefixes를 붙이는 방법은?\n\n\n117\nReact와 ES6를 활용해서 컴포넌트를 import &amp; export 하는 방법은?\n\n\n118\nReact 컴포넌트 명에서 주의해야 할 점은?\n\n\n119\n왜 컴포넌트 생성자는 단 한번만 호출되는가?\n\n\n120\nReact에서 상수를 선언하는 방법은?\n\n\n121\nReact에서는 어떻게 클릭이벤트가 트리거 되는가?\n\n\n122\nReact에서 async await을 쓰는 것이 가능한가?\n\n\n123\nReact의 일반적인 디렉토리 구조는?\n\n\n124\n유명한 애니메이션을 위한 패키지는?\n\n\n125\nstyle 모듈의 이점은 무엇인가?\n\n\n126\nReact에 특화된 linter엔 무엇이 있는가?\n\n\n127\nAjax call은 어떻게 만들고, 어느 라이프사이클 메소드에서 실행해야 하는가?\n\n\n128\nrender props란 무엇인가?\n\n\n\n\n¶Core React\n¶What is React\n리액트는 오픈소스 프론트엔드 자바스크립트 라이브러리로, 특히 싱글 페이지 어플리케이션의 사용자 인터페이스 구축을 위해 사용된다. 웹가 모바일 앱의 뷰단을 다르기 위하여 사용되고 있다. 리액트는 페이스북에서 일아흔 Jordan Walke가 만들었다. 최초로 리액트 기반으로 만들어진 서비스는 2011년에 페이스북 뉴스 피드이며, 2012년에는 인스타그램도 리액트로 만들어 졌다.\n👆\n¶What are the major features of React?\n리액트의 주요 기능은 무엇인가?\n\nRealDOM을 조작하는데 많은 비용이 소모되어 대신 VirtualDOM을 활용하고 있다.\n서버사이드렌더링을 지원한다\n단방향 데이터흐름 또는 단방향 데이터 바인딩을 따른다\n뷰를 개발하는데 있어 재사용 가능한 컴포넌트 사용\n\n👆\n¶What is JSX?\nJSX는 ECMA Script의 XML 신택스 확장 표기법이다. (Javascript XML의 약자다.) 기본적으로, React.createElement()함수에 문법 슈가를 제공하며,HTML 스타일의 템플릿 구문화함께 javascript를 표현할 수 있다.\n아래 예제에서, return안에 있는 &lt;h1&gt; 구문이 자바스크립트 함수의 render function 으로 제공된다.\n123456789class App extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;&#123;\"Welcome to React world!\"&#125;&lt;/h1&gt;      &lt;/div&gt;    );  &#125;&#125;\n👆\n¶What is the difference between Element and Component?\nelement는 DOM노드나 컴포넌트 단에서 화면에 보여주고 싶은 요소를 그리는 하나의 오브젝트를 의미한다. element는 element의 props에서 포함될 수 있다. 리액트에서 element를 만드는건 많은 비용이 들지 않는다. 한번 만들고 나면, 더이상 변경이 불가능하다.\n리액트에서 element를 만드는 예시는 아래와 같다.\n1const element = React.createElement(\"div\", &#123; id: \"login-btn\" &#125;, \"Login\");\n위 함수는 아래와 같은 object를 리턴한다\n1234567&#123;  type: 'div',  props: &#123;    children: 'Login',    id: 'login-btn'  &#125;&#125;\n그리고 ReactDOM.render()이 아래와 같은 DOM을 만들어 줄 것이다.\n1&lt;div id=\"login-btn\"&gt;Login&lt;/div&gt;\n반면에 컴포넌트는 다양한 방식으로 선언가능하다. 컴포넌트는 render()와 함께 쓴다면 클래스가 될 수도 있다. 좀더 단순한 방법으로, 함수로도 선언이 될 수 있다. 두 방식 모두 props를 input으로 받으며, JSX를 리턴한다.\n12345const Button = (&#123; onLogin &#125;) =&gt; (  &lt;div id=&#123;\"login-btn\"&#125; onClick=&#123;onLogin&#125;&gt;    Login  &lt;/div&gt;);\nJSX는 이를 React.createElement() 함수로 트랜스파일 시킬 것이다.\n12const Button = (&#123; onLogin &#125;) =&gt; React.createElement( 'div', &#123; id: 'login-btn',onClick: onLogin &#125;, 'Login' )\n👆\n¶How to create components in React?\n두 가지 방법이 존재한다.\n\n함수형 컴포넌트: 컴포넌트를 만드는 가장 심플한 방식이다. props를 첫번째 파라미터로 받는 받는 순수 자바스크립트 함수를 만들고, React Element를 반환하면 된다.\n\n123function Greeting(&#123; message &#125;) &#123;  return &lt;h1&gt;&#123;`Hello, $&#123;message&#125;`&#125;&lt;/h1&gt;;&#125;\n\n클래스 컴포넌트: ES6의 클래스를 활용하여 컴포넌트를 정의할 수도 있다. 위 컴포넌트를 클래스 컴포넌트로 바꾼다면 이렇게 될 것이다.\n\n12345class Greeting extends React.Component &#123;  render() &#123;    return &lt;h1&gt;&#123;`Hello, $&#123;this.props.message&#125;`&#125;&lt;/h1&gt;;  &#125;&#125;\n👆\n¶When to use a Class Component over a Function Component?\n컴포넌트가 state나 라이프 사이클 메소드를 필요로 할 때 클래스 컴포넌트를, 그렇지 않으면 함수형 컴포넌트를 활용하면 된다.\n\n근데 요즘은 useState을 사용하면 함수형 컴포넌트에서도 state사용이 가능하다\n\n👆\n¶What are Pure Components?\nReact.PureComponent는 React.Component에서 shouldComponentUpdate가 없다는 것만 제외하면 동일하다. props나 state에 변화가 있을 경우, PureComponent는 두 변수에 대해서 얕은 비교를 한다. 반면 Component는 그런 비교를 하지 않는다. 따라서 Component는 shouldComponentUpdate가 호출 될 때마다 다시 render한다.\n👆\n¶What is state in React?\nstate란 컴포넌트가 살아있는 동안에 걸쳐 변화할 수도 있는 값을 가지고 있는 object다. 따라서 state를 가능한 간단하게, 그리고 state의 구성요소를 최소화하는 노력을 기울여야 한다. 다음은 User Component에 message state를 관리하는 예제다.\n1234567891011121314151617class User extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      message: \"Welcome to React world\"    &#125;;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;h1&gt;&#123;this.state.message&#125;&lt;/h1&gt;      &lt;/div&gt;    );  &#125;&#125;\nstate는 props와 비슷하지만, 컴포넌트가 완전히 소유권을 쥐고 있다는 것이 다르다.다른 어떤 컴포넌트도 한 컴포넌트가 소유하고 있는 state에 접근할 수 없다.\n👆\n¶What are props in React?\nprops는 컴포넌트의 input 값이다. HTML 태그 속성과 유사한 규칙을 사용하여 ReactComponent에 전달할 수 있는 단일 값 또는 객체 다. 이런 데이터 들은 부모 컴포넌트에서 자식 컴포넌트로 보낼 수 있다.\n리액트에서 props를 쓰는 주요 목적은 컴포넌트에 아래와 같은 기능을 제공하기 위해서다.\n\n컴포넌트에 custom data를 넘기기 위해\nstate의 변화를 trigger 하기 위해\nComponent의 render메소드 안에서 this.props.*** 로 사용하기 위함\n\n예를 들어, reactProp 을 만들어서 쓴다고 가정해 보자.\n1&lt;Element reactProp=&#123;\"1\"&#125; /&gt;\nreactProp은 (뭐라고 정의했던 지 간에) React를 사용하여 생성된 component에서 접근이 가능하고, React native props에서 접근하여 사용할 수 있다.\n1props.reactProp;\n👆\n¶What is the difference between state and props?\nprops와 state는 모두 순수 자바스크립트 오브젝트다. 두 객체 모두 render의 output에 영향을 줄 수 있는 정보를 가지고 있지만, 컴포넌트의 기능적인 측면에서는 약간 다르다. props는 함수의 파라미터와 비슷한 방식으로 작동하는 반면, state는 컴포넌트 내에서 선언된 변수와 비슷하다.\n👆\n¶Why should we not update the state directly?\nstate를 아래와 같이 바로 업데이트 하면 렌더링이 일어나지 않는다.\n1this.state.message = \"Hello world\";\n대신에 setState() 메서드를 사용하자.이는 state의 변경이 있을 때 component를 업데이트 해준다. state에 변화가 있을 경우, 컴포넌트는 리렌더링으로 응답한다.\n12//Correctthis.setState(&#123; message: \"Hello World\" &#125;);\n주의: state를 직접 할당할 수 있는 곳은 constructor 혹은 자바스크립트 클래스의 필드를 선언하는 syntax 뿐이다.\n👆\n¶What is the purpose of callback function as an argument of setState()?\n콜백함수는 setState가 끝나고 컴포넌트가 렌더링 된 이후에 실행된다.setState는 비동기로 이루어지기 때문에 callback에서는 어떤 액션이든 취할 수 있다.\n주의: 콜백함수를 사용하는 것보다 라이프사이클 메서드를 사용하는게 더 좋다.\n123setState(&#123; name: \"John\" &#125;, () =&gt;  console.log(\"The name has updated and component re-rendered\"));\n¶What is the difference between HTML and React event handling?\n\nHTML에서는 이벤트명은 소문자로 작성되어야 한다.\n\n1&lt;button onclick=\"activateLasers()\"&gt;&lt;/button&gt;\nReact는 camelCase를 사용한다.\n1&lt;button onClick=\"&#123;activateLasers&#125;\"&gt;&lt;/button&gt;\n\nHTML에서는, false를 리턴하면 이후 기본 액션을 막을 수 있다.\n\n1&lt;a href=\"#\" onclick='console.log(\"The link was clicked.\"); return false;' /&gt;\n하지만 react에서는 preventDefault()를 명시적으로 사용해야 한다.\n1234function handleClick(event) &#123;  event.preventDefault();  console.log(\"The link was clicked.\");&#125;\n¶How to bind methods or event handlers in JSX callbacks?\n\n생성자에서 바인딩하기: 자바스크립트 클래스에서는, 메소드들이 기본적으로 바인딩 되어 있지 않다. 이는 클래스 메서드로 정의된 리액트 이벤트 핸들러와 마찬가지다. 보통, 생성자에서 바인딩한다.\n\n12345678910class Component extends React.Componenet &#123;  constructor(props) &#123;    super(props);    this.handleClick = this.handleClick.bind(this);  &#125;  handleClick() &#123;    // ...  &#125;&#125;\n\n퍼블리기 클래스 필드 구문: 생성자에서 바인딩 되기를 원치 않는다면, 퍼블릭 클래스의 필드 구문을 이용하여 callback을 올바르게 바인딩 할 수 있다.\n\n12345handleClick = () =&gt; &#123;  console.log(\"this is:\", this);&#125;;&lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt;;\n\n클래스 필드(class field)\n클래스 내부의 캡슐화된 변수를 말한다. 데이터 멤버 또는 멤버 변수라고도 부른다. 클래스 필드는 인스턴스의 프로퍼티 또는 정적 프로퍼티가 될 수 있다. 쉽게 말해, 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티를 클래스 기반 객체지향 언어에서는 클래스 필드라고 부른다.\n\n12345class Foo &#123;  name = \"\"; // SyntaxError  constructor() &#123;&#125;&#125;\n\nconstructor 내부에서 선언한 클래스 필드는 클래스가 생성할 인스턴스를 가리키는 this에 바인딩한다. 이로써 클래스 필드는 클래스가 생성할 인스턴스의 프로퍼티가 되며, 클래스의 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. 즉, 언제나 public이다.\nES6의 클래스는 다른 객체지향 언어처럼 private, public, protected 키워드와 같은 접근 제한자(access modifier)를 지원하지 않는다.\n\n\n화살표함수: 콜백에 화살표 함수를 사용할 수도 있다.\n\n1&lt;button onClick=&#123;event =&gt; this.handleClick(event)&#125;&gt;&#123;\"Click me\"&#125;&lt;/button&gt;\n주의: 콜백이 하위 컴포넌트에 prop으로 전달된다면, component가 리렌더링 될 수도 있다. 이러한 경우에는, 성능을 고려해서 1, 2번의 예제를 활용하는 것이 낫다.\n👆\n¶How to pass a parameter to an event handler or callback?\n이벤트 핸들러와 파라미터 전달을ㅇ 화살표 함수로 감쌀 수 있다.\n1&lt;button onClick=&#123;() =&gt; this.handleClick(id)&#125; /&gt;\n이는 .bind와 같다.\n1&lt;button onClick=\"&#123;this.handleClick.bind(this,\" id)&#125; /&gt;\n두 방식 이외에도, 아래와 같은 배열 함수 방식으로 정의해서 전달할 수도 있다.\n1234&lt;button onClick=&#123;this.handleClick(id)&#125; /&gt;;handleClick = id =&gt; () =&gt; &#123;  console.log(\"Hello, your ticket number is\", id);&#125;;\n👆\n¶What are synthetic events in React?\nsynthetic event (합성함수) 는 브라우저의 네이티브 이벤트를 위한 크로스 브라우저 래퍼다. 이 api는 브라우저의 네이티브 이벤트와 동일하며, 마찬가지로 stopPropagation() preventDefault()도 포함하고 있지만, 모든 브라우저에서 동일하게 작동한다는 점이 다르다.\n👆\n¶What is inline conditional expressions?\n조건부 렌더 표현을 위해 javascript의 if문이나 삼항연산자를 사용할 수 있다. 이외에도 중괄호로 묶어서 javascript의 논리식인 &amp;&amp;을 붙여서 jsx에서도 사용할 수 있다.\n123456&lt;h1&gt;Hello!&lt;/h1&gt;; &#123; messages.length &gt; 0 &amp;&amp; !isLogin ? (&lt;h2&gt;You have &#123;messages.length&#125; unread messages.&lt;/h2&gt;) : (&lt;h2&gt;You don't have unread messages.&lt;/h2&gt;); &#125;\n👆\n¶What are “key” props and what is the benefit of using them in arrays of elements?\nkey는 특별한 string 속성으로, 배열을 사용할 때 이용해야 한다. key는 리액트에서 어떤 item이 변화하고, 추가되고, 삭제되었는지 구별하는데 도움을 준다. 대부분 key로 id를 사용한다.\n123const todoItems = todos.map(todo =&gt;&lt;li key=\"&#123;todo.id&#125;\"&gt;&#123;todo.text&#125;&lt;/li&gt;);\n만약 이런 ID가 없다면, index를 사용할 수 있다.\n12345const todoItems = todos.map((todo, index) =&gt;&lt;li key=\"&#123;index&#125;\"&gt;  &#123;todo.text&#125;&lt;/li&gt;)\n주의\n\nindex를 key로 사용하는 방식은, 아이템의 순서가 바뀌는 경우가 발생할 수 있는 케이스에는 별로 추천할만하지 못하다. 이는 퍼포먼스에 악영향을 미치고, component state에 악영향을 미칠 수 있다.\nlist를 별도 컴포넌트로 뽑아서 사용하는 경우, key를 리스트 컴포넌트가 아닌 li 태그에 사용해야 한다.\n리스트 아이템에 key가 없으면 콘솔에 경고 메시지가 뜬다.\n\n¶What is the use of refs?\nref는 element의 참조값을 반환한다. 대부분 이러한 경우는 피해야 하지만, DOM이나 component에 다이렉트로 접근해야할 때 유용하다.\n👆\n¶How to create refs?\n\n최근에 추가된 방식으로, React.createRef() 메소들를 사용하면, React element는 ref를 통해서 접근할 수 있다. ref를 컴포넌트에서 접근하기 위해서는, 생성자 안에 ref를 instance property로 할당하면 된다.\n\n123456789class MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    this.myRef = React.createRef();  &#125;  render() &#123;    return &lt;div ref=&#123;this.myRef&#125; /&gt;;  &#125;&#125;\n\nReact 버전과 상관없이 ref 콜백을 활용하는 방식이 있다. 예를 들어, SearchBar 컴포넌트의 인풋 요소들은 아래와 같은 방식으로 접근 가능하다.\n\n12345678910111213141516171819202122class SearchBar extends Component &#123;  constructor(props) &#123;    super(props);    this.txtSearch = null;    this.state = &#123; term: \"\" &#125;;    this.setInputSearchRef = e =&gt; &#123;      this.txtSearch = e;    &#125;;  &#125;  onInputChange(event) &#123;    this.setState(&#123; term: this.txtSearch.value &#125;);  &#125;  render() &#123;    return (      &lt;input        value=&#123;this.state.term&#125;        onChange=&#123;this.onInputChange.bind(this)&#125;        ref=&#123;this.setInputSearchRef&#125;      /&gt;    );  &#125;&#125;\n또한 컴포넌트의 함수 내에서 클로져를 ref를 사용할 수도 있다.\n주의: 추천할만한 방법은 아니지만, 인라인 ref callback을 이용하는 방식도 있다.\n👆\n¶What are forward refs?\nRef forwarding은 일부 컴포넌트에서 ref를 받아서 자식 컴포넌트에게 전달하는 것을 의미한다.\n123456789const ButtonElement = React.forwardRef((props, ref) =&gt; (  &lt;button ref=&#123;ref&#125; className=\"CustomButton\"&gt;    &#123;props.children&#125;  &lt;/button&gt;));// Create ref to the DOM button:const ref = React.createRef();&lt;ButtonElement ref=&#123;ref&#125;&gt;&#123;\"Forward Ref\"&#125;&lt;/ButtonElement&gt;;\n👆\n¶Which is preferred option with in callback refs and findDOMNode()?\ncallback ref를 쓰는 것이 더 선호된다. 왜냐하면 findDOMNode()는 향후에 있을 리액트의 개선사항이 반영되지 않기 때문이다.\n레거시에서 findDOMNode를 사용하는 방법이 있다.\n123456789class MyComponent extends Component &#123;  componentDidMount() &#123;    findDOMNode(this).scrollIntoView();  &#125;  render() &#123;    return &lt;div /&gt;;  &#125;&#125;\n그래서 선호하는 방법은 다음과 같다.\n12345678910111213class MyComponent extends Component &#123;  constructor(props) &#123;    super(props);    this.node = createRef();  &#125;  componentDidMount() &#123;    this.node.current.scrollIntoView();  &#125;  render() &#123;    return &lt;div ref=&#123;this.node&#125; /&gt;;  &#125;&#125;\n👆\n¶Why are String Refs legacy?\n예전에 React를 다뤄보았다면, 옛날 방식인 ref를 string으로 쓰는, ref={'textInput'} 와 같이 ref속성이 string이고, DOM Node인 refs.textInput로 접근하는 방법에 익숙할 것이다. 그러나 이러한 string ref는 하단에서 언급할 문제들 때문에, 레거시로 보는 것이 맞다. 그리고 string ref는 React v16에서 제거 되었다.\n\nString ref는 실행중인 component 요소를 추적하도록 강제한다. 그리고 React Module을 stateful하게 만들기 때문에, 이는 번들시 react module이 중복 되는 경우 이상한 오류를 발생시킨다.\n라이브러리를 추가하여 String ref를 child component에 전달한다면, 사용자는 다른 ref를 추가할 수 없다. 그러나 callback ref를 사용하면 이런 문제를 해결할 수 있다.\nFlow와 같은 정적 분석에서는 동작하지 않는다. Flow는 string ref를 this.refs와 같은 형태로 표시하도록 만드는 트릭을 추적할 수 없다. callback ref는 string ref보다 flow에 더 잘맞다.\n대부분이 render callback 패턴으로 동작하기를 기대하지만, 그렇게 동작하지 않는다.\n\n12345678910111213class MyComponent extends Component &#123;  renderRow = index =&gt; &#123;    // 동작하지 않는다. ref는 MyComponent가 아닌 DataTable에 연결될 것이다.    return &lt;input ref=&#123;\"input-\" + index&#125; /&gt;;    // 이거는 동작한다. callback ref가 짱이다.    return &lt;input ref=&#123;input =&gt; (this[\"input-\" + index] = input)&#125; /&gt;;  &#125;;  render() &#123;    return &lt;DataTable data=&#123;this.props.data&#125; renderRow=&#123;this.renderRow&#125; /&gt;;  &#125;&#125;\n👆\n¶What is Virtual DOM?\nVirtual DOM은 메모리 내에서 표현되는 Real DOM 이다. UI는 메모리 상에서 표현되며, 그리고 real DOM과 동기화 된다. 이는 렌더 함수 호출과 화면에 elements 표시 하는 사이에 일어난다. 이 모든 과정을 reconciliation이라고 한다.\n👆\n¶How Virtual DOM works?\n\n\n어디서든 데이터가 편하면, Virtual DOM내에서 전체 UI가 다시 렌덜이 된다.\n\n\n\n그런 다음 이전 DOM과 새로운 DOM을 비교한다.\n\n\n\n계산이 끝나면, Real DOM 중에서 실제로 업데이트가 있었던 부분 만 변경을 가한다.\n\n\n\n👆\n¶What is the difference between Shadow DOM and Virtual DOM?\nShadow DOM은 web component의 scope및 CSS scope 지정을 위해 설계된 web browser 기술이다. Virtual DOM은 브라우저 API 위에 자바스크립트에서 구현되는 개념이다.\n👆\n¶What is React Fiber?\nFiber는 React v16에서 새로운 reconciliation 엔진, 그리고 코어 알고리즘을 새로 작성한 것으로 볼 수 있다. React Fiber의 목적은 애니메이션, 레이아웃, 제스쳐, 작업일시정지 및 중단, 여려 유형의 업데이트 우선순위 조절, 동시성 등 여러가지 기본 사항에 대한 성능을 높이는 것이다.\n👆\n¶What is the main goal of React Fiber?\nReact Fiber 의 목표는 애니메이션, 레이아웃, 제스처등의 성능을 높이는 것이다. 렌더링 작업을 chunk별로 작업하고, 여러 프레임 별로 이를 펼치면서 작업하는 점진적 렌더링을 통해 이를 구현했다.\n👆\n¶What are controlled components?\n입력요소를 제어하는 component를 controlled components라고 부른다. 모든 상태변경에 연관뢴 handler function이 존재한다.\n예를 들어, 모든 이름을 대문자로 쓰기 위해서는, handleChange를 아래와 같이 쓰게 된다.\n123handleChange(event) &#123;  this.setState(&#123;value: event.target.value.toUpperCase()&#125;)&#125;\n👆\n¶What are uncontrolled components?\nuncontrolled components란 내부적으로 자기 자신의 state를 가지고 있는 component다. 현재 필요한 값을 찾기 위해 ref를 사용하여 DOM query를 할 수 있다. 이는 전통적인 HTML 과 비슷하다.\nUserProfile Component를 아래에서 보자면, name input이 ref를 통해서 접근할 수 있다.\n123456789101112131415161718192021222324class UserProfile extends React.Component &#123;  constructor(props) &#123;    super(props);    this.handleSubmit = this.handleSubmit.bind(this);    this.input = React.createRef();  &#125;  handleSubmit(event) &#123;    alert(\"A name was submitted: \" + this.input.current.value);    event.preventDefault();  &#125;  render() &#123;    return (      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        &lt;label&gt;          &#123;\"Name:\"&#125;          &lt;input type=\"text\" ref=&#123;this.input&#125; /&gt;        &lt;/label&gt;        &lt;input type=\"submit\" value=\"Submit\" /&gt;      &lt;/form&gt;    );  &#125;&#125;\n대부분의 경우, 폼에서는 controlled component를 사용하기를 추천한다.\n👆\n¶What is the difference between createElement and cloneElement?\nJSX는 React.createElement() 함수로 UI에 나타낼 React element를 생성한다. 반면 cloneElement는 element를 props로 보낼 때 사용한다.\n👆\n¶What is Lifting State Up in React?\n여러 component 들이 동일한 변경 데이터를 공유해야하는 경우 가까운 부모 component 로 state를 올리는 것이 좋다. 즉, 두개의 자식 component가 부모에 있는 동일한 데이터를 공유할 때. 두개의 자식 component 들은 local state를 유지하는 대신, 부모로 state를 올려야 한다.\n👆\n¶What are the different phases of component lifecycle?\nReact lifecycle에는 세 개의 phase가 있다.\n\nmounting: 컴포넌트가 browser DOM에 마운트 될 준비가 된 상태다. 이 phase에는 constructor() getDerivedStateFromProps() render() componentDidMount()가 있다\nupdating: 이 단계에서는, 컴포넌트가 두가지 방법으로 업데이트 된다. 새로운 props를 보내거나, setState() forceUpdate()를 통해서 state를 업데이트 하는 방법이 있다. 이 단계에서는, getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 가 포함된다.\nunmounting: 이단계에서는, browser DOM이 더 이 더이상 필요 없어지거나 unmount된다. 여기에는 componentWillUnmount()가 포함된다.\n\nDOM에서의 변경을 적용할 때, 내부에서 어떤 과정을 거치는지 알아볼 필요가 있다. 각 단계는 아래와 같다.\n\n\nRender 컴포넌트가 어떠한 사이드 이펙트 없이 렌더링 된다. 이는 Pure Component에 적용되며, 이 단계에서는 일시정지, 중단, 렌더 재시작등이 가능하다.\n\n\nPre-commit: 컴포넌트가 실제 변화를 DOM에 반영하기 전에, 리액트가 DOM을 getSnapshotBeforeUpdate() 통해서 DOM 을 읽을 수도 있다.\n\n\nCommit: React는 DOM과 함꼐 작동하며, 각각의 라이프 사이클 마지막에 실행되는 것들이 포함된다. componentDidMount() componentDidUpdate() componentWillUnmount()\n16.3 이후\n\n\n\n16.3 이전\n\n👆\n¶What are the lifecycle methods of React?\nReact 16.3+\n\ngetDerivedStateFromProps: 모든 render()가 실행되기 바로 직전에 호출된다. props의 변화의 결과로 내부 state 변화를 가능하게 해주는 메서드로, 굉장히 드물게 사용된다.\ncomponentDidMount: 첫렌더링이 다 끝나고, 모든 ajax 요청이 완료, DOM이나 state 변화, 그리고 이벤트 리스너가 모두 설정된 다음에 호출된다.\nshouldComponentUpdate: 컴포넌트가 업데이트 될지 말지를 결정한다. default로 true를 리턴한다. 만약 state나 props 업데이트 이후에 컴포넌트가 업데이트 될 필요가 없다고 생각한다면, false를 리턴하면 된다. 컴포넌트가 새로운 props를 받은 후에, 리 렌더링을 방지해서 성능을 향상시키기에 가장 좋은 위치다.\ngetSnapshotBeforeUpdate: 렌더 결과물이 DOM에 커밋되기 직전에 호출된다. 여기서 리턴된 모든 값은 componentDidUpdate()로 넘겨진다. 스크롤 포지션 등, DOM에서 필요한 정보를 사용할 때 유용하다.\ncomponentDidUpdate: prop/state의 변화d의 응답으로 DOM을 업데이트 할 때 필요하다. 이 메소드는 만약 shouldComponentUpdate()가 false를 리턴하면 호출되지 않는다.\ncomponentWillUnmount: 네트워크 요청을 취소하거나, 컴포넌트와 관련된 이벤트 리스너를 삭제할 때 쓰인다.\n\n\nbefore 16.3은 따로 번역하지 않겠습니다.\n\n\ncomponentWillMount: Executed before rendering and is used for App level configuration in your root component.\ncomponentDidMount: Executed after first rendering and here all AJAX requests, DOM or state updates, and set up event listeners should occur.\ncomponentWillReceiveProps: Executed when particular prop updates to trigger state transitions.\nshouldComponentUpdate: Determines if the component will be updated or not. By default it returns true. If you are sure that the component doesn’t need to render after state or props are updated, you can return false value. It is a great place to improve performance as it allows you to prevent a re-render if component receives new prop.\ncomponentWillUpdate: Executed before re-rendering the component when there are props &amp; state changes confirmed by shouldComponentUpdate() which returns true.\ncomponentDidUpdate: Mostly it is used to update the DOM in response to prop or state changes.\ncomponentWillUnmount: It will be used to cancel any outgoing network requests, or remove all event listeners associated with the component.\n\n👆\n¶What are Higher-Order Components?\nHigher-order Component (이하 HOC)는 컴포넌트를 받아서 새로운 컴포넌트를 리턴하는 컴포넌트다. 기본적으로, 이러한 패턴은 리액트의 컴포넌트적인 특성에서 유래되었다.\n이를 Pure Component라고 부르는데, 동적으로 제공되는 하위 component를 그대로 사용하지만, 입력받은 component를 수정/복사하지 않기 때문이다.\nHOC는 아래와 같은 use case에서 사용할 수 있다.\n\n코드 재사용, 로직 추상화\nrender 하이재킹\nstate 추상화 또는 조작\nprops 조작\n\n👆\n¶How to create props proxy for HOC component?\nprops proxy pattern을 아래와 같이 사용한다면, 컴포넌트에 넘겨진 props를 추가/수정할 수 있다.\n1234567891011121314function HOC(WrappedComponent) &#123;  return class Test extends Component &#123;    render() &#123;      const newProps = &#123;        title: \"New Header\",        footer: false,        showFeatureX: false,        showFeatureY: true      &#125;;      return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;;    &#125;  &#125;;&#125;\n👆\n¶What is context?\nContext는 props을 탑다운으로 주지 않고도, 어느 레벨에서든 데이터를 컴포넌트 트리에 넘기는 방법이다. 예를 들어 인증받은 사용자, 언어 설정, UI theme 등 어플리케이션 단위에서 다양한 컴포넌트가 사용해야 하는 데이터를 context를 통해서 줄 수 있다.\n1const &#123; Provider, Consumer &#125; = React.createContext(defaultValue);\n👆\n¶What is children prop?\nChildren은 prop (this.prop.children) 으로, 다른 컴포넌트에 컴포넌트를 넘길 수 있는 방법으로, 다른 prop를 사용하는 것과 동일하다. 컴포넌트 트리는 이 children을 여닫는 태그 사이에 두며, 이는 컴포넌트를 children prop으로 건내게 된다.\nReact API에서 이러한 형태로 다양한 prop을 제공하고 있다. React.Children.map React.Children.forEach React.Children.count React.Children.only React.Children.toArray 사용예제는 아래와 같다.\n12345678910111213const MyDiv = React.createClass(&#123;  render: function() &#123;    return &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt;;  &#125;&#125;);ReactDOM.render(  &lt;MyDiv&gt;    &lt;span&gt;&#123;\"Hello\"&#125;&lt;/span&gt;    &lt;span&gt;&#123;\"World\"&#125;&lt;/span&gt;  &lt;/MyDiv&gt;,  node);\n👆\n¶How to write comments in React?\nReact/JSX의 주석은 자바스크립트의 다중 주석과 비슷하지만, { }에 쌓여있다는 것이 다르다.\n한 줄\n1234&lt;div&gt;  &#123;/* Single-line comments(In vanilla JavaScript, the single-line comments are  represented by double slash(//)) */&#125; &#123;`Welcome $&#123;user&#125;, let's play React`&#125;&lt;/div&gt;\n여러 줄\n1234&lt;div&gt;  &#123;/* Multi-line comments for more than one line */&#125; &#123;`Welcome $&#123;user&#125;, let's  play React`&#125;&lt;/div&gt;\n👆\n¶What is the purpose of using super constructor with props argument?\n자식 클래스 생성자는 super()메소드가 호출되기 전까지 this 레퍼런스를 쓸 수 없다. 이와 동일한것이 es6의 서브 클래스에 구현되어 있다. super() 메소드에 props를 파라미터로 호출하는 주요 이유는 this.props를 자식 생성자에서 쓰기 위해서다.\nprops 넘기는 경우\n1234567class MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    console.log(this.props); // prints &#123; name: 'John', age: 42 &#125;  &#125;&#125;\nprops 안 넘기는 경우\n123456789101112131415class MyComponent extends React.Component &#123;  constructor(props) &#123;    super();    console.log(this.props); // prints undefined    // but props parameter is still available    console.log(props); // prints &#123; name: 'John', age: 42 &#125;  &#125;  render() &#123;    // no difference outside constructor    console.log(this.props); // prints &#123; name: 'John', age: 42 &#125;  &#125;&#125;\n👆\n¶What is reconciliation?\n컴포넌트의 props나 state에 변경이 있을때, React는 이전에 렌더링 된 element와 새롭게 렌더링된 것을 비교하여 실제 DOM이 업데이트 되어야 할지를 결정한다. 똑같지 않을때, React는 DOM을 업데이트 한다. 이 과정을 reconciliation이라고 한다.\n👆\n¶How to set state with a dynamic key name?\nJSX코드 내에서 es6또는 바벨 트랜스파일러를 쓰고 있다면, computed property 명을 쓸 수 있다.\n123handleInputChange(event) &#123;  this.setState(&#123; [event.target.id]: event.target.value &#125;)&#125;\n👆\n¶What would be the common mistake of function being called every time the component renders?\n함수를 파라미터로 넘기는 과정에서 함수가 호출되지 않는지 확인해야 한다.\n👆\n¶Is lazy function supports named exports?\n아니다. 현재 React.lazy함수는 default export만 지원한다. named exports된 모듈을 import 하고 싶을 경우에는, 사이에 디폴트로 reexports 하는 모듈을 만들수 있다. 이는 트리쉐이킹을 도와주고, 사용하지 않는 컴포넌트를 pull하지 않을 수 있다. 밑에서 예를 살펴보자.\n123// MoreComponents.jsexport const SomeComponent = /* ... */;export const UnusedComponent = /* ... */;\n이 컴포넌트 중간에 IntermediateComponent.js를 만들어서 다시 export 한다.\n12// IntermediateComponent.jsexport &#123; SomeComponent as default &#125; from \"./MoreComponents.js\";\n그리고 lazy 함수를 이용해서 아래와 같이 임포트 할 수 있다.\n12import React, &#123; lazy &#125; from \"react\";const SomeComponent = lazy(() =&gt; import(\"./IntermediateComponent.js\"));\n👆\n¶Why React uses className over class attribute?\nclass는 자바스크립트의 예약어 이고, JSX는 javascript를 확장해 만든 것이다. 따라서 class를 쓰면 충돌이 일어나기 자바스크립트 예약어와 충동리 발생하기 때문에 className을 사용한다. className prop에 string을 넘겨 주면 된다.\n123render() &#123;  return &lt;span className=&#123;'menu navigation-menu'&#125;&gt;&#123;'Menu'&#125;&lt;/span&gt;&#125;\n👆\n¶What are fragments?\nReact에서는 하나의 컴포넌트가 여러개의 elements를 리턴하는 것이 일반적인 패턴이다. Fragments는 추가로 DOM 노드를 사용하지 않더라도 여러개의 노드들을 묶을 수 있게 해준다.\n123456789render() &#123;  return (    &lt;React.Fragment&gt;      &lt;ChildA /&gt;      &lt;ChildB /&gt;      &lt;ChildC /&gt;    &lt;/React.Fragment&gt;  )&#125;\n123456789render() &#123;  return (    &lt;&gt;      &lt;ChildA /&gt;      &lt;ChildB /&gt;      &lt;ChildC /&gt;    &lt;/&gt;  )&#125;\n👆\n¶Why fragments are better than container divs?\n\nFragment는 실제로 추가적인 DOM을 만들지 않기 때문에 더 빠르고 메모리 사용량도 적다. 이는 매우 크고 깊은 트리를 만들 때 상당한 이점으로 작용한다.\nCSS Grid나 firefox같은 일부 특수한 CSS 메커니즘은 특별한 부모-자식 관계를 가지고 있는데, div를 중간에 추가하는 것은 원하는 레이아웃을 그리기 어렵게 한다.\nDOM Inspector를 사용할 때 덜 혼잡스럽다.\n\n👆\n¶What are portals in React?\nportals 은 상위 Component 의 DOM 계층 구조 외부에 존재하는 DOM 노드로, 자식을 render 하는데 권장되는 방법이다.\n1ReactDOM.createPortal(child, container);\n첫번째 인자는 React Child에서만 렌더링이 가능하며, 여기에는 element, string, fragment 가 포함된다. 두번째 인자는 DOM 엘리먼트다.\n👆\n¶What are stateless components?\n컴포넌트의 동작이 state와 독립되어 있다면, 이는 stateless 컴포넌트다. 함수나 클래스를 이용해서 stateless 컴포넌트를 만들 수 있다. 하지만 컴포넌트의 라이프 사이클 훅이 필요하지 않다면, 함수형으로 가는 것이 좋다. 함수형 컴포넌트를 선택한다면 많은 이점을 가져갈 수 있다. 코드 사용 및 이해가 쉽고, 조금더 빠르며, 그리고 this 키워드의 충돌을 막을 수 있다.\n👆\n¶What are stateful components?\nstate의 사용에 종속적인 컴포넌트를 stateful component라고 한다. 이 컴포넌트는 항상 class 컴포넌트로 만들어 져야 하며, constructor를 통해서 초기화 되어야 한다.\n12345678910class App extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; count: 0 &#125;;  &#125;  render() &#123;    // ...  &#125;&#125;\n👆\n¶How to apply validation on props in React?\nReact가 development로 실행한다면, 자동으로 컴포넌트에 있는 props의 타입을 올바르게 체크해 준다. 만약 타입이 올바르지 않다면, React는 콘솔에 경고 메시지를 띄운다. 성능 상의 이슈를 위해 production에서는 이 기능이 꺼져 있다. 필수적인 prop은 isRequired다. 사용할 수 있는 prop type의 종류는 아래와 같다.\n\nPropTypes.number\nPropTypes.string\nPropTypes.array\nPropTypes.object\nPropTypes.func\nPropTypes.node\nPropTypes.element\nPropTypes.bool\nPropTypes.symbol\nPropTypes.any\n\n아래와 같이 쓸수 있다.\n123456789101112131415161718import React from \"react\";import PropTypes from \"prop-types\";class User extends React.Component &#123;  static propTypes = &#123;    name: PropTypes.string.isRequired,    age: PropTypes.number.isRequired  &#125;;  render() &#123;    return (      &lt;&gt;        &lt;h1&gt;&#123;`Welcome, $&#123;this.props.name&#125;`&#125;&lt;/h1&gt;        &lt;h2&gt;&#123;`Age, $&#123;this.props.age&#125;`&#125;&lt;/h2&gt;      &lt;/&gt;    );  &#125;&#125;\n주의: 리액트 v15.5부터 PropType이 React.PropTypes에서 prop-types로 이동했다.\n👆\n¶What are the advantages of React?\n\nVirtual DOM으로 어플리케이션의 성능을 향상시킬 수 있음\nJSX를 통해 코들르 쉽게 읽고 쓸수 있음\n클라이언트와 서버사이드 양쪽에서 렌더링 라능\n뷰만 다루는 라이브러리이기 때문에, 다른 프레임워크 (Angular, Backbone) 등과 쉽게 연동 가능\nJest와 같은 툴로 쉽게 유닛/인티그레이션 테스트 가능\n\n👆\n¶What are the limitations of React?\n\n풀 프레임워크가 아니라, view만 다루고 있음.\n뉴비 웹 개발자들에게 러닝 커브가 존재\n전통적인 MVC 프레임워크와 인터그레이팅을 하기 위해서는 추가적인 설정이 필요\ninline 템플릿과 JSX로 인해 코드의 복잡성 증가\n오버엔지니어링/보일러플레이팅을 야기하는 작은 단위의 컴포넌트가 너무 많이 존재\n\n👆\n¶What are error boundaries in React v16?\nError boundaries란 하위 component tree 에서 자바스크립트 에러 를 catch 하고, 기록하고, 에가 발생한 component tree가 아닌 대체 UI를 표현해 주는 component를 말한다.\n새롭게 추가된 라이프사이클 메서드인 componentDidCatch(error, info)나 static getDerivedStateFromError()를 사용한다면, 클래스 컴포넌트는 error boundary가 될 수 있다.\n123456789101112131415161718192021222324class ErrorBoundary extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; hasError: false &#125;;  &#125;  componentDidCatch(error, info) &#123;    // 에러 리포틍 서비스를 위해 로그를 기록할 수도 있고    logErrorToMyService(error, info);  &#125;  static getDerivedStateFromError(error) &#123;    // fallback UI를 표현하기 위해여 state를 업데이트 할 수도 있다.    return &#123; hasError: true &#125;;  &#125;  render() &#123;    if (this.state.hasError) &#123;      // custom Fallback UI를 그릴 수 있다.      return &lt;h1&gt;&#123;\"Something went wrong.\"&#125;&lt;/h1&gt;;    &#125;    return this.props.children;  &#125;&#125;\n그리고 이 컴포넌트는 아래와 같이 사용할 수 있다.\n123&lt;ErrorBoundary&gt;  &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt;\n👆\n¶How error boundaries handled in React v15?\nunstable_handleError 메서드를 활용한 기본적인 error boundaries만 제공하고 있다. 그리고 v16에서 componentDidCatch로 변경되었다.\n👆\n¶What are the recommended ways for static type checking?\n보통 PropTypes를 많이 사용한다. 그러나 크기가 큰 어플리케이션의 경우에는, Flow나 타입스크립트같은, 컴파일 단계에서 타입체킹을 제공하고 자동완성을 지원해주는 정적 타입 체커를 사용하는 것이 좋다.\n👆\n¶What is the use of react-dom package?\nreact-dom은 앱 최 상단 레벨에서 사용되는, DOM을 다루는데 필요한 메서드를 제공한다. 대부분의 컴포넌트는 이 모듈을 필요로 하지 않는다. 여기에 있는 메소드를 몇가지 나열하면\n\nrender()\nhydrate()\nunmountComponentAtNode()\nfindDOMNode()\ncreatePortal()\n\n👆\n¶What is the purpose of render method of react-dom?\nrender 메서드는 제공된 컨테이너의 DOM에 있는 React element를 render 하고 Component에 대한 참조를 반환하는데 사용된다. React element가 이전에 렌더링 되었다면 update 를 수행하고 최근의 변경사항을 반영하기 위해 필요에 따라 DOM을 변경하기도 한다.\n1ReactDOM.render(element, container[, callback])\n옵셔널 콜백이 있따면, 컴포넌트가 렌더링/업데이트 된 이후로 실행된다.\n👆\n¶What is ReactDOMServer?\nReactDOMServer는 컴포넌트를 정적 마크업으로 렌더링할 수 있게 해준다. (보통 노드 서버에서 많이 사용 된다) 이 오브젝트는 서버사이드 렌더링을 할 때 사용된다. 아래 메서드들은 서버와 브라우저 환경 모두에서 사용할 수 있다.\n\nrenderToString()\nrenderToStaticMarkup()\n\n예를 들어, 노드 베이스 웹서버인 Express, Hapi, Koa 등에서 서버를 실행한다면, renderToString메서드를 호출하여 이에 대한 응답으로 루트 컴포넌트를 string으로 렌더링할 수 있다.\n1234567891011// using Expressimport &#123; renderToString &#125; from \"react-dom/server\";import MyPage from \"./MyPage\";app.get(\"/\", (req, res) =&gt; &#123;  res.write(\"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\");  res.write('&lt;div id=\"content\"&gt;');  res.write(renderToString(&lt;MyPage /&gt;));  res.write(\"&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\");  res.end();&#125;);\n👆\n¶How to use innerHTML in React?\nbrowser DOM에서 innerHTML대신 dangerouslySetInnerHTML를 사용할 수 있다. innerHTML과 마찬가지로, 이 속성 또한 크로스 사이트 스크립팅 공격 (XSS)에 취약하다. __html을 키로 하고 HTML text를 값으로 가지는 object를 리턴하면 된다.\n1234567function createMarkup() &#123;  return &#123; __html: \"First &amp;middot; Second\" &#125;;&#125;function MyComponent() &#123;  return &lt;div dangerouslySetInnerHTML=&#123;createMarkup()&#125; /&gt;;&#125;\n👆\n¶How to use styles in React?\nstyle 속성은 css 문자열 대신 camelCased속성이 있는 자바스크립트 오브젝트를 허용한다. 이는 DOM 스타일 자바스크립트 속성과 일치하며, 효율적이고, XSS 보안 허점을 막아준다.\n👆\n¶How events are different in React?\nReact 엘리먼트에서 이벤트를 다루는 것은 문법상 약간의 차이가 있다.\n\n리액트 이벤트 핸들러는 lowerCase가 아닌 camelCase로 써야한다.\nJSX에서는 문자열이 아닌, 함수 이벤트 핸들러를 파라미터로 보낸다.\n\n👆\n¶What will happen if you use setState() in constructor?\nsetState()를 사용하면, 객체 상태가 할당되고, 자식을 포함한 모든 컴포넌트가 다시 렌더링된다. 그리고 아래와 같은 에러메시지가 나타난다. Can only update a mounted or mounting component. 따라서 this.state를 사용하여 생성자내에서 변수를 초기화 해야 한다.\n👆\n¶What is the impact of indexes as keys?\n키는 리액트에서 엘리먼트를 추적할 수 있도록 안정적이어야 하고, 예측가능해야 하고, 유니크해야 한다.\n아래 코드에서 각 엘리먼트의 키는 데이터를 따르는 것이 아니라 단순히 순서에 따라 결정된다. 이는 React가 하는 최적화를 제한한다.\nharmony123&#123;  todos.map((todo, index) =&gt; &lt;Todo &#123;...todo&#125; key=&#123;index&#125; /&gt;);&#125;\n만약 데이터를 유니크 키로 사용한다면 위의 조건을 만족하기 때문에, React는 다시 연산할 필요 없이 재정렬할 수 있다.\nharmony123&#123;  todos.map(todo =&gt; &lt;Todo &#123;...todo&#125; key=&#123;todo.id&#125; /&gt;);&#125;\n👆\n¶Is it good to use setState() in componentWillMount() method?\ncomponentWillMount()에서 비동기 초기화를 하는 것은 피하도록 권장한다. componentWillMount()는 마운팅이 일어나기 직전에 바로 실행된다. 이는 render()함수가 불리우기 직전이며, 따라서 여기에서 state를 새로 값을 할당 한다 하더라도 리렌더링을 트리거 하지 않는다. 이 메소드 내에서는 사이드 이펙트나 subscription등은 피해야 한다. 따라서 비동기 초기화는 componentDidMount()에서 하는 것이 좋다.\nharmony12345678componentDidMount() &#123;  axios.get(`api/todos`)    .then((result) =&gt; &#123;      this.setState(&#123;        messages: [...result.data]      &#125;)    &#125;)&#125;\n👆\n¶What will happen if you use props in initial state?\n컴포넌트의 새로고칩 없이 props가 변경된다면, 현재 상태의 컴포넌트는 절대로 업데이트 하지 않기 때문에 새로운 prop값이 화면에 표시되지 않을 것이다. props를 통한 state값의 초기화는 컴포넌트가 딱 초기화 되었을 때만 실행된다.\nharmony1234567891011121314class MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      records: [],      inputValue: this.props.inputValue    &#125;;  &#125;  render() &#123;    return &lt;div&gt;&#123;this.state.inputValue&#125;&lt;/div&gt;;  &#125;&#125;\nprops를 render 함수 내에서 쓰면 값을 업데이트 한다.\nharmony12345678910111213class MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      record: []    &#125;;  &#125;  render() &#123;    return &lt;div&gt;&#123;this.props.inputValue&#125;&lt;/div&gt;;  &#125;&#125;\n👆\n¶How do you conditionally render components?\n때로는 어떤 상태값에 따라서 렌더링을 다르게 해야하는 경우가 발생한다. JSX는 false나 undefined는 렌더링하지 않으므로, 특정 조건에 true를 주는 형식으로 조건부 렌더링을 할 수 있다.\nharmony123456const MyComponent = (&#123; name, address &#125;) =&gt; (  &lt;div&gt;    &lt;h2&gt;&#123;name&#125;&lt;/h2&gt;    &#123;address &amp;&amp; &lt;p&gt;&#123;address&#125;&lt;/p&gt;&#125;  &lt;/div&gt;);\nif-else도 삼항연산자를 활용하면 아래와 같이 할 수 있다.\nharmony123456const MyComponent = (&#123; name, address &#125;) =&gt; (  &lt;div&gt;    &lt;h2&gt;&#123;name&#125;&lt;/h2&gt;    &#123;address ? &lt;p&gt;&#123;address&#125;&lt;/p&gt; : &lt;p&gt;&#123;\"Address is not available\"&#125;&lt;/p&gt;&#125;  &lt;/div&gt;);\n👆\n¶Why we need to be careful when spreading props on DOM elements?\nspread prop를 쓴다면, HTML에 알수없는 속성을 추가할 수 있는 위험이 있기 때문에 좋지 못하다. 대신 ...rest 연산자를 쓴다면, 필요한 props만 추가해서 넣을 수 있다.\n1234567const ComponentA = () =&gt; (  &lt;ComponentB isDisplay=&#123;true&#125; className=&#123;\"componentStyle\"&#125; /&gt;);const ComponentB = (&#123; isDisplay, ...domProps &#125;) =&gt; (  &lt;div &#123;...domProps&#125;&gt;&#123;\"ComponentB\"&#125;&lt;/div&gt;);\n👆\n¶How you use decorators in React?\n클래스 컴포넌트에 데코레이터를 쓸 수 있으며, 이는 함수에 컴포넌트를 넘기는 것과 동일하다. 데코레이터는 유연하고 읽기 쉬운 방법으로 컴포넌트를 기능적으로 수정할 수 있도록 한다.\n123456789101112131415@setTitle(\"Profile\")class Profile extends React.Component &#123;  //....&#125;const setTitle = title =&gt; WrappedComponent =&gt; &#123;  return class extends React.Component &#123;    componentDidMount() &#123;      document.title = title;    &#125;    render() &#123;      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;    &#125;  &#125;;&#125;;\n주의: 데코레이터는 es7 문법에 포함되지 못하고 현재 stage2 단계에 있다.\n👆\n¶How do you memoize a component?\n함수형 컴포넌트를 기반으로한 메모이제이션이 가능한 라이브러리가 있다. 예를 들어, moize라이브러리를 활용하면, 다른 컴포넌트 내에서 컴포넌트를 메모이제이션 할 수 있다.\n1234567891011import moize from \"moize\";import Component from \"./components/Component\"; // this module exports a non-memoized componentconst MemoizedFoo = moize.react(Component);const Consumer = () =&gt; &#123;  &lt;div&gt;    &#123;\"I will memoize the following entry:\"&#125;    &lt;MemoizedFoo /&gt;  &lt;/div&gt;;&#125;;\n👆\n¶How you implement Server Side Rendering or SSR?\nReact는 이미 노드 서버에서 렌더링을 다룰 수 있도록 지원되고 있다. 클라이언트 사이드와 동일하게 렌더링할 수 있는 특수한 버전의 DOM renderer가 제공되고 있다.\n1234import ReactDOMServer from \"react-dom/server\";import App from \"./App\";ReactDOMServer.renderToString(&lt;App /&gt;);\n이 메소드는 일반적인 HTML을 string으로 내보내며, 이는 서버의 응답 일부를 페이지 본문 내부에 위치시킬 수 있다. 클라이언트 사이드에서, 리액트는 미리 렌더링된 컨텐츠를 감지하고 나머지를 원활하게 렌더링할 수 있다.\n👆\n¶How to enable production mode in React?\nWebpack의 DefinePlugin 메서드를 활용하여, NODE_ENV를 production으로 설정해야 propType의 유효성 검사 같은 추가적인 경고를 제거할 수 있다.\nproduction 모드와 별도로, 주석을 제거하고 코드르 압축시키는 uglify의 dead-code 코드를 사용하여 minify하면 번들링 사이즈를 줄일 수 있다.\n👆\n¶What is CRA and its benefits?\nCRA(create-react-app)는 특별한 설정없이도 빠르고 간편하게 리액트 어플리케이션을 만들수 있도록 해주는 Cli tool이다.\n1234567891011# Installation$ npm install -g create-react-app# Create new project$ create-react-app todo-app$ cd todo-app# Build, test and run$ npm run build$ npm run test$ npm start`\n여기에는 리액트 앱을 만드는데 필요한 모든 것이 담겨져 있다.\n\nReact, JSX, ES6, 문법 지원을 위한 Flow\nspread operator와 같은 es6 문법\nauto prefixed css를 통해, -web-kit` 과 같은 접두어를 붙이지 않아도 됨\n빠른 인터렉티브 유닛 테스트 러너와 함께 커버리지 리포팅\n일반적인 실수에 대해 경고하는 라이브 dev 서버\n배포를 위해 소스맵, 해쉬와 함께 제공되는 JS, CSS, 이미지 번들링 해주는 빌드 스크립트\n\n👆\n¶What is the lifecycle methods order in mounting?\n컴포넌트가 생성되고, DOM에 들어가는 과정에서 아래와 같은 라이프 사이클 메서드가 순서대로 호출된다.\n\nconstructor()\nstatic getDerivedStateFromProps()\nrender()\ncomponentDidMount()\n\n👆\n¶What are the lifecycle methods going to be deprecated in React v16?\n다음 lifecycle메서드는 안전하지 않은 코딩법이 될 수 있고, 비동기 렌더링시 문제가 발생할 수 있다.\n\ncomponentWillMount()\ncomponentWillReceiveProps()\ncomponentWillUpdate()\n\nv16.3 부터 UNSAFE_ prefix가 붙고, v17에서는 삭제된다.\n👆\n¶What is the purpose of getDerivedStateFromProps() lifecycle method?\n새로운 라이프 사이클 메서드 getDerivedStateFromProps()는 component가 인스턴스화 된 후, 다시 렌더링 되기전에 호출된다. object를 반환하여 state를 업데이트 하거나, null을 리턴하ㅕㅇ 새로운 props에서 state update가 필요하지 않도록 나타낼 수도 있다.\n12345class MyComponent extends React.Component &#123;  static getDerivedStateFromProps(props, state) &#123;    // ...  &#125;&#125;\n이 메서드는 componentDidUpdate()와 함께 쓴다면, componentWillReceiveProps()의 모든 유즈케이스에 적용할 수 있다.\n👆\n¶What is the purpose of getSnapshotBeforeUpdate() lifecycle method?\n새로운 메서드 getSnapshotBeforeUpdate()는 DOM 업데이트 직전에 호출된다. 이 메서드의 반환값은 componentDidUpdate()의 세번째 파라미터로 전달된다.\n12345class MyComponent extends React.Component &#123;  getSnapshotBeforeUpdate(prevProps, prevState) &#123;    // ...  &#125;&#125;\n이 메서드는 componentDidUpdate()와 함께 쓴다면, componentWillUpdate()의 모든 유즈케이스에 적용할 수 있다.\n👆\n¶Do Hooks replace render props and higher order components?\nrender props와 HOC 모두 한개의 자식만 렌더링 하지만, 대부분의 경우 Hooks API를 아용하면 트리에 의존성을 줄이면서 간단하게 구현할 수 있다.\n👆\n¶What is the recommended way for naming components?\ndisplayName을 쓰는 것 보다 컴포넌트에 레퍼런스를 주는 방법이 더 좋다.\ndisplayName을 쓰는 법 보다\n1234export default React.createClass(&#123;  displayName: \"TodoApp\"  // ...&#125;);\n이렇게 하는게 더 좋다.\n123export default class TodoApp extends React.Component &#123;  // ...&#125;\n👆\n¶What is the recommended ordering of methods in component class?\n마운팅에서 렌더링까지 아래와 같은 순서로 나열하길 권장한다.\n\nstatic 메서드\nconstructor()\ngetChildContext()\ncomponentWillMount()\ncomponentDidMount()\ncomponentWillReceiveProps()\nshouldComponentUpdate()\ncomponentWillUpdate()\ncomponentDidUpdate()\ncomponentWillUnmount()\n클릭 또는 이벤트 핸들러 onClickSubmit() onChangeDescription()\n렌더를 위한 getter 메서드 getSelectReason() getFooterContent()\n옵셔널 렌더 메서드 renderNavigation() renderProfilePicture()\nrender()\n\n¶What is a switching component?\n스위칭 컴포넌트란 하나 이상의 컴포넌트를 렌더링하는 컴포넌트를 의미한다. prop을 map으로 받아서 해당하는 컴포넌트를 보여주면 된다.\n아래 코드 참조.\n123456789101112131415161718192021import HomePage from \"./HomePage\";import AboutPage from \"./AboutPage\";import ServicesPage from \"./ServicesPage\";import ContactPage from \"./ContactPage\";const PAGES = &#123;  home: HomePage,  about: AboutPage,  services: ServicesPage,  contact: ContactPage&#125;;const Page = props =&gt; &#123;  const Handler = PAGES[props.page] || ContactPage;  return &lt;Handler &#123;...props&#125; /&gt;;&#125;;Page.propTypes = &#123;  page: PropTypes.oneOf(Object.keys(PAGES)).isRequired&#125;;\n👆\n¶Why we need to pass a function to setState()?\n그 이유는 setState()가 비동기로 작동하는데에 있다. React는 성능상의 문제로 인해, state의 변경작업을 배치로 하는데, 이 때문에 setState()를 바로 호출한다고 해서 바로 반영되지 않는다. 이 말은, setState()를 호출 할 때 그 당시 state의 값에 의존하면 안된다는 뜻이다. 따라서 setState()에는 이전 값에 접근할 수 있는 함수를 사용하는 것이 좋다. 이는 사용자가 비동기로 작동하는 setState()의 특징으로 인해 이전 값에 접근하는 것을 방지해 준다.\n초기 값이 0 이라고 가정하자. 여기 1 씩 올리는 동작을 하는 코드가 세개 있다.\n12345// assuming this.state.count === 0this.setState(&#123; count: this.state.count + 1 &#125;);this.setState(&#123; count: this.state.count + 1 &#125;);this.setState(&#123; count: this.state.count + 1 &#125;);// this.state.count === 1, not 3\n만약 setState()에 함수를 넘겨준다면, 올바르게 동작할 것이다.\n1234this.setState((prevState, props) =&gt; (&#123;  count: prevState.count + props.increment&#125;));// this.state.count === 3 as expected\n👆\n¶What is strict mode in React?\nReact.StrictMode는 어플리케이션의 잠재적인 문제를 하이라이팅 해주는 유용한 컴포넌트다. &lt;Fragment&gt;와 마찬가지로, &lt;StrictMode&gt;는 추가적으로 DOM을 렌더링하지 않는다. 이는 단지 자식 컴포넌트의 추가적인 체크와 경고를 할 뿐이다. 그리고 이러한 체크는 development 에서만 가능하다.\n12345678910111213141516import React from \"react\";function ExampleApplication() &#123;  return (    &lt;div&gt;      &lt;Header /&gt;      &lt;React.StrictMode&gt;        &lt;div&gt;          &lt;ComponentOne /&gt;          &lt;ComponentTwo /&gt;        &lt;/div&gt;      &lt;/React.StrictMode&gt;      &lt;Footer /&gt;    &lt;/div&gt;  );&#125;\n위 예에서, ComponentOne ComponentTwo만 체크할 것이다.\n👆\n¶What are React Mixins?\nMixins은 공통적인 기능을 가질 수 있도록 컴포넌트를 분리하는 방법이다. 그러나 사용하지 말아야 한다. HOC 나 데레이터를 사용하면 된다.\n가장 유명한 사용법중 하나는 PureRenderMixin이다. 이전 props또는 state와 얕은 비교를 했을 때 일치하는 경우, 리렌더링을 막아주는 역할을 한다.\n123456const PureRenderMixin = require(\"react-addons-pure-render-mixin\");const Button = React.createClass(&#123;  mixins: [PureRenderMixin]  // ...&#125;);\n👆\n¶Why is isMounted() an anti-pattern and what is the proper solution?\nisMounted()의 일반적인 사용사례는 컴포넌트가 언마운트 된 후에 setState()를 호출하는 것을 방지하기 위함이다.\n123if (this.isMounted()) &#123;  this.setState(&#123;...&#125;)&#125;\nsetState()를 호출하기 전에 isMounted()를 검사하면 경고를 없앨수있지만, 경고의 목적을 잃어버리는 꼴이 된다. 컴포넌트의 마운트가 해제된 후에 reference를 가지고 있다고 판단하므로 이는 일종의 코드 스멜이라고 볼 수 있다.\n좋은 해결책은 컴포넌트의 마운트가 해제된 후 setState()가 호출될 수 있는 위치를 찾아 수정하는 것이다. 이러한 상황은 대게 컴포넌트가 데이터를 기다리고 있다가 데이터의 도착전 마운트가 해제 되는, 콜백 상황에서 많이 발생된다. 콜백은 마운트가 해제되기 전에 componentWillUnMount에서 취소되어야 한다.\n👆\n¶What are the Pointer Events supported in React?\n포인터 이벤트는 모든 입력 이벤트를 다루는 통일된 방법을 제공한다. 과거에는 마우스 및 각각의 이벤트 리스너를 달았지만, 요즘에는 핸드폰 터치, 서피스, 펜 등 마우스 외에 다양한 입력기기가 나타나기 시작했다. 한가지 명심해야 할 점은 이러한 이벤트들이 포인트 이벤트 명세를 지원하는 브라우저에서만 동작할 것이라는 점이다.\n아래의 이벤트 타입들이 React DOM에서 지원하는 것이다.\n\nonPointerDown\nonPointerMove\nonPointerUp\nonPointerCancel\nonGotPointerCapture\nonLostPointerCaptur\nonPointerEnter\nonPointerLeave\nonPointerOver\nonPointerOut\n\n👆\n¶Why should component names start with capital letter?\nJSX를 이용해서 렌더링을 하다보면, 컴포넌트의 명이 대문자가 아닐 경우 태그 인식에 실패했다는 에러메시지를 뱉는다. 그 이유는 오직 HTML 엘리먼트와 SGV 태그만이 소문자로 시작하기 때문이다.\n123class SomeComponent extends Component &#123; // Code goes here&#125;`\n클래스 명을 소문자로 시작하게 컴포넌트를 만들 수 있지만, import 할 때는 대문자로 하면 된다.\n1234567class myComponent extends Component &#123;  render() &#123;    return &lt;div /&gt;;  &#125;&#125;export default myComponent;\n1import MyComponent from \"./MyComponent\";\n👆\n¶Are custom DOM attributes supported in React v16?\n가능하다. 과거 React는 알수없는 DOM 속성을 무시했다. JSX에 리액트가 알수 없는 속성을 넣었다면, 리액트는 이를 무시했다.\n예를 들어, 과거에는 아래와 같이 동작했다.\n1&lt;div mycustomattribute=&#123;\"something\"&#125; /&gt;\n1&lt;div /&gt;\n그러나 React v16부터는 알수없는 속성도 결국 DOM에 반영된다.\n1&lt;div mycustomattribute=\"something\" /&gt;\n이는 브라우저에 특화된 비표준 속성, 새로운 DOM api, 서드파티 라이브러리 등을 사용할 때 유용하다.\n👆\n¶What is the difference between constructor and getInitialState?\nes6 클래스에서는 constructor로 state를 초기화 하고, React.createClass를 사용할 때는 getInitialState()으로 초기화 한다.\nes6\n12345678class MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      /* initial state */    &#125;;  &#125;&#125;\nReact.createClass()\n1234567const MyComponent = React.createClass(&#123;  getInitialState() &#123;    return &#123;      /* initial state */    &#125;;  &#125;&#125;);\n👆\n¶Can you force a component to re-render without calling setState?\n기본적으로, state나 prop의 변화가 있을 때만 컴포넌트가 리렌더링 된다. 만약 render() 메서드가 외부의 다른 데이터에 의존적이라면, forceUpdate()를 통해서 컴포넌트를 리렌더링 할 수 있다.\n1component.forceUpdate(callback);\n다만 이러한 방법은 권장되지 않으며, render()메소드에서 this.props나 this.state를 참조하는 것이 권장된다.\n👆\n¶What is the difference between super() and super(props) in React using ES6 classes?\nconstructor()에서 this.props에 접근하고 싶다면, super()메서드에 this.props를 넘겨야 한다.\n123456class MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props);    console.log(this.props); // &#123; name: 'John', ... &#125;  &#125;&#125;\n123456class MyComponent extends React.Component &#123;  constructor(props) &#123;    super();    console.log(this.props); // undefined  &#125;&#125;\n👆\n¶How to loop inside JSX?\nArray.prototype.map을 es6의 화살표 함수 문법과 사용하면 된다.\n1234&lt;tbody&gt;  &#123;items.map(item =&gt;  &lt;SomeComponent key=\"&#123;item.id&#125;\" name=\"&#123;item.name&#125;\" /&gt;)&#125;&lt;/tbody&gt;\nfor루프는 사용할 수 없다.\n12345&lt;tbody&gt;  for (let i = 0; i &lt; items.length; i++) &#123;  &lt;SomeComponent key=\"&#123;items[i].id&#125;\" name=\"&#123;items[i].name&#125;\" /&gt;  &#125;&lt;/tbody&gt;\nJSX 태그는 함수호출로 트랜스파일이 되는데, 이 경우 표현식내에 제어문을 사용할 수 없다. 다만 이는 stage1에 있는 do proposal로 해결 될 수도 있다.\n👆\n¶How do you access props in attribute quotes?\nReact와 JSX는 속성 값에 string interpolation을 지원하지 않는다. 따라서 아래 코드는 작동하지 않는다.\n1&lt;img className=\"image\" src=\"images/&#123;this.props.image&#125;\" /&gt;\n하지만 {}와 함께 javascript 표현식을 넣으면 가능하다.\n12&lt;img className='image' src=&#123;'images/' + this.props.image&#125; /&gt; &lt;imgclassName='image' src=&#123;`images/$&#123;this.props.image&#125;`&#125; /&gt;\n👆\n¶What is React proptype array with shape?\n만약 특정 object를 가진 array를 넘기고 싶다면, React.PropTypes.arrayOf()와 함께 React.PropTypes.shape()를 쓰면 된다.\n12345678ReactComponent.propTypes = &#123;  arrayWithShape: React.PropTypes.arrayOf(    React.PropTypes.shape(&#123;      color: React.PropTypes.string.isRequired,      fontSize: React.PropTypes.number.isRequired    &#125;)  ).isRequired&#125;;\n👆\n¶How to conditionally apply class attributes?\n따옴표 안에 내용은 모두 string으로 인식하기 때문에 {}를 쓸 수 없다.\n1&lt;div className=\"btn-panel &#123;this.props.visible ? 'show' : 'hidden'&#125;\"&gt;&lt;/div&gt;\n다만 {}안에 모든 식을 넣으면 가능하다. (공백은 반드시 있어야 한다)\n1&lt;div className=&#123;'btn-panel ' + (this.props.visible ? 'show' : 'hidden')&#125;&gt;\n템플릿 string도 가능하다\n1&lt;div className=&#123;`btn-panel $&#123;this.props.visible ? 'show' : 'hidden'&#125;`&#125;&gt;\n👆\n¶What is the difference between React and ReactDOM?\nReact 패키지내에는 엘리먼트와 컴포넌트 클래스에 도움을 줄 수 있는 React.createElement() React.Component React.children등을 가지고 있다. React 패키지 내에는 컴포넌트를 만드는데 도움이 되는 이러한 요소들이 있다고 보면 된다. 반면 React-dom패키지는 ReactDOM.render() 서버사이드 렌더링에 필요한 react-dom/server에 속한 ReactDOMServer.renderToString() ReactDOMServer.renderToStaticMarkUp() 이 있다.\n👆\n¶Why ReactDOM is separated from React?\nReact 팀은 DOM조작과 관련된 모든 기능을 ReactDOM 라이브러리로 옮겼다. 이는 React v0.14에서 처음으로 분리되었다. 이 때 패키지를 보자면, react-native react-art react-canvas react-three등 패키지 분리가 깔끔해졌으며, React패키지 자체에는 브라우저 DOM 조작과 관련된 라이브러리가 없다는 것이 명확해졌다. React가 다수의 환경에서 렌더링을 지원하기 위해, React팀은 React와 React-dom을 분리할 계획을 수립햇다. 이러한 방법론은 웹 버전에서 쓰이는 React와 React-Native사이에 컴포넌트를 쓰는 방법론을 공유할 수 있도록 해준다.\n👆\n¶How to use React label element?\n표준 for 속성을 사용하는 text input에 바인드된 &lt;label&gt;을 사용하려고 하면, 속성이 없는 HTML이 생성되고 콘솔에 경고가 출력된다.\n12&lt;label for=&#123;'user'&#125;&gt;&#123;'User'&#125;&lt;/label&gt;&lt;input type=&#123;'text'&#125; id=&#123;'user'&#125; /&gt;\nfor는 자바스크립트의 예약어이므로, htmlFor를 사용해야 한다.\n12&lt;label htmlFor=&#123;'user'&#125;&gt;&#123;'User'&#125;&lt;/label&gt;&lt;input type=&#123;'text'&#125; id=&#123;'user'&#125; /&gt;\n👆\n¶How to combine multiple inline style objects?\nspread 연산자를 사용하면 된다.\n1&lt;button style=&#123;&#123;...styles.panel.button, ...styles.panel.submitButton&#125;&#125;&gt;&#123;'Submit'&#125;&lt;/button&gt;\nReact Native라면 array를 사용하면 된다.\n1&lt;button style=&#123;[styles.panel.button, styles.panel.submitButton]&#125;&gt;&#123;'Submit'&#125;&lt;/button&gt;\n👆\n¶How to re-render the view when the browser is resized?\ncomponentDidMount()에서 resize이벤트를 걸어두고, width와 height를 업데이트 하면 된다. 그리고 이 이벤트는 componentWillUnmount()에서 제거해줘야 한다.\n1234567891011121314151617181920212223242526class WindowDimensions extends React.Component &#123;  constructor(props)&#123;    super(props);    this.updateDimensions = this.updateDimensions.bind(this);  &#125;     componentWillMount() &#123;    this.updateDimensions()  &#125;  componentDidMount() &#123;    window.addEventListener('resize', this.updateDimensions)  &#125;  componentWillUnmount() &#123;    window.removeEventListener('resize', this.updateDimensions)  &#125;  updateDimensions() &#123;    this.setState(&#123;width: window.innerWidth, height: window.innerHeight&#125;)  &#125;  render() &#123;    return &lt;span&gt;&#123;this.state.width&#125; x &#123;this.state.height&#125;&lt;/span&gt;  &#125;&#125;\n👆\n¶What is the difference between setState() and replaceState() methods?\nsetState()는 과거의 state값을 현재 값으로 합친다. 반면 replaceState()는 현재 state를 버리고 넘어오는 state로 바꾼다. 이전 key를 모두 제거하는 경우가 아니라면 보통 useState()를 사용한다. replaceState()대신 setState()에서 false/null을 사용할 수도 있다.\n👆\n¶How to listen to state changes?\n아래 라이프사이클 메서드는 state의 변화가 있을 때 호출된다. 여기에서 이전 state와 props과 현재 state/props 값을 비교하여 의미있는 변화가 있었는지 추적할 수 있다.\n12componentWillUpdate(object nextProps, object nextState)componentDidUpdate(object prevProps, object prevState)\n👆\n¶What is the recommended approach of removing an array element in React state?\nArray.prototype.filter()메서드가 올바른 방법이다.\n12345removeItem(index) &#123;  this.setState(&#123;    data: this.state.data.filter((item, i) =&gt; i !== index)  &#125;)&#125;\n👆\n¶Is it possible to use React without rendering HTML?\n16.2 이상의 버전에서는 가능하다.\n123render() &#123;  return false&#125;\n123render() &#123;  return null&#125;\n123render() &#123;  return []&#125;\n123render() &#123;  return &lt;React.Fragment&gt;&lt;/React.Fragment&gt;&#125;\n123render() &#123;  return &lt;&gt;&lt;/&gt;&#125;\nundefined의 경우에는 작동하지 않는다.\n👆\n¶How to pretty print JSON with React?\n&lt;pre&gt; 태그안에 JSON.stringify()를 사용하면 된다.\n12345678910111213const data = &#123; name: 'John', age: 42 &#125;class User extends React.Component &#123;  render() &#123;    return (      &lt;pre&gt;        &#123;JSON.stringify(data, null, 2)&#125;      &lt;/pre&gt;    )  &#125;&#125;React.render(&lt;User /&gt;, document.getElementById('container'))\n👆\n¶Why you can’t update props in React?\nprops은 불변이며, 하향식으로 전달되는 것이 React의 철학이다. 이 말인 즉, 부모는 어떤 prop값이든 자식에세 보낼 수 있지만, 자식은 그 prop값을 수정할 수 없다는 것이다.\n👆\n¶How to focus an input element on page load?\ninput 엘리먼트에 ref를 만들고, 이를 componentDidMount()에서 쓰면 된다.\n123456789101112131415161718192021class App extends React.Component&#123;  componentDidMount() &#123;    this.nameInput.focus()  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;input          defaultValue=&#123;'Won\\'t focus'&#125;        /&gt;        &lt;input          ref=&#123;(input) =&gt; this.nameInput = input&#125;          defaultValue=&#123;'Will focus'&#125;        /&gt;      &lt;/div&gt;    )  &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('app'))\n👆\n¶What are the possible ways of updating objects in state?\n\nstate를 병합할 object를 setState()에 서 사용하는 법\n\n`Object.assign()로 Object의 복사본을 만든다.\n\n\n\n12const user = Object.assign(&#123;&#125;, this.state.user, &#123; age: 42 &#125;)this.setState(&#123; user &#125;)-\n\nspread 연산자를 사용하는 법\n\n12const user = &#123; ...this.state.user, age: 42 &#125;this.setState(&#123; user &#125;)\n\nsetState()와 함수를 사용하는 법\n\n123456this.setState(prevState =&gt; (&#123;  user: &#123;    ...prevState.user,    age: 42  &#125;&#125;))\n👆\n¶Why function is preferred over object for setState()?\nReact는 성능의 문제로 인해 여러개의 setState()를 배치 형태로 호출하게 된다. 왜냐하면 this.props와 this.state는 비동기로 업데이트 될 수 있기 때문이다. 다음 state를 계산할 때 이전에 계산된 값을 신뢰하면 안된다.\n아래 예제는 제대로 작동하지 않는다.\n1234// Wrongthis.setState(&#123;  counter: this.state.counter + this.props.increment,&#125;)\n이를 위해 함수로 setState()를 호출하는 것이 권장된다. 함수로 호출시 이전 state값을 받을 수 있고, 업데이트할 때 사용할 prop도 받아올 수 있다.\n1234// Correctthis.setState((prevState, props) =&gt; (&#123;  counter: prevState.counter + props.increment&#125;))\n👆\n¶How can we find the version of React at runtime in the browser?\nReact.version을 사용하면 된다.\n123456const REACT_VERSION = React.versionReactDOM.render(  &lt;div&gt;&#123;`React version: $&#123;REACT_VERSION&#125;`&#125;&lt;/div&gt;,  document.getElementById('app'))\n👆\n¶What are the approaches to include polyfills in your create-react-app?\n\ncore-js를 수동으로 임포트하는 법\npolyfills.js과 같은 파일을 만들고, 이를 루트인 index.js에서 임포트 한다. 그리고 core-js를 설치하여 필요한 기능을 임포트 한다.\n\n123import 'core-js/fn/array/find'import 'core-js/fn/array/includes'import 'core-js/fn/number/is-nan'\n\n폴리필 서비스를 이용하는 방법\npolyfill.io를 CDN으로 가져와서, index.html에 추가하는 방법\n\n1&lt;script src='https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes'&gt;&lt;/script&gt;\n👆\n¶How to use https instead of http in create-react-app?\n환경설정에 HTTPS=true를 세팅하면 된다.\npacakge.json\n123\"scripts\": &#123;  \"start\": \"set HTTPS=true &amp;&amp; react-scripts start\"&#125;\n아니면 set HTTPS=true &amp;&amp; npm start로 실행하면 된다.\n👆\n¶How to avoid using relative path imports in create-react-app?\n루트 디렉토리에 .env를 만들고, 임포트 경로를 작성한다.\nNODE_PATH=src/app\n개발서벌르 재시작하면, 상대경로 없이 src/app에 있는 파일을 import 할 수 있다.\n👆\n¶How to add Google Analytics for React Router?\nhistory 객체에 리스너를 추가하여 각 페이지 뷰에 달아 둔다.\n1234history.listen(function (location) &#123;  window.ga('set', 'page', location.pathname + location.search)  window.ga('send', 'pageview', location.pathname + location.search)&#125;)\n👆\n¶How to update a component every second?\nsetInterval()에 트리거를 걸어두면 되지만, unmount시에 이를 해제하여 메모리 누수와 에러를 방지해야 한다.\n1234567componentDidMount() &#123;  this.interval = setInterval(() =&gt; this.setState(&#123; time: Date.now() &#125;), 1000)&#125;componentWillUnmount() &#123;  clearInterval(this.interval)&#125;\n👆\n¶How do you apply vendor prefixes to inline styles in React?\nreact는 자동으로 vender prefix를 붙여주지 않으므로, 수동으로 붙여야 한다.\n12345&lt;div style=&#123;&#123;  transform: 'rotate(90deg)',  WebkitTransform: 'rotate(90deg)', // note the capital 'W' here  msTransform: 'rotate(90deg)' // 'ms' is the only lowercase vendor prefix&#125;&#125; /&gt;\n👆\n¶How to import and export components using React and ES6?\ndefault키워드를 사용하여 컴포넌트를 익스포트 한다.\n123456789101112import React from 'react'import User from 'user'export default class MyProfile extends React.Component &#123;  render()&#123;    return (      &lt;User type=\"customer\"&gt;        //...      &lt;/User&gt;    )  &#125;&#125;\n위 예제에서는 MyProfile이 멤버가 되어 모듈로 익스포트 되는데, 이는 다른 컴포넌트에서 굳이 이름을 명세하지 않더라도 임포트 할 수 있게 해준다.\n👆\n¶What are the exceptions on React component naming?\n몇가지 예외적인 경우를 제외하고, 컴포넌트 명은 대문자로 시작해야 한다. 소문자와 . (속성 접근자)을 사용하는 경우 유효한 컴포넌트 명이다. 아래의 예가 그러한 유효한 경우다.\n12345render()&#123;   return (       &lt;obj.component /&gt; // `React.createElement(obj.component)`      )&#125;\n👆\n¶Why is a component constructor called only once?\nReact의 reconciliation 알고리즘은 후속 렌더링 과정에서 사용자 정의 컴포넌트가 똒같은 위치에 나타나면, 이전과 동일 한 요소이므로 새로운 인스턴스를 만드는 대신 이전 인스턴스를 재사용한다고 가정한다.\n👆\n¶How to define constants in React?\nes7의 static 필드를 사용하여 상수를 정의할 수 있다.\n123class MyComponent extends React.Component &#123;  static DEFAULT_PAGINATION = 10&#125;\n현재 static 필드는 stage3에 있다.\n👆\n¶How to programmatically trigger click event in React?\ncallback을 통한 ref prop를 사용하여 HTMLInputElement 객체에 대한 참조를 가져와서 class property 로 저장한 다음, 이렇게 저장된 참조를 활용하여 HTMLElement.click 메서드를 사용해 이벤트 핸들러에서 클릭 이벤트를 트리거 할 수 있다.\n\nrender 메서드에서 ref를 생성한다.\n\n1&lt;input ref=&#123;input =&gt; this.inputElement = input&#125; /&gt;\n\n이벤트 핸들러에서 클릭 이벤트를 트리거 한다.\n\n1this.inputElement.click()\n👆\n¶Is it possible to use async/await in plain React?\nReact 에서 async/await 을 사용하고 싶다면 Babel 과 transform-async-to-generator 플러그인이 필요하다. React Native에서는 기본적으로 지원하고 있다.\n👆\n¶What are the common folder structures for React?\n크게 두가지 종류가 있다.\n\n기능 또는 라우팅으로 분류하는 방법\n\n기능과 라우팅에 따라서 css, js, 테스트 코드를 묶는 방법이다.\n123456789101112131415161718common/├─ Avatar.js├─ Avatar.css├─ APIUtils.js└─ APIUtils.test.jsfeed/├─ index.js├─ Feed.js├─ Feed.css├─ FeedStory.js├─ FeedStory.test.js└─ FeedAPI.jsprofile/├─ index.js├─ Profile.js├─ ProfileHeader.js├─ ProfileHeader.css└─ ProfileAPI.js\n\n파일 타입 별로 분류하는 법\n\n123456789101112131415api/├─ APIUtils.js├─ APIUtils.test.js├─ ProfileAPI.js└─ UserAPI.jscomponents/├─ Avatar.js├─ Avatar.css├─ Feed.js├─ Feed.css├─ FeedStory.js├─ FeedStory.test.js├─ Profile.js├─ ProfileHeader.js└─ ProfileHeader.css\n👆\n¶What are the popular packages for animation?\nReact Transition Group과 React Motion이 React 생태계에서 유명한 애니메이션 패키지다.\n👆\n¶What is the benefit of styles modules?\n스타일 값을 하드코딩 하는 것은 권장하지 않는 방식이다. 서로다른 UI 컴포넌트에서 넓게 사용되는 값은 하나의 모듈에서 추출해서 쓰는 것이 좋다.\n아래와 같은 방식을 사용하면, 서로다른 컴포넌트에서 동일한 스타일을 가져올 수 있다.\n12345678910111213export const colors = &#123;  white,  black,  blue&#125;export const space = [  0,  8,  16,  32,  64]\n그리고 각각의 컴포넌트에서 이를 임포트 하면 된다.\n1import &#123; space, colors &#125; from './styles'\n👆\n¶What are the popular React-specific linters?\n자바스크립트 lint로는 eslint가 유명하다. 코드 스타일을 분석할 수 있는 다양한 플러그인이 있다. React에서 가장 유명한 것은 eslint-plugin-react다. 기본적으로 몇가지 베스트 프랙티스를 확인하여, 이 규칙을 바탕으로 iterator의 키에서 부터 prop type까지 확인해 준다. 다른 유명한 플러그인으로는 eslint-plugin-jsx-a11y가 있는데, 이는 접근성과 관련된 일반적인 문제를 해결하는데 도움을 준다. JSX는 alt tabindex와 같은 HTML과 약간 다른 문법을 제공하므로, 일반적인 플러그인으로 는 확인이 어렵다.\n👆\n¶How to make AJAX call and in which component lifecycle methods should I make an AJAX call?\nAxios, jQuery Ajax, 브라우저 빌트인 fetch등을 활용하여 ajax를 활용할 수 있다. 이렇게 데이터를 가져오는 것은 반드시 componentDidMount()내에서 해야 한다. 이는 데이터를 받어온 뒤에 setState()로 컴포넌트를 업데이트 할 수 있게 해준다.\n예를 들어, 아래 코드에서 employee 목록을 가져오고 state를 업데이트 한다.\n1234567891011121314151617181920212223242526272829303132333435363738394041class MyComponent extends React.Component &#123;  constructor(props) &#123;    super(props)    this.state = &#123;      employees: [],      error: null    &#125;  &#125;  componentDidMount() &#123;    fetch('https://api.example.com/items')      .then(res =&gt; res.json())      .then(        (result) =&gt; &#123;          this.setState(&#123;            employees: result.employees          &#125;)        &#125;,        (error) =&gt; &#123;          this.setState(&#123; error &#125;)        &#125;      )  &#125;  render() &#123;    const &#123; error, employees &#125; = this.state    if (error) &#123;      return &lt;div&gt;Error: &#123;error.message&#125;&lt;/div&gt;;    &#125; else &#123;      return (        &lt;ul&gt;          &#123;employees.map(item =&gt; (            &lt;li key=&#123;employee.name&#125;&gt;              &#123;employee.name&#125;-&#123;employees.experience&#125;            &lt;/li&gt;          ))&#125;        &lt;/ul&gt;      )    &#125;  &#125;&#125;\n👆\n¶What are render props?\nRender Props는 값이 함수인 prop을 활용하여 컴포넌트 간에 코드를 share할 수 있게 해주는 방법이다. 아래 컴포넌트는 render prop을 활용하여 React element를 리턴한다.\n123&lt;DataProvider render=&#123;data =&gt; (  &lt;h1&gt;&#123;`Hello $&#123;data.target&#125;`&#125;&lt;/h1&gt;)&#125;/&gt;\nReact Router 와 DownShift 라이브러리가 이 패턴을 사용한다.\n👆\n","dateCreated":"2019-08-20T16:22:35+09:00","dateModified":"2019-08-28T16:44:01+09:00","datePublished":"2019-08-20T16:22:35+09:00","description":"목차\n\nNo.QuestionsCore React1리액트란 무엇인가?2리액트의 주요 기능은 무엇인가?3JSX란 무엇인가?4element와 component의 차이점은 무엇인가?5리액트에서 컴포넌트를 어떻게 만드는가?6클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가?7순수한 컴포넌트는 무엇인가?8state는 무엇인가?9props는 무엇인가?10state와 props의 차이는 무엇인가?11왜 state를 바로 업데이트 하면 안되는가?12setState() 콜백의 용도는 무엇인가?13HTML과 React의 이벤트 핸들링 차이는 무엇인","headline":"리액트 인터뷰 질문 & 답 (1)","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/"},"publisher":{"@type":"Organization","name":"yceffort","sameAs":["https://github.com/yceffort","mailto: root@yceffort.kr"],"image":"https://www.gravatar.com/avatar/f24f66c6311c477d8ac26a9ef346560c","logo":{"@type":"ImageObject","url":"https://www.gravatar.com/avatar/f24f66c6311c477d8ac26a9ef346560c"}},"url":"https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/","keywords":"react, javascript"}</script>
    <meta name="description" content="목차  No.QuestionsCore React1리액트란 무엇인가?2리액트의 주요 기능은 무엇인가?3JSX란 무엇인가?4element와 component의 차이점은 무엇인가?5리액트에서 컴포넌트를 어떻게 만드는가?6클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가?7순수한 컴포넌트는 무엇인가?8state는 무엇인가?9props는 무엇인가?10state와">
<meta name="keywords" content="react,javascript">
<meta property="og:type" content="blog">
<meta property="og:title" content="리액트 인터뷰 질문 &amp; 답 (1)">
<meta property="og:url" content="https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/index.html">
<meta property="og:site_name" content="yceffort">
<meta property="og:description" content="목차  No.QuestionsCore React1리액트란 무엇인가?2리액트의 주요 기능은 무엇인가?3JSX란 무엇인가?4element와 component의 차이점은 무엇인가?5리액트에서 컴포넌트를 어떻게 만드는가?6클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가?7순수한 컴포넌트는 무엇인가?8state는 무엇인가?9props는 무엇인가?10state와">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom1.png">
<meta property="og:image" content="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom2.png">
<meta property="og:image" content="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom3.png">
<meta property="og:image" content="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/phases16.3.jpg?raw=true">
<meta property="og:image" content="https://github.com/sudheerj/reactjs-interview-questions/blob/master/images/phases.png?raw=true">
<meta property="og:updated_time" content="2019-08-28T07:44:01.157Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="리액트 인터뷰 질문 &amp; 답 (1)">
<meta name="twitter:description" content="목차  No.QuestionsCore React1리액트란 무엇인가?2리액트의 주요 기능은 무엇인가?3JSX란 무엇인가?4element와 component의 차이점은 무엇인가?5리액트에서 컴포넌트를 어떻게 만드는가?6클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가?7순수한 컴포넌트는 무엇인가?8state는 무엇인가?9props는 무엇인가?10state와">
<meta name="twitter:image" content="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom1.png">
    
    
    
    
    
    <meta property="og:image" content="https://www.gravatar.com/avatar/6b0848c9324388ed7ca5157d9d6e67c6?s=640" />
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-iyxsfxng5z2aqzamse6aps0lcii97y4op8hvyv9myltr058xvtcydusibtym.min.css">
    <!--STYLES END-->
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-139493546-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-139493546-1');
    </script>


    
</head>
    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
    

<header id="header" data-behavior="2">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">yceffort</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="https://www.gravatar.com/avatar/6b0848c9324388ed7ca5157d9d6e67c6?s=90" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->


    

<nav id="sidebar" data-behavior="2">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://www.gravatar.com/avatar/6b0848c9324388ed7ca5157d9d6e67c6?s=110" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">yceffort</h4>
                
                    <h5 class="sidebar-profile-bio"><p>yceffort</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#"
                            
                            title="Home"
                        >
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/all-tags"
                            
                            title="Tags"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                            title="Search"
                        >
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/bookmark"
                            
                            title="Bookmark"
                        >
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Bookmark</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="#about"
                            
                            title="About"
                        >
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/yceffort" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto: root@yceffort.kr" target="_blank" rel="noopener" title="Mail">
                    
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/atom.xml"
                            
                            title="RSS"
                        >
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="2"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            리액트 인터뷰 질문 &amp; 답 (1)
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-08-20T16:22:35+09:00">
	
		    Aug 20, 2019
    	
    </time>
    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <p><a href="/2019/08/13/reactjs-interview-questions/">목차</a></p>
<table>
<thead>
<tr>
<th>No.</th>
<th>Questions</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong>Core React</strong></td>
</tr>
<tr>
<td>1</td>
<td><a href="#what-is-react">리액트란 무엇인가?</a></td>
</tr>
<tr>
<td>2</td>
<td><a href="#what-are-the-major-features-of-react">리액트의 주요 기능은 무엇인가?</a></td>
</tr>
<tr>
<td>3</td>
<td><a href="#what-is-jsx">JSX란 무엇인가?</a></td>
</tr>
<tr>
<td>4</td>
<td><a href="#what-is-the-difference-between-element-and-component">element와 component의 차이점은 무엇인가?</a></td>
</tr>
<tr>
<td>5</td>
<td><a href="#how-to-create-components-in-react">리액트에서 컴포넌트를 어떻게 만드는가?</a></td>
</tr>
<tr>
<td>6</td>
<td><a href="#when-to-use-a-class-component-over-a-function-component">클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가?</a></td>
</tr>
<tr>
<td>7</td>
<td><a href="#what-are-pure-components">순수한 컴포넌트는 무엇인가?</a></td>
</tr>
<tr>
<td>8</td>
<td><a href="#what-is-state-in-react">state는 무엇인가?</a></td>
</tr>
<tr>
<td>9</td>
<td><a href="#what-are-props-in-react">props는 무엇인가?</a></td>
</tr>
<tr>
<td>10</td>
<td><a href="#what-is-the-difference-between-state-and-props">state와 props의 차이는 무엇인가?</a></td>
</tr>
<tr>
<td>11</td>
<td><a href="#why-should-we-not-update-the-state-directly">왜 state를 바로 업데이트 하면 안되는가?</a></td>
</tr>
<tr>
<td>12</td>
<td><a href="#what-is-the-purpose-of-callback-function-as-an-argument-of-setstate">setState() 콜백의 용도는 무엇인가?</a></td>
</tr>
<tr>
<td>13</td>
<td><a href="#what-is-the-difference-between-html-and-react-event-handling">HTML과 React의 이벤트 핸들링 차이는 무엇인가?</a></td>
</tr>
<tr>
<td>14</td>
<td><a href="#how-to-bind-methods-or-event-handlers-in-jsx-callbacks">JSX 콜백에 메소드나 이벤트 핸들러를 바인딩하는 방법은 무엇인가?</a></td>
</tr>
<tr>
<td>15</td>
<td><a href="#how-to-pass-a-parameter-to-an-event-handler-or-callback">이벤트 핸들러나 콜백에 파라미터를 전달하는 방법은?</a></td>
</tr>
<tr>
<td>16</td>
<td><a href="#what-are-synthetic-events-in-react">리액트의 synthetic event는 무엇인가?</a></td>
</tr>
<tr>
<td>17</td>
<td><a href="#what-is-inline-conditional-expressions">인라인 조건식은 무엇인가?</a></td>
</tr>
<tr>
<td>18</td>
<td><a href="#what-are-key-props-and-what-is-the-benefit-of-using-them-in-arrays-of-elements"><code>key</code> props는 무엇이며, 배열의 요소에서 사용함으로써 얻을 수 있는 이점은 무엇인가?</a></td>
</tr>
<tr>
<td>19</td>
<td><a href="#what-is-the-use-of-refs"><code>ref</code>의 목적은 무엇인가?</a></td>
</tr>
<tr>
<td>20</td>
<td><a href="#how-to-create-refs"><code>ref</code>는 어떻게 생성하는가?</a></td>
</tr>
<tr>
<td>21</td>
<td><a href="#what-are-forward-refs">forward refs란 무엇이인가?</a></td>
</tr>
<tr>
<td>22</td>
<td><a href="#which-is-preferred-option-with-in-callback-refs-and-finddomnode">callback ref와 findDOMNode중 어떤것이 더 선호되는가?</a></td>
</tr>
<tr>
<td>23</td>
<td><a href="#why-are-string-refs-legacy">string ref가 왜 legacy가 되었는가?</a></td>
</tr>
<tr>
<td>24</td>
<td><a href="#what-is-virtual-dom">Virtual DOM 은 무엇인가?</a></td>
</tr>
<tr>
<td>25</td>
<td><a href="#how-virtual-dom-works">Virtual DOM은 어떻게 작동하는가?</a></td>
</tr>
<tr>
<td>26</td>
<td><a href="#what-is-the-difference-between-shadow-dom-and-virtual-dom">Shadow DOM과 Virtual DOM의 차이는 무엇인가?</a></td>
</tr>
<tr>
<td>27</td>
<td><a href="#what-is-react-fiber">What is React Fiber?</a></td>
</tr>
<tr>
<td>28</td>
<td><a href="#what-is-the-main-goal-of-react-fiber">React Fiber의 목적은 무엇인가?</a></td>
</tr>
<tr>
<td>29</td>
<td><a href="#what-are-controlled-components">controlled components는 무엇인가?</a></td>
</tr>
<tr>
<td>30</td>
<td><a href="#what-are-uncontrolled-components">uncontrolled components는 무엇인가?</a></td>
</tr>
<tr>
<td>31</td>
<td><a href="#what-is-the-difference-between-createelement-and-cloneelement"><code>createElement</code>와 <code>cloneElement</code>의 차이는 무엇인가?</a></td>
</tr>
<tr>
<td>32</td>
<td><a href="#what-is-lifting-state-up-in-react">React에서 lifting state up은 무엇인가?</a></td>
</tr>
<tr>
<td>33</td>
<td><a href="#what-are-the-different-phases-of-component-lifecycle">Component Lifecycle의 각 phase에는 어떤 차이가 있는가?</a></td>
</tr>
<tr>
<td>34</td>
<td><a href="#what-are-the-lifecycle-methods-of-react">Component Lifecycle에는 어떤 method가 있는가?</a></td>
</tr>
<tr>
<td>35</td>
<td><a href="#what-are-higher-order-components">Higher-Order 컴포넌트는 무엇인가?</a></td>
</tr>
<tr>
<td>36</td>
<td><a href="#how-to-create-props-proxy-for-hoc-component">HOC 컴포넌트에서 props proxy를 어떻게 만드는가?</a></td>
</tr>
<tr>
<td>37</td>
<td><a href="#what-is-context">Context란 무엇인가?</a></td>
</tr>
<tr>
<td>38</td>
<td><a href="#what-is-children-prop">자식 prop는 무엇인가?</a></td>
</tr>
<tr>
<td>39</td>
<td><a href="#how-to-write-comments-in-react">React에서 주석을 어떻게 쓰는가?</a></td>
</tr>
<tr>
<td>40</td>
<td><a href="#what-is-the-purpose-of-using-super-constructor-with-props-argument">props 변수가 있는 super 생성자의 목적은 무엇인가?</a></td>
</tr>
<tr>
<td>41</td>
<td><a href="#what-is-reconciliation">reconciliation은 무엇인가??</a></td>
</tr>
<tr>
<td>42</td>
<td><a href="#how-to-set-state-with-a-dynamic-key-name">동적 key name으로 setState하는 방법은?</a></td>
</tr>
<tr>
<td>43</td>
<td><a href="#what-would-be-the-common-mistake-of-function-being-called-every-time-the-component-renders">렌더가 될 때 마다 호출되는 function의 일반적인 실수는 무엇인가?</a></td>
</tr>
<tr>
<td>44</td>
<td><a href="#is-lazy-function-supports-named-exports">lazy함수가 named exports를 지원하는가?</a></td>
</tr>
<tr>
<td>45</td>
<td><a href="#why-react-uses-classname-over-class-attribute">리액트가 class 속성에 class 대신 className을 쓰는가?</a></td>
</tr>
<tr>
<td>46</td>
<td><a href="#what-are-fragments">fragments란 무엇인가?</a></td>
</tr>
<tr>
<td>47</td>
<td><a href="#why-fragments-are-better-than-container-divs">fragment가 div 컨테이너보다 좋은 이유는?</a></td>
</tr>
<tr>
<td>48</td>
<td><a href="#what-are-portals-in-react">react에서 portals란 무엇인가?</a></td>
</tr>
<tr>
<td>49</td>
<td><a href="#what-are-stateless-components">stateless 컴포넌트란?</a></td>
</tr>
<tr>
<td>50</td>
<td><a href="#what-are-stateful-components">stateful 컴포넌트란?</a></td>
</tr>
<tr>
<td>51</td>
<td><a href="#how-to-apply-validation-on-props-in-react">React props에서 유효성 검사를 하는 방법은?</a></td>
</tr>
<tr>
<td>52</td>
<td><a href="#what-are-the-advantages-of-react">React의 장점은?</a></td>
</tr>
<tr>
<td>53</td>
<td><a href="#what-are-the-limitations-of-react">React의 한계는?</a></td>
</tr>
<tr>
<td>54</td>
<td><a href="#what-are-error-boundaries-in-react-v16">React v16에서 error boundaries는?</a></td>
</tr>
<tr>
<td>55</td>
<td><a href="#how-error-boundaries-handled-in-react-v15">React v15에서 error boundaries는?</a></td>
</tr>
<tr>
<td>56</td>
<td><a href="#what-are-the-recommended-ways-for-static-type-checking">정적 타입 체킹을 하는 최선의 방법은?</a></td>
</tr>
<tr>
<td>57</td>
<td><a href="#what-is-the-use-of-react-dom-package">react-dom package의 쓰임새는?</a></td>
</tr>
<tr>
<td>58</td>
<td><a href="#what-is-the-purpose-of-render-method-of-react-dom">react-dom의 render 메서드의 목적?</a></td>
</tr>
<tr>
<td>59</td>
<td><a href="#what-is-reactdomserver">ReactDOMServer란?</a></td>
</tr>
<tr>
<td>60</td>
<td><a href="#how-to-use-innerhtml-in-react">React에서 InnerHtml를 쓰는 방법은?</a></td>
</tr>
<tr>
<td>61</td>
<td><a href="#how-to-use-styles-in-react">React에서 스타일을 쓰는 방법은?</a></td>
</tr>
<tr>
<td>62</td>
<td><a href="#how-events-are-different-in-react">React에서 이벤트는 어떻게 다른가?</a></td>
</tr>
<tr>
<td>63</td>
<td><a href="#what-will-happen-if-you-use-setstate-in-constructor">constructor에서 setState를 쓴다면?</a></td>
</tr>
<tr>
<td>64</td>
<td><a href="#what-is-the-impact-of-indexes-as-keys">index를 키로 쓸 경우 어떤 일이 벌어지는가?</a></td>
</tr>
<tr>
<td>65</td>
<td><a href="#is-it-good-to-use-setstate-in-componentwillmount-method">componentWillMount() method안에서 setState()를 쓰는 것이 바람직한가?</a></td>
</tr>
<tr>
<td>66</td>
<td><a href="#what-will-happen-if-you-use-props-in-initial-state">initial state에서 props를 쓰면 어떻게 되는가?</a></td>
</tr>
<tr>
<td>67</td>
<td><a href="#how-do-you-conditionally-render-components">어떻게 조건부로 컴포넌트를 렌더링하는가?</a></td>
</tr>
<tr>
<td>68</td>
<td><a href="#why-we-need-to-be-careful-when-spreading-props-on-dom-elements">DOM 엘리먼트에서 스프레드 props를 쓸 때 주의해야 할 점은?</a></td>
</tr>
<tr>
<td>69</td>
<td><a href="#how-you-use-decorators-in-react">React에서 decorator를 쓰는 방법은?</a></td>
</tr>
<tr>
<td>70</td>
<td><a href="#how-do-you-memoize-a-component">컴포넌트를 메모이제이션 하는 법은?</a></td>
</tr>
<tr>
<td>71</td>
<td><a href="#how-you-implement-server-side-rendering-or-ssr">서버사이드렌더링을 하는 방법은?</a></td>
</tr>
<tr>
<td>72</td>
<td><a href="#how-to-enable-production-mode-in-react">React에서 프로덕션 모드를 키는 방법은?</a></td>
</tr>
<tr>
<td>73</td>
<td><a href="#what-is-cra-and-its-benefits">CRA는 무엇이고 이점은 무엇인가?</a></td>
</tr>
<tr>
<td>74</td>
<td><a href="#what-is-the-lifecycle-methods-order-in-mounting">마운팅시 라이프사이클 메서드의 순서는?</a></td>
</tr>
<tr>
<td>75</td>
<td><a href="#what-are-the-lifecycle-methods-going-to-be-deprecated-in-react-v16">React v16에서 deprecated된 라이프 사이클 메서드는?</a></td>
</tr>
<tr>
<td>76</td>
<td><a href="#what-is-the-purpose-of-getderivedstatefromprops-lifecycle-method">getDerivedStateFromProps() 의 목적은?</a></td>
</tr>
<tr>
<td>77</td>
<td><a href="#what-is-the-purpose-of-getsnapshotbeforeupdate-lifecycle-method">getSnapshotBeforeUpdate()의 목적은?</a></td>
</tr>
<tr>
<td>78</td>
<td><a href="#do-hooks-replace-render-props-and-higher-order-components">Hooks api가 render props와 HOC를 대체하는가?</a></td>
</tr>
<tr>
<td>79</td>
<td><a href="#what-is-the-recommended-way-for-naming-components">네이밍 컴포넌트를 위한 최상의 방법은?</a></td>
</tr>
<tr>
<td>80</td>
<td><a href="#what-is-the-recommended-ordering-of-methods-in-component-class">컴포넌트 클래스에서 메소더의 순서를 정하는 방법은?</a></td>
</tr>
<tr>
<td>81</td>
<td><a href="#what-is-a-switching-component">스위칭 컴포넌트란 무엇인가?</a></td>
</tr>
<tr>
<td>82</td>
<td><a href="#why-we-need-to-pass-a-function-to-setstate">왜 setState에 함수를 넘겨야 하는가?</a></td>
</tr>
<tr>
<td>83</td>
<td><a href="#what-is-strict-mode-in-react">React에서 strict mode란 무엇인가?</a></td>
</tr>
<tr>
<td>84</td>
<td><a href="#what-are-react-mixins">React 믹스인이란?</a></td>
</tr>
<tr>
<td>85</td>
<td><a href="#why-is-ismounted-an-anti-pattern-and-what-is-the-proper-solution">왜 isMounted()가 안티패턴이고, 이를 위한 올바른 해결책이 무엇인가?</a></td>
</tr>
<tr>
<td>86</td>
<td><a href="#what-are-the-pointer-events-supported-in-react">React에서 지원하는 포인터 이벤트는 무엇인가?</a></td>
</tr>
<tr>
<td>87</td>
<td><a href="#why-should-component-names-start-with-capital-letter">왜 컴포넌트 명은 대문자로 시작해야 하는가?</a></td>
</tr>
<tr>
<td>88</td>
<td><a href="#are-custom-dom-attributes-supported-in-react-v16">React v16에서 커스텀 DOM 속성을 지원하는가?</a></td>
</tr>
<tr>
<td>89</td>
<td><a href="#what-is-the-difference-between-constructor-and-getinitialstate">constructor와 getInitialState의 차이점은?</a></td>
</tr>
<tr>
<td>90</td>
<td><a href="#can-you-force-a-component-to-re-render-without-calling-setstate">setState를 호출하지 않고 강제로 컴포넌트를 리렌더링하는 방법은?</a></td>
</tr>
<tr>
<td>91</td>
<td><a href="#what-is-the-difference-between-super-and-superprops-in-react-using-es6-classes">React에서 es6클래스를 쓸 때 super()와 super(props)의 차이점은?</a></td>
</tr>
<tr>
<td>92</td>
<td><a href="#how-to-loop-inside-jsx">JSX에서 반복문을 도는 방법은?</a></td>
</tr>
<tr>
<td>93</td>
<td><a href="#how-do-you-access-props-in-attribute-quotes">HTML속성에서 props에 접근하는 방법은?</a></td>
</tr>
<tr>
<td>94</td>
<td><a href="#what-is-react-proptype-array-with-shape">React의 Prop array에 특정형식의 array를 넘기는 방법은?</a></td>
</tr>
<tr>
<td>95</td>
<td><a href="#how-to-conditionally-apply-class-attributes">조건부로 클래스 속성을 추가하는 방법은?</a></td>
</tr>
<tr>
<td>96</td>
<td><a href="#what-is-the-difference-between-react-and-reactdom">React과 ReactDOM의 차이는?</a></td>
</tr>
<tr>
<td>97</td>
<td><a href="#why-reactdom-is-separated-from-react">왜 React-DOM은 React에서 분리되었는가?</a></td>
</tr>
<tr>
<td>98</td>
<td><a href="#how-to-use-react-label-element">React 라벨 엘리먼트를 사용하는 방법은?</a></td>
</tr>
<tr>
<td>99</td>
<td><a href="#how-to-combine-multiple-inline-style-objects">여러개의 인라인 스타일을 한꺼번에 쓰는 방법은?</a></td>
</tr>
<tr>
<td>100</td>
<td><a href="#how-to-re-render-the-view-when-the-browser-is-resized">브라우저 리사이즈 시 뷰를 리렌더링하는 방법은?</a></td>
</tr>
<tr>
<td>101</td>
<td><a href="#what-is-the-difference-between-setstate-and-replacestate-methods">setState와 replaceState의 차이점은?</a></td>
</tr>
<tr>
<td>102</td>
<td><a href="#how-to-listen-to-state-changes">state의 변경을 listen하는 방법은?</a></td>
</tr>
<tr>
<td>103</td>
<td><a href="#what-is-the-recommended-approach-of-removing-an-array-element-in-react-state">React state에서 배열의 특정 엘리먼트를 지우는 올바른 방법은?</a></td>
</tr>
<tr>
<td>104</td>
<td><a href="#is-it-possible-to-use-react-without-rendering-html">HTML 렌더링 없이 React를 사용하는 방법은?</a></td>
</tr>
<tr>
<td>105</td>
<td><a href="#how-to-pretty-print-json-with-react">React에서 json을 pretty하게 프린트 하는 방법은?</a></td>
</tr>
<tr>
<td>106</td>
<td><a href="#why-you-cant-update-props-in-react">왜 React에서 props를 업데이트 하지 못하는가?</a></td>
</tr>
<tr>
<td>107</td>
<td><a href="#how-to-focus-an-input-element-on-page-load">페이지 로딩 중에 input 엘리먼트에 포커스를 주는 방법은?</a></td>
</tr>
<tr>
<td>108</td>
<td><a href="#what-are-the-possible-ways-of-updating-objects-in-state">state에 있는 객체를 업데이트하는 방법은?</a></td>
</tr>
<tr>
<td>109</td>
<td><a href="#why-function-is-preferred-over-object-for-setstate">왜 setState()에 object보다 function이 더 나은가?</a></td>
</tr>
<tr>
<td>110</td>
<td><a href="#how-can-we-find-the-version-of-react-at-runtime-in-the-browser">브라우저에서 React 런타임의 버전을 알아내는 방법은?</a></td>
</tr>
<tr>
<td>111</td>
<td><a href="#what-are-the-approaches-to-include-polyfills-in-your-create-react-app">CTA에서 폴리필을 추가하는 일반적인 방법은?</a></td>
</tr>
<tr>
<td>112</td>
<td><a href="#how-to-use-https-instead-of-http-in-create-react-app">CTA에서 http대신 https를 쓰는 법은?</a></td>
</tr>
<tr>
<td>113</td>
<td><a href="#how-to-avoid-using-relative-path-imports-in-create-react-app">CTA에서 상대경로 import를 피하는 방법은?</a></td>
</tr>
<tr>
<td>114</td>
<td><a href="#how-to-add-google-analytics-for-react-router">React 라우터에 구글 애널리틱스를 붙이는 방법은?</a></td>
</tr>
<tr>
<td>115</td>
<td><a href="#how-to-update-a-component-every-second">매 초마다 컴포넌트를 업데이트 하는 방법은?</a></td>
</tr>
<tr>
<td>116</td>
<td><a href="#how-do-you-apply-vendor-prefixes-to-inline-styles-in-react">React에서 인라인 스타일로 vendor prefixes를 붙이는 방법은?</a></td>
</tr>
<tr>
<td>117</td>
<td><a href="#how-to-import-and-export-components-using-react-and-es6">React와 ES6를 활용해서 컴포넌트를 import &amp; export 하는 방법은?</a></td>
</tr>
<tr>
<td>118</td>
<td><a href="#what-are-the-exceptions-on-react-component-naming?">React 컴포넌트 명에서 주의해야 할 점은?</a></td>
</tr>
<tr>
<td>119</td>
<td><a href="#why-is-a-component-constructor-called-only-once">왜 컴포넌트 생성자는 단 한번만 호출되는가?</a></td>
</tr>
<tr>
<td>120</td>
<td><a href="#how-to-define-constants-in-react">React에서 상수를 선언하는 방법은?</a></td>
</tr>
<tr>
<td>121</td>
<td><a href="#how-to-programmatically-trigger-click-event-in-react">React에서는 어떻게 클릭이벤트가 트리거 되는가?</a></td>
</tr>
<tr>
<td>122</td>
<td><a href="#is-it-possible-to-use-asyncawait-in-plain-react">React에서 async await을 쓰는 것이 가능한가?</a></td>
</tr>
<tr>
<td>123</td>
<td><a href="#what-are-the-common-folder-structures-for-react">React의 일반적인 디렉토리 구조는?</a></td>
</tr>
<tr>
<td>124</td>
<td><a href="#what-are-the-popular-packages-for-animation">유명한 애니메이션을 위한 패키지는?</a></td>
</tr>
<tr>
<td>125</td>
<td><a href="#what-is-the-benefit-of-styles-modules">style 모듈의 이점은 무엇인가?</a></td>
</tr>
<tr>
<td>126</td>
<td><a href="#what-are-the-popular-react-specific-linters">React에 특화된 linter엔 무엇이 있는가?</a></td>
</tr>
<tr>
<td>127</td>
<td><a href="#how-to-make-ajax-call-and-in-which-component-lifecycle-methods-should-i-make-an-ajax-call">Ajax call은 어떻게 만들고, 어느 라이프사이클 메소드에서 실행해야 하는가?</a></td>
</tr>
<tr>
<td>128</td>
<td><a href="#what-are-render-props">render props란 무엇인가?</a></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="core-react"><a class="header-anchor" href="#core-react">¶</a>Core React</h2>
<h3 id="what-is-react"><a class="header-anchor" href="#what-is-react">¶</a>What is React</h3>
<p>리액트는 오픈소스 프론트엔드 자바스크립트 라이브러리로, 특히 싱글 페이지 어플리케이션의 사용자 인터페이스 구축을 위해 사용된다. 웹가 모바일 앱의 뷰단을 다르기 위하여 사용되고 있다. 리액트는 페이스북에서 일아흔 Jordan Walke가 만들었다. 최초로 리액트 기반으로 만들어진 서비스는 2011년에 페이스북 뉴스 피드이며, 2012년에는 인스타그램도 리액트로 만들어 졌다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-major-features-of-react"><a class="header-anchor" href="#what-are-the-major-features-of-react">¶</a>What are the major features of React?</h3>
<p>리액트의 주요 기능은 무엇인가?</p>
<ul>
<li>RealDOM을 조작하는데 많은 비용이 소모되어 대신 VirtualDOM을 활용하고 있다.</li>
<li>서버사이드렌더링을 지원한다</li>
<li>단방향 데이터흐름 또는 단방향 데이터 바인딩을 따른다</li>
<li>뷰를 개발하는데 있어 재사용 가능한 컴포넌트 사용</li>
</ul>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-jsx"><a class="header-anchor" href="#what-is-jsx">¶</a>What is JSX?</h3>
<p>JSX는 ECMA Script의 XML 신택스 확장 표기법이다. (Javascript XML의 약자다.) 기본적으로, <code>React.createElement()</code>함수에 문법 슈가를 제공하며,HTML 스타일의 템플릿 구문화함께 javascript를 표현할 수 있다.</p>
<p>아래 예제에서, <code>return</code>안에 있는 <code>&lt;h1&gt;</code> 구문이 자바스크립트 함수의 render function 으로 제공된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="string">"Welcome to React world!"</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-difference-between-element-and-component"><a class="header-anchor" href="#what-is-the-difference-between-element-and-component">¶</a>What is the difference between Element and Component?</h3>
<p><code>element</code>는 DOM노드나 컴포넌트 단에서 화면에 보여주고 싶은 요소를 그리는 하나의 오브젝트를 의미한다. <code>element</code>는 <code>element</code>의 props에서 포함될 수 있다. 리액트에서 <code>element</code>를 만드는건 많은 비용이 들지 않는다. 한번 만들고 나면, 더이상 변경이 불가능하다.</p>
<p>리액트에서 <code>element</code>를 만드는 예시는 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(<span class="string">"div"</span>, &#123; <span class="attr">id</span>: <span class="string">"login-btn"</span> &#125;, <span class="string">"Login"</span>);</span><br></pre></td></tr></table></figure>
<p>위 함수는 아래와 같은 object를 리턴한다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: <span class="string">'div'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    children: <span class="string">'Login'</span>,</span><br><span class="line">    id: <span class="string">'login-btn'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그리고 <code>ReactDOM.render()</code>이 아래와 같은 DOM을 만들어 줄 것이다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"login-btn"</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>반면에 컴포넌트는 다양한 방식으로 선언가능하다. 컴포넌트는 <code>render()</code>와 함께 쓴다면 클래스가 될 수도 있다. 좀더 단순한 방법으로, 함수로도 선언이 될 수 있다. 두 방식 모두 <code>props</code>를 input으로 받으며, <code>JSX</code>를 리턴한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">&#123; onLogin &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div id=&#123;<span class="string">"login-btn"</span>&#125; onClick=&#123;onLogin&#125;&gt;</span><br><span class="line">    Login</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>JSX는 이를 <code>React.createElement()</code> 함수로 트랜스파일 시킬 것이다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Button = (&#123; onLogin &#125;) =&gt; React.createElement( 'div', &#123; id: 'login-btn',</span><br><span class="line">onClick: onLogin &#125;, 'Login' )</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-create-components-in-react"><a class="header-anchor" href="#how-to-create-components-in-react">¶</a>How to create components in React?</h3>
<p>두 가지 방법이 존재한다.</p>
<ol>
<li>함수형 컴포넌트: 컴포넌트를 만드는 가장 심플한 방식이다. <code>props</code>를 첫번째 파라미터로 받는 받는 순수 자바스크립트 함수를 만들고, React Element를 반환하면 된다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">&#123; message &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello, $&#123;message&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>클래스 컴포넌트: ES6의 클래스를 활용하여 컴포넌트를 정의할 수도 있다. 위 컴포넌트를 클래스 컴포넌트로 바꾼다면 이렇게 될 것이다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello, $&#123;this.props.message&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="when-to-use-a-class-component-over-a-function-component"><a class="header-anchor" href="#when-to-use-a-class-component-over-a-function-component">¶</a>When to use a Class Component over a Function Component?</h3>
<p>컴포넌트가 <strong>state나 라이프 사이클 메소드를</strong> 필요로 할 때 클래스 컴포넌트를, 그렇지 않으면 함수형 컴포넌트를 활용하면 된다.</p>
<blockquote>
<p>근데 요즘은 <code>useState</code>을 사용하면 함수형 컴포넌트에서도 state사용이 가능하다</p>
</blockquote>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-pure-components"><a class="header-anchor" href="#what-are-pure-components">¶</a>What are Pure Components?</h3>
<p><code>React.PureComponent</code>는 <code>React.Component</code>에서 <code>shouldComponentUpdate</code>가 없다는 것만 제외하면 동일하다. <code>props</code>나 <code>state</code>에 변화가 있을 경우, <code>PureComponent</code>는 두 변수에 대해서 <a href="https://reactjs.org/docs/shallow-compare.html" target="_blank" rel="noopener">얕은 비교</a>를 한다. 반면 <code>Component</code>는 그런 비교를 하지 않는다. 따라서 <code>Component</code>는 <code>shouldComponentUpdate</code>가 호출 될 때마다 다시 render한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-state-in-react"><a class="header-anchor" href="#what-is-state-in-react">¶</a>What is state in React?</h3>
<p><code>state</code>란 컴포넌트가 살아있는 동안에 걸쳐 변화할 수도 있는 값을 가지고 있는 object다. 따라서 state를 가능한 간단하게, 그리고 state의 구성요소를 최소화하는 노력을 기울여야 한다. 다음은 User Component에 message state를 관리하는 예제다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      message: <span class="string">"Welcome to React world"</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="keyword">this</span>.state.message&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>state</code>는 <code>props</code>와 비슷하지만, 컴포넌트가 완전히 소유권을 쥐고 있다는 것이 다르다.다른 어떤 컴포넌트도 한 컴포넌트가 소유하고 있는 <code>state</code>에 접근할 수 없다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-props-in-react"><a class="header-anchor" href="#what-are-props-in-react">¶</a>What are props in React?</h3>
<p><code>props</code>는 컴포넌트의 input 값이다. HTML 태그 속성과 유사한 규칙을 사용하여 ReactComponent에 전달할 수 있는 단일 값 또는 객체 다. 이런 데이터 들은 부모 컴포넌트에서 자식 컴포넌트로 보낼 수 있다.</p>
<p>리액트에서 <code>props</code>를 쓰는 주요 목적은 컴포넌트에 아래와 같은 기능을 제공하기 위해서다.</p>
<ul>
<li>컴포넌트에 custom data를 넘기기 위해</li>
<li><code>state</code>의 변화를 trigger 하기 위해</li>
<li>Component의 render메소드 안에서 this.props.*** 로 사용하기 위함</li>
</ul>
<p>예를 들어, <code>reactProp</code> 을 만들어서 쓴다고 가정해 보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Element reactProp=&#123;<span class="string">"1"</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p><code>reactProp</code>은 (뭐라고 정의했던 지 간에) React를 사용하여 생성된 component에서 접근이 가능하고, React native props에서 접근하여 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.reactProp;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-difference-between-state-and-props"><a class="header-anchor" href="#what-is-the-difference-between-state-and-props">¶</a>What is the difference between state and props?</h3>
<p><code>props</code>와 <code>state</code>는 모두 순수 자바스크립트 오브젝트다. 두 객체 모두 <code>render</code>의 output에 영향을 줄 수 있는 정보를 가지고 있지만, 컴포넌트의 기능적인 측면에서는 약간 다르다. <code>props</code>는 함수의 파라미터와 비슷한 방식으로 작동하는 반면, <code>state</code>는 컴포넌트 내에서 선언된 변수와 비슷하다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-should-we-not-update-the-state-directly"><a class="header-anchor" href="#why-should-we-not-update-the-state-directly">¶</a>Why should we not update the state directly?</h3>
<p><code>state</code>를 아래와 같이 바로 업데이트 하면 렌더링이 일어나지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.message = <span class="string">"Hello world"</span>;</span><br></pre></td></tr></table></figure>
<p>대신에 <code>setState()</code> 메서드를 사용하자.이는 <code>state</code>의 변경이 있을 때 <code>component</code>를 업데이트 해준다. <code>state</code>에 변화가 있을 경우, 컴포넌트는 리렌더링으로 응답한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">message</span>: <span class="string">"Hello World"</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>주의: state를 직접 할당할 수 있는 곳은 <code>constructor</code> 혹은 자바스크립트 클래스의 필드를 선언하는 syntax 뿐이다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-purpose-of-callback-function-as-an-argument-of-setstate"><a class="header-anchor" href="#what-is-the-purpose-of-callback-function-as-an-argument-of-setstate">¶</a>What is the purpose of callback function as an argument of <code>setState()</code>?</h3>
<p>콜백함수는 setState가 끝나고 컴포넌트가 렌더링 된 이후에 실행된다.<code>setState</code>는 비동기로 이루어지기 때문에 callback에서는 어떤 액션이든 취할 수 있다.</p>
<p>주의: 콜백함수를 사용하는 것보다 라이프사이클 메서드를 사용하는게 더 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setState(&#123; <span class="attr">name</span>: <span class="string">"John"</span> &#125;, () =&gt;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The name has updated and component re-rendered"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="what-is-the-difference-between-html-and-react-event-handling"><a class="header-anchor" href="#what-is-the-difference-between-html-and-react-event-handling">¶</a>What is the difference between HTML and React event handling?</h3>
<ol>
<li>HTML에서는 이벤트명은 소문자로 작성되어야 한다.</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"activateLasers()"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>React는 camelCase를 사용한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">"&#123;activateLasers&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>HTML에서는, <code>false</code>를 리턴하면 이후 기본 액션을 막을 수 있다.</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">'console.log("The link was clicked."); return false;'</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>하지만 react에서는 <code>preventDefault()</code>를 명시적으로 사용해야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"The link was clicked."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="how-to-bind-methods-or-event-handlers-in-jsx-callbacks"><a class="header-anchor" href="#how-to-bind-methods-or-event-handlers-in-jsx-callbacks">¶</a>How to bind methods or event handlers in JSX callbacks?</h3>
<ol>
<li>생성자에서 바인딩하기: 자바스크립트 클래스에서는, 메소드들이 기본적으로 바인딩 되어 있지 않다. 이는 클래스 메서드로 정의된 리액트 이벤트 핸들러와 마찬가지다. 보통, 생성자에서 바인딩한다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Componenet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>퍼블리기 클래스 필드 구문: 생성자에서 바인딩 되기를 원치 않는다면, 퍼블릭 클래스의 필드 구문을 이용하여 callback을 올바르게 바인딩 할 수 있다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"this is:"</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt; Click me &lt;<span class="regexp">/button&gt;;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>클래스 필드(class field)<br>
클래스 내부의 캡슐화된 변수를 말한다. 데이터 멤버 또는 멤버 변수라고도 부른다. 클래스 필드는 인스턴스의 프로퍼티 또는 정적 프로퍼티가 될 수 있다. 쉽게 말해, 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티를 클래스 기반 객체지향 언어에서는 클래스 필드라고 부른다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  name = <span class="string">""</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>constructor 내부에서 선언한 클래스 필드는 클래스가 생성할 인스턴스를 가리키는 this에 바인딩한다. 이로써 클래스 필드는 클래스가 생성할 인스턴스의 프로퍼티가 되며, 클래스의 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. 즉, 언제나 public이다.<br>
ES6의 클래스는 다른 객체지향 언어처럼 private, public, protected 키워드와 같은 접근 제한자(access modifier)를 지원하지 않는다.</p>
</blockquote>
<ol start="3">
<li>화살표함수: 콜백에 화살표 함수를 사용할 수도 있다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;event =&gt; <span class="keyword">this</span>.handleClick(event)&#125;&gt;&#123;<span class="string">"Click me"</span>&#125;&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>주의: 콜백이 하위 컴포넌트에 <code>prop</code>으로 전달된다면, component가 리렌더링 될 수도 있다. 이러한 경우에는, 성능을 고려해서 1, 2번의 예제를 활용하는 것이 낫다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-pass-a-parameter-to-an-event-handler-or-callback"><a class="header-anchor" href="#how-to-pass-a-parameter-to-an-event-handler-or-callback">¶</a>How to pass a parameter to an event handler or callback?</h3>
<p>이벤트 핸들러와 파라미터 전달을ㅇ 화살표 함수로 감쌀 수 있다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick(id)&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>이는 <code>.bind</code>와 같다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">"&#123;this.handleClick.bind(this,"</span> <span class="attr">id</span>)&#125; /&gt;</span></span><br></pre></td></tr></table></figure>
<p>두 방식 이외에도, 아래와 같은 배열 함수 방식으로 정의해서 전달할 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick(id)&#125; /&gt;;</span><br><span class="line">handleClick = <span class="function"><span class="params">id</span> =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, your ticket number is"</span>, id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-synthetic-events-in-react"><a class="header-anchor" href="#what-are-synthetic-events-in-react">¶</a>What are synthetic events in React?</h3>
<p>synthetic event (합성함수) 는 브라우저의 네이티브 이벤트를 위한 크로스 브라우저 래퍼다. 이 api는 브라우저의 네이티브 이벤트와 동일하며, 마찬가지로 <code>stopPropagation()</code> <code>preventDefault()</code>도 포함하고 있지만, 모든 브라우저에서 동일하게 작동한다는 점이 다르다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-inline-conditional-expressions"><a class="header-anchor" href="#what-is-inline-conditional-expressions">¶</a>What is inline conditional expressions?</h3>
<p>조건부 렌더 표현을 위해 javascript의 if문이나 삼항연산자를 사용할 수 있다. 이외에도 중괄호로 묶어서 javascript의 논리식인 &amp;&amp;을 붙여서 jsx에서도 사용할 수 있다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">; &#123; messages.length &gt; 0 &amp;&amp; !isLogin ? (</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>You have &#123;messages.length&#125; unread messages.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">) : (</span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>You don't have unread messages.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">); &#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-key-props-and-what-is-the-benefit-of-using-them-in-arrays-of-elements"><a class="header-anchor" href="#what-are-key-props-and-what-is-the-benefit-of-using-them-in-arrays-of-elements">¶</a>What are “key” props and what is the benefit of using them in arrays of elements?</h3>
<p><code>key</code>는 특별한 string 속성으로, 배열을 사용할 때 이용해야 한다. <code>key</code>는 리액트에서 어떤 item이 변화하고, 추가되고, 삭제되었는지 구별하는데 도움을 준다. 대부분 key로 id를 사용한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map(todo =&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"&#123;todo.id&#125;"</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>만약 이런 ID가 없다면, index를 사용할 수 있다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo, index) =&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">"&#123;index&#125;"</span>&gt;</span></span><br><span class="line">  &#123;todo.text&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>주의</p>
<ol>
<li>index를 key로 사용하는 방식은, 아이템의 순서가 바뀌는 경우가 발생할 수 있는 케이스에는 별로 추천할만하지 못하다. 이는 퍼포먼스에 악영향을 미치고, component state에 악영향을 미칠 수 있다.</li>
<li>list를 별도 컴포넌트로 뽑아서 사용하는 경우, key를 리스트 컴포넌트가 아닌 <code>li</code> 태그에 사용해야 한다.</li>
<li>리스트 아이템에 <code>key</code>가 없으면 콘솔에 경고 메시지가 뜬다.</li>
</ol>
<h3 id="what-is-the-use-of-refs"><a class="header-anchor" href="#what-is-the-use-of-refs">¶</a>What is the use of refs?</h3>
<p><code>ref</code>는 element의 참조값을 반환한다. 대부분 이러한 경우는 피해야 하지만, DOM이나 component에 다이렉트로 접근해야할 때 유용하다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-create-refs"><a class="header-anchor" href="#how-to-create-refs">¶</a>How to create refs?</h3>
<ol>
<li>최근에 추가된 방식으로, <code>React.createRef()</code> 메소들를 사용하면, React element는 <code>ref</code>를 통해서 접근할 수 있다. <code>ref</code>를 컴포넌트에서 접근하기 위해서는, 생성자 안에 <code>ref</code>를 instance property로 할당하면 된다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.myRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>React 버전과 상관없이 ref 콜백을 활용하는 방식이 있다. 예를 들어, SearchBar 컴포넌트의 인풋 요소들은 아래와 같은 방식으로 접근 가능하다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchBar</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.txtSearch = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">term</span>: <span class="string">""</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>.setInputSearchRef = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.txtSearch = e;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  onInputChange(event) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">term</span>: <span class="keyword">this</span>.txtSearch.value &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input</span><br><span class="line">        value=&#123;<span class="keyword">this</span>.state.term&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>.onInputChange.bind(<span class="keyword">this</span>)&#125;</span><br><span class="line">        ref=&#123;<span class="keyword">this</span>.setInputSearchRef&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>또한 컴포넌트의 함수 내에서 클로져를 <code>ref</code>를 사용할 수도 있다.</p>
<p>주의: 추천할만한 방법은 아니지만, 인라인 <code>ref</code> callback을 이용하는 방식도 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-forward-refs"><a class="header-anchor" href="#what-are-forward-refs">¶</a>What are forward refs?</h3>
<p>Ref forwarding은 일부 컴포넌트에서 ref를 받아서 자식 컴포넌트에게 전달하는 것을 의미한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ButtonElement = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  &lt;button ref=&#123;ref&#125; className=<span class="string">"CustomButton"</span>&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Create ref to the DOM button:</span></span><br><span class="line"><span class="regexp">const ref = React.createRef();</span></span><br><span class="line"><span class="regexp">&lt;ButtonElement ref=&#123;ref&#125;&gt;&#123;"Forward Ref"&#125;&lt;/</span>ButtonElement&gt;;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="which-is-preferred-option-with-in-callback-refs-and-finddomnode"><a class="header-anchor" href="#which-is-preferred-option-with-in-callback-refs-and-finddomnode">¶</a>Which is preferred option with in callback refs and findDOMNode()?</h3>
<p>callback ref를 쓰는 것이 더 선호된다. 왜냐하면 <code>findDOMNode()</code>는 향후에 있을 리액트의 개선사항이 반영되지 않기 때문이다.</p>
<p>레거시에서 <code>findDOMNode</code>를 사용하는 방법이 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    findDOMNode(<span class="keyword">this</span>).scrollIntoView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>그래서 선호하는 방법은 다음과 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.node = createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.node.current.scrollIntoView();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.node&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-are-string-refs-legacy"><a class="header-anchor" href="#why-are-string-refs-legacy">¶</a>Why are String Refs legacy?</h3>
<p>예전에 React를 다뤄보았다면, 옛날 방식인 <code>ref</code>를 string으로 쓰는, <code>ref={'textInput'}</code> 와 같이 ref속성이 string이고, DOM Node인 <code>refs.textInput</code>로 접근하는 방법에 익숙할 것이다. 그러나 이러한 string ref는 하단에서 언급할 문제들 때문에, 레거시로 보는 것이 맞다. 그리고 string ref는 React v16에서 제거 되었다.</p>
<ol>
<li>String ref는 실행중인 component 요소를 추적하도록 강제한다. 그리고 React Module을 stateful하게 만들기 때문에, 이는 번들시 react module이 중복 되는 경우 이상한 오류를 발생시킨다.</li>
<li>라이브러리를 추가하여 String ref를 child component에 전달한다면, 사용자는 다른 ref를 추가할 수 없다. 그러나 callback ref를 사용하면 이런 문제를 해결할 수 있다.</li>
<li>Flow와 같은 정적 분석에서는 동작하지 않는다. Flow는 string ref를 this.refs와 같은 형태로 표시하도록 만드는 트릭을 추적할 수 없다. callback ref는 string ref보다 flow에 더 잘맞다.</li>
<li>대부분이 render callback 패턴으로 동작하기를 기대하지만, 그렇게 동작하지 않는다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  renderRow = <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 동작하지 않는다. ref는 MyComponent가 아닌 DataTable에 연결될 것이다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;</span>"<span class="attr">input-</span>" + <span class="attr">index</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    // 이거는 동작한다. callback ref가 짱이다.</span></span><br><span class="line">    return &lt;input ref=&#123;input =&gt; (this["input-" + index] = input)&#125; /&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;DataTable data=&#123;this.props.data&#125; renderRow=&#123;this.renderRow&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-virtual-dom"><a class="header-anchor" href="#what-is-virtual-dom">¶</a>What is Virtual DOM?</h3>
<p>Virtual DOM은 메모리 내에서 표현되는 Real DOM 이다. UI는 메모리 상에서 표현되며, 그리고 real DOM과 동기화 된다. 이는 렌더 함수 호출과 화면에 elements 표시 하는 사이에 일어난다. 이 모든 과정을 <code>reconciliation</code>이라고 한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-virtual-dom-works"><a class="header-anchor" href="#how-virtual-dom-works">¶</a>How Virtual DOM works?</h3>
<ol>
<li>
<p>어디서든 데이터가 편하면, Virtual DOM내에서 전체 UI가 다시 렌덜이 된다.<br>
<img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom1.png" alt="virtual-dom-1"></p>
</li>
<li>
<p>그런 다음 이전 DOM과 새로운 DOM을 비교한다.<br>
<img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom2.png" alt="virtual-dom-2"></p>
</li>
<li>
<p>계산이 끝나면, Real DOM 중에서 실제로 업데이트가 있었던 부분 만 변경을 가한다.<br>
<img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom3.png" alt="virtual-dom-3"></p>
</li>
</ol>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-difference-between-shadow-dom-and-virtual-dom"><a class="header-anchor" href="#what-is-the-difference-between-shadow-dom-and-virtual-dom">¶</a>What is the difference between Shadow DOM and Virtual DOM?</h3>
<p>Shadow DOM은 web component의 scope및 CSS scope 지정을 위해 설계된 web browser 기술이다. Virtual DOM은 브라우저 API 위에 자바스크립트에서 구현되는 개념이다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-react-fiber"><a class="header-anchor" href="#what-is-react-fiber">¶</a>What is React Fiber?</h3>
<p>Fiber는 React v16에서 새로운 reconciliation 엔진, 그리고 코어 알고리즘을 새로 작성한 것으로 볼 수 있다. React Fiber의 목적은 애니메이션, 레이아웃, 제스쳐, 작업일시정지 및 중단, 여려 유형의 업데이트 우선순위 조절, 동시성 등 여러가지 기본 사항에 대한 성능을 높이는 것이다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-main-goal-of-react-fiber"><a class="header-anchor" href="#what-is-the-main-goal-of-react-fiber">¶</a>What is the main goal of React Fiber?</h3>
<p>React Fiber 의 목표는 애니메이션, 레이아웃, 제스처등의 성능을 높이는 것이다. 렌더링 작업을 chunk별로 작업하고, 여러 프레임 별로 이를 펼치면서 작업하는 점진적 렌더링을 통해 이를 구현했다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-controlled-components"><a class="header-anchor" href="#what-are-controlled-components">¶</a>What are controlled components?</h3>
<p>입력요소를 제어하는 component를 controlled components라고 부른다. 모든 상태변경에 연관뢴 handler function이 존재한다.</p>
<p>예를 들어, 모든 이름을 대문자로 쓰기 위해서는, <code>handleChange</code>를 아래와 같이 쓰게 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange(event) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: event.target.value.toUpperCase()&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-uncontrolled-components"><a class="header-anchor" href="#what-are-uncontrolled-components">¶</a>What are uncontrolled components?</h3>
<p>uncontrolled components란 내부적으로 자기 자신의 state를 가지고 있는 component다. 현재 필요한 값을 찾기 위해 ref를 사용하여 DOM query를 할 수 있다. 이는 전통적인 HTML 과 비슷하다.</p>
<p><code>UserProfile</code> Component를 아래에서 보자면, <code>name</code> input이 ref를 통해서 접근할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProfile</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleSubmit = <span class="keyword">this</span>.handleSubmit.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.input = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(<span class="string">"A name was submitted: "</span> + <span class="keyword">this</span>.input.current.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          &#123;<span class="string">"Name:"</span>&#125;</span><br><span class="line">          &lt;input type=<span class="string">"text"</span> ref=&#123;<span class="keyword">this</span>.input&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="submit" value="Submit" /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>대부분의 경우, 폼에서는 controlled component를 사용하기를 추천한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-difference-between-createelement-and-cloneelement"><a class="header-anchor" href="#what-is-the-difference-between-createelement-and-cloneelement">¶</a>What is the difference between createElement and cloneElement?</h3>
<p>JSX는 <code>React.createElement()</code> 함수로 UI에 나타낼 React element를 생성한다. 반면 <code>cloneElement</code>는 element를 props로 보낼 때 사용한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-lifting-state-up-in-react"><a class="header-anchor" href="#what-is-lifting-state-up-in-react">¶</a>What is Lifting State Up in React?</h3>
<p>여러 component 들이 동일한 변경 데이터를 공유해야하는 경우 가까운 부모 component 로 state를 올리는 것이 좋다. 즉, 두개의 자식 component가 부모에 있는 동일한 데이터를 공유할 때. 두개의 자식 component 들은 local state를 유지하는 대신, 부모로 state를 올려야 한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-different-phases-of-component-lifecycle"><a class="header-anchor" href="#what-are-the-different-phases-of-component-lifecycle">¶</a>What are the different phases of component lifecycle?</h3>
<p>React lifecycle에는 세 개의 phase가 있다.</p>
<ol>
<li><code>mounting</code>: 컴포넌트가 browser DOM에 마운트 될 준비가 된 상태다. 이 phase에는 <code>constructor()</code> <code>getDerivedStateFromProps()</code> <code>render()</code> <code>componentDidMount()</code>가 있다</li>
<li><code>updating</code>: 이 단계에서는, 컴포넌트가 두가지 방법으로 업데이트 된다. 새로운 <code>props</code>를 보내거나, <code>setState()</code> <code>forceUpdate()</code>를 통해서 state를 업데이트 하는 방법이 있다. 이 단계에서는, <code>getDerivedStateFromProps()</code> <code>shouldComponentUpdate()</code> <code>render()</code> <code>getSnapshotBeforeUpdate()</code> <code>componentDidUpdate()</code> 가 포함된다.</li>
<li><code>unmounting</code>: 이단계에서는, browser DOM이 더 이 더이상 필요 없어지거나 unmount된다. 여기에는 <code>componentWillUnmount()</code>가 포함된다.</li>
</ol>
<p>DOM에서의 변경을 적용할 때, 내부에서 어떤 과정을 거치는지 알아볼 필요가 있다. 각 단계는 아래와 같다.</p>
<ol>
<li>
<p><code>Render</code> 컴포넌트가 어떠한 사이드 이펙트 없이 렌더링 된다. 이는 Pure Component에 적용되며, 이 단계에서는 일시정지, 중단, 렌더 재시작등이 가능하다.</p>
</li>
<li>
<p><code>Pre-commit</code>: 컴포넌트가 실제 변화를 DOM에 반영하기 전에, 리액트가 DOM을 <code>getSnapshotBeforeUpdate()</code> 통해서 DOM 을 읽을 수도 있다.</p>
</li>
<li>
<p><code>Commit</code>: React는 DOM과 함꼐 작동하며, 각각의 라이프 사이클 마지막에 실행되는 것들이 포함된다. <code>componentDidMount()</code> <code>componentDidUpdate()</code> <code>componentWillUnmount()</code></p>
<p>16.3 이후</p>
</li>
</ol>
<p><img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/phases16.3.jpg?raw=true" alt="react-16.3-phases"></p>
<p>16.3 이전</p>
<p><img src="https://github.com/sudheerj/reactjs-interview-questions/blob/master/images/phases.png?raw=true" alt="before-react-16.3"></p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-lifecycle-methods-of-react"><a class="header-anchor" href="#what-are-the-lifecycle-methods-of-react">¶</a>What are the lifecycle methods of React?</h3>
<p>React 16.3+</p>
<ul>
<li><code>getDerivedStateFromProps</code>: 모든 <code>render()</code>가 실행되기 바로 직전에 호출된다. props의 변화의 결과로 내부 state 변화를 가능하게 해주는 메서드로, 굉장히 드물게 사용된다.</li>
<li><code>componentDidMount</code>: 첫렌더링이 다 끝나고, 모든 ajax 요청이 완료, DOM이나 state 변화, 그리고 이벤트 리스너가 모두 설정된 다음에 호출된다.</li>
<li><code>shouldComponentUpdate</code>: 컴포넌트가 업데이트 될지 말지를 결정한다. default로 true를 리턴한다. 만약 state나 props 업데이트 이후에 컴포넌트가 업데이트 될 필요가 없다고 생각한다면, false를 리턴하면 된다. 컴포넌트가 새로운 props를 받은 후에, 리 렌더링을 방지해서 성능을 향상시키기에 가장 좋은 위치다.</li>
<li><code>getSnapshotBeforeUpdate</code>: 렌더 결과물이 DOM에 커밋되기 직전에 호출된다. 여기서 리턴된 모든 값은 <code>componentDidUpdate()</code>로 넘겨진다. 스크롤 포지션 등, DOM에서 필요한 정보를 사용할 때 유용하다.</li>
<li><code>componentDidUpdate</code>: prop/state의 변화d의 응답으로 DOM을 업데이트 할 때 필요하다. 이 메소드는 만약 <code>shouldComponentUpdate()</code>가 <code>false</code>를 리턴하면 호출되지 않는다.</li>
<li><code>componentWillUnmount</code>: 네트워크 요청을 취소하거나, 컴포넌트와 관련된 이벤트 리스너를 삭제할 때 쓰인다.</li>
</ul>
<blockquote>
<p>before 16.3은 따로 번역하지 않겠습니다.</p>
</blockquote>
<ul>
<li><code>componentWillMount</code>: Executed before rendering and is used for App level configuration in your root component.</li>
<li><code>componentDidMount</code>: Executed after first rendering and here all AJAX requests, DOM or state updates, and set up event listeners should occur.<br>
componentWillReceiveProps: Executed when particular prop updates to trigger state transitions.</li>
<li><code>shouldComponentUpdate</code>: Determines if the component will be updated or not. By default it returns true. If you are sure that the component doesn’t need to render after state or props are updated, you can return false value. It is a great place to improve performance as it allows you to prevent a re-render if component receives new prop.</li>
<li><code>componentWillUpdate</code>: Executed before re-rendering the component when there are props &amp; state changes confirmed by shouldComponentUpdate() which returns true.</li>
<li><code>componentDidUpdate</code>: Mostly it is used to update the DOM in response to prop or state changes.</li>
<li><code>componentWillUnmount</code>: It will be used to cancel any outgoing network requests, or remove all event listeners associated with the component.</li>
</ul>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-higher-order-components"><a class="header-anchor" href="#what-are-higher-order-components">¶</a>What are Higher-Order Components?</h3>
<p>Higher-order Component (이하 HOC)는 컴포넌트를 받아서 새로운 컴포넌트를 리턴하는 컴포넌트다. 기본적으로, 이러한 패턴은 리액트의 컴포넌트적인 특성에서 유래되었다.</p>
<p>이를 <code>Pure Component</code>라고 부르는데, 동적으로 제공되는 하위 component를 그대로 사용하지만, 입력받은 component를 수정/복사하지 않기 때문이다.</p>
<p>HOC는 아래와 같은 use case에서 사용할 수 있다.</p>
<ul>
<li>코드 재사용, 로직 추상화</li>
<li>render 하이재킹</li>
<li>state 추상화 또는 조작</li>
<li>props 조작</li>
</ul>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-create-props-proxy-for-hoc-component"><a class="header-anchor" href="#how-to-create-props-proxy-for-hoc-component">¶</a>How to create props proxy for HOC component?</h3>
<p><code>props proxy pattern</code>을 아래와 같이 사용한다면, 컴포넌트에 넘겨진 props를 추가/수정할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        title: <span class="string">"New Header"</span>,</span><br><span class="line">        footer: <span class="literal">false</span>,</span><br><span class="line">        showFeatureX: <span class="literal">false</span>,</span><br><span class="line">        showFeatureY: <span class="literal">true</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-context"><a class="header-anchor" href="#what-is-context">¶</a>What is context?</h3>
<p>Context는 props을 탑다운으로 주지 않고도, 어느 레벨에서든 데이터를 컴포넌트 트리에 넘기는 방법이다. 예를 들어 인증받은 사용자, 언어 설정, UI theme 등 어플리케이션 단위에서 다양한 컴포넌트가 사용해야 하는 데이터를 context를 통해서 줄 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Provider, Consumer &#125; = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-children-prop"><a class="header-anchor" href="#what-is-children-prop">¶</a>What is children prop?</h3>
<p>Children은 prop (<code>this.prop.children</code>) 으로, 다른 컴포넌트에 컴포넌트를 넘길 수 있는 방법으로, 다른 prop를 사용하는 것과 동일하다. 컴포넌트 트리는 이 children을 여닫는 태그 사이에 두며, 이는 컴포넌트를 <code>children prop</code>으로 건내게 된다.</p>
<p>React API에서 이러한 형태로 다양한 prop을 제공하고 있다. <code>React.Children.map</code> <code>React.Children.forEach</code> <code>React.Children.count</code> <code>React.Children.only</code> <code>React.Children.toArray</code> 사용예제는 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyDiv = React.createClass(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyDiv&gt;</span><br><span class="line">    &lt;span&gt;&#123;<span class="string">"Hello"</span>&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span&gt;&#123;"World"&#125;&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/MyDiv&gt;,</span></span><br><span class="line"><span class="regexp">  node</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-write-comments-in-react"><a class="header-anchor" href="#how-to-write-comments-in-react">¶</a>How to write comments in React?</h3>
<p>React/JSX의 주석은 자바스크립트의 다중 주석과 비슷하지만, <code>{ }</code>에 쌓여있다는 것이 다르다.</p>
<p>한 줄</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;/* Single-line comments(In vanilla JavaScript, the single-line comments are</span><br><span class="line">  represented by double slash(//)) */&#125; &#123;`Welcome $&#123;user&#125;, let's play React`&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>여러 줄</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  &#123;/* Multi-line comments for more than one line */&#125; &#123;`Welcome $&#123;user&#125;, let's</span><br><span class="line">  play React`&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-purpose-of-using-super-constructor-with-props-argument"><a class="header-anchor" href="#what-is-the-purpose-of-using-super-constructor-with-props-argument">¶</a>What is the purpose of using super constructor with props argument?</h3>
<p>자식 클래스 생성자는 <code>super()</code>메소드가 호출되기 전까지 <code>this</code> 레퍼런스를 쓸 수 없다. 이와 동일한것이 es6의 서브 클래스에 구현되어 있다. <code>super()</code> 메소드에 props를 파라미터로 호출하는 주요 이유는 <code>this.props</code>를 자식 생성자에서 쓰기 위해서다.</p>
<p>props 넘기는 경우</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// prints &#123; name: 'John', age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>props 안 넘기는 경우</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// prints undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// but props parameter is still available</span></span><br><span class="line">    <span class="built_in">console</span>.log(props); <span class="comment">// prints &#123; name: 'John', age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// no difference outside constructor</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// prints &#123; name: 'John', age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-reconciliation"><a class="header-anchor" href="#what-is-reconciliation">¶</a>What is reconciliation?</h3>
<p>컴포넌트의 props나 state에 변경이 있을때, React는 이전에 렌더링 된 element와 새롭게 렌더링된 것을 비교하여 실제 DOM이 업데이트 되어야 할지를 결정한다. 똑같지 않을때, React는 DOM을 업데이트 한다. 이 과정을 <code>reconciliation</code>이라고 한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-set-state-with-a-dynamic-key-name"><a class="header-anchor" href="#how-to-set-state-with-a-dynamic-key-name">¶</a>How to set state with a dynamic key name?</h3>
<p>JSX코드 내에서 es6또는 바벨 트랜스파일러를 쓰고 있다면, computed property 명을 쓸 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleInputChange(event) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; [event.target.id]: event.target.value &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-would-be-the-common-mistake-of-function-being-called-every-time-the-component-renders"><a class="header-anchor" href="#what-would-be-the-common-mistake-of-function-being-called-every-time-the-component-renders">¶</a>What would be the common mistake of function being called every time the component renders?</h3>
<p>함수를 파라미터로 넘기는 과정에서 함수가 호출되지 않는지 확인해야 한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="is-lazy-function-supports-named-exports"><a class="header-anchor" href="#is-lazy-function-supports-named-exports">¶</a>Is lazy function supports named exports?</h3>
<p>아니다. 현재 <code>React.lazy</code>함수는 default export만 지원한다. named exports된 모듈을 import 하고 싶을 경우에는, 사이에 디폴트로 reexports 하는 모듈을 만들수 있다. 이는 트리쉐이킹을 도와주고, 사용하지 않는 컴포넌트를 pull하지 않을 수 있다. 밑에서 예를 살펴보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MoreComponents.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SomeComponent = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> UnusedComponent = <span class="comment">/* ... */</span>;</span><br></pre></td></tr></table></figure>
<p>이 컴포넌트 중간에 <code>IntermediateComponent.js</code>를 만들어서 다시 export 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntermediateComponent.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; SomeComponent <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">"./MoreComponents.js"</span>;</span><br></pre></td></tr></table></figure>
<p>그리고 lazy 함수를 이용해서 아래와 같이 임포트 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; lazy &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> SomeComponent = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">"./IntermediateComponent.js"</span>));</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-react-uses-classname-over-class-attribute"><a class="header-anchor" href="#why-react-uses-classname-over-class-attribute">¶</a>Why React uses <code>className</code> over <code>class</code> attribute?</h3>
<p><code>class</code>는 자바스크립트의 예약어 이고, JSX는 javascript를 확장해 만든 것이다. 따라서 <code>class</code>를 쓰면 충돌이 일어나기 자바스크립트 예약어와 충동리 발생하기 때문에 <code>className</code>을 사용한다. <code>className</code> prop에 <code>string</code>을 넘겨 주면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;</span>'<span class="attr">menu</span> <span class="attr">navigation-menu</span>'&#125;&gt;</span>&#123;'Menu'&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-fragments"><a class="header-anchor" href="#what-are-fragments">¶</a>What are fragments?</h3>
<p>React에서는 하나의 컴포넌트가 여러개의 elements를 리턴하는 것이 일반적인 패턴이다. Fragments는 추가로 DOM 노드를 사용하지 않더라도 여러개의 노드들을 묶을 수 있게 해준다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">      &lt;ChildC /&gt;</span><br><span class="line">    &lt;<span class="regexp">/React.Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;ChildA /&gt;</span><br><span class="line">      &lt;ChildB /&gt;</span><br><span class="line">      &lt;ChildC /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-fragments-are-better-than-container-divs"><a class="header-anchor" href="#why-fragments-are-better-than-container-divs">¶</a>Why fragments are better than container divs?</h3>
<ol>
<li>Fragment는 실제로 추가적인 DOM을 만들지 않기 때문에 더 빠르고 메모리 사용량도 적다. 이는 매우 크고 깊은 트리를 만들 때 상당한 이점으로 작용한다.</li>
<li>CSS Grid나 firefox같은 일부 특수한 CSS 메커니즘은 특별한 부모-자식 관계를 가지고 있는데, div를 중간에 추가하는 것은 원하는 레이아웃을 그리기 어렵게 한다.</li>
<li>DOM Inspector를 사용할 때 덜 혼잡스럽다.</li>
</ol>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-portals-in-react"><a class="header-anchor" href="#what-are-portals-in-react">¶</a>What are portals in React?</h3>
<p>portals 은 상위 Component 의 DOM 계층 구조 외부에 존재하는 DOM 노드로, 자식을 render 하는데 권장되는 방법이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container);</span><br></pre></td></tr></table></figure>
<p>첫번째 인자는 React Child에서만 렌더링이 가능하며, 여기에는 element, string, fragment 가 포함된다. 두번째 인자는 DOM 엘리먼트다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-stateless-components"><a class="header-anchor" href="#what-are-stateless-components">¶</a>What are stateless components?</h3>
<p>컴포넌트의 동작이 state와 독립되어 있다면, 이는 stateless 컴포넌트다. 함수나 클래스를 이용해서 stateless 컴포넌트를 만들 수 있다. 하지만 컴포넌트의 라이프 사이클 훅이 필요하지 않다면, 함수형으로 가는 것이 좋다. 함수형 컴포넌트를 선택한다면 많은 이점을 가져갈 수 있다. 코드 사용 및 이해가 쉽고, 조금더 빠르며, 그리고 <code>this</code> 키워드의 충돌을 막을 수 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-stateful-components"><a class="header-anchor" href="#what-are-stateful-components">¶</a>What are stateful components?</h3>
<p>state의 사용에 종속적인 컴포넌트를 stateful component라고 한다. 이 컴포넌트는 항상 class 컴포넌트로 만들어 져야 하며, <code>constructor</code>를 통해서 초기화 되어야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-apply-validation-on-props-in-react"><a class="header-anchor" href="#how-to-apply-validation-on-props-in-react">¶</a>How to apply validation on props in React?</h3>
<p>React가 development로 실행한다면, 자동으로 컴포넌트에 있는 props의 타입을 올바르게 체크해 준다. 만약 타입이 올바르지 않다면, React는 콘솔에 경고 메시지를 띄운다. 성능 상의 이슈를 위해 production에서는 이 기능이 꺼져 있다. 필수적인 prop은 <code>isRequired</code>다. 사용할 수 있는 prop type의 종류는 아래와 같다.</p>
<ol>
<li><code>PropTypes.number</code></li>
<li><code>PropTypes.string</code></li>
<li><code>PropTypes.array</code></li>
<li><code>PropTypes.object</code></li>
<li><code>PropTypes.func</code></li>
<li><code>PropTypes.node</code></li>
<li><code>PropTypes.element</code></li>
<li><code>PropTypes.bool</code></li>
<li><code>PropTypes.symbol</code></li>
<li><code>PropTypes.any</code></li>
</ol>
<p>아래와 같이 쓸수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: PropTypes.string.isRequired,</span><br><span class="line">    age: PropTypes.number.isRequired</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;<span class="string">`Welcome, <span class="subst">$&#123;<span class="keyword">this</span>.props.name&#125;</span>`</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;&#123;`Age, $&#123;this.props.age&#125;`&#125;&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>주의: 리액트 v15.5부터 PropType이 <code>React.PropTypes</code>에서 <code>prop-types</code>로 이동했다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-advantages-of-react"><a class="header-anchor" href="#what-are-the-advantages-of-react">¶</a>What are the advantages of React?</h3>
<ol>
<li>Virtual DOM으로 어플리케이션의 성능을 향상시킬 수 있음</li>
<li>JSX를 통해 코들르 쉽게 읽고 쓸수 있음</li>
<li>클라이언트와 서버사이드 양쪽에서 렌더링 라능</li>
<li>뷰만 다루는 라이브러리이기 때문에, 다른 프레임워크 (Angular, Backbone) 등과 쉽게 연동 가능</li>
<li>Jest와 같은 툴로 쉽게 유닛/인티그레이션 테스트 가능</li>
</ol>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-limitations-of-react"><a class="header-anchor" href="#what-are-the-limitations-of-react">¶</a>What are the limitations of React?</h3>
<ol>
<li>풀 프레임워크가 아니라, view만 다루고 있음.</li>
<li>뉴비 웹 개발자들에게 러닝 커브가 존재</li>
<li>전통적인 MVC 프레임워크와 인터그레이팅을 하기 위해서는 추가적인 설정이 필요</li>
<li>inline 템플릿과 JSX로 인해 코드의 복잡성 증가</li>
<li>오버엔지니어링/보일러플레이팅을 야기하는 작은 단위의 컴포넌트가 너무 많이 존재</li>
</ol>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-error-boundaries-in-react-v16"><a class="header-anchor" href="#what-are-error-boundaries-in-react-v16">¶</a>What are error boundaries in React v16?</h3>
<p>Error boundaries란 하위 component tree 에서 자바스크립트 에러 를 catch 하고, 기록하고, 에가 발생한 component tree가 아닌 대체 UI를 표현해 주는 component를 말한다.</p>
<p>새롭게 추가된 라이프사이클 메서드인 <code>componentDidCatch(error, info)</code>나 <code>static getDerivedStateFromError()</code>를 사용한다면, 클래스 컴포넌트는 error boundary가 될 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// 에러 리포틍 서비스를 위해 로그를 기록할 수도 있고</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// fallback UI를 표현하기 위해여 state를 업데이트 할 수도 있다.</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// custom Fallback UI를 그릴 수 있다.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;"Something went wrong."&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그리고 이 컴포넌트는 아래와 같이 사용할 수 있다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">MyWidget</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-error-boundaries-handled-in-react-v15"><a class="header-anchor" href="#how-error-boundaries-handled-in-react-v15">¶</a>How error boundaries handled in React v15?</h3>
<p><code>unstable_handleError</code> 메서드를 활용한 기본적인 error boundaries만 제공하고 있다. 그리고 v16에서 <code>componentDidCatch</code>로 변경되었다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-recommended-ways-for-static-type-checking"><a class="header-anchor" href="#what-are-the-recommended-ways-for-static-type-checking">¶</a>What are the recommended ways for static type checking?</h3>
<p>보통 <code>PropTypes</code>를 많이 사용한다. 그러나 크기가 큰 어플리케이션의 경우에는, Flow나 타입스크립트같은, 컴파일 단계에서 타입체킹을 제공하고 자동완성을 지원해주는 정적 타입 체커를 사용하는 것이 좋다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-use-of-react-dom-package"><a class="header-anchor" href="#what-is-the-use-of-react-dom-package">¶</a>What is the use of <code>react-dom</code> package?</h3>
<p><code>react-dom</code>은 앱 최 상단 레벨에서 사용되는, DOM을 다루는데 필요한 메서드를 제공한다. 대부분의 컴포넌트는 이 모듈을 필요로 하지 않는다. 여기에 있는 메소드를 몇가지 나열하면</p>
<ol>
<li><code>render()</code></li>
<li><code>hydrate()</code></li>
<li><code>unmountComponentAtNode()</code></li>
<li><code>findDOMNode()</code></li>
<li><code>createPortal()</code></li>
</ol>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-purpose-of-render-method-of-react-dom"><a class="header-anchor" href="#what-is-the-purpose-of-render-method-of-react-dom">¶</a>What is the purpose of render method of <code>react-dom</code>?</h3>
<p>render 메서드는 제공된 컨테이너의 DOM에 있는 React element를 render 하고 Component에 대한 참조를 반환하는데 사용된다. React element가 이전에 렌더링 되었다면 update 를 수행하고 최근의 변경사항을 반영하기 위해 필요에 따라 DOM을 변경하기도 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(element, container[, callback])</span><br></pre></td></tr></table></figure>
<p>옵셔널 콜백이 있따면, 컴포넌트가 렌더링/업데이트 된 이후로 실행된다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-reactdomserver"><a class="header-anchor" href="#what-is-reactdomserver">¶</a>What is ReactDOMServer?</h3>
<p><code>ReactDOMServer</code>는 컴포넌트를 정적 마크업으로 렌더링할 수 있게 해준다. (보통 노드 서버에서 많이 사용 된다) 이 오브젝트는 서버사이드 렌더링을 할 때 사용된다. 아래 메서드들은 서버와 브라우저 환경 모두에서 사용할 수 있다.</p>
<ol>
<li><code>renderToString()</code></li>
<li><code>renderToStaticMarkup()</code></li>
</ol>
<p>예를 들어, 노드 베이스 웹서버인 Express, Hapi, Koa 등에서 서버를 실행한다면, <code>renderToString</code>메서드를 호출하여 이에 대한 응답으로 루트 컴포넌트를 string으로 렌더링할 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using Express</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">"react-dom/server"</span>;</span><br><span class="line"><span class="keyword">import</span> MyPage <span class="keyword">from</span> <span class="string">"./MyPage"</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.write(<span class="string">"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;"</span>);</span><br><span class="line">  res.write(<span class="string">'&lt;div id="content"&gt;'</span>);</span><br><span class="line">  res.write(renderToString(<span class="xml"><span class="tag">&lt;<span class="name">MyPage</span> /&gt;</span>));</span></span><br><span class="line"><span class="xml">  res.write("<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><span class="string">");</span></span><br><span class="line"><span class="string">  res.end();</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-use-innerhtml-in-react"><a class="header-anchor" href="#how-to-use-innerhtml-in-react">¶</a>How to use innerHTML in React?</h3>
<p>browser DOM에서 <code>innerHTML</code>대신 <code>dangerouslySetInnerHTML</code>를 사용할 수 있다. <code>innerHTML</code>과 마찬가지로, 이 속성 또한 크로스 사이트 스크립팅 공격 (XSS)에 취약하다. <code>__html</code>을 키로 하고 HTML text를 값으로 가지는 object를 리턴하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMarkup</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">__html</span>: <span class="string">"First &amp;middot; Second"</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;createMarkup()&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-use-styles-in-react"><a class="header-anchor" href="#how-to-use-styles-in-react">¶</a>How to use styles in React?</h3>
<p>style 속성은 css 문자열 대신 camelCased속성이 있는 자바스크립트 오브젝트를 허용한다. 이는 DOM 스타일 자바스크립트 속성과 일치하며, 효율적이고, XSS 보안 허점을 막아준다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-events-are-different-in-react"><a class="header-anchor" href="#how-events-are-different-in-react">¶</a>How events are different in React?</h3>
<p>React 엘리먼트에서 이벤트를 다루는 것은 문법상 약간의 차이가 있다.</p>
<ol>
<li>리액트 이벤트 핸들러는 lowerCase가 아닌 camelCase로 써야한다.</li>
<li>JSX에서는 문자열이 아닌, 함수 이벤트 핸들러를 파라미터로 보낸다.</li>
</ol>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-will-happen-if-you-use-setstate-in-constructor"><a class="header-anchor" href="#what-will-happen-if-you-use-setstate-in-constructor">¶</a>What will happen if you use <code>setState()</code> in constructor?</h3>
<p><code>setState()</code>를 사용하면, 객체 상태가 할당되고, 자식을 포함한 모든 컴포넌트가 다시 렌더링된다. 그리고 아래와 같은 에러메시지가 나타난다. <strong>Can only update a mounted or mounting component.</strong> 따라서 <code>this.state</code>를 사용하여 생성자내에서 변수를 초기화 해야 한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-impact-of-indexes-as-keys"><a class="header-anchor" href="#what-is-the-impact-of-indexes-as-keys">¶</a>What is the impact of indexes as keys?</h3>
<p>키는 리액트에서 엘리먼트를 추적할 수 있도록 안정적이어야 하고, 예측가능해야 하고, 유니크해야 한다.</p>
<p>아래 코드에서 각 엘리먼트의 키는 데이터를 따르는 것이 아니라 단순히 순서에 따라 결정된다. 이는 React가 하는 최적화를 제한한다.</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos.map(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> &lt;Todo &#123;...todo&#125; key=&#123;index&#125; /&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>만약 데이터를 유니크 키로 사용한다면 위의 조건을 만족하기 때문에, React는 다시 연산할 필요 없이 재정렬할 수 있다.</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos.map(<span class="function"><span class="params">todo</span> =&gt;</span> &lt;Todo &#123;...todo&#125; key=&#123;todo.id&#125; /&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="is-it-good-to-use-setstate-in-componentwillmount-method"><a class="header-anchor" href="#is-it-good-to-use-setstate-in-componentwillmount-method">¶</a>Is it good to use <code>setState()</code> in <code>componentWillMount()</code> method?</h3>
<p><code>componentWillMount()</code>에서 비동기 초기화를 하는 것은 피하도록 권장한다. <code>componentWillMount()</code>는 마운팅이 일어나기 직전에 바로 실행된다. 이는 <code>render()</code>함수가 불리우기 직전이며, 따라서 여기에서 state를 새로 값을 할당 한다 하더라도 리렌더링을 트리거 하지 않는다. 이 메소드 내에서는 사이드 이펙트나 subscription등은 피해야 한다. 따라서 비동기 초기화는 <code>componentDidMount()</code>에서 하는 것이 좋다.</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  axios.get(<span class="string">`api/todos`</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        messages: [...result.data]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-will-happen-if-you-use-props-in-initial-state"><a class="header-anchor" href="#what-will-happen-if-you-use-props-in-initial-state">¶</a>What will happen if you use props in initial state?</h3>
<p>컴포넌트의 새로고칩 없이 props가 변경된다면, 현재 상태의 컴포넌트는 절대로 업데이트 하지 않기 때문에 새로운 prop값이 화면에 표시되지 않을 것이다. props를 통한 state값의 초기화는 컴포넌트가 딱 초기화 되었을 때만 실행된다.</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      records: [],</span><br><span class="line">      inputValue: <span class="keyword">this</span>.props.inputValue</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.inputValue&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>props를 render 함수 내에서 쓰면 값을 업데이트 한다.</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      record: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.inputValue&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-do-you-conditionally-render-components"><a class="header-anchor" href="#how-do-you-conditionally-render-components">¶</a>How do you conditionally render components?</h3>
<p>때로는 어떤 상태값에 따라서 렌더링을 다르게 해야하는 경우가 발생한다. JSX는 <code>false</code>나 <code>undefined</code>는 렌더링하지 않으므로, 특정 조건에 true를 주는 형식으로 조건부 렌더링을 할 수 있다.</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, address &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;name&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &#123;address &amp;&amp; &lt;p&gt;&#123;address&#125;&lt;/</span>p&gt;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>if-else도 삼항연산자를 활용하면 아래와 같이 할 수 있다.</p>
<figure class="highlight jsx"><figcaption><span>harmony</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = <span class="function">(<span class="params">&#123; name, address &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;&#123;name&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &#123;address ? &lt;p&gt;&#123;address&#125;&lt;/</span>p&gt; : <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;"Address is not available"&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-we-need-to-be-careful-when-spreading-props-on-dom-elements"><a class="header-anchor" href="#why-we-need-to-be-careful-when-spreading-props-on-dom-elements">¶</a>Why we need to be careful when spreading props on DOM elements?</h3>
<p>spread prop를 쓴다면, HTML에 알수없는 속성을 추가할 수 있는 위험이 있기 때문에 좋지 못하다. 대신 <code>...rest</code> 연산자를 쓴다면, 필요한 props만 추가해서 넣을 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ComponentA = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;ComponentB isDisplay=&#123;<span class="literal">true</span>&#125; className=&#123;<span class="string">"componentStyle"</span>&#125; /&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ComponentB = <span class="function">(<span class="params">&#123; isDisplay, ...domProps &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;div &#123;...domProps&#125;&gt;&#123;<span class="string">"ComponentB"</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-you-use-decorators-in-react"><a class="header-anchor" href="#how-you-use-decorators-in-react">¶</a>How you use decorators in React?</h3>
<p>클래스 컴포넌트에 데코레이터를 쓸 수 있으며, 이는 함수에 컴포넌트를 넘기는 것과 동일하다. 데코레이터는 유연하고 읽기 쉬운 방법으로 컴포넌트를 기능적으로 수정할 수 있도록 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@setTitle(<span class="string">"Profile"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profile</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setTitle = <span class="function"><span class="params">title</span> =&gt;</span> WrappedComponent =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>주의: 데코레이터는 es7 문법에 포함되지 못하고 현재 stage2 단계에 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-do-you-memoize-a-component"><a class="header-anchor" href="#how-do-you-memoize-a-component">¶</a>How do you memoize a component?</h3>
<p>함수형 컴포넌트를 기반으로한 메모이제이션이 가능한 라이브러리가 있다. 예를 들어, <code>moize</code>라이브러리를 활용하면, 다른 컴포넌트 내에서 컴포넌트를 메모이제이션 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moize <span class="keyword">from</span> <span class="string">"moize"</span>;</span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">"./components/Component"</span>; <span class="comment">// this module exports a non-memoized component</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MemoizedFoo = moize.react(Component);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Consumer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;<span class="string">"I will memoize the following entry:"</span>&#125;</span><br><span class="line">    &lt;MemoizedFoo /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-you-implement-server-side-rendering-or-ssr"><a class="header-anchor" href="#how-you-implement-server-side-rendering-or-ssr">¶</a>How you implement Server Side Rendering or SSR?</h3>
<p>React는 이미 노드 서버에서 렌더링을 다룰 수 있도록 지원되고 있다. 클라이언트 사이드와 동일하게 렌더링할 수 있는 특수한 버전의 DOM renderer가 제공되고 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">"react-dom/server"</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./App"</span>;</span><br><span class="line"></span><br><span class="line">ReactDOMServer.renderToString(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>);</span></span><br></pre></td></tr></table></figure>
<p>이 메소드는 일반적인 HTML을 string으로 내보내며, 이는 서버의 응답 일부를 페이지 본문 내부에 위치시킬 수 있다. 클라이언트 사이드에서, 리액트는 미리 렌더링된 컨텐츠를 감지하고 나머지를 원활하게 렌더링할 수 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-enable-production-mode-in-react"><a class="header-anchor" href="#how-to-enable-production-mode-in-react">¶</a>How to enable production mode in React?</h3>
<p>Webpack의 <code>DefinePlugin</code> 메서드를 활용하여, <code>NODE_ENV</code>를 <code>production</code>으로 설정해야 propType의 유효성 검사 같은 추가적인 경고를 제거할 수 있다.</p>
<p>production 모드와 별도로, 주석을 제거하고 코드르 압축시키는 uglify의 dead-code 코드를 사용하여 minify하면 번들링 사이즈를 줄일 수 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-cra-and-its-benefits"><a class="header-anchor" href="#what-is-cra-and-its-benefits">¶</a>What is CRA and its benefits?</h3>
<p>CRA(<code>create-react-app</code>)는 특별한 설정없이도 빠르고 간편하게 리액트 어플리케이션을 만들수 있도록 해주는 Cli tool이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Installation</span><br><span class="line">$ npm install -g create-react-app</span><br><span class="line"></span><br><span class="line"># Create new project</span><br><span class="line">$ create-react-app todo-app</span><br><span class="line">$ cd todo-app</span><br><span class="line"></span><br><span class="line"># Build, test and run</span><br><span class="line">$ npm run build</span><br><span class="line">$ npm run test</span><br><span class="line">$ npm start`</span><br></pre></td></tr></table></figure>
<p>여기에는 리액트 앱을 만드는데 필요한 모든 것이 담겨져 있다.</p>
<ol>
<li>React, JSX, ES6, 문법 지원을 위한 Flow</li>
<li>spread operator와 같은 es6 문법</li>
<li>auto prefixed css를 통해, -web-kit` 과 같은 접두어를 붙이지 않아도 됨</li>
<li>빠른 인터렉티브 유닛 테스트 러너와 함께 커버리지 리포팅</li>
<li>일반적인 실수에 대해 경고하는 라이브 dev 서버</li>
<li>배포를 위해 소스맵, 해쉬와 함께 제공되는 JS, CSS, 이미지 번들링 해주는 빌드 스크립트</li>
</ol>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-lifecycle-methods-order-in-mounting"><a class="header-anchor" href="#what-is-the-lifecycle-methods-order-in-mounting">¶</a>What is the lifecycle methods order in mounting?</h3>
<p>컴포넌트가 생성되고, DOM에 들어가는 과정에서 아래와 같은 라이프 사이클 메서드가 순서대로 호출된다.</p>
<ol>
<li><code>constructor()</code></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ol>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-lifecycle-methods-going-to-be-deprecated-in-react-v16"><a class="header-anchor" href="#what-are-the-lifecycle-methods-going-to-be-deprecated-in-react-v16">¶</a>What are the lifecycle methods going to be deprecated in React v16?</h3>
<p>다음 lifecycle메서드는 안전하지 않은 코딩법이 될 수 있고, 비동기 렌더링시 문제가 발생할 수 있다.</p>
<ol>
<li><code>componentWillMount()</code></li>
<li><code>componentWillReceiveProps()</code></li>
<li><code>componentWillUpdate()</code></li>
</ol>
<p>v16.3 부터 <code>UNSAFE_</code> prefix가 붙고, v17에서는 삭제된다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-purpose-of-getderivedstatefromprops-lifecycle-method"><a class="header-anchor" href="#what-is-the-purpose-of-getderivedstatefromprops-lifecycle-method">¶</a>What is the purpose of <code>getDerivedStateFromProps()</code> lifecycle method?</h3>
<p>새로운 라이프 사이클 메서드 <code>getDerivedStateFromProps()</code>는 component가 인스턴스화 된 후, 다시 렌더링 되기전에 호출된다. object를 반환하여 state를 업데이트 하거나, null을 리턴하ㅕㅇ 새로운 props에서 state update가 필요하지 않도록 나타낼 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(props, state) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 메서드는 <code>componentDidUpdate()</code>와 함께 쓴다면, <code>componentWillReceiveProps()</code>의 모든 유즈케이스에 적용할 수 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-purpose-of-getsnapshotbeforeupdate-lifecycle-method"><a class="header-anchor" href="#what-is-the-purpose-of-getsnapshotbeforeupdate-lifecycle-method">¶</a>What is the purpose of <code>getSnapshotBeforeUpdate()</code> lifecycle method?</h3>
<p>새로운 메서드 <code>getSnapshotBeforeUpdate()</code>는 DOM 업데이트 직전에 호출된다. 이 메서드의 반환값은 <code>componentDidUpdate()</code>의 세번째 파라미터로 전달된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 메서드는 <code>componentDidUpdate()</code>와 함께 쓴다면, <code>componentWillUpdate()</code>의 모든 유즈케이스에 적용할 수 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="do-hooks-replace-render-props-and-higher-order-components"><a class="header-anchor" href="#do-hooks-replace-render-props-and-higher-order-components">¶</a>Do Hooks replace render props and higher order components?</h3>
<p>render props와 HOC 모두 한개의 자식만 렌더링 하지만, 대부분의 경우 Hooks API를 아용하면 트리에 의존성을 줄이면서 간단하게 구현할 수 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-recommended-way-for-naming-components"><a class="header-anchor" href="#what-is-the-recommended-way-for-naming-components">¶</a>What is the recommended way for naming components?</h3>
<p><code>displayName</code>을 쓰는 것 보다 컴포넌트에 레퍼런스를 주는 방법이 더 좋다.</p>
<p><code>displayName</code>을 쓰는 법 보다</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line">  displayName: <span class="string">"TodoApp"</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>이렇게 하는게 더 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">TodoApp</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-recommended-ordering-of-methods-in-component-class"><a class="header-anchor" href="#what-is-the-recommended-ordering-of-methods-in-component-class">¶</a>What is the recommended ordering of methods in component class?</h3>
<p>마운팅에서 렌더링까지 아래와 같은 순서로 나열하길 권장한다.</p>
<ol>
<li><code>static</code> 메서드</li>
<li><code>constructor()</code></li>
<li><code>getChildContext()</code></li>
<li><code>componentWillMount()</code></li>
<li><code>componentDidMount()</code></li>
<li><code>componentWillReceiveProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>componentWillUpdate()</code></li>
<li><code>componentDidUpdate()</code></li>
<li><code>componentWillUnmount()</code></li>
<li>클릭 또는 이벤트 핸들러 <code>onClickSubmit()</code> <code>onChangeDescription()</code></li>
<li>렌더를 위한 <code>getter</code> 메서드 <code>getSelectReason()</code> <code>getFooterContent()</code></li>
<li>옵셔널 렌더 메서드 <code>renderNavigation()</code> <code>renderProfilePicture()</code></li>
<li><code>render()</code></li>
</ol>
<h3 id="what-is-a-switching-component"><a class="header-anchor" href="#what-is-a-switching-component">¶</a>What is a switching component?</h3>
<p>스위칭 컴포넌트란 하나 이상의 컴포넌트를 렌더링하는 컴포넌트를 의미한다. prop을 map으로 받아서 해당하는 컴포넌트를 보여주면 된다.</p>
<p>아래 코드 참조.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HomePage <span class="keyword">from</span> <span class="string">"./HomePage"</span>;</span><br><span class="line"><span class="keyword">import</span> AboutPage <span class="keyword">from</span> <span class="string">"./AboutPage"</span>;</span><br><span class="line"><span class="keyword">import</span> ServicesPage <span class="keyword">from</span> <span class="string">"./ServicesPage"</span>;</span><br><span class="line"><span class="keyword">import</span> ContactPage <span class="keyword">from</span> <span class="string">"./ContactPage"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PAGES = &#123;</span><br><span class="line">  home: HomePage,</span><br><span class="line">  about: AboutPage,</span><br><span class="line">  services: ServicesPage,</span><br><span class="line">  contact: ContactPage</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Page = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Handler = PAGES[props.page] || ContactPage;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Handler</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Page.propTypes = &#123;</span></span><br><span class="line"><span class="xml">  page: PropTypes.oneOf(Object.keys(PAGES)).isRequired</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-we-need-to-pass-a-function-to-setstate"><a class="header-anchor" href="#why-we-need-to-pass-a-function-to-setstate">¶</a>Why we need to pass a function to setState()?</h3>
<p>그 이유는 <code>setState()</code>가 비동기로 작동하는데에 있다. React는 성능상의 문제로 인해, state의 변경작업을 배치로 하는데, 이 때문에 <code>setState()</code>를 바로 호출한다고 해서 바로 반영되지 않는다. 이 말은, <code>setState()</code>를 호출 할 때 그 당시 <code>state</code>의 값에 의존하면 안된다는 뜻이다. 따라서 <code>setState()</code>에는 이전 값에 접근할 수 있는 함수를 사용하는 것이 좋다. 이는 사용자가 비동기로 작동하는 <code>setState()</code>의 특징으로 인해 이전 값에 접근하는 것을 방지해 준다.</p>
<p>초기 값이 0 이라고 가정하자. 여기 1 씩 올리는 동작을 하는 코드가 세개 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assuming this.state.count === 0</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="comment">// this.state.count === 1, not 3</span></span><br></pre></td></tr></table></figure>
<p>만약 <code>setState()</code>에 함수를 넘겨준다면, 올바르게 동작할 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  count: prevState.count + props.increment</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// this.state.count === 3 as expected</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-strict-mode-in-react"><a class="header-anchor" href="#what-is-strict-mode-in-react">¶</a>What is strict mode in React?</h3>
<p><code>React.StrictMode</code>는 어플리케이션의 잠재적인 문제를 하이라이팅 해주는 유용한 컴포넌트다. <code>&lt;Fragment&gt;</code>와 마찬가지로, <code>&lt;StrictMode&gt;</code>는 추가적으로 DOM을 렌더링하지 않는다. 이는 단지 자식 컴포넌트의 추가적인 체크와 경고를 할 뿐이다. 그리고 이러한 체크는 development 에서만 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleApplication</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;React.StrictMode&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ComponentOne /&gt;</span><br><span class="line">          &lt;ComponentTwo /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>React.StrictMode&gt;</span><br><span class="line">      &lt;Footer /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>위 예에서, <code>ComponentOne</code> <code>ComponentTwo</code>만 체크할 것이다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-react-mixins"><a class="header-anchor" href="#what-are-react-mixins">¶</a>What are React Mixins?</h3>
<p><code>Mixins</code>은 공통적인 기능을 가질 수 있도록 컴포넌트를 분리하는 방법이다. 그러나 사용하지 말아야 한다. HOC 나 데레이터를 사용하면 된다.</p>
<p>가장 유명한 사용법중 하나는 <code>PureRenderMixin</code>이다. 이전 props또는 state와 얕은 비교를 했을 때 일치하는 경우, 리렌더링을 막아주는 역할을 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PureRenderMixin = <span class="built_in">require</span>(<span class="string">"react-addons-pure-render-mixin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Button = React.createClass(&#123;</span><br><span class="line">  mixins: [PureRenderMixin]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-is-ismounted-an-anti-pattern-and-what-is-the-proper-solution"><a class="header-anchor" href="#why-is-ismounted-an-anti-pattern-and-what-is-the-proper-solution">¶</a>Why is <code>isMounted()</code> an anti-pattern and what is the proper solution?</h3>
<p><code>isMounted()</code>의 일반적인 사용사례는 컴포넌트가 언마운트 된 후에 <code>setState()</code>를 호출하는 것을 방지하기 위함이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isMounted()) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setState()</code>를 호출하기 전에 <code>isMounted()</code>를 검사하면 경고를 없앨수있지만, 경고의 목적을 잃어버리는 꼴이 된다. 컴포넌트의 마운트가 해제된 후에 reference를 가지고 있다고 판단하므로 이는 일종의 코드 스멜이라고 볼 수 있다.</p>
<p>좋은 해결책은 컴포넌트의 마운트가 해제된 후 <code>setState()</code>가 호출될 수 있는 위치를 찾아 수정하는 것이다. 이러한 상황은 대게 컴포넌트가 데이터를 기다리고 있다가 데이터의 도착전 마운트가 해제 되는, 콜백 상황에서 많이 발생된다. 콜백은 마운트가 해제되기 전에 <code>componentWillUnMount</code>에서 취소되어야 한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-pointer-events-supported-in-react"><a class="header-anchor" href="#what-are-the-pointer-events-supported-in-react">¶</a>What are the Pointer Events supported in React?</h3>
<p>포인터 이벤트는 모든 입력 이벤트를 다루는 통일된 방법을 제공한다. 과거에는 마우스 및 각각의 이벤트 리스너를 달았지만, 요즘에는 핸드폰 터치, 서피스, 펜 등 마우스 외에 다양한 입력기기가 나타나기 시작했다. 한가지 명심해야 할 점은 이러한 이벤트들이 포인트 이벤트 명세를 지원하는 브라우저에서만 동작할 것이라는 점이다.</p>
<p>아래의 이벤트 타입들이 React DOM에서 지원하는 것이다.</p>
<ol>
<li>onPointerDown</li>
<li>onPointerMove</li>
<li>onPointerUp</li>
<li>onPointerCancel</li>
<li>onGotPointerCapture</li>
<li>onLostPointerCaptur</li>
<li>onPointerEnter</li>
<li>onPointerLeave</li>
<li>onPointerOver</li>
<li>onPointerOut</li>
</ol>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-should-component-names-start-with-capital-letter"><a class="header-anchor" href="#why-should-component-names-start-with-capital-letter">¶</a>Why should component names start with capital letter?</h3>
<p>JSX를 이용해서 렌더링을 하다보면, 컴포넌트의 명이 대문자가 아닐 경우 태그 인식에 실패했다는 에러메시지를 뱉는다. 그 이유는 오직 HTML 엘리먼트와 SGV 태그만이 소문자로 시작하기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Code goes here</span></span><br><span class="line">&#125;<span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>클래스 명을 소문자로 시작하게 컴포넌트를 만들 수 있지만, import 할 때는 대문자로 하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default myComponent;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">"./MyComponent"</span>;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="are-custom-dom-attributes-supported-in-react-v16"><a class="header-anchor" href="#are-custom-dom-attributes-supported-in-react-v16">¶</a>Are custom DOM attributes supported in React v16?</h3>
<p>가능하다. 과거 React는 알수없는 DOM 속성을 무시했다. JSX에 리액트가 알수 없는 속성을 넣었다면, 리액트는 이를 무시했다.</p>
<p>예를 들어, 과거에는 아래와 같이 동작했다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div mycustomattribute=&#123;<span class="string">"something"</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>그러나 React v16부터는 알수없는 속성도 결국 DOM에 반영된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">mycustomattribute</span>=<span class="string">"something"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>이는 브라우저에 특화된 비표준 속성, 새로운 DOM api, 서드파티 라이브러리 등을 사용할 때 유용하다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-difference-between-constructor-and-getinitialstate"><a class="header-anchor" href="#what-is-the-difference-between-constructor-and-getinitialstate">¶</a>What is the difference between constructor and getInitialState?</h3>
<p>es6 클래스에서는 <code>constructor</code>로 state를 초기화 하고, <code>React.createClass</code>를 사용할 때는 <code>getInitialState()</code>으로 초기화 한다.</p>
<p>es6</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      <span class="comment">/* initial state */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>React.createClass()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyComponent = React.createClass(&#123;</span><br><span class="line">  getInitialState() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">/* initial state */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="can-you-force-a-component-to-re-render-without-calling-setstate"><a class="header-anchor" href="#can-you-force-a-component-to-re-render-without-calling-setstate">¶</a>Can you force a component to re-render without calling setState?</h3>
<p>기본적으로, state나 prop의 변화가 있을 때만 컴포넌트가 리렌더링 된다. 만약 <code>render()</code> 메서드가 외부의 다른 데이터에 의존적이라면, <code>forceUpdate()</code>를 통해서 컴포넌트를 리렌더링 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.forceUpdate(callback);</span><br></pre></td></tr></table></figure>
<p>다만 이러한 방법은 권장되지 않으며, <code>render()</code>메소드에서 <code>this.props</code>나 <code>this.state</code>를 참조하는 것이 권장된다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-difference-between-super-and-super-props-in-react-using-es6-classes"><a class="header-anchor" href="#what-is-the-difference-between-super-and-super-props-in-react-using-es6-classes">¶</a>What is the difference between <code>super()</code> and <code>super(props)</code> in React using ES6 classes?</h3>
<p><code>constructor()</code>에서 <code>this.props</code>에 접근하고 싶다면, <code>super()</code>메서드에 <code>this.props</code>를 넘겨야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// &#123; name: 'John', ... &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-loop-inside-jsx"><a class="header-anchor" href="#how-to-loop-inside-jsx">¶</a>How to loop inside JSX?</h3>
<p><code>Array.prototype.map</code>을 es6의 화살표 함수 문법과 사용하면 된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">  &#123;items.map(item =&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">key</span>=<span class="string">"&#123;item.id&#125;"</span> <span class="attr">name</span>=<span class="string">"&#123;item.name&#125;"</span> /&gt;</span>)&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>for</code>루프는 사용할 수 없다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">  for (let i = 0; i <span class="tag">&lt; <span class="attr">items.length</span>; <span class="attr">i</span>++) &#123;</span></span><br><span class="line">  &lt;SomeComponent key="&#123;items[i].id&#125;" name="&#123;items[i].name&#125;" /&gt;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSX 태그는 함수호출로 트랜스파일이 되는데, 이 경우 표현식내에 제어문을 사용할 수 없다. 다만 이는 stage1에 있는 <a href="https://github.com/tc39/proposal-do-expressions" target="_blank" rel="noopener">do</a> proposal로 해결 될 수도 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-do-you-access-props-in-attribute-quotes"><a class="header-anchor" href="#how-do-you-access-props-in-attribute-quotes">¶</a>How do you access props in attribute quotes?</h3>
<p>React와 JSX는 속성 값에 string interpolation을 지원하지 않는다. 따라서 아래 코드는 작동하지 않는다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"images/&#123;this.props.image&#125;"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>하지만 <code>{}</code>와 함께 javascript 표현식을 넣으면 가능하다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">className</span>=<span class="string">'image'</span> <span class="attr">src</span>=<span class="string">&#123;</span>'<span class="attr">images</span>/' + <span class="attr">this.props.image</span>&#125; /&gt;</span> <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag"><span class="attr">className</span>=<span class="string">'image'</span> <span class="attr">src</span>=<span class="string">&#123;</span>`<span class="attr">images</span>/$&#123;<span class="attr">this.props.image</span>&#125;`&#125; /&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-react-proptype-array-with-shape"><a class="header-anchor" href="#what-is-react-proptype-array-with-shape">¶</a>What is React proptype array with shape?</h3>
<p>만약 특정 object를 가진 array를 넘기고 싶다면, <code>React.PropTypes.arrayOf()</code>와 함께 <code>React.PropTypes.shape()</code>를 쓰면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.propTypes = &#123;</span><br><span class="line">  arrayWithShape: React.PropTypes.arrayOf(</span><br><span class="line">    React.PropTypes.shape(&#123;</span><br><span class="line">      color: React.PropTypes.string.isRequired,</span><br><span class="line">      fontSize: React.PropTypes.number.isRequired</span><br><span class="line">    &#125;)</span><br><span class="line">  ).isRequired</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-conditionally-apply-class-attributes"><a class="header-anchor" href="#how-to-conditionally-apply-class-attributes">¶</a>How to conditionally apply class attributes?</h3>
<p>따옴표 안에 내용은 모두 string으로 인식하기 때문에 <code>{}</code>를 쓸 수 없다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"btn-panel &#123;this.props.visible ? 'show' : 'hidden'&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>다만 <code>{}</code>안에 모든 식을 넣으면 가능하다. (공백은 반드시 있어야 한다)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>'<span class="attr">btn-panel</span> ' + (<span class="attr">this.props.visible</span> ? '<span class="attr">show</span>' <span class="attr">:</span> '<span class="attr">hidden</span>')&#125;&gt;</span></span><br></pre></td></tr></table></figure>
<p>템플릿 string도 가능하다</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">btn-panel</span> $&#123;<span class="attr">this.props.visible</span> ? '<span class="attr">show</span>' <span class="attr">:</span> '<span class="attr">hidden</span>'&#125;`&#125;&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-difference-between-react-and-reactdom"><a class="header-anchor" href="#what-is-the-difference-between-react-and-reactdom">¶</a>What is the difference between React and ReactDOM?</h3>
<p>React 패키지내에는 엘리먼트와 컴포넌트 클래스에 도움을 줄 수 있는 <code>React.createElement()</code> <code>React.Component</code> <code>React.children</code>등을 가지고 있다. React 패키지 내에는 컴포넌트를 만드는데 도움이 되는 이러한 요소들이 있다고 보면 된다. 반면 <code>React-dom</code>패키지는 <code>ReactDOM.render()</code> 서버사이드 렌더링에 필요한 <code>react-dom/server</code>에 속한 <code>ReactDOMServer.renderToString()</code> <code>ReactDOMServer.renderToStaticMarkUp()</code> 이 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-reactdom-is-separated-from-react"><a class="header-anchor" href="#why-reactdom-is-separated-from-react">¶</a>Why ReactDOM is separated from React?</h3>
<p>React 팀은 DOM조작과 관련된 모든 기능을 <code>ReactDOM</code> 라이브러리로 옮겼다. 이는 React v0.14에서 처음으로 분리되었다. 이 때 패키지를 보자면, <code>react-native</code> <code>react-art</code> <code>react-canvas</code> <code>react-three</code>등 패키지 분리가 깔끔해졌으며, <code>React</code>패키지 자체에는 브라우저 DOM 조작과 관련된 라이브러리가 없다는 것이 명확해졌다. React가 다수의 환경에서 렌더링을 지원하기 위해, React팀은 React와 React-dom을 분리할 계획을 수립햇다. 이러한 방법론은 웹 버전에서 쓰이는 React와 React-Native사이에 컴포넌트를 쓰는 방법론을 공유할 수 있도록 해준다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-use-react-label-element"><a class="header-anchor" href="#how-to-use-react-label-element">¶</a>How to use React label element?</h3>
<p>표준 <code>for</code> 속성을 사용하는 <code>text input</code>에 바인드된 <code>&lt;label&gt;</code>을 사용하려고 하면, 속성이 없는 HTML이 생성되고 콘솔에 경고가 출력된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&#123;</span>'<span class="attr">user</span>'&#125;&gt;</span>&#123;'User'&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#123;</span>'<span class="attr">text</span>'&#125; <span class="attr">id</span>=<span class="string">&#123;</span>'<span class="attr">user</span>'&#125; /&gt;</span></span><br></pre></td></tr></table></figure>
<p>for는 자바스크립트의 예약어이므로, <code>htmlFor</code>를 사용해야 한다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&#123;</span>'<span class="attr">user</span>'&#125;&gt;</span>&#123;'User'&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#123;</span>'<span class="attr">text</span>'&#125; <span class="attr">id</span>=<span class="string">&#123;</span>'<span class="attr">user</span>'&#125; /&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-combine-multiple-inline-style-objects"><a class="header-anchor" href="#how-to-combine-multiple-inline-style-objects">¶</a>How to combine multiple inline style objects?</h3>
<p>spread 연산자를 사용하면 된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;...styles.panel.button,</span> <span class="attr">...styles.panel.submitButton</span>&#125;&#125;&gt;</span>&#123;'Submit'&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>React Native라면 array를 사용하면 된다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;[styles.panel.button,</span> <span class="attr">styles.panel.submitButton</span>]&#125;&gt;</span>&#123;'Submit'&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-re-render-the-view-when-the-browser-is-resized"><a class="header-anchor" href="#how-to-re-render-the-view-when-the-browser-is-resized">¶</a>How to re-render the view when the browser is resized?</h3>
<p><code>componentDidMount()</code>에서 <code>resize</code>이벤트를 걸어두고, width와 height를 업데이트 하면 된다. 그리고 이 이벤트는 <code>componentWillUnmount()</code>에서 제거해줘야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowDimensions</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.updateDimensions = <span class="keyword">this</span>.updateDimensions.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.updateDimensions()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateDimensions)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'resize'</span>, <span class="keyword">this</span>.updateDimensions)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateDimensions() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">width</span>: <span class="built_in">window</span>.innerWidth, <span class="attr">height</span>: <span class="built_in">window</span>.innerHeight&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;this.state.width&#125; x &#123;this.state.height&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-difference-between-setstate-and-replacestate-methods"><a class="header-anchor" href="#what-is-the-difference-between-setstate-and-replacestate-methods">¶</a>What is the difference between <code>setState()</code> and <code>replaceState()</code> methods?</h3>
<p><code>setState()</code>는 과거의 state값을 현재 값으로 합친다. 반면 <code>replaceState()</code>는 현재 state를 버리고 넘어오는 <code>state</code>로 바꾼다. 이전 key를 모두 제거하는 경우가 아니라면 보통 <code>useState()</code>를 사용한다. <code>replaceState()</code>대신 <code>setState()</code>에서 <code>false/null</code>을 사용할 수도 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-listen-to-state-changes"><a class="header-anchor" href="#how-to-listen-to-state-changes">¶</a>How to listen to state changes?</h3>
<p>아래 라이프사이클 메서드는 state의 변화가 있을 때 호출된다. 여기에서 이전 state와 props과 현재 state/props 값을 비교하여 의미있는 변화가 있었는지 추적할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(object nextProps, object nextState)</span><br><span class="line">componentDidUpdate(object prevProps, object prevState)</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-recommended-approach-of-removing-an-array-element-in-react-state"><a class="header-anchor" href="#what-is-the-recommended-approach-of-removing-an-array-element-in-react-state">¶</a>What is the recommended approach of removing an array element in React state?</h3>
<p><code>Array.prototype.filter()</code>메서드가 올바른 방법이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">removeItem(index) &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    data: <span class="keyword">this</span>.state.data.filter(<span class="function">(<span class="params">item, i</span>) =&gt;</span> i !== index)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="is-it-possible-to-use-react-without-rendering-html"><a class="header-anchor" href="#is-it-possible-to-use-react-without-rendering-html">¶</a>Is it possible to use React without rendering HTML?</h3>
<p>16.2 이상의 버전에서는 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span><span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span><span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>undefined</code>의 경우에는 작동하지 않는다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-pretty-print-json-with-react"><a class="header-anchor" href="#how-to-pretty-print-json-with-react">¶</a>How to pretty print JSON with React?</h3>
<p><code>&lt;pre&gt;</code> 태그안에 <code>JSON.stringify()</code>를 사용하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">42</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;pre&gt;</span><br><span class="line">        &#123;<span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="number">2</span>)&#125;</span><br><span class="line">      &lt;<span class="regexp">/pre&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">React.render(&lt;User /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>))</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-you-can-t-update-props-in-react"><a class="header-anchor" href="#why-you-can-t-update-props-in-react">¶</a>Why you can’t update props in React?</h3>
<p>props은 불변이며, 하향식으로 전달되는 것이 <code>React</code>의 철학이다. 이 말인 즉, 부모는 어떤 prop값이든 자식에세 보낼 수 있지만, 자식은 그 prop값을 수정할 수 없다는 것이다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-focus-an-input-element-on-page-load"><a class="header-anchor" href="#how-to-focus-an-input-element-on-page-load">¶</a>How to focus an input element on page load?</h3>
<p><code>input</code> 엘리먼트에 ref를 만들고, 이를 <code>componentDidMount()</code>에서 쓰면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.nameInput.focus()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          defaultValue=&#123;<span class="string">'Won\'t focus'</span>&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          ref=&#123;(input) =&gt; <span class="keyword">this</span>.nameInput = input&#125;</span><br><span class="line">          defaultValue=&#123;<span class="string">'Will focus'</span>&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-possible-ways-of-updating-objects-in-state"><a class="header-anchor" href="#what-are-the-possible-ways-of-updating-objects-in-state">¶</a>What are the possible ways of updating objects in state?</h3>
<ol>
<li>state를 병합할 object를 <code>setState()</code>에 서 사용하는 법
<ul>
<li>`Object.assign()로 Object의 복사본을 만든다.</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="keyword">this</span>.state.user, &#123; <span class="attr">age</span>: <span class="number">42</span> &#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; user &#125;)-</span><br></pre></td></tr></table></figure>
<ul>
<li>spread 연산자를 사용하는 법</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; ...this.state.user, <span class="attr">age</span>: <span class="number">42</span> &#125;</span><br><span class="line"><span class="keyword">this</span>.setState(&#123; user &#125;)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>setState()</code>와 함수를 사용하는 법</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    ...prevState.user,</span><br><span class="line">    age: <span class="number">42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-function-is-preferred-over-object-for-setstate"><a class="header-anchor" href="#why-function-is-preferred-over-object-for-setstate">¶</a>Why function is preferred over object for <code>setState()</code>?</h3>
<p>React는 성능의 문제로 인해 여러개의 <code>setState()</code>를 배치 형태로 호출하게 된다. 왜냐하면 <code>this.props</code>와 <code>this.state</code>는 비동기로 업데이트 될 수 있기 때문이다. 다음 state를 계산할 때 이전에 계산된 값을 신뢰하면 안된다.</p>
<p>아래 예제는 제대로 작동하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>이를 위해 함수로 <code>setState()</code>를 호출하는 것이 권장된다. 함수로 호출시 이전 state값을 받을 수 있고, 업데이트할 때 사용할 <code>prop</code>도 받아올 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-can-we-find-the-version-of-react-at-runtime-in-the-browser"><a class="header-anchor" href="#how-can-we-find-the-version-of-react-at-runtime-in-the-browser">¶</a>How can we find the version of React at runtime in the browser?</h3>
<p><code>React.version</code>을 사용하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> REACT_VERSION = React.version</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;div&gt;&#123;<span class="string">`React version: <span class="subst">$&#123;REACT_VERSION&#125;</span>`</span>&#125;&lt;<span class="regexp">/div&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('app')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-approaches-to-include-polyfills-in-your-create-react-app"><a class="header-anchor" href="#what-are-the-approaches-to-include-polyfills-in-your-create-react-app">¶</a>What are the approaches to include polyfills in your <code>create-react-app</code>?</h3>
<ol>
<li><code>core-js</code>를 수동으로 임포트하는 법<br>
<code>polyfills.js</code>과 같은 파일을 만들고, 이를 루트인 <code>index.js</code>에서 임포트 한다. 그리고 <code>core-js</code>를 설치하여 필요한 기능을 임포트 한다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'core-js/fn/array/find'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js/fn/array/includes'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'core-js/fn/number/is-nan'</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>폴리필 서비스를 이용하는 방법<br>
<code>polyfill.io</code>를 CDN으로 가져와서, <code>index.html</code>에 추가하는 방법</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-use-https-instead-of-http-in-create-react-app"><a class="header-anchor" href="#how-to-use-https-instead-of-http-in-create-react-app">¶</a>How to use https instead of http in create-react-app?</h3>
<p>환경설정에 <code>HTTPS=true</code>를 세팅하면 된다.</p>
<p>pacakge.json</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "set HTTPS=true &amp;&amp; react-scripts start"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>아니면 <code>set HTTPS=true &amp;&amp; npm start</code>로 실행하면 된다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-avoid-using-relative-path-imports-in-create-react-app"><a class="header-anchor" href="#how-to-avoid-using-relative-path-imports-in-create-react-app">¶</a>How to avoid using relative path imports in create-react-app?</h3>
<p>루트 디렉토리에 <code>.env</code>를 만들고, 임포트 경로를 작성한다.</p>
<p><code>NODE_PATH=src/app</code></p>
<p>개발서벌르 재시작하면, 상대경로 없이 <code>src/app</code>에 있는 파일을 import 할 수 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-add-google-analytics-for-react-router"><a class="header-anchor" href="#how-to-add-google-analytics-for-react-router">¶</a>How to add Google Analytics for React Router?</h3>
<p>history 객체에 리스너를 추가하여 각 페이지 뷰에 달아 둔다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.listen(<span class="function"><span class="keyword">function</span> (<span class="params">location</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.ga(<span class="string">'set'</span>, <span class="string">'page'</span>, location.pathname + location.search)</span><br><span class="line">  <span class="built_in">window</span>.ga(<span class="string">'send'</span>, <span class="string">'pageview'</span>, location.pathname + location.search)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-update-a-component-every-second"><a class="header-anchor" href="#how-to-update-a-component-every-second">¶</a>How to update a component every second?</h3>
<p><code>setInterval()</code>에 트리거를 걸어두면 되지만, unmount시에 이를 해제하여 메모리 누수와 에러를 방지해야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.setState(&#123; <span class="attr">time</span>: <span class="built_in">Date</span>.now() &#125;), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(<span class="keyword">this</span>.interval)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-do-you-apply-vendor-prefixes-to-inline-styles-in-react"><a class="header-anchor" href="#how-do-you-apply-vendor-prefixes-to-inline-styles-in-react">¶</a>How do you apply vendor prefixes to inline styles in React?</h3>
<p>react는 자동으로 vender prefix를 붙여주지 않으므로, 수동으로 붙여야 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;</span><br><span class="line">  transform: <span class="string">'rotate(90deg)'</span>,</span><br><span class="line">  WebkitTransform: <span class="string">'rotate(90deg)'</span>, <span class="comment">// note the capital 'W' here</span></span><br><span class="line">  msTransform: <span class="string">'rotate(90deg)'</span> <span class="comment">// 'ms' is the only lowercase vendor prefix</span></span><br><span class="line">&#125;&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-import-and-export-components-using-react-and-es6"><a class="header-anchor" href="#how-to-import-and-export-components-using-react-and-es6">¶</a>How to import and export components using React and ES6?</h3>
<p><code>default</code>키워드를 사용하여 컴포넌트를 익스포트 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">'user'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProfile</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;User type=<span class="string">"customer"</span>&gt;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">      &lt;<span class="regexp">/User&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>위 예제에서는 MyProfile이 멤버가 되어 모듈로 익스포트 되는데, 이는 다른 컴포넌트에서 굳이 이름을 명세하지 않더라도 임포트 할 수 있게 해준다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-exceptions-on-react-component-naming"><a class="header-anchor" href="#what-are-the-exceptions-on-react-component-naming">¶</a>What are the exceptions on React component naming?</h3>
<p>몇가지 예외적인 경우를 제외하고, 컴포넌트 명은 대문자로 시작해야 한다. 소문자와 . (속성 접근자)을 사용하는 경우 유효한 컴포넌트 명이다. 아래의 예가 그러한 유효한 경우다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">       &lt;obj.component /&gt; <span class="comment">// `React.createElement(obj.component)`</span></span><br><span class="line">      )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="why-is-a-component-constructor-called-only-once"><a class="header-anchor" href="#why-is-a-component-constructor-called-only-once">¶</a>Why is a component constructor called only once?</h3>
<p>React의 reconciliation 알고리즘은 후속 렌더링 과정에서 사용자 정의 컴포넌트가 똒같은 위치에 나타나면, 이전과 동일 한 요소이므로 새로운 인스턴스를 만드는 대신 이전 인스턴스를 재사용한다고 가정한다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-define-constants-in-react"><a class="header-anchor" href="#how-to-define-constants-in-react">¶</a>How to define constants in React?</h3>
<p>es7의 static 필드를 사용하여 상수를 정의할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> DEFAULT_PAGINATION = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>현재 static 필드는 stage3에 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-programmatically-trigger-click-event-in-react"><a class="header-anchor" href="#how-to-programmatically-trigger-click-event-in-react">¶</a>How to programmatically trigger click event in React?</h3>
<p>callback을 통한 ref prop를 사용하여 HTMLInputElement 객체에 대한 참조를 가져와서 class property 로 저장한 다음, 이렇게 저장된 참조를 활용하여 <code>HTMLElement.click</code> 메서드를 사용해 이벤트 핸들러에서 클릭 이벤트를 트리거 할 수 있다.</p>
<ol>
<li>render 메서드에서 ref를 생성한다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;input =&gt; <span class="keyword">this</span>.inputElement = input&#125; /&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>이벤트 핸들러에서 클릭 이벤트를 트리거 한다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.inputElement.click()</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="is-it-possible-to-use-async-await-in-plain-react"><a class="header-anchor" href="#is-it-possible-to-use-async-await-in-plain-react">¶</a>Is it possible to use async/await in plain React?</h3>
<p>React 에서 async/await 을 사용하고 싶다면 Babel 과 transform-async-to-generator 플러그인이 필요하다. React Native에서는 기본적으로 지원하고 있다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-common-folder-structures-for-react"><a class="header-anchor" href="#what-are-the-common-folder-structures-for-react">¶</a>What are the common folder structures for React?</h3>
<p>크게 두가지 종류가 있다.</p>
<ol>
<li>기능 또는 라우팅으로 분류하는 방법</li>
</ol>
<p>기능과 라우팅에 따라서 css, js, 테스트 코드를 묶는 방법이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">common/</span><br><span class="line">├─ Avatar.js</span><br><span class="line">├─ Avatar.css</span><br><span class="line">├─ APIUtils.js</span><br><span class="line">└─ APIUtils.test.js</span><br><span class="line">feed/</span><br><span class="line">├─ index.js</span><br><span class="line">├─ Feed.js</span><br><span class="line">├─ Feed.css</span><br><span class="line">├─ FeedStory.js</span><br><span class="line">├─ FeedStory.test.js</span><br><span class="line">└─ FeedAPI.js</span><br><span class="line">profile/</span><br><span class="line">├─ index.js</span><br><span class="line">├─ Profile.js</span><br><span class="line">├─ ProfileHeader.js</span><br><span class="line">├─ ProfileHeader.css</span><br><span class="line">└─ ProfileAPI.js</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>파일 타입 별로 분류하는 법</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">api/</span><br><span class="line">├─ APIUtils.js</span><br><span class="line">├─ APIUtils.test.js</span><br><span class="line">├─ ProfileAPI.js</span><br><span class="line">└─ UserAPI.js</span><br><span class="line">components/</span><br><span class="line">├─ Avatar.js</span><br><span class="line">├─ Avatar.css</span><br><span class="line">├─ Feed.js</span><br><span class="line">├─ Feed.css</span><br><span class="line">├─ FeedStory.js</span><br><span class="line">├─ FeedStory.test.js</span><br><span class="line">├─ Profile.js</span><br><span class="line">├─ ProfileHeader.js</span><br><span class="line">└─ ProfileHeader.css</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-popular-packages-for-animation"><a class="header-anchor" href="#what-are-the-popular-packages-for-animation">¶</a>What are the popular packages for animation?</h3>
<p>React Transition Group과 React Motion이 React 생태계에서 유명한 애니메이션 패키지다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-is-the-benefit-of-styles-modules"><a class="header-anchor" href="#what-is-the-benefit-of-styles-modules">¶</a>What is the benefit of styles modules?</h3>
<p>스타일 값을 하드코딩 하는 것은 권장하지 않는 방식이다. 서로다른 UI 컴포넌트에서 넓게 사용되는 값은 하나의 모듈에서 추출해서 쓰는 것이 좋다.</p>
<p>아래와 같은 방식을 사용하면, 서로다른 컴포넌트에서 동일한 스타일을 가져올 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> colors = &#123;</span><br><span class="line">  white,</span><br><span class="line">  black,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> space = [</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  <span class="number">8</span>,</span><br><span class="line">  <span class="number">16</span>,</span><br><span class="line">  <span class="number">32</span>,</span><br><span class="line">  <span class="number">64</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>그리고 각각의 컴포넌트에서 이를 임포트 하면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; space, colors &#125; <span class="keyword">from</span> <span class="string">'./styles'</span></span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-the-popular-react-specific-linters"><a class="header-anchor" href="#what-are-the-popular-react-specific-linters">¶</a>What are the popular React-specific linters?</h3>
<p>자바스크립트 lint로는 eslint가 유명하다. 코드 스타일을 분석할 수 있는 다양한 플러그인이 있다. React에서 가장 유명한 것은 <code>eslint-plugin-react</code>다. 기본적으로 몇가지 베스트 프랙티스를 확인하여, 이 규칙을 바탕으로 iterator의 키에서 부터 prop type까지 확인해 준다. 다른 유명한 플러그인으로는 <code>eslint-plugin-jsx-a11y</code>가 있는데, 이는 접근성과 관련된 일반적인 문제를 해결하는데 도움을 준다. JSX는 <code>alt</code> <code>tabindex</code>와 같은 HTML과 약간 다른 문법을 제공하므로, 일반적인 플러그인으로 는 확인이 어렵다.</p>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="how-to-make-ajax-call-and-in-which-component-lifecycle-methods-should-i-make-an-ajax-call"><a class="header-anchor" href="#how-to-make-ajax-call-and-in-which-component-lifecycle-methods-should-i-make-an-ajax-call">¶</a>How to make AJAX call and in which component lifecycle methods should I make an AJAX call?</h3>
<p>Axios, jQuery Ajax, 브라우저 빌트인 <code>fetch</code>등을 활용하여 ajax를 활용할 수 있다. 이렇게 데이터를 가져오는 것은 반드시 <code>componentDidMount()</code>내에서 해야 한다. 이는 데이터를 받어온 뒤에 <code>setState()</code>로 컴포넌트를 업데이트 할 수 있게 해준다.</p>
<p>예를 들어, 아래 코드에서 employee 목록을 가져오고 state를 업데이트 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      employees: [],</span><br><span class="line">      error: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch(<span class="string">'https://api.example.com/items'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">      .then(</span><br><span class="line">        (result) =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            employees: result.employees</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        (error) =&gt; &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123; error &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; error, employees &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;employees.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">            &lt;li key=&#123;employee.name&#125;&gt;</span><br><span class="line">              &#123;employee.name&#125;-&#123;employees.experience&#125;</span><br><span class="line">            &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">          ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="#table-of-contents">👆</a></p>
<h3 id="what-are-render-props"><a class="header-anchor" href="#what-are-render-props">¶</a>What are render props?</h3>
<p><strong>Render Props</strong>는 값이 함수인 prop을 활용하여 컴포넌트 간에 코드를 share할 수 있게 해주는 방법이다. 아래 컴포넌트는 <code>render prop</code>을 활용하여 React element를 리턴한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;DataProvider render=&#123;data =&gt; (</span><br><span class="line">  &lt;h1&gt;&#123;<span class="string">`Hello <span class="subst">$&#123;data.target&#125;</span>`</span>&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">)&#125;/</span>&gt;</span><br></pre></td></tr></table></figure>
<p>React Router 와 DownShift 라이브러리가 이 패턴을 사용한다.</p>
<p><a href="#table-of-contents">👆</a></p>

            

        </div>
    </div>

    <style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#000000 !important;background-color:#FFFFFF !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 0px 9px !important;font-size: 17px !important;letter-spacing:-0.08px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Lato', sans-serif !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#000000 !important;}</style><link href="https://fonts.googleapis.com/css?family=Lato&subset=latin,latin-ext" rel="stylesheet">
    <center style="display: block; text-align: -webkit-center; margin-top: 20px;">
        <a class="bmc-button" target="_blank" href="https://www.buymeacoffee.com/foryeffort"><img src="https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg" alt="coffee for yceffort"><span style="margin-left:5px">coffee for yceffort</span></a>
    </center>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/javascript/">javascript</a> <a class="tag tag--primary tag--small t-link" href="/tags/react/">react</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/08/21/reactjs-interview-questions-2/" data-tooltip="리액트 인터뷰 질문 &amp; 답 (2)" aria-label="PREVIOUS: 리액트 인터뷰 질문 &amp; 답 (2)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/08/20/typescript-type-assertion/" data-tooltip="타입스크립트 타입 단언" aria-label="NEXT: 타입스크립트 타입 단언">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/" title="Share on Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/" title="Share on Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 yceffort. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/08/21/reactjs-interview-questions-2/" data-tooltip="리액트 인터뷰 질문 &amp; 답 (2)" aria-label="PREVIOUS: 리액트 인터뷰 질문 &amp; 답 (2)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/08/20/typescript-type-assertion/" data-tooltip="타입스크립트 타입 단언" aria-label="NEXT: 타입스크립트 타입 단언">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/" title="Share on Facebook">
                    <i class="fab fa-facebook" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/" title="Share on Twitter">
                    <i class="fab fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="2">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/">
                        <i class="fab fa-facebook" aria-hidden="true"></i><span>Share on Facebook</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/">
                        <i class="fab fa-twitter" aria-hidden="true"></i><span>Share on Twitter</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://www.gravatar.com/avatar/6b0848c9324388ed7ca5157d9d6e67c6?s=110" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">yceffort</h4>
        
            <div id="about-card-bio"><p>yceffort</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>programmer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                Korea
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://community.algolia.com/wordpress/img/community-badge.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/05/31/bitcoin-btcd-bitcoin-cli/">
                            <h3 class="media-heading">Bitcoin) BTCD와 bitcoin-cli (bitcoin core)의 차이</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 31, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/05/31/ReactiveX-Observable/">
                            <h3 class="media-heading">ReactiveX) Observable</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 31, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/05/31/Levenshtein-distance/">
                            <h3 class="media-heading">두 String의 유사도를 측정해보자 - Levenshtein distance</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 31, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/05/31/compare-string-with-voice/">
                            <h3 class="media-heading">발음 기반으로 String의 유사도를 비교해 보자.</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 31, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/05/31/some-trick-delphi/">
                            <h3 class="media-heading">Delphi) Some tricks</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 31, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/05/31/tracking-bitcoin-core-sync/">
                            <h3 class="media-heading">Bitcoin) Bitcoin-core의 Sync를 동기화 해보자.</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 31, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/05/31/i-bought-bitcoin-and/">
                            <h3 class="media-heading">Bitcoin) 비트코인 샀던 후기</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 31, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/05/31/Reactivex-subject/">
                            <h3 class="media-heading">ReactiveX) Subject</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    May 31, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/06/01/golang-structure-embedding/">
                            <h3 class="media-heading">GoLang) 구조체와 임베딩</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jun 1, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="https://www.yceffort.kr/2018/06/17/bitcoin-white-paper-summary/">
                            <h3 class="media-heading">Bitcoin) 비트코인 백서 요약</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jun 17, 2018
                                
                            </span>
                        </span>
                        <!-- <div class="media-content hide-xs font-merryweather"></div> -->
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                249 posts found
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://photos.smugmug.com/Galleries/All/i-m7cLXBm/0/X3/Lights%20of%20Lyngen-X3.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-x1zkdpaoieempqljgobpkeq95zi4mqk1sxpehbfxheuw5zbkhl7yw1l7engd.min.js"></script>
<!--SCRIPTS END-->

    
        <script>
             var disqus_config = function () {
                 this.page.url = 'https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/';
                 
                    this.page.identifier = '2019/08/20/reactjs-interview-questions-1/';
                 
             };
            (function() {
                var d = document, s = d.createElement('script');
                var disqus_shortname = 'https-www-yceffort-kr';
                s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
    


    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script>
    <script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
    <script>
        var algoliaClient = algoliasearch('LA1F1N8028', 'a69ce72946da4962e0d62d5a662a0c06');
        var algoliaIndex = algoliaClient.initIndex('yceffort_blog');
    </script>


    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
