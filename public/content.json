{"meta":{"title":"yceffort","subtitle":"private blog","description":"this is the yceffort's private blog","author":"yceffort","url":"https://www.yceffort.kr","root":"/"},"pages":[{"title":"404","date":"2019-05-20T02:50:56.432Z","updated":"2019-05-20T02:50:56.432Z","comments":false,"path":"404.html","permalink":"https://www.yceffort.kr/404.html","excerpt":"Page Not Found","text":"Page Not Found"},{"title":"all-tags","date":"2019-05-20T02:50:56.476Z","updated":"2019-05-20T02:50:56.476Z","comments":false,"path":"all-tags/index.html","permalink":"https://www.yceffort.kr/all-tags/index.html","excerpt":"","text":""},{"title":"bookmark","date":"2019-08-13T07:23:15.630Z","updated":"2019-08-13T07:23:15.630Z","comments":false,"path":"bookmark/index.html","permalink":"https://www.yceffort.kr/bookmark/index.html","excerpt":"* Software disenchantment * 브라우저는 어떻게 동작하는가? ¶장기프로젝트 * 브라우저는 어떻게 동작하는가? - 모던 웹브라우저가 동작하는 방법 * 리액트 인터뷰 질문 & 답","text":"Software disenchantment 브라우저는 어떻게 동작하는가? ¶장기프로젝트 브라우저는 어떻게 동작하는가? - 모던 웹브라우저가 동작하는 방법 리액트 인터뷰 질문 &amp; 답"},{"title":"","date":"2019-08-21T02:54:22.678Z","updated":"2019-08-21T02:54:22.678Z","comments":true,"path":"images/favicon/manifest.json","permalink":"https://www.yceffort.kr/images/favicon/manifest.json","excerpt":"{\"name\":\"App\",\"icons\":[{\"src\":\"/android-icon-36x36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\",\"density\":\"0.75\"},{\"src\":\"/android-icon-48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\",\"density\":\"1.0\"},{\"src\":\"/android-icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\",\"density\":\"1.5\"},{\"src\":\"/android-icon","text":"{\"name\":\"App\",\"icons\":[{\"src\":\"/android-icon-36x36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\",\"density\":\"0.75\"},{\"src\":\"/android-icon-48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\",\"density\":\"1.0\"},{\"src\":\"/android-icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\",\"density\":\"1.5\"},{\"src\":\"/android-icon-96x96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\",\"density\":\"2.0\"},{\"src\":\"/android-icon-144x144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\",\"density\":\"3.0\"},{\"src\":\"/android-icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\",\"density\":\"4.0\"}]}"}],"posts":[{"title":"Tensorflow.js - 01. 시작하기","slug":"tensorflowjs-01-get-started","date":"2019-12-20T04:49:06.000Z","updated":"2019-12-20T05:16:20.889Z","comments":true,"path":"2019/12/20/tensorflowjs-01-get-started/","link":"","permalink":"https://www.yceffort.kr/2019/12/20/tensorflowjs-01-get-started/","excerpt":"https://www.tensorflow.org/js/tutorials을 개인적인 학습을 위해 번역한 글입니다. 정확한 번역을 위해서가 아니라, 개인적인 공부를 위해서 하는 것입니다. 오해 ㄴㄴ ¶시작하기 Tensorflow.js는 브라우저와 Node.js에서 머신러닝 모델을 사용하고 훈련시킬 수 있는 자바스크립트 라이브러리입니다. 시작하는 다양한 방법은 아래 섹션들을 참고하세요. ¶직접 Tensors를 사용하지 않고 머신러닝 프로그램을 작성하기 저레벨의 Tensors나 Optimizers 등을 고려하지 않고 머신러닝을 시작하","text":"https://www.tensorflow.org/js/tutorials을 개인적인 학습을 위해 번역한 글입니다. 정확한 번역을 위해서가 아니라, 개인적인 공부를 위해서 하는 것입니다. 오해 ㄴㄴ ¶시작하기 Tensorflow.js는 브라우저와 Node.js에서 머신러닝 모델을 사용하고 훈련시킬 수 있는 자바스크립트 라이브러리입니다. 시작하는 다양한 방법은 아래 섹션들을 참고하세요. ¶직접 Tensors를 사용하지 않고 머신러닝 프로그램을 작성하기 저레벨의 Tensors나 Optimizers 등을 고려하지 않고 머신러닝을 시작하고 싶나요? Tensorflow.js를 기반으로 구축한 ml5.js 라이브러리는 간결하고 접근 가능한 API 를 통해 브라우저 환경에서 머신러닝 알고리즘 및 모델에 접근할 수 있게 해줍니다. ml5.js ¶Tensorflow.js 설치하기 Tensors, layers, optimizers, loss functions 등의 개념에 익숙하신가요? Tensorflow.js는 자바스크립트 환경에서 신경망 네트워크 구축을 위한 유연함을 제공합니다. Tensorflow.js를 브라우저와 node.js환경에서 어떻게 실행할 수 있는지 아래에서 확인해보세요. 설치하기 ¶이미 훈련된 모델을 Tensorflow.js로 변환하기 파이썬으로 사전에 훈련된 모델을 어떻게 Tensorflow.js로 변환할 수 있는지 알아보세요. Keras Model (번역예정) GraphDef Model (번역예정) ¶이미 존재하는 Tensorflow.js 코드에서 배우기 tfjs-examples는 다양한 머신러닝 과제들을 Tensorflow.js로 구현한 작은 코드 예제들을 보여줍니다. Github에서 보기 ¶Tensorflow.js 모델을 시각화 하기 tfjs-vis 는 브라우저에서 Tensorflow.js를 시각화 할 수 있는 작은 라이브러리 입니다. ¶데이터를 Tensorflow.js에서 처리하기 TensorFlow.js는 머신러닝을 활용해 데이터를 처리할 수 있도록 도와줍니다.","categories":[],"tags":[{"name":"machine-learning","slug":"machine-learning","permalink":"https://www.yceffort.kr/tags/machine-learning/"},{"name":"ai","slug":"ai","permalink":"https://www.yceffort.kr/tags/ai/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://www.yceffort.kr/tags/tensorflow/"},{"name":"tensrflowjs","slug":"tensrflowjs","permalink":"https://www.yceffort.kr/tags/tensrflowjs/"}]},{"title":"Tensorflow.js - 02. 설치하기","slug":"tensorflowjs-02-setup","date":"2019-12-20T04:49:01.000Z","updated":"2019-12-20T05:15:36.497Z","comments":true,"path":"2019/12/20/tensorflowjs-02-setup/","link":"","permalink":"https://www.yceffort.kr/2019/12/20/tensorflowjs-02-setup/","excerpt":"¶설치 ¶브라우저 설치 Tensorflow.js를 설치하는 방법은 두 가지가 있습니다. * Script tag를 이용하는법 * npm을 이용해서 설치하고, Parcel, Webpack, Rollup 같은 빌드 툴을 사용 뉴비 웹 개발자거나, 위 에서 언급한 패키지 들을 전혀 모른다면 스크립트 태그를 활용하세요. 혹은 조금 경험 이 있거나, 큰 규모의 프로그램을 계획하고 있다면 빌드 툴 활용을 검토해보세요. ¶스크립트 태그 사용하기 1","text":"¶설치 ¶브라우저 설치 Tensorflow.js를 설치하는 방법은 두 가지가 있습니다. Script tag를 이용하는법 npm을 이용해서 설치하고, Parcel, Webpack, Rollup 같은 빌드 툴을 사용 뉴비 웹 개발자거나, 위 에서 언급한 패키지 들을 전혀 모른다면 스크립트 태그를 활용하세요. 혹은 조금 경험 이 있거나, 큰 규모의 프로그램을 계획하고 있다면 빌드 툴 활용을 검토해보세요. ¶스크립트 태그 사용하기 1&lt;script src=\"https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js\"&gt;&lt;/script&gt; 12345678910111213141516// linear regression 모델const model = tf.sequential();model.add(tf.layers.dense(&#123; units: 1, inputShape: [1] &#125;));model.compile(&#123; loss: \"meanSquaredError\", optimizer: \"sgd\" &#125;);// 훈련을 위한 임의 데이터 생성const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);// 데이터 기반으로 훈련시키기model.fit(xs, ys, &#123; epochs: 10 &#125;).then(() =&gt; &#123; // 훈련한 모델을 기반으로 데이터 예측 model.predict(tf.tensor2d([5], [1, 1])).print(); // dev tool에 결과 값이 나온다.&#125;); ¶npm을 이용해서 설치하기 npm cli나 yarn둘다 활용할 수 있습니다. 1yarn add @tensorflow/tfjs 1npm install @tensorflow/tfjs 123456789101112131415161718import * as tf from \"@tensorflow/tfjs\";// linear regression 모델const model = tf.sequential();model.add(tf.layers.dense(&#123; units: 1, inputShape: [1] &#125;));model.compile(&#123; loss: \"meanSquaredError\", optimizer: \"sgd\" &#125;);// 훈련을 위한 임의 데이터 생성const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);// 데이터 기반으로 훈련시키기model.fit(xs, ys, &#123; epochs: 10 &#125;).then(() =&gt; &#123; // 훈련한 모델을 기반으로 데이터 예측 model.predict(tf.tensor2d([5], [1, 1])).print(); // 결과 값이 나온다.&#125;); ¶Node.js 설치 npm cli나 yarn둘다 활용할 수 있습니다. Option1 native C++ 바인딩이 포함되어 있는 Tensorflow.js 설치 1yarn add @tensorflow/tfjs-node 1npm install @tensorflow/tfjs-node Option2 (리눅스 만 가능) 만약 시스템에서 CUDA NVIDIA GPU를 활용 가능하다면, 더 고성능 퍼포먼스를 위해 GPU 패키지를 사용할 수도 있습니다. 1yarn add @tensorflow/tfjs-node-gpu 1npm install @tensorflow/tfjs-node-gpu Option3 순수 자바스크립트 버전 설치. 셋 중에 가장 느린 버전입니다. 1yarn add @tensorflow/tfjs 1npm install @tensorflow/tfjs 123456789101112131415161718192021222324const tf = require(\"@tensorflow/tfjs\");// 옵셔널// '@tensorflow/tfjs-node-gpu' gpu와 사용하고 싶다면require(\"@tensorflow/tfjs-node\");// Train a simple model:const model = tf.sequential();model.add( tf.layers.dense(&#123; units: 100, activation: \"relu\", inputShape: [10] &#125;));model.add(tf.layers.dense(&#123; units: 1, activation: \"linear\" &#125;));model.compile(&#123; optimizer: \"sgd\", loss: \"meanSquaredError\" &#125;);const xs = tf.randomNormal([100, 10]);const ys = tf.randomNormal([100, 1]);model.fit(xs, ys, &#123; epochs: 100, callbacks: &#123; onEpochEnd: (epoch, log) =&gt; console.log(`Epoch $&#123;epoch&#125;: loss = $&#123;log.loss&#125;`) &#125;&#125;); ¶TypeScript 타입스크립트 환경에서 사용한다면, 그리고 프로젝트에서 strict null 체킹을 한다면skipLibCheck: true 을 tsconfig.json에 포함시켜서 컴파일 도중에 에러가 나지 않도록 처리해야 합니다.","categories":[],"tags":[{"name":"machine-learning","slug":"machine-learning","permalink":"https://www.yceffort.kr/tags/machine-learning/"},{"name":"ai","slug":"ai","permalink":"https://www.yceffort.kr/tags/ai/"},{"name":"tensorflow","slug":"tensorflow","permalink":"https://www.yceffort.kr/tags/tensorflow/"},{"name":"tensrflowjs","slug":"tensrflowjs","permalink":"https://www.yceffort.kr/tags/tensrflowjs/"}]},{"title":"2020년 목표","slug":"goal-2020","date":"2019-12-18T07:38:23.000Z","updated":"2019-12-20T01:55:20.320Z","comments":true,"path":"2019/12/18/goal-2020/","link":"","permalink":"https://www.yceffort.kr/2019/12/18/goal-2020/","excerpt":"Don’t do anything boring ¶Tensorflow JS 중요도: ★★★★★ 난이도: ★★★★★ AI가 하고 싶어요 선생님… tensorflowjs 를 튜토리얼부터 따라하면서 배워보자. ¶알고리즘 강의 백준강의 이제 알고리즘 정복할 때가 되었다. 자바스크립트와 파이썬으로 진행해볼 예정. 중요도: ★★★★ 난이도: ★★ ¶Preference 패키지 terminal과 친숙해지기 위해 alias설정, git 설정 등을 모아 놓은 private repository를 만들어보고자 한다. https://blog.ap","text":"Don’t do anything boring ¶Tensorflow JS 중요도: ★★★★★ 난이도: ★★★★★ AI가 하고 싶어요 선생님… tensorflowjs 를 튜토리얼부터 따라하면서 배워보자. ¶알고리즘 강의 백준강의 이제 알고리즘 정복할 때가 되었다. 자바스크립트와 파이썬으로 진행해볼 예정. 중요도: ★★★★ 난이도: ★★ ¶Preference 패키지 terminal과 친숙해지기 위해 alias설정, git 설정 등을 모아 놓은 private repository를 만들어보고자 한다. https://blog.appkr.dev/work-n-play/dotfiles/ https://github.com/inbeom/dotfiles https://github.com/boxersb/dotfiles 요런 거를 참고해보자. dotfiles 보다는 광범위한 영역을 커버해보고 싶다. 중요도: ★ 난이도: ★★ ¶Resume 작성 마크다운 문서로 Resume를 준비해두자. 그리고 꼭 이직은 아니더라도 한 두군데 이따금씩 넣어보면서 업계에서의 내 위치(?) 를 고민해보자. 중요도: ★★★★ 난이도: ★ ¶Kindle 이제 이 좁은 집에 더 이상 책 둘 곳도 없다. 이제 그냥 킨들로 읽자. 작년까지는 무식하게 많이 읽자 주의 였다면, 이제는 좀 한권씩 정독할 생각이다. 중요도: ★★★ 난이도: ★★★★★ ¶영어 Speaking 영어 면접 대비인데… 당장 일하러갈일이 없어서 이건 안 할 수도 있겠다. 중요도: ★★★ 난이도: ★ ¶앱 런칭 flutter 나 react-native-app으로 새롭게 앱 하나 만들어 보고 싶다. 근데 마땅히 뭘 만들어야 할지 아무생각이 없다. 중요도: ★ 난이도: ★★★★","categories":[],"tags":[{"name":"diary","slug":"diary","permalink":"https://www.yceffort.kr/tags/diary/"}]},{"title":"Github을 아름답게 관리하기","slug":"lets-beautify-git","date":"2019-12-18T05:31:17.000Z","updated":"2019-12-18T07:22:00.830Z","comments":true,"path":"2019/12/18/lets-beautify-git/","link":"","permalink":"https://www.yceffort.kr/2019/12/18/lets-beautify-git/","excerpt":"¶Commit Message 좋은 git commit 메시지를 위한 영어사전 좋은 git 커밋 메시지를 작성하기 위한 7가지 약속 ¶요약 Single Line 1 [#issue number] :emoji: Commit Message Multi Line 1 2 3 [#issue number] :emoji: Commit Message - change detail1 - change detail2 * Single Line 과 동일하지만, Multi Line 으로 가면 두 번째 라인은 반드시 비워둘 것 * 세 번째","text":"¶Commit Message 좋은 git commit 메시지를 위한 영어사전 좋은 git 커밋 메시지를 작성하기 위한 7가지 약속 ¶요약 Single Line 1[#issue number] :emoji: Commit Message Multi Line 123[#issue number] :emoji: Commit Message- change detail1- change detail2 Single Line 과 동일하지만, Multi Line 으로 가면 두 번째 라인은 반드시 비워둘 것 세 번째 라인부터 Change 상세를 리스트 형식으로 기술 ¶Linear History in git ¶장점 git bisect possibility of submitting with history to another version control system like SVN Documentation for the posterity. A linear history is typically easier to follow. This is similar to how you want your code to be well structured and documented: whenever someone needs to deal with it later (code or history) it is very valuable to be able to quickly understand what is going on. Improving code review efficiency and effectiveness. If a topic branch is divided into linear, logical steps, it is much easier to review it compared to reviewing a convoluted history or a squashed change-monolith (which can be overwhelming). When you need to modify the history at a later time. For instance when reverting or cherry-picking a feature in whole or in part. Scalability. Unless you strive to keep your history linear when your team grows larger (e.g. hundreds of contributors), your history can become very bloated with cross branch merges, and it can be hard for all the contributors to keep track of what is going on. 출처 ¶Rebase 리베이스가 최고다 출처 간단히 요약하면, 내가 작업한 내용을 master의 최신 커밋 뒤에 이어서 붙이는 것이다. 우리의 목표 rebase 대상 브랜치 (보통은 master)를 checkout해서 pull rebase 하려는 브랜치 (내가 작업한 브랜치)를 checkout해서 pull 현재까지의 상태는 이럴 것이다. git rebase master 를 때린다 컨플릭이 없다면 6번으로 컨플릭이 있다면 컨플릭을 해결한 후에 git rebase --continue를 한다. git push origin &lt;branch&gt; --force로 force push를 한다. 리베이스는 과거 커밋을 지우고 뒤에 이어 붙인 새로운 커밋을 만들기 때문에, 저장소의 커밋 히스토리를 다시 쓰게 된다.","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.yceffort.kr/tags/git/"}]},{"title":"2019년 회고","slug":"retrospective-2019","date":"2019-12-13T12:25:46.000Z","updated":"2019-12-18T07:22:09.928Z","comments":true,"path":"2019/12/13/retrospective-2019/","link":"","permalink":"https://www.yceffort.kr/2019/12/13/retrospective-2019/","excerpt":"2019년도 이제 2주가 채 남지 않았습니다. 2019년에 대해 잠시 뒤돌아 보는 시간을 갖도록 하겠습니다. ¶Achievement ¶1. 퇴사 그리고 이직 사실 K사에 있었을 때에는, 나름에 그 다음 이직에 대한 몇가지 원칙이 있었습니다. * 3년을 채워서 꼭 안식월 1달을 누리기 * 더 돈을 많이 주고, 복지도 더 좋은 곳을 가기 * 웹 개발 그만 두고 다른 일하기 (Data 분석, AI frontend 등…) 결론은 무엇하나 지키지 못했습니다. * 3년을 2달 앞두고 퇴사 * 돈은 더 많이 주는데, 복지가 더","text":"2019년도 이제 2주가 채 남지 않았습니다. 2019년에 대해 잠시 뒤돌아 보는 시간을 갖도록 하겠습니다. ¶Achievement ¶1. 퇴사 그리고 이직 사실 K사에 있었을 때에는, 나름에 그 다음 이직에 대한 몇가지 원칙이 있었습니다. 3년을 채워서 꼭 안식월 1달을 누리기 더 돈을 많이 주고, 복지도 더 좋은 곳을 가기 웹 개발 그만 두고 다른 일하기 (Data 분석, AI frontend 등…) 결론은 무엇하나 지키지 못했습니다. 3년을 2달 앞두고 퇴사 돈은 더 많이 주는데, 복지가 더 좋지는 않음 (K사가 짱이었습니다) 웹 개발은 계속 (…) 1번은 그다지 아쉽지 않았고 (쉬는 건 별로 좋아하지 않으므로), 2번도 반은 이뤘으니 그렇다 치더라도, 웹 개발을 계속할 줄은 몰랐습니다. 나름 웹 개발은 많이 해왔다고 자부하고 있었고, 진입장벽도 낮은 데다가 오래 일할 수 있는 분야는 아닌 거 같아서, 한참 눈돌아가던 인공지능을 하고싶어서 새로운 전환점을 갖고 싶었는데요. 시장은 만만치 않더군요. 그리고 제 스펙은 더 만만치 않았습니다. 결국 (꼬드김에 못이겨) 스타트업에 왔는데요. 얼마나 내가 개발을 못하고, 얼마나 배울 것이 많은지, 또 얼마나 잘난 사람들이 많은지 매일매일 깨닫고 있습니다. 솔직히, 개발자라고 말하는게 부끄러운 정도였습니다. ¶2. 석사 K 대학에서 드디어 석사 졸업을 하게 되었습니다. 🚀🚀🚀🚀🚀 2년전 회사가 심심해서 &amp; 그리고 스스로 개발 경쟁력이 없는 것 같아서 시작한 기술경영과정. 나름 개발 외의 일에 머리를 굴려보고, 더 넓은 시야를 가지게 되었는데요. 2년간의 학비와 대전 교통비를 갈아넣은 결과 배운 것은 아래와 같습니다. 개발이 2500배쯤은 더 재밌다 개발보다 PPT만들고 발표하는 걸 더 잘하는 거 같다 (ㄹㅇ) 인맥을 늘릴 기회는 인싸에게나 오는 것이다 (한번 아싸는 영원한 아싸) 연구하고 논문쓰는건 내가 할짓이 못된다 효도의 연장선과 어줍잖은 학위부심을 얻었다는 데에서 의의를 두렵니다. ¶3. 블로그 2019년 막판 3달은 거지같은 졸업준비를 하느라 손 하나도 못댔는데, 블로그가 나름 유의미한 성과가 있었습니다. 네이버 영화 댓글 크롤링하는 거에 대해 관심이 많으신가 보더라구요. 이메일로 물어보시는 분들도 있었고- 사실 이거 친구 대학원 과제 도와주려고 올린 포스팅인데, 이렇게 반응이 좋을 줄은 몰랐습니다. https://okky.kr/article/634588?note=1805107 이렇게 제 링크가 인용되는 것도 봤구요. 사실 별거 아닌 내용이었는데 뿌듯했습니다. 또 지난 1~2년 사이에 블록체인/비트코인을 조졌는데, 여기저기 관련해서 제 글이 떠다니더군요. http://wiki.hash.kr/index.php/활동증명 http://wiki.hash.kr/index.php/중요도증명 https://www.moneynet.co.kr/free_board/20385461 https://medium.com/b-ock-chain/pow와-pos의-문제점-1851a2227074 등 등 … 하지만 블록체인 쪽은 이제 손땠습니다. 제가 백수가 되지 않는 한에서는 다시 블록체인이나 비트코인을 쳐다볼 일은 없을 것 같습니다. ¶Conclusion 2019년, 그래도 학교 공부만 하다가 끝장 난 줄알았는데 (실제로는 그렇지만) 다행이네요. 2019년 제 점수는 60점 드리겠습니다. 노력은 가상했지만, 발전했는가는 잘 모르는 한 해였습니다.","categories":[],"tags":[{"name":"diary","slug":"diary","permalink":"https://www.yceffort.kr/tags/diary/"}]},{"title":"리액트 텍스트 하이라이트 만들기","slug":"react-text-highlight","date":"2019-10-15T01:51:36.000Z","updated":"2019-12-18T05:23:29.702Z","comments":true,"path":"2019/10/15/react-text-highlight/","link":"","permalink":"https://www.yceffort.kr/2019/10/15/react-text-highlight/","excerpt":"¶요구사항 한 엘리먼트안에서 특정한 키워드를 다른 색싱으로 바꿔서 출력하는 것이다. 아래 예시를 살펴보자 ¶before 1 카카오 페이지 카카오 스토리 카카오톡 ¶after 1 2 3 4 5 카카오 페이지 카카오 스토리 카카오톡 ¶의식의 흐름 특정 키워드가 포함되어 있는지, 그리고 그것을 따로 뽑아 낼 수 있는 가장","text":"¶요구사항 한 엘리먼트안에서 특정한 키워드를 다른 색싱으로 바꿔서 출력하는 것이다. 아래 예시를 살펴보자 ¶before 1&lt;Text&gt;카카오 페이지 카카오 스토리 카카오톡&lt;/Text&gt; ¶after 12345&lt;Text&gt; &lt;Text color=\"blue\"&gt;카카오 &lt;/Text&gt;페이지 &lt;Text color=\"blue\"&gt;카카오 &lt;/Text&gt;스토리 &lt;Text color=\"blue\"&gt;카카오&lt;/Text&gt;톡&lt;/Text&gt; ¶의식의 흐름 특정 키워드가 포함되어 있는지, 그리고 그것을 따로 뽑아 낼 수 있는 가장 간단한 방법은 무엇일까? 바로 split 일 것이다. 12const splitResult = \"카카오 페이지, 카카오 스토리, 카카오톡\";splitResult.split(\"카카오\"); // [\"\", \" 페이지, \", \" 스토리, \", \"톡\"] 그러나 여기서 두 가지 몰랐던 사실을 알게 된다. 첫 문자에 seperator 가 동일하게 나올 경우, 앞에 &quot;&quot;가 무조건 나온다. text === seperator 면 결과는 빈 문자열 두개다. 12const splitResult = \"카카오\";splitResult.split(\"카카오\"); // [\"\", \"\"] 문자열에서 separator가 등장하면 해당 부분은 삭제되고 남은 문자열이 배열로 반환됩니다. separator가 등장하지 않거나 생략되었을 경우 배열은 원본 문자열을 유일한 원소로 가집니다. separator가 빈 문자열일 경우, str은 문자열의 모든 문자를 원소로 가지는 배열로 변환됩니다. separator가 원본 문자열의 처음이나 끝에 등장할 경우 반환되는 배열도 빈 문자열로 시작하거나 끝납니다. 그러므로 원본 문자열에 separator 하나만이 포함되어 있을 경우 빈 문자열 두 개를 원소로 가지는 배열이 반환됩니다. 평소에 잘 몰랐던 split의 심오한 철학이 많이 있으니 가서 확인해보는 것도 좋을 듯 하다. 암튼 첫 번쨰 결과물은 이렇다. 1234567891011121314151617181920const [initial, ...rest] = text.split(highlight)&lt;Text&gt; &#123;rest.reduce( (partialResult, current) =&gt; [ ...partialResult, &lt;Text key=&#123;highlight + current&#125; color=&#123;highlightColor&#125; inlineBlock size=&#123;fontSize&#125; whiteSpace=\"pre\" &gt; &#123;highlight&#125; &lt;/Text&gt;, current, ], [initial], )&#125;&lt;/Text&gt; reduce 를 활용해서, 처리했다. 근데 어차피, map으로 돌면서 하는게 더 간단하지 않을까 하는 아이디어가 나왔다. ¶결과 123456789101112131415161718192021const initial = text.split(highlight)&lt;Text&gt; &#123;initial.map((normal, i) =&gt; i &gt; 0 ? ( &lt;&gt; &lt;Text key=&#123;highlight + i.toString()&#125; color=&#123;highlightColor&#125; inlineBlock size=&#123;fontSize&#125; whiteSpace=\"pre\" &gt; &#123;highlight&#125; &lt;/Text&gt; &#123;normal&#125; &lt;/&gt; ) : ( &lt;&gt;&#123;normal&#125;&lt;/&gt; ), )&#125;&lt;/Text&gt; i &gt; 0 을 처리한 이유는, 어차피 첫번째 엘리먼트는 무조건 하이라이트가 안되는 텍스트가 오기 때문이다! 첫단어가 일치하는 단어라면 &quot;&quot;가 올 것이고, 일치 하지 않는 단어라면 그 단어 그대로 올라오기 떄문에 첫번째 단어는 별도처리를 하지 않아도 된다. 그리고 두번째 엘리먼트 부터 해당 text가 있어서 쪼개진 단어가 올것이기 때문에, 앞에 하이라이트 텍스트를 붙여주고, 그 다음 평범한 단어를 붙여주면 된다.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://www.yceffort.kr/tags/typescript/"},{"name":"algorithm","slug":"algorithm","permalink":"https://www.yceffort.kr/tags/algorithm/"}]},{"title":"typescript debounce","slug":"debounce","date":"2019-10-14T00:17:00.000Z","updated":"2019-12-18T05:23:29.702Z","comments":true,"path":"2019/10/14/debounce/","link":"","permalink":"https://www.yceffort.kr/2019/10/14/debounce/","excerpt":"Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Provide option","text":"Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Provide options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last func invocation. 출처 디바운스는 과다한 이벤트 로직이 실행되는 것을 방지하는 함수로, 호출이 반복되는 동안에는 반복해서 로직이 실행되는 것을 막고, 설정한 시간이 지나고 나서야 로직이 실행하게 하는 함수다. 123456789101112export function debounce&lt;Params extends any[]&gt;( func: (...args: Params) =&gt; any, timeout: number): (...args: Params) =&gt; void &#123; let timer: NodeJS.Timeout; return (...args: Params) =&gt; &#123; clearTimeout(timer); timer = setTimeout(() =&gt; &#123; func(...args); &#125;, timeout); &#125;;&#125; 즉, 반복되는 이벤트가 계속해서 실행될 때, 매번 그 이벤트를 실행하는 것이 아니라, timeout 만큼의 시간이 흐른뒤에, 이전의 이벤트를 무시하고 이벤트 하나만 실행하는 것이다.","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://www.yceffort.kr/tags/typescript/"}]},{"title":"브라우저 히스토리 조작","slug":"handle-browser-history","date":"2019-09-30T00:28:48.000Z","updated":"2019-12-18T05:23:29.702Z","comments":true,"path":"2019/09/30/handle-browser-history/","link":"","permalink":"https://www.yceffort.kr/2019/09/30/handle-browser-history/","excerpt":"¶브라우저 히스토리 브라우저의 히스토리는 window.history안에 있다. History {length: 3, scrollRestoration: \"auto\", state: null} length만 가져올 수 있을 뿐, 실제 내부에 리스트는 가져올 수가 없는데 이는 보안상의 문제 때문이다. window.history.back() window.history.forward()는 각각 브라우저의 앞으로가기 뒤로 가기와 동일한 역할을 한다. ¶특정 위치로 가기 window.history.go(n) 현재 페이지의 index는 0 이","text":"¶브라우저 히스토리 브라우저의 히스토리는 window.history안에 있다. History {length: 3, scrollRestoration: &quot;auto&quot;, state: null} length만 가져올 수 있을 뿐, 실제 내부에 리스트는 가져올 수가 없는데 이는 보안상의 문제 때문이다. window.history.back() window.history.forward()는 각각 브라우저의 앞으로가기 뒤로 가기와 동일한 역할을 한다. ¶특정 위치로 가기 window.history.go(n) 현재 페이지의 index는 0 이라고 볼 수 있다. -1 은 바로 전 페이지, 1 은 다음 페이지라고 볼 수 있다. ¶히스토리 추가 및 변경 ¶pushState window.pushState(state, title, url) 아래와 같이 한번 사용해보자. 1history.pushState(&#123; hello: \"world\" &#125;, \"title\", \"hello\"); 현재 있는 페이지 주소창에서 hello가 추가되었음을 알 수 있다. 그러나 브라우저는 이를 불러오지도 않고, 해당 주소의 존재여부도 파악하지 않는다. 그저 주소만 바뀐 것이다. 아래 프로세스를 살펴보자. www.google.com 접속 -&gt; history: 1 history.pushState({ hello: &quot;world&quot; }, &quot;title&quot;, &quot;hello&quot;); 입력 -&gt; 주소창: google.com/hello / history: 2 www.naver.com 접속 -&gt; history: 3 뒤로가기 버튼 클릭 https://www.google.com/hello 가 404를 띄움 -&gt; history.state에 hello: world 가 있음. 뒤로가기 버튼 클릭 www.google.com 으로 돌아가지만, 여전히 404 따라서 pushState는 history에 새로운 history만을 추가할 뿐, 실질적으로 페이지 이동은 일으키지 않는 다는 것을 볼 수 있다. ¶state javascript object로, pushState로 새로운 히스토리를 만드는 것과 관련이 있다. 사용자가 새로운 상태로 이동할 때마다, popState이벤트가 발생해서, state의 사본을 가져온다. 파이어폭스의 경우 640k정도의 데이터를 저장할 수 있으며, 이는 브라우저를 재시작해도 사용할 수 있다. 즉, 해당 history state에서 필요한 값을 넣어두는 용도로 사용하면 좋다. ¶title 현재 파이어폭스나 크롬에서 쓰지 않는 변수로 보인다. state의 명칭을 기록해 두는 용도로 사용하면 될 것 같다. ¶URL 새로운 history의 url을 지정한다. 이 전 예제에서도 봤던 것처럼, 브라우저는 해당 URL을 호출하지 않는다. 어째 돌아가는 모양, 주소는 바뀌지만 url을 로딩하지 않는 다는 것이 window.location = '#foo' 와 비슷해 보이는 측면이 있다. 이렇게 쓸모없어보이는 pushState는 아래와 같은 장점이 있다. pushState로 생성한 URL은 현재 URL을 기준으로 한다. 반대로 window.location는 해쉬값을 지정할 경우에만 같은 document에 머물러 있다. (아무튼 URL로딩을 안함) URL 변경이 필요 없다면, URL값을 안넣어서 변경을 안해주어도 된다. 반대로 해쉬값 지정의 경우에는 현재 해쉬값과 다른 경우에만 새로운 히스토리를 생성한다. state 오브젝트로 데이터를 저장할 수 있다. 반면 해쉬는 해쉬값을 활용해야 한다. ¶replaceState replaceState는 pushState와 동작이 거의 비슷하다. 다만 히스토리를 추가하는 것이 아닌, 덮어 쓴다는 것에서 차이가 있다.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"},{"name":"browser","slug":"browser","permalink":"https://www.yceffort.kr/tags/browser/"}]},{"title":"타입스크립트 제네릭","slug":"typescript-generic","date":"2019-09-19T06:10:14.000Z","updated":"2019-09-19T07:11:02.993Z","comments":true,"path":"2019/09/19/typescript-generic/","link":"","permalink":"https://www.yceffort.kr/2019/09/19/typescript-generic/","excerpt":"¶제네릭이란 제네릭은 클래스 내부에서 사용하는 데이터의 타입을 외부에서 지정하는 것을 의미한다. 어떤 타입의 데이터를 쓸지를, 클래스 선언부가 아니라 외부에서 결정하는 것이다. 일단 자바 코드로 한번 살펴보자. 1 2 3 4 5 6 class Person{ public T name; } Person p1 = new Person(); Person p1 = new Person(); T라는 데이터 타입은 존재하지 않는다. T는 nam","text":"¶제네릭이란 제네릭은 클래스 내부에서 사용하는 데이터의 타입을 외부에서 지정하는 것을 의미한다. 어떤 타입의 데이터를 쓸지를, 클래스 선언부가 아니라 외부에서 결정하는 것이다. 일단 자바 코드로 한번 살펴보자. 123456class Person&lt;T&gt;&#123; public T name;&#125;Person&lt;String&gt; p1 = new Person&lt;String&gt;();Person&lt;StringBuilder&gt; p1 = new Person&lt;StringBuilder&gt;(); T라는 데이터 타입은 존재하지 않는다. T는 name의 타입으로, 아래 처럼 Person을 사용하는 곳에서 정해진다. 따라서 string이 될수도, stringbuilder가 될수도 있는 것이다. 하지만 자바스크립트에서는 제네릭을 쓸일이 없다. 타입이 없기 때문에, 타입에 맞지 않는 코딩을 한다면 런타임에서 에러가 발생한다. 하지만 타입스크립트는 정적타입 언어이기 때문에 제네릭이 필요하게 되었다. ¶any를 그냥 쓰면 안되나? 아래 코드를 살펴보자. 12345678910111213class School &#123; private students: any[] = []; constructor() &#123;&#125; go(student: any): void &#123; this.students.push(student); &#125; bye(): void &#123; this.students.pop(); &#125;&#125; 12345const school = new School();stack.push(\"라이오넬 멧시\");stack.push(10);stack.pop().substring(0);stack.pop().substring(0); // 에러 string에 이어서 number도 일일이 대응하기 위해서는 any를 쓰거나, 상속을 받아야 할 것이다. ¶typescript 문법 12345678910111213class School&lt;T&gt; &#123; private students: T[] = []; constructor() &#123;&#125; go(student: T): void &#123; this.students.push(student); &#125; bye(): T &#123; return this.students.pop(); &#125;&#125; &lt;T&gt;는 제네릭을 의미하며, 그안에 타입으로 사용될 T를 넣었다. 다른 문자도 되지만, 대게는 T를 쓰고 Type Variables라고 한다. 123const numberSchool = new School&lt;number&gt;();const stringSchool = new School&lt;string&gt;();const stringSchool = new School&lt;boolean&gt;(); 이제 각각의 타입이 선언되어 사용될 수 가 있다. ¶함수에 써보기 다양한 타입의 array를 받아서 그 array의 첫번쨰를 리턴하는 함수를 만든다고 가정해보자. any를 사용한다면 123function returnFirstItem(items: any[]): any &#123; return items[0];&#125; 하지만 제네릭을 쓴다면 12345function returnFirstItem&lt;T&gt;(items: T[]): T &#123; return items[0];&#125;returnFirstItem&lt;number&gt; [0, 1, 2, 3]; 이 된다. ¶여러개 Generic 12345function multipleGeneric&lt;T, U&gt;(a1: T, a2: U): [T, U] &#123; return [a1, a2];&#125;multipleGeneric&lt;string, boolean&gt;(\"true\", true); ¶rest에서 제네릭 12345678910interface XYZ &#123; x: any; y: any; z: any;&#125;function dropXYZ&lt;T extends XYZ&gt;(obj: T) &#123; let &#123; x, y, z, ...rest &#125; = obj; return rest;&#125; 객체에서 x, y, z를 빼다가 나머지를 리턴하는 함수이다. 객체에서 x, y, z가 없다면 컴파일 단계에서 에러가 날 것이고, x, y, z 가 있다면 어떤 타입이든 상관없이 x, y, z를 제거하고 리턴해줄 것이다. 만약 x, y, z가 없는 리턴타입까지 정확하게 명사히고 싶다면 이런 짓도 가능하다. 1234567891011121314interface XYZ &#123; x: any; y: any; z: any;&#125;// Pick&lt;T, a&gt;는 T에서 a만 받는 다는 것이다// Exclude&lt;keyof T, keyof XYZ&gt;는 앞에 타입에서 뒤에 있는 타입을 제외해준다.type DropXYZ&lt;T&gt; = Pick&lt;T, Exclude&lt;keyof T, keyof XYZ&gt;&gt;;function dropXYZ&lt;T extends XYZ&gt;(obj: T): DropXYZ&lt;T&gt; &#123; let &#123; x, y, z, ...rest &#125; = obj; return rest;&#125; conditional types에 대해서도 알아봐야 겠다.","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://www.yceffort.kr/tags/typescript/"}]},{"title":"자바스크립트의 이벤트루프, 태스크, 그리고 마이크로 태스크","slug":"javascript-event-loop","date":"2019-09-06T00:51:26.000Z","updated":"2019-09-20T00:36:54.551Z","comments":true,"path":"2019/09/06/javascript-event-loop/","link":"","permalink":"https://www.yceffort.kr/2019/09/06/javascript-event-loop/","excerpt":"¶자바스크립트는 단일 스레드 기반의 언어 자바스크립트는 ‘단일 스레드’ 기반의 언어다. 즉, 스레드가 하나이기 때문에 동시에 하나의 작업만 처리할 수 있다. 그러나 자바스크립트가 사용되는 웹을 곰곰히 생각해보면 동시에 여러개의 작업을 처리하는 모습을 볼 수 있다. 스레드가 하나인 자바스크립트는 동시성을 어떻게 처리할까? 먼저 브라우저 구동환경을 살펴보자. 위 이미지에서, 자바스크립트 엔진은 메모리 할당을 관리하는 heap과 call stack만 존재하는 것을 알 수 있다. 즉, 동시성에 대한 처리는 자바스크립트 외부에서 처","text":"¶자바스크립트는 단일 스레드 기반의 언어 자바스크립트는 ‘단일 스레드’ 기반의 언어다. 즉, 스레드가 하나이기 때문에 동시에 하나의 작업만 처리할 수 있다. 그러나 자바스크립트가 사용되는 웹을 곰곰히 생각해보면 동시에 여러개의 작업을 처리하는 모습을 볼 수 있다. 스레드가 하나인 자바스크립트는 동시성을 어떻게 처리할까? 먼저 브라우저 구동환경을 살펴보자. 위 이미지에서, 자바스크립트 엔진은 메모리 할당을 관리하는 heap과 call stack만 존재하는 것을 알 수 있다. 즉, 동시성에 대한 처리는 자바스크립트 외부에서 처리하고 있음을 알 수 있다. 즉, 정리해서 말하면 자바스크립트는 단일 스레드기반의 언어라서, 단일 호출 스택을 사용하지만, 실제로 자바스크립트를 이용하는 환경 (브라우저, Nodejs)에서는 여러개의 스레드를 활용하며, 이러한 환경을 자바스크립트 엔진과 상호 연동하기 위해서 사용하는 것이 바로 이벤트 루프다. ¶단일 호출 스택, Run-to-Completion 자바스크립트의 함수가 실행되는 방식을 Run-to-Completion, 하나의 함수가 실행되면 이게 끝날 떄까지는 다른 어떤 작업도 끼어들지 못함을 의미한다. 자바스크립트는 하나의 호출 스택을 사용하며, 현재 스택에 쌓여있는 함수들이 모두 실행되기 전까지는 다른 어떠한 함수도 실행될 수 없다. 123456789101112131415161718function delay() &#123; for (var i = 0; i &lt; 10000; i++);&#125;function hi3() &#123; delay(); hi2(); console.log(\"hi3!\"); // (3)&#125;function hi2() &#123; delay(); console.log(\"hi2!\"); // (2)&#125;function hi1() &#123; console.log(\"hi1!\"); // (4)&#125;setTimeout(hi1, 10); // (1)hi3(); 이 함수들이 실행되는 순서를 살펴보자. 여기를 살펴보세용 . setTimeout이 얼마나 일찍 끝났건 간에, 다른 작업들이 먼저 콜 스택에 들어갔으므로, hi1은 절대 먼저 실행되지 않는다. 근데 어디서 이 setTimout에 있는 hi1()를 잡아다가 다시 실행해줬을까? 이를 도와주는 것이 태스크 큐와 이벤트 루프다. 태스크 큐는 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열이고, 이벤트 루프는 콜 스택이 비워질 때 마다 콜백함수에서 꺼내와서 실행하는 역할을 한다. 10ms가 지난 후에, hi1()은 바로 실행되지 안혹, 태스크 큐에 추가한다. 이벤트루프는 현재 실행중인 모든 태스크가 끝나자마자 큐에서 대기중인 첫번째 태스크인 hi1()을 실행해서, 콜스택에 추가한다. 비동기 api들은 작업이 완료되면 콜백함수를 태스크 큐에 추가한다 이벤트 루프는 현재 실행중인 태스크가 없을때 태스크 큐에서 FIFO형식으로 큐를 꺼내와서 실행한다. 렌더링 엔진의 경우에도 마찬가지로, 자바스크립트 엔진과 동일한 태스크 큐를 사용한다. ¶마이크로 태스크 123456789101112131415console.log(\"script start\");setTimeout(function() &#123; console.log(\"setTimeout\");&#125;, 0);Promise.resolve() .then(function() &#123; console.log(\"promise1\"); &#125;) .then(function() &#123; console.log(\"promise2\"); &#125;);console.log(\"script end\"); 여기서 Promise가 setTimeout보다 먼저 실행되는데, 그 이유는 Promise가 마이크로 태스크에 등록되기 떄문이다. 마이크로 태스크는 일반 태스크 보다 더 높은 우선순위를 갖으며, 태스크 큐에 대기중인 것이 있다고 하더라도 마이크로태스크에 있는 것이 우선해서 실행된다. 마이크로 태스크의 잡은 태스크 큐보다 우선하기 때문에, 시간이 오래 걸릴 경우 렌더링 엔진이 작동하지 못하고(일반 태스크에 있으므로) 렌더링이 느려지는 현상이 발생할 수도 있다.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"리액트 인터뷰 질문 & 답 (2)","slug":"reactjs-interview-questions-2","date":"2019-08-21T01:17:16.000Z","updated":"2019-09-06T00:30:06.545Z","comments":true,"path":"2019/08/21/reactjs-interview-questions-2/","link":"","permalink":"https://www.yceffort.kr/2019/08/21/reactjs-interview-questions-2/","excerpt":"목차 ¶Table of Contents No.QuestionsReact Router129What is React Router?130How React Router is different from history library?131What are the components of React Router v4?132What is the purpose of push and replace methods of history?133How do you programmatically navigate using React router","text":"목차 ¶Table of Contents No. Questions React Router 129 What is React Router? 130 How React Router is different from history library? 131 What are the &lt;Router&gt; components of React Router v4? 132 What is the purpose of push and replace methods of history? 133 How do you programmatically navigate using React router v4? 134 How to get query parameters in React Router v4 135 Why you get “Router may have only one child element” warning? 136 How to pass params to history.push method in React Router v4? 137 How to implement default or NotFound page? 138 How to get history on React Router v4? 139 How to perform automatic redirect after login? React Internationalization 140 What is React-Intl? 141 What are the main features of React Intl? 142 What are the two ways of formatting in React Intl? 143 How to use FormattedMessage as placeholder using React Intl? 144 How to access current locale with React Intl 145 How to format date using React Intl? React Testing 146 What is Shallow Renderer in React testing? 147 What is TestRenderer package in React? 148 What is the purpose of ReactTestUtils package? 149 What is Jest? 150 What are the advantages of Jest over Jasmine? 151 Give a simple example of Jest test case React Redux 152 What is Flux? 153 What is Redux? 154 What are the core principles of Redux? 155 What are the downsides of Redux compared to Flux? 156 What is the difference between mapStateToProps() and mapDispatchToProps()? 157 Can I dispatch an action in reducer? 158 How to access Redux store outside a component? 159 What are the drawbacks of MVW pattern 160 Are there any similarities between Redux and RxJS? 161 How to dispatch an action on load? 162 How to use connect from React Redux? 163 How to reset state in Redux? 164 Whats the purpose of at symbol in the redux connect decorator? 165 What is the difference between React context and React Redux? 166 Why are Redux state functions called reducers? 167 How to make AJAX request in Redux? 168 Should I keep all component’s state in Redux store? 169 What is the proper way to access Redux store? 170 What is the difference between component and container in React Redux? 171 What is the purpose of the constants in Redux? 172 What are the different ways to write mapDispatchToProps()? 173 What is the use of the ownProps parameter in mapStateToProps() and mapDispatchToProps()? 174 How to structure Redux top level directories? 175 What is redux-saga? 176 What is the mental model of redux-saga? 177 What are the differences between call and put in redux-saga 178 What is Redux Thunk? 179 What are the differences between redux-saga and redux-thunk 180 What is Redux DevTools? 181 What are the features of Redux DevTools? 182 What are Redux selectors and Why to use them? 183 What is Redux Form? 184 What are the main features of Redux Form? 185 How to add multiple middlewares to Redux? 186 How to set initial state in Redux? 187 How Relay is different from Redux? React Native 188 What is the difference between React Native and React? 189 How to test React Native apps? 190 How to do logging in React Native? 191 How to debug your React Native? React supported libraries and Integration 192 What is reselect and how it works? 193 What is Flow? 194 What is the difference between Flow and PropTypes? 195 How to use font-awesome icons in React? 196 What is React Dev Tools? 197 Why is DevTools not loading in Chrome for local files? 198 How to use Polymer in React? 199 What are the advantages of React over Vue.js? 200 What is the difference between React and Angular? 201 Why React tab is not showing up in DevTools? 202 What are styled components? 203 Give an example of Styled Components? 204 What is Relay? 205 How to use TypeScript in create-react-app application? ¶React Router ¶What is React Router? React Router는 리액트 최상단에 있는 강력한 라우팅 라이브러리로, 페이지에 보여주는 내용과 URL사이에 동기화를 유지해주고, 어플리케이션에 새로운 화면과 흐름을 추가할 수 있도록 도와준다. 👆 ¶How React Router is different from history library? React router는 history라이브러리를 감싼 래퍼로, 브라우저의 window.history와 상호작용하고, 브라우저 및 해쉬의 히스토리를 다룬다. 또한 모바일 앱 개발 (React Native) 및 Node의 unit testing처럼 global histroy가 없는 환경에 유용한 메모리 히스토리를 제공한다. 👆 ¶What are the &lt;Router&gt; components of React Router v4? v4는 새로운 3개의 &lt;Router&gt; 컴포넌트를 제공한다. &lt;BrowserRouter&gt; &lt;HashRouter&gt; &lt;MemoryRouter&gt; 위 컴포넌트는 각각 브라우저, 해쉬, 메모리 히스토리 인스턴스를 만들어준다. React Router v4는 Router Object의 context를 통해, history 인스턴스의 속성과 메소드를 활용할 수 있게 해준다. 👆 ¶What is the purpose of push() and replace() methods of history? 히스토리 인스턴스에는 네비게이션 목적으로 두개의 메소드를 제공한다. push() replace() 만약 히스토리가 방문했던 곳들의 배열이라고 생각한다면, push()가 그 역할을 할 것이고, 현재 위치를 덮어쓰는 느낌을 원한다면 replace()가 맞을 것이다. 👆 ¶How do you programmatically navigate using React Router v4? Component 내에서 프로그래밍으로 라우팅/네비게이팅 하는 방법에는 3가지가 있다. HOF에서 withRouter()를 쓰는법 HOF의 withRouter()는 컴포넌트의 prop에 히스토리 오브젝트를 인젝트 한다. 이 오브젝트는 push() replace()를 제공하여 context의 사용을 피하게 해준다. 123456789101112import &#123; withRouter &#125; from \"react-router-dom\"; // this also works with 'react-router-native'const Button = withRouter((&#123; history &#125;) =&gt; ( &lt;button type=\"button\" onClick=&#123;() =&gt; &#123; history.push(\"/new-location\"); &#125;&#125; &gt; &#123;\"Click Me!\"&#125; &lt;/button&gt;)); &lt;Route&gt; 컴포넌트와 render props 패턴을 사용하는 법 &lt;Route&gt;는 withRouter()와 같은 props를 넘기므로, history prop을 통해 histoy 메서드에 접근할 수 있을 것이다. 12345678910111213141516import &#123; Route &#125; from \"react-router-dom\";const Button = () =&gt; ( &lt;Route render=&#123;(&#123; history &#125;) =&gt; ( &lt;button type=\"button\" onClick=&#123;() =&gt; &#123; history.push(\"/new-location\"); &#125;&#125; &gt; &#123;\"Click Me!\"&#125; &lt;/button&gt; )&#125; /&gt;); Context 이 방식은 딱히 추천되지 않고, 불안정한 API 활용으로 간주된다. 12345678910111213141516const Button = (props, context) =&gt; ( &lt;button type=\"button\" onClick=&#123;() =&gt; &#123; context.history.push(\"/new-location\"); &#125;&#125; &gt; &#123;\"Click Me!\"&#125; &lt;/button&gt;);Button.contextTypes = &#123; history: React.PropTypes.shape(&#123; push: React.PropTypes.func.isRequired &#125;)&#125;; 👆 ¶How to get query parameters in React Router v4? 수년간 다른 구현 지원에 대한 사용자들의 많은 요청 때문에, React Router v4에서는 query string을 parsing 하는 방법은 사라졌다. 이는 유저가 원하는 대로 구현할 수 있는 자유도를 주었다. 추천하는 방법은, query string 라이브러리를 사용하는 것이다. 12const queryString = require(\"query-string\");const parsed = queryString.parse(props.location.search); native 방식을 선호한다면 URLSearchParam을 사용할 수도 있다. 12const params = new URLSearchParams(props.location.search);const foo = params.get(\"name\"); 다만 IE11에서는 폴리필이 필요하다. 👆 ¶Why you get “Router may have only one child element” warning? Route는 &lt;Switch&gt; 블록으로 감싸줘야 하는데, 왜냐하면 &lt;Switch&gt;는 라우트를 베타적으로 감싸기 때문이다. 먼저 Switch를 임포트 해야 한다. 1import &#123; Switch, Router, Route &#125; from \"react-router\"; 그리고 route를 &lt;Switch&gt; 블록에 넣어햐 한다. 12345&lt;Router&gt; &lt;Switch&gt; &lt;Route &#123;/* ... */&#125; /&gt; &lt;Route &#123;/* ... */&#125; /&gt; &lt;/Switch&gt;&lt;/Router&gt; 👆 ¶How to pass params to history.push method in React Router v4? history 객체에 props를 보낼 수 있다. 12345this.props.history.push(&#123; pathname: \"/template\", search: \"?name=sudheer\", state: &#123; detail: response.data &#125;&#125;); search 속성은 push()에서 query param을 보낼 때 사용된다. 👆 ¶How to implement default or NotFound page? &lt;Switch&gt;는 첫번째로 일치하는 &lt;Route&gt;를 렌더링한다. path가 없는 route는 항상 매치하게 되어 있다. 따라서, path를 제거한 route를 하나 추가하면 된다. 12345&lt;Switch&gt; &lt;Route exact path=\"/\" component=&#123;Home&#125; /&gt; &lt;Route path=\"/user\" component=&#123;User&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt;&lt;/Switch&gt; 👆 ¶How to get history on React Router v4? history 오브젝트를 익스포트 하는 모듈을 만들고, 프로젝트 전체에서 해당 모듈을 임포트 한다. 예를들어, 12345import &#123; createBrowserHistory &#125; from \"history\";export default createBrowserHistory(&#123; /* pass a configuration object here if needed */&#125;); 빌트인 라우터 대신에, &lt;Router&gt; 컴포넌트를 쓴다. 위에서 만든 history.js를 index.js에 임포트 한다. 12345678910import &#123; Router &#125; from \"react-router-dom\";import history from \"./history\";import App from \"./App\";ReactDOM.render( &lt;Router history=&#123;history&#125;&gt; &lt;App /&gt; &lt;/Router&gt;, holder); 빌트인 히스토리 오브젝트와 비슷하게, history의 push메소드를 쓸수도 있다. 1234// some-other-file.jsimport history from \"./history\";history.push(\"/go-here\"); 👆 ¶How to perform automatic redirect after login? react-routersms &lt;Redirect&gt; 컴포넌트를 제공한다. &lt;Redirect&gt;를 렌더링 하면 새로운 위치로 이동하게 된다. 서버사이드 리다이렉트와 마찬가지로, 새로운 위치는 현재 히스토리 스택에 있는 현재 위치를 덮어쓰게 된다. 123456789101112import React, &#123; Component &#125; from \"react\";import &#123; Redirect &#125; from \"react-router\";export default class LoginComponent extends Component &#123; render() &#123; if (this.state.isLoggedIn === true) &#123; return &lt;Redirect to=\"/your/redirect/page\" /&gt;; &#125; else &#123; return &lt;div&gt;&#123;\"Login Please\"&#125;&lt;/div&gt;; &#125; &#125;&#125; 👆 ¶React Internationalization ¶What is React Intl? React Intl string, dates, numbers, 복수 표현 등을 다국어로 포맷팅할 수 있는 컴포넌트와 API를 제공한다. React Intl는 components 와 API 를 바탕으로 Reac를 바인딩하는 FormatJS 의 일부분이다. 👆 ¶What are the main features of React Intl? 숫자를 , 와 함께 표현 날짜와 시간을 올바르게 표현 현재시간을 기준으로 날자를 표현 string의 복수표현 150+개의 언어 지원 브라우저와 노드에서 실행 표준에 맞춰 제작 👆 ¶What are the two ways of formatting in React Intl? string, number, date를 포맷팅하는 방법은 react 컴포넌트 또는 api를 사용하는 두가지 방법이 있다. harmony1234&lt;FormattedMessage id=&#123;\"account\"&#125; defaultMessage=&#123;\"The amount is less than minimum balance.\"&#125;/&gt; 12345678const messages = defineMessages(&#123; accountMessage: &#123; id: \"account\", defaultMessage: \"The amount is less than minimum balance.\" &#125;&#125;);formatMessage(messages.accountMessage); 👆 ¶How to use &lt;FormattedMessage&gt; as placeholder using React Intl? &lt;Formatted... /&gt; 컴포넌트는 plain text가 아닌 elements를 반환하므로, placeholder, alt text처럼 string이 필요한 곳에는 쓸 수 없다. 따라서 여기에서는 formatMessage()를 사용해야한다. higher-order component인 injectIntl()을 사용하여, 컴포넌트에 intl 객체를 주입하고, 객체에서 사용할 수 있는 formatMessage()를 사용하여 message를 포맷팅할 수 있다. harmony12345678910111213import React from \"react\";import &#123; injectIntl, intlShape &#125; from \"react-intl\";const MyComponent = (&#123; intl &#125;) =&gt; &#123; const placeholder = intl.formatMessage(&#123; id: \"messageId\" &#125;); return &lt;input placeholder=&#123;placeholder&#125; /&gt;;&#125;;MyComponent.propTypes = &#123; intl: intlShape.isRequired&#125;;export default injectIntl(MyComponent); 👆 ¶How to access current locale with React Intl? 어느 어플리케이션에서든 injectIntl()를 사용하면 현재 로케일을 얻을 수 있다. 👆 ¶How to format date using React Intl? higher-order 컴포넌트 injectIntl()는 컴포넌트의 props에 formatDate()메서드를 제공한다. 이 메서드는 내부적으로 FormattedDate인스턴스를 활용하고, 이는 포맷된 날짜를 string으로 제공한다. harmony1234567891011121314151617import &#123; injectIntl, intlShape &#125; from \"react-intl\";const stringDate = this.props.intl.formatDate(date, &#123; year: \"numeric\", month: \"numeric\", day: \"numeric\"&#125;);const MyComponent = (&#123; intl &#125;) =&gt; ( &lt;div&gt;&#123;`The formatted date is $&#123;stringDate&#125;`&#125;&lt;/div&gt;);MyComponent.propTypes = &#123; intl: intlShape.isRequired&#125;;export default injectIntl(MyComponent); 👆 ¶React Testing ¶What is Shallow Renderer in React testing? Shallow rendering는 React에서 유닛테스트 케이스를 작성할 때 유용하다. 이는 컴포넌트를 한단계 더 깊이 렌더링하며, 렌더링되지 않은 하위 컴포넌트에 대한 고민 ㅇ벗이 렌더링 메서드가 반환하는 것에 대해 asset를 수행할 수 있다. harmony12345678function MyComponent() &#123; return ( &lt;div&gt; &lt;span className=&#123;\"heading\"&#125;&gt;&#123;\"Title\"&#125;&lt;/span&gt; &lt;span className=&#123;\"description\"&#125;&gt;&#123;\"Description\"&#125;&lt;/span&gt; &lt;/div&gt; );&#125; 123456789101112import ShallowRenderer from \"react-test-renderer/shallow\";const renderer = new ShallowRenderer();renderer.render(&lt;MyComponent /&gt;);const result = renderer.getRenderOutput();expect(result.type).toBe(\"div\");expect(result.props.children).toEqual([ &lt;span className=&#123;\"heading\"&#125;&gt;&#123;\"Title\"&#125;&lt;/span&gt;, &lt;span className=&#123;\"description\"&#125;&gt;&#123;\"Description\"&#125;&lt;/span&gt;]); 👆 ¶What is TestRenderer package in React? TestRenderer 패키지는 component 를 DOM 또는 Native mobile 환경에 의존없이 순수 Javascript Object 로 렌더링 할 수 있는 renderer 를 제공한다. 이 패키지를 사용하면 브라우저 또는 jsdom 의 사용없이 ReactDOM 또는 React Native 에서 렌더링 되는 플랫폼의 뷰 계층구조 (DOM 트리와 유사) 의 스냅샷을 쉽게 가져올 수 있다. harmony1234567891011121314import TestRenderer from \"react-test-renderer\";const Link = (&#123; page, children &#125;) =&gt; &lt;a href=&#123;page&#125;&gt;&#123;children&#125;&lt;/a&gt;;const testRenderer = TestRenderer.create( &lt;Link page=&#123;\"https://www.facebook.com/\"&#125;&gt;&#123;\"Facebook\"&#125;&lt;/Link&gt;);console.log(testRenderer.toJSON());// &#123;// type: 'a',// props: &#123; href: 'https://www.facebook.com/' &#125;,// children: [ 'Facebook' ]// &#125; 👆 ¶What is the purpose of ReactTestUtils package? ReactTestUtils는 유닛테스트를 목적으로 DOM을 조작할 수 있는 with-addons패키지를 제공한다. 👆 ¶What is Jest? Jest는 페이스북이 만든 자바스크립트 유닛테스트 프레임워크로, Jasmine을 기반으로 만들어 졌으며 자동 mock 생성, jsdom 환경 제공 등의 기능을 제공한다. 컴포넌트를 테스트 하는데 사용 된다. 👆 ¶What are the advantages of Jest over Jasmine? Jasmine보다 Jest가 더 좋은 점은 소스코드에서 자동으로 테스트 코드를 찾아서 테스트 테스트 시 자동으로 mock 의 존성 참고 동기로 작성된 코드를 비동기로 테스트 fake Dom implementation으로 테스트 하여, 명령줄에서도 테스트 가능 병렬 프로세스로 테스트 하여 테스트가 더욱 빠르게 수행됨 👆 ¶Give a simple example of Jest test case 두 숫자를 더하는 sum.js를 작성한다. 12const sum = (a, b) =&gt; a + b;export default sum; 테스트를 수행하는 sum.test.js를 작성 12345import sum from \"./sum\";test(\"adds 1 + 2 to equal 3\", () =&gt; &#123; expect(sum(1, 2)).toBe(3);&#125;); package.json에 테스트를 실행하는 코드 추가 12345&#123; \"scripts\": &#123; \"test\": \"jest\" &#125;&#125; yarn test npm test로 테스트 실행 및 결과 확인 123$ yarn testPASS ./sum.test.js✓ adds 1 + 2 to equal 3 (2ms) 👆 ¶React Redux ¶What is flux? Flux는 어플리케이션 디자인 패러다임으로, 전통적인 모델인 MVC pattern을 대체하기 위해 나왔다. Flux는 프레임워크나 라이브러리가 아닌, React와 양방향 데이터 흐름을 기반으로 하는 새로운 아키텍쳐다. 페이스북이 React를 사용할 때 내부적으로 이 패턴을 활용한다. dispatcher, sotres, views 컴포넌트 사이 작업흐름은 아래처럼 input과 output이 구별되어 나타난다. 👆 ¶What is Redux? Redux는 flux 디자인 패턴을 기반으로 한 자바스크립트 앱의 예측가능한 state container다. Redux는 React또는 다른 어떤 뷰 라이브러리와 함께 사용할 수 있다. Redux는 크기가 매우 작고 (2kb), 다른 디펜던시를 갖고 있지 않다. 👆 ¶What are the core principles of Redux? Redux는 다음 세가지 기본 원칙을 가지고 있다. 신뢰할 수 있는 단일 출처: 어플리케이션의 state는 단일 store에 객체트리 형태로 저장되어 있다. 단일 state tree는 변화를 쉽게 추적ㄷ할 수 있게 해주며, 어플리케이션을 디버그하고 검사하는 것을 쉽게 만들어 준다. state는 읽기 전용: state를 변경할 수 있는 방법은 단한가지로, 객체가 어떤 일이 일어났는지 묘사하는 액션을 보내는 것이다. 이는 views나 네트워크 콜백이 직접 state를 수정하지 않도록 한다. 변화는 순수 함수로만 이루어진다: 액션별로 state 트리가 어떻게 변화하는지 명세하기 위해, reducer를 사용해야 한다. 👆 ¶What are the downsides of Redux compared to Flux? Flux와 비교했을 때, Redux는 몇가지 단점을 가지고 있다. 변이를 피하는 법을 배워야 한다: Flux는 데이터 변이에 대해 특별한 의견이 없지만, Redux는 데이터 변이를 선호하지 않으며, 다른 추가 보완 패키지를 활용하여 이를 유지한다. dev-only 패지지인 redux-immutable-state-invariant나 Immutable.js를 활용하거나, 팀원들에게 변이 없는 코드에 대해 방법론을 확산해야 한다. 패키지를 고를때 신중해진다: Flux는 undo/redo, 지속성, 폼 관련 문제에 대해 무관심하지만, Redux 는 미들웨어 및 Store 개선 등 확장된 포인트들을 가지고 풍부한 생태계를 만들어 냈기 때문에, 패키지 선택에 주의가 필요하다. 타입체크: Flux는 정적 타입 체크를 할 수 있는 방법이 있지만, Redux는 아직 지원하고 있지 않다. 👆 ¶What is the difference between mapStateToProps() and mapDispatchToProps()? mapStateToProps()는 컴포넌트에서 다른 컴포넌트에 의해 업데이트된 state를 가져올수 있도록 도와주는 유틸리티다. 12345const mapStateToProps = state =&gt; &#123; return &#123; todos: getVisibleTodos(state.todos, state.visibilityFilter) &#125;;&#125;; mapDispatchToProps()는 컴포넌트가 이벤트를 발생시킬 수 있도록 도와주는 유틸리티다. (이 이벤트는 어플리케이션의 state에 변화를 가져올 수 있음) 1234567const mapDispatchToProps = dispatch =&gt; &#123; return &#123; onTodoClick: id =&gt; &#123; dispatch(toggleTodo(id)); &#125; &#125;;&#125;; mapDispatchToProps에서는 항상 객체를 파라미터로 보내기를 권장한다. Redux는 (…args) =&gt; dispatch(onTodoClick(…args))와 같은 형태의 다른 함수로 감싸고, 이렇게 감싼 함수를 컴포넌트의 prop로 전달한다. 123const mapDispatchToProps = &#123; onTodoClick&#125;; 👆 ¶Can I dispatch an action in reducer? Reducer안에서 액션을 보내는 것은 안티패턴이다. Reducer는 사이드이펙트를 최소화 하기 위하여, 단순히 액션에 대한 처리와 새로운 state를 가진 object를 반환하기만 해야 한다. Reducer내에서 리스너를 달고, 액션을 보내는 것은 다른 액션과 연쇄작용을 일으킬 수도 있으며, 사이드 이펙트를 야기할 수도 있다. 👆 ¶How to access Redux store outside a component? createStore()로 만들어진 모듈을 export 하면 된다. 그리고 global 객체인 window를 사용해서는 안된다. 123store = createStore(myReducer);export default store; 👆 ¶What are the drawbacks of MVW pattern? DOM 조작은, 많은 비용을 지불해야 하고, 어플리케이션을 느리고 비효율적으로 만든다. 순환 참조로 인해, 복잡한 모델이 모델과 뷰주변에 만들어질 수 있다. 구글 docs와 같은 협업 어플리케이션에서는 많은 양의 데이터 변경이 일어날 수 있다. 추가적으로 많은 코드를 쓰지 않고 undo를 쉽게 할 수 없다. 👆 ¶Are there any similarities between Redux and RxJS? 두 라이브러리는 목적부터 완전히 다르지만, 약간의 비슷한점을 가지고있다. Redux는 어플리케이션 전반에서 state를 관리할 수 있게 도와주는 툴이다. 이는 보통 UI 아키텍쳐에서 ㅁ낳이 사용된다. Angular의 대체재라고 볼 수 있다. 반면 Rxjs는 반응형 프로그래밍 라이브러리다. RxJS는 자바스크립트에서 비동기 작업을 수행하기 위해 사용된다. Promise의 대체재라고 볼 수있다. Redux는 Store가 반응형이기 때문에 반응형 패러다임을 사용한다. Store는 액션을 어느정도 거리에서 관찰하다가, 스스로 변화한다. RxJS 또한 반응형 패러다임을 사용하는 반면, 아키텍쳐를 제공하지 않고 Observable 과 같은 블록을 제공한다. 👆 ¶How to dispatch an action on load? componentDidMount()와 render()메서드에서 데이터를 확인하는 액션을 전닥ㄹ할 수 있고 데이터를 확인할 수 있다. harmony123456789101112131415161718192021222324class App extends Component &#123; componentDidMount() &#123; this.props.fetchData(); &#125; render() &#123; return this.props.isLoaded ? ( &lt;div&gt;&#123;\"Loaded\"&#125;&lt;/div&gt; ) : ( &lt;div&gt;&#123;\"Not Loaded\"&#125;&lt;/div&gt; ); &#125;&#125;const mapStateToProps = state =&gt; (&#123; isLoaded: state.isLoaded&#125;);const mapDispatchToProps = &#123; fetchData &#125;;export default connect( mapStateToProps, mapDispatchToProps)(App); 👆 ¶How to use connect() from React Redux? container에서 store를 사용하기 위해서는 아래 두단계를 따라야 한다. mapStateToProps()를 사용: state의 값을 props에서 지정한 store에 맵핑시킨다. 위 props를 Container 와 연결: mapStateToProps()에 의해 리턴되는 객체들은 컨테이너와 연결된다. 이를 react-redux의 connect로 import 할 수 있다. harmony1234567891011121314import React from \"react\";import &#123; connect &#125; from \"react-redux\";class App extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.containerData&#125;&lt;/div&gt;; &#125;&#125;function mapStateToProps(state) &#123; return &#123; containerData: state.data &#125;;&#125;export default connect(mapStateToProps)(App); 👆 ¶How to reset state in Redux? combineReducers()로 생성된 reducer 에게 action 을 위임하도록 application 단에서 root reducer 를 작성해야 한다. 예를 들어, USER_LOGOUT 액션에 초기 state값을 리턴하는 rootReducer()를 예로 들어보자. 알다시피, reducer는 action에 상관없이 첫 번째 매개변수가 undefined로 호출된다면, 초기 상태값을 반환한다. 1234567891011const appReducer = combineReducers(&#123; /* your app's top-level reducers */&#125;);const rootReducer = (state, action) =&gt; &#123; if (action.type === \"USER_LOGOUT\") &#123; state = undefined; &#125; return appReducer(state, action);&#125;; redux-persist를 사용하는 경우, 스토리지를 비워야 할 수도 있다. redux-persist에서는 스토리지 안진에 있는 state의 사본을 보관해둔다. 먼저, 적절한 스토리지 엔진을 임포트 한다음, 상태를 undefined로 설정하기 전에 storage state key를 비워주어야 한다. 👆 ¶Whats the purpose of at symbol in the Redux connect decorator? @는 자바스크립트에서 데코레이터를 나타낼 떄 쓰는 표현식이다. 데코레이터는 class와 속성에 주석을 달고, 이를 수정할 수 있게 해준다. 데코레이터가 없는 redux를 예로 들어보자. 123456789101112131415161718192021import React from \"react\";import * as actionCreators from \"./actionCreators\";import &#123; bindActionCreators &#125; from \"redux\";import &#123; connect &#125; from \"react-redux\";function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; actions: bindActionCreators(actionCreators, dispatch) &#125;;&#125;class MyApp extends React.Component &#123; // ...define your main app here&#125;export default connect( mapStateToProps, mapDispatchToProps)(MyApp); 1234567891011121314151617181920import React from \"react\";import * as actionCreators from \"./actionCreators\";import &#123; bindActionCreators &#125; from \"redux\";import &#123; connect &#125; from \"react-redux\";function mapStateToProps(state) &#123; return &#123; todos: state.todos &#125;;&#125;function mapDispatchToProps(dispatch) &#123; return &#123; actions: bindActionCreators(actionCreators, dispatch) &#125;;&#125;@connect( mapStateToProps, mapDispatchToProps)export default class MyApp extends React.Component &#123; // ...define your main app here&#125; 위 예제는 데코레이터를 사용한 것을 제외하고는 비슷하다. 데코레이터는 아직 자바스크립트 런타임에 구현되어 있지 않다. 여전히 실험적인 내용이기 때문에 수정될 여지가 있다. 바벨을 사용하면 이 데코레이터를 쓸 수 있다. 👆 ¶What is the difference between React context and React Redux? Context는 어플리케이션에서 다이렉트로 사용할 수 있으며, 깊게 중첩된 컴포넌트에 데이터를 전달하는데 유용하다. 반면 Redux는 훨씬 더 강력하며, Context API가 제공하지 않는 기능을 제공한다. 또한, React Redux 는 내부적으로 context를 활용하지만, public api에 공개하지는 않는다. 👆 ¶Why are Redux state functions called reducers? Reducers 는 항상 모든 이전과 현재의 action을 기반으로한 상태값을 반환한다. Redux reducer 가 호출 될 때 마다 상태와 액션이 파라미터로 전달된다. 상태는 action 에 따라 감소되거나 누적되어 다음 상태를 반환한다. 최종 상태를 얻기 위한 action을 실행하는데 action 단위와 store 의 초기 상태 값을 줄일 수 있다. 👆 ¶How to make AJAX request in Redux? 비동기 액션을 허용하는 미들웨어인 redux-thunk를 사용하면 가능하다. 1234567891011121314151617export function fetchAccount(id) &#123; return dispatch =&gt; &#123; dispatch(setLoadingAccountState()); // Show a loading spinner fetch(`/account/$&#123;id&#125;`, response =&gt; &#123; dispatch(doneFetchingAccount()); // Hide loading spinner if (response.status === 200) &#123; dispatch(setAccount(response.json)); // Use a normal function to set the received state &#125; else &#123; dispatch(someError); &#125; &#125;); &#125;;&#125;function setAccount(data) &#123; return &#123; type: \"SET_Account\", data: data &#125;;&#125; 👆 ¶Should I keep all component’s state in Redux store? Redux Store 에서는 Data를 저장하고, 컴포넌트 내부에서는 UI 에 관련된 상태들을 저장한다. 👆 ¶What is the proper way to access Redux store? 컴포넌트에서 스토어에 접근하는 좋은 방법은 connect()함수를 이용하는 것이다. 이 함수는 이미 존재하는 컴포넌트를 감싸 새로운 컴포넌트를 만든다. 이러한 방식을 HOC(Higher Order Component)라고 하는데, 이는 리액트에서 컴포넌트의 기능을 확장할 때 주로 사용한다. 이 방법은 상태와 action 생성자를 컴포넌트에 매핑하고, store가 업데이트 되면 자동적으로 컴포넌트에 state와 action 생성자를 전달 할 수 있도록 해준다. conenct를 사용한 &lt;FilterLink&gt; component예제를 아래에서 살펴보자. 123456789101112131415161718import &#123; connect &#125; from \"react-redux\";import &#123; setVisibilityFilter &#125; from \"../actions\";import Link from \"../components/Link\";const mapStateToProps = (state, ownProps) =&gt; (&#123; active: ownProps.filter === state.visibilityFilter&#125;);const mapDispatchToProps = (dispatch, ownProps) =&gt; (&#123; onClick: () =&gt; dispatch(setVisibilityFilter(ownProps.filter))&#125;);const FilterLink = connect( mapStateToProps, mapDispatchToProps)(Link);export default FilterLink; 이미 성능최적화가 되어 있고, 버그를 발생할 여지도 적기 때문에 개발자들은 context api로 바로 스토어에 접근하는 것 보다는 connect()를 사용하는 것을 더 선호한다. 👆 ¶What is the difference between component and container in React Redux? Component는 어플리케이션의 일부분을 표시하는 함수 또는 클래스 컴포넌트를 의미한다. Container는 비공식적인 용어로, Redux Store와 연결된 컴포넌트를 지칭한다. Container 는 Redux 의 state update 와 action 을 구독하며, DOM element 를 렌더링하지 않는다. 이러한 rendering응ㄴ 하위 component 들에게 위임한다. 👆 ¶What is the purpose of the constants in Redux? 상수를 사용하면 IDE를 사용할 때 프로젝트 전체에서 특정한 기능의 모든 사용내역을 쉽게 찾을 수 있다. 또한 오타로 인한 버그도 방지할 수 있다. 오타가 난다면 즉시 ReferenceError를 낸다. 일반적으로 constant.js또는 actionTypes.js에 저장한다. 123456export const ADD_TODO = \"ADD_TODO\";export const DELETE_TODO = \"DELETE_TODO\";export const EDIT_TODO = \"EDIT_TODO\";export const COMPLETE_TODO = \"COMPLETE_TODO\";export const COMPLETE_ALL = \"COMPLETE_ALL\";export const CLEAR_COMPLETED = \"CLEAR_COMPLETED\"; 이 파일은 두 군데에서 사용된다. 액션 생성시 12345import &#123; ADD_TODO &#125; from \"./actionTypes\";export function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;;&#125; 리듀서 12345678910111213141516import &#123; ADD_TODO &#125; from \"./actionTypes\";export default (state = [], action) =&gt; &#123; switch (action.type) &#123; case ADD_TODO: return [ ...state, &#123; text: action.text, completed: false &#125; ]; default: return state; &#125;&#125;; 👆 ¶What are the different ways to write mapDispatchToProps()? mapDispatchToProps() 안에서 dispatch() 를 사용하여 action creators를 바인딩하는 방법은 몇가지가 있다. 123456789const mapDispatchToProps = dispatch =&gt; (&#123; action: () =&gt; dispatch(action())&#125;);const mapDispatchToProps = dispatch =&gt; (&#123; action: bindActionCreators(action, dispatch)&#125;);const mapDispatchToProps = &#123; action &#125;; 👆 ¶What is the use of the ownProps parameter in mapStateToProps() and mapDispatchToProps()? ownProps 파라미터가 명시되어 있다면, React Redux는 component로 전달된 props를 연결된 함수로 전달한다. 그래서 만약 connected component를 사용한다면, 123import ConnectedComponent from \"./containers/ConnectedComponent\";&lt;ConnectedComponent user=&#123;\"john\"&#125; /&gt;; mapStateToProps()와 mapDispatchToProps()안의 ownProps는 객체가 될 것이다. 1&#123; \"user\": \"john\" &#125; 이 객체를 활용하여 함수에서 무엇을 반환할지 결정할 수 있다. 👆 ¶How to structure Redux top level directories? 대부분의 어플리케이션이 아래와 같은 상위구조 레벨을 가지고 있다. Components: Redux를 모르는 컴포넌트 Container: Redux와 연결된 컴포넌트 Actions: 파일의 이름이 앱의 일부와 일치하는 액션을 생성하는 모든 것 Reducer: 상태 키와 일치파는 파일명을 가진 모든 리듀서 Store: 스토어 초기화를 위해 사용 이러한 구조는 중소규모의 어플리케이션에 적합하다. 👆 ¶What is redux-saga? redux-saga 는 side effects (데이터를 가져오는 비동기적인 작업이나 browser cache 에 접근하는 것등)를 React/Redux applications에서 더 쉽게 만들도록 도와주는 라이브러리다. 👆 ¶What is the mental model of redux-saga? Saga는 어플리케이션과 분리된 스레드와 같은것으로, 부수적인 역할을 담당하기 위한 책임을 가지고 있다. redux-saga는 redux의 미들웨어로, 메인 application 에서 Redux actions 과 함께 쓰레드를 시작, 중지, 취소 할 수 있으며 전체의 Redux application 상태에 접근할 수 있으며 Redux actions 도 전달할 수 있다. 👆 ¶What are the differences between call() and put() in redux-saga? call() put() 모두 effect creator 함수다. call()은 함수는 middleware 가 promise 를 어떻게 호출할지를 설명하는 effect 을 생성하는데 사용된다. put() 함수는 store 에 action 을 통하여 전달하도록 미들웨어에게 가르치는 effect 를 생성한다. 사용자의 데이터를 가져오는 예제를 보고 effects 가 어떻게 동작하는지 살펴보자. 1234567891011function* fetchUserSaga(action) &#123; // `call` function accepts rest arguments, which will be passed to `api.fetchUser` function. // Instructing middleware to call promise, it resolved value will be assigned to `userData` variable const userData = yield call(api.fetchUser, action.userId); // Instructing middleware to dispatch corresponding action. yield put(&#123; type: \"FETCH_USER_SUCCESS\", userData &#125;);&#125; 👆 ¶What is Redux Thunk? Redux Thunk 는 action 대신 함수를 반환하는 action 생성자를 작성 할 수 있는 미들웨어다. Thunk 는 action dispatch 를 지연 시키거나, 특정한 조건이 성립되는 경우에만 dispatch 하도록 할 수 있다. 내부 함수는 파라미터로로 dispatch() getState()를 받는다. 👆 ¶What are the differences between redux-saga and redux-thunk? Redux Thunk 와 Redux Saga 는 모두 side effect 를 다룬다. 대부분의 시나리오에서 Thunk 는 Promise 를 사용하여 처리하고 Saga 는 Generators 를 사용한다. Promise 는 많은 개발자들에게 친숙하기 때문에 Thunk 는 비교적 다루기 쉽고, Sagas와 Generator 는 기능은 강력한 반면에 러닝커브가 존재한다. 두 미들웨어 모두 공존 할 수 있다. Thunk 로 시작하여도 만약 Saga 가 필요하다면 도입 할 수 있다. 👆 ¶What is Redux DevTools? Redux DevTools 은 Redux 를 위한 hot reload 기능을 가진 실시간 편집이 가능한 툴이다. 액션을 다시 재현하거나 UI 를 사용자 정의에 맞게 만들 수 있다. Redux DevTools 을 프로젝트에 설치하여 사용하고 싶지 않다면 Chrome 또는 Firefox 용 Extension 사용을 고려해 볼 수 있다. 👆 ¶What are the features of Redux DevTools? 모든 상태와 액션을 검사 action 을 취소하여 작업을 되돌리기 reducer 의 코드를 변경 시 staged된 액션을 재평가 action 에서 어떤 일이 일어났는지, 오류가 발생하였는지 확인 persistState() store enhancer 을 사용하면 page reload 에서 debug session을 유지할 수 있음 👆 ¶What are Redux selectors and why to use them? Selectors 는 Redux state 를 인수로받고 데이터를 반환하여 component 로 전달하는 함수다. 예를 들어, state에서 유저 상태정보를 받는다면 아래와 같이 처리할 수 있다. 1const getUserData = state =&gt; state.user.data; 👆 ¶What is Redux Form? Redux Form은 React와 Redux와 동시에 작동하며, React 폼 내에서 Redux의 모든 상태를 저장할 수 있다. Redux Form은 HTML5 input요소들과 사용가능하며, Material UI, React Widget, React bootstrap 과 같은 UI 프레임워크와도 동작이 가능하다. 👆 ¶What are the main features of Redux Form? Redux store를 통한 필드 값 유지 값 유효성 검사 (동기, 비동기) 포맷팅, 파싱, 정규화 👆 ¶How to add multiple middlewares to Redux? applyMiddleware()를 사용하면 된다. 예를 들어, applyMiddleware()를 사용하여 redux-thunk와 logger를 추가할 수 있다. 1234import &#123; createStore, applyMiddleware &#125; from \"redux\";const createStoreWithMiddleware = applyMiddleware(ReduxThunk, logger)( createStore); 👆 ¶How to set initial state in Redux? createStore에 두번째 인자로 초기 state값을 넘겨주면 된다. 12345678910const rootReducer = combineReducers(&#123; todos: todos, visibilityFilter: visibilityFilter&#125;);const initialState = &#123; todos: [&#123; id: 123, name: \"example\", completed: false &#125;]&#125;;const store = createStore(rootReducer, initialState); 👆 ¶How Relay is different from Redux? Relay와 Redux모두 하나의 스토어를 쓴다는 점에서 같다. 가장 큰 차이점은, 서버로 붙어 받은 메시지만 릴레이 한다는 점, 그리고 상태값을 모두 GraphQL 쿼리로 받는다는 것이다. Relay는 변경된 데이터만 가져온다는 점에서 데이터를 캐싱하거나 최적화할 수 있다. ¶React Native ¶What is the difference between React Native and React? React는 자바스크립트 라이브러리로, 프론트엔드와 서버에서 동작하며, 유저인터페이스나 웹 어플리케이션을 만들기 위해 사용된다. React Native는 네이티브 앱 컴포넌트를 컴파일하기 위한 모바일 프레임워크로, 자바스크립트 기반 React로 iOS, Android와 같은 네이티브 어플리케이션을 만들 수 있게 해준다. 👆 ¶How to test React Native apps? React Native는 iOS나 안드로이드와 같은 시뮬레이터로만 테스트가 가능하다. expo app를 활용한다면, qr코드를 활용하여 무선 네트워크 상에서도 모바일과 컴퓨터로 싱크를 맞출 수 있다. 👆 ¶How to do logging in React Native? console.log console.warn을 사용할 수 있다. React Native v0.29에서는 아래 명령어로도 가능하다. 12$ react-native log-ios$ react-native log-android 👆 ¶How to debug your React Native? iOS 시뮬레이터로 어플리케이션을 실행한다. Command + D를 눌러서 웹페이지가 http://localhost:8081/debugger-ui에서 실행되게 한다. Pause On Caught Exceptions을 활성화 하면 원활하게 디버그가 가능하다. Command + Option + I 또는 View -&gt; Developer -&gt; Developer Tools로 크롬 개발자 도구를 띄운다. 디버그가 가능하다. 👆","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"리액트 인터뷰 질문 & 답 (1)","slug":"reactjs-interview-questions-1","date":"2019-08-20T07:22:35.000Z","updated":"2019-08-28T07:44:01.157Z","comments":true,"path":"2019/08/20/reactjs-interview-questions-1/","link":"","permalink":"https://www.yceffort.kr/2019/08/20/reactjs-interview-questions-1/","excerpt":"목차 No.QuestionsCore React1리액트란 무엇인가?2리액트의 주요 기능은 무엇인가?3JSX란 무엇인가?4element와 component의 차이점은 무엇인가?5리액트에서 컴포넌트를 어떻게 만드는가?6클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가?7순수한 컴포넌트는 무엇인가?8state는 무엇인가?9props는 무엇인가?10state와 props의 차이는 무엇인가?11왜 state를 바로 업데이트 하면 안되는가?12setState() 콜백의 용도는 무엇인가?13HTML과 React의 이벤트 핸들링 차이는 무엇인","text":"목차 No. Questions Core React 1 리액트란 무엇인가? 2 리액트의 주요 기능은 무엇인가? 3 JSX란 무엇인가? 4 element와 component의 차이점은 무엇인가? 5 리액트에서 컴포넌트를 어떻게 만드는가? 6 클래스 / 함수 컴포넌트는 각각 언제 사용해야 하는가? 7 순수한 컴포넌트는 무엇인가? 8 state는 무엇인가? 9 props는 무엇인가? 10 state와 props의 차이는 무엇인가? 11 왜 state를 바로 업데이트 하면 안되는가? 12 setState() 콜백의 용도는 무엇인가? 13 HTML과 React의 이벤트 핸들링 차이는 무엇인가? 14 JSX 콜백에 메소드나 이벤트 핸들러를 바인딩하는 방법은 무엇인가? 15 이벤트 핸들러나 콜백에 파라미터를 전달하는 방법은? 16 리액트의 synthetic event는 무엇인가? 17 인라인 조건식은 무엇인가? 18 key props는 무엇이며, 배열의 요소에서 사용함으로써 얻을 수 있는 이점은 무엇인가? 19 ref의 목적은 무엇인가? 20 ref는 어떻게 생성하는가? 21 forward refs란 무엇이인가? 22 callback ref와 findDOMNode중 어떤것이 더 선호되는가? 23 string ref가 왜 legacy가 되었는가? 24 Virtual DOM 은 무엇인가? 25 Virtual DOM은 어떻게 작동하는가? 26 Shadow DOM과 Virtual DOM의 차이는 무엇인가? 27 What is React Fiber? 28 React Fiber의 목적은 무엇인가? 29 controlled components는 무엇인가? 30 uncontrolled components는 무엇인가? 31 createElement와 cloneElement의 차이는 무엇인가? 32 React에서 lifting state up은 무엇인가? 33 Component Lifecycle의 각 phase에는 어떤 차이가 있는가? 34 Component Lifecycle에는 어떤 method가 있는가? 35 Higher-Order 컴포넌트는 무엇인가? 36 HOC 컴포넌트에서 props proxy를 어떻게 만드는가? 37 Context란 무엇인가? 38 자식 prop는 무엇인가? 39 React에서 주석을 어떻게 쓰는가? 40 props 변수가 있는 super 생성자의 목적은 무엇인가? 41 reconciliation은 무엇인가?? 42 동적 key name으로 setState하는 방법은? 43 렌더가 될 때 마다 호출되는 function의 일반적인 실수는 무엇인가? 44 lazy함수가 named exports를 지원하는가? 45 리액트가 class 속성에 class 대신 className을 쓰는가? 46 fragments란 무엇인가? 47 fragment가 div 컨테이너보다 좋은 이유는? 48 react에서 portals란 무엇인가? 49 stateless 컴포넌트란? 50 stateful 컴포넌트란? 51 React props에서 유효성 검사를 하는 방법은? 52 React의 장점은? 53 React의 한계는? 54 React v16에서 error boundaries는? 55 React v15에서 error boundaries는? 56 정적 타입 체킹을 하는 최선의 방법은? 57 react-dom package의 쓰임새는? 58 react-dom의 render 메서드의 목적? 59 ReactDOMServer란? 60 React에서 InnerHtml를 쓰는 방법은? 61 React에서 스타일을 쓰는 방법은? 62 React에서 이벤트는 어떻게 다른가? 63 constructor에서 setState를 쓴다면? 64 index를 키로 쓸 경우 어떤 일이 벌어지는가? 65 componentWillMount() method안에서 setState()를 쓰는 것이 바람직한가? 66 initial state에서 props를 쓰면 어떻게 되는가? 67 어떻게 조건부로 컴포넌트를 렌더링하는가? 68 DOM 엘리먼트에서 스프레드 props를 쓸 때 주의해야 할 점은? 69 React에서 decorator를 쓰는 방법은? 70 컴포넌트를 메모이제이션 하는 법은? 71 서버사이드렌더링을 하는 방법은? 72 React에서 프로덕션 모드를 키는 방법은? 73 CRA는 무엇이고 이점은 무엇인가? 74 마운팅시 라이프사이클 메서드의 순서는? 75 React v16에서 deprecated된 라이프 사이클 메서드는? 76 getDerivedStateFromProps() 의 목적은? 77 getSnapshotBeforeUpdate()의 목적은? 78 Hooks api가 render props와 HOC를 대체하는가? 79 네이밍 컴포넌트를 위한 최상의 방법은? 80 컴포넌트 클래스에서 메소더의 순서를 정하는 방법은? 81 스위칭 컴포넌트란 무엇인가? 82 왜 setState에 함수를 넘겨야 하는가? 83 React에서 strict mode란 무엇인가? 84 React 믹스인이란? 85 왜 isMounted()가 안티패턴이고, 이를 위한 올바른 해결책이 무엇인가? 86 React에서 지원하는 포인터 이벤트는 무엇인가? 87 왜 컴포넌트 명은 대문자로 시작해야 하는가? 88 React v16에서 커스텀 DOM 속성을 지원하는가? 89 constructor와 getInitialState의 차이점은? 90 setState를 호출하지 않고 강제로 컴포넌트를 리렌더링하는 방법은? 91 React에서 es6클래스를 쓸 때 super()와 super(props)의 차이점은? 92 JSX에서 반복문을 도는 방법은? 93 HTML속성에서 props에 접근하는 방법은? 94 React의 Prop array에 특정형식의 array를 넘기는 방법은? 95 조건부로 클래스 속성을 추가하는 방법은? 96 React과 ReactDOM의 차이는? 97 왜 React-DOM은 React에서 분리되었는가? 98 React 라벨 엘리먼트를 사용하는 방법은? 99 여러개의 인라인 스타일을 한꺼번에 쓰는 방법은? 100 브라우저 리사이즈 시 뷰를 리렌더링하는 방법은? 101 setState와 replaceState의 차이점은? 102 state의 변경을 listen하는 방법은? 103 React state에서 배열의 특정 엘리먼트를 지우는 올바른 방법은? 104 HTML 렌더링 없이 React를 사용하는 방법은? 105 React에서 json을 pretty하게 프린트 하는 방법은? 106 왜 React에서 props를 업데이트 하지 못하는가? 107 페이지 로딩 중에 input 엘리먼트에 포커스를 주는 방법은? 108 state에 있는 객체를 업데이트하는 방법은? 109 왜 setState()에 object보다 function이 더 나은가? 110 브라우저에서 React 런타임의 버전을 알아내는 방법은? 111 CTA에서 폴리필을 추가하는 일반적인 방법은? 112 CTA에서 http대신 https를 쓰는 법은? 113 CTA에서 상대경로 import를 피하는 방법은? 114 React 라우터에 구글 애널리틱스를 붙이는 방법은? 115 매 초마다 컴포넌트를 업데이트 하는 방법은? 116 React에서 인라인 스타일로 vendor prefixes를 붙이는 방법은? 117 React와 ES6를 활용해서 컴포넌트를 import &amp; export 하는 방법은? 118 React 컴포넌트 명에서 주의해야 할 점은? 119 왜 컴포넌트 생성자는 단 한번만 호출되는가? 120 React에서 상수를 선언하는 방법은? 121 React에서는 어떻게 클릭이벤트가 트리거 되는가? 122 React에서 async await을 쓰는 것이 가능한가? 123 React의 일반적인 디렉토리 구조는? 124 유명한 애니메이션을 위한 패키지는? 125 style 모듈의 이점은 무엇인가? 126 React에 특화된 linter엔 무엇이 있는가? 127 Ajax call은 어떻게 만들고, 어느 라이프사이클 메소드에서 실행해야 하는가? 128 render props란 무엇인가? ¶Core React ¶What is React 리액트는 오픈소스 프론트엔드 자바스크립트 라이브러리로, 특히 싱글 페이지 어플리케이션의 사용자 인터페이스 구축을 위해 사용된다. 웹가 모바일 앱의 뷰단을 다르기 위하여 사용되고 있다. 리액트는 페이스북에서 일아흔 Jordan Walke가 만들었다. 최초로 리액트 기반으로 만들어진 서비스는 2011년에 페이스북 뉴스 피드이며, 2012년에는 인스타그램도 리액트로 만들어 졌다. 👆 ¶What are the major features of React? 리액트의 주요 기능은 무엇인가? RealDOM을 조작하는데 많은 비용이 소모되어 대신 VirtualDOM을 활용하고 있다. 서버사이드렌더링을 지원한다 단방향 데이터흐름 또는 단방향 데이터 바인딩을 따른다 뷰를 개발하는데 있어 재사용 가능한 컴포넌트 사용 👆 ¶What is JSX? JSX는 ECMA Script의 XML 신택스 확장 표기법이다. (Javascript XML의 약자다.) 기본적으로, React.createElement()함수에 문법 슈가를 제공하며,HTML 스타일의 템플릿 구문화함께 javascript를 표현할 수 있다. 아래 예제에서, return안에 있는 &lt;h1&gt; 구문이 자바스크립트 함수의 render function 으로 제공된다. 123456789class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;\"Welcome to React world!\"&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 👆 ¶What is the difference between Element and Component? element는 DOM노드나 컴포넌트 단에서 화면에 보여주고 싶은 요소를 그리는 하나의 오브젝트를 의미한다. element는 element의 props에서 포함될 수 있다. 리액트에서 element를 만드는건 많은 비용이 들지 않는다. 한번 만들고 나면, 더이상 변경이 불가능하다. 리액트에서 element를 만드는 예시는 아래와 같다. 1const element = React.createElement(\"div\", &#123; id: \"login-btn\" &#125;, \"Login\"); 위 함수는 아래와 같은 object를 리턴한다 1234567&#123; type: 'div', props: &#123; children: 'Login', id: 'login-btn' &#125;&#125; 그리고 ReactDOM.render()이 아래와 같은 DOM을 만들어 줄 것이다. 1&lt;div id=\"login-btn\"&gt;Login&lt;/div&gt; 반면에 컴포넌트는 다양한 방식으로 선언가능하다. 컴포넌트는 render()와 함께 쓴다면 클래스가 될 수도 있다. 좀더 단순한 방법으로, 함수로도 선언이 될 수 있다. 두 방식 모두 props를 input으로 받으며, JSX를 리턴한다. 12345const Button = (&#123; onLogin &#125;) =&gt; ( &lt;div id=&#123;\"login-btn\"&#125; onClick=&#123;onLogin&#125;&gt; Login &lt;/div&gt;); JSX는 이를 React.createElement() 함수로 트랜스파일 시킬 것이다. 12const Button = (&#123; onLogin &#125;) =&gt; React.createElement( 'div', &#123; id: 'login-btn',onClick: onLogin &#125;, 'Login' ) 👆 ¶How to create components in React? 두 가지 방법이 존재한다. 함수형 컴포넌트: 컴포넌트를 만드는 가장 심플한 방식이다. props를 첫번째 파라미터로 받는 받는 순수 자바스크립트 함수를 만들고, React Element를 반환하면 된다. 123function Greeting(&#123; message &#125;) &#123; return &lt;h1&gt;&#123;`Hello, $&#123;message&#125;`&#125;&lt;/h1&gt;;&#125; 클래스 컴포넌트: ES6의 클래스를 활용하여 컴포넌트를 정의할 수도 있다. 위 컴포넌트를 클래스 컴포넌트로 바꾼다면 이렇게 될 것이다. 12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;&#123;`Hello, $&#123;this.props.message&#125;`&#125;&lt;/h1&gt;; &#125;&#125; 👆 ¶When to use a Class Component over a Function Component? 컴포넌트가 state나 라이프 사이클 메소드를 필요로 할 때 클래스 컴포넌트를, 그렇지 않으면 함수형 컴포넌트를 활용하면 된다. 근데 요즘은 useState을 사용하면 함수형 컴포넌트에서도 state사용이 가능하다 👆 ¶What are Pure Components? React.PureComponent는 React.Component에서 shouldComponentUpdate가 없다는 것만 제외하면 동일하다. props나 state에 변화가 있을 경우, PureComponent는 두 변수에 대해서 얕은 비교를 한다. 반면 Component는 그런 비교를 하지 않는다. 따라서 Component는 shouldComponentUpdate가 호출 될 때마다 다시 render한다. 👆 ¶What is state in React? state란 컴포넌트가 살아있는 동안에 걸쳐 변화할 수도 있는 값을 가지고 있는 object다. 따라서 state를 가능한 간단하게, 그리고 state의 구성요소를 최소화하는 노력을 기울여야 한다. 다음은 User Component에 message state를 관리하는 예제다. 1234567891011121314151617class User extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; message: \"Welcome to React world\" &#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.message&#125;&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; state는 props와 비슷하지만, 컴포넌트가 완전히 소유권을 쥐고 있다는 것이 다르다.다른 어떤 컴포넌트도 한 컴포넌트가 소유하고 있는 state에 접근할 수 없다. 👆 ¶What are props in React? props는 컴포넌트의 input 값이다. HTML 태그 속성과 유사한 규칙을 사용하여 ReactComponent에 전달할 수 있는 단일 값 또는 객체 다. 이런 데이터 들은 부모 컴포넌트에서 자식 컴포넌트로 보낼 수 있다. 리액트에서 props를 쓰는 주요 목적은 컴포넌트에 아래와 같은 기능을 제공하기 위해서다. 컴포넌트에 custom data를 넘기기 위해 state의 변화를 trigger 하기 위해 Component의 render메소드 안에서 this.props.*** 로 사용하기 위함 예를 들어, reactProp 을 만들어서 쓴다고 가정해 보자. 1&lt;Element reactProp=&#123;\"1\"&#125; /&gt; reactProp은 (뭐라고 정의했던 지 간에) React를 사용하여 생성된 component에서 접근이 가능하고, React native props에서 접근하여 사용할 수 있다. 1props.reactProp; 👆 ¶What is the difference between state and props? props와 state는 모두 순수 자바스크립트 오브젝트다. 두 객체 모두 render의 output에 영향을 줄 수 있는 정보를 가지고 있지만, 컴포넌트의 기능적인 측면에서는 약간 다르다. props는 함수의 파라미터와 비슷한 방식으로 작동하는 반면, state는 컴포넌트 내에서 선언된 변수와 비슷하다. 👆 ¶Why should we not update the state directly? state를 아래와 같이 바로 업데이트 하면 렌더링이 일어나지 않는다. 1this.state.message = \"Hello world\"; 대신에 setState() 메서드를 사용하자.이는 state의 변경이 있을 때 component를 업데이트 해준다. state에 변화가 있을 경우, 컴포넌트는 리렌더링으로 응답한다. 12//Correctthis.setState(&#123; message: \"Hello World\" &#125;); 주의: state를 직접 할당할 수 있는 곳은 constructor 혹은 자바스크립트 클래스의 필드를 선언하는 syntax 뿐이다. 👆 ¶What is the purpose of callback function as an argument of setState()? 콜백함수는 setState가 끝나고 컴포넌트가 렌더링 된 이후에 실행된다.setState는 비동기로 이루어지기 때문에 callback에서는 어떤 액션이든 취할 수 있다. 주의: 콜백함수를 사용하는 것보다 라이프사이클 메서드를 사용하는게 더 좋다. 123setState(&#123; name: \"John\" &#125;, () =&gt; console.log(\"The name has updated and component re-rendered\")); ¶What is the difference between HTML and React event handling? HTML에서는 이벤트명은 소문자로 작성되어야 한다. 1&lt;button onclick=\"activateLasers()\"&gt;&lt;/button&gt; React는 camelCase를 사용한다. 1&lt;button onClick=\"&#123;activateLasers&#125;\"&gt;&lt;/button&gt; HTML에서는, false를 리턴하면 이후 기본 액션을 막을 수 있다. 1&lt;a href=\"#\" onclick='console.log(\"The link was clicked.\"); return false;' /&gt; 하지만 react에서는 preventDefault()를 명시적으로 사용해야 한다. 1234function handleClick(event) &#123; event.preventDefault(); console.log(\"The link was clicked.\");&#125; ¶How to bind methods or event handlers in JSX callbacks? 생성자에서 바인딩하기: 자바스크립트 클래스에서는, 메소드들이 기본적으로 바인딩 되어 있지 않다. 이는 클래스 메서드로 정의된 리액트 이벤트 핸들러와 마찬가지다. 보통, 생성자에서 바인딩한다. 12345678910class Component extends React.Componenet &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; // ... &#125;&#125; 퍼블리기 클래스 필드 구문: 생성자에서 바인딩 되기를 원치 않는다면, 퍼블릭 클래스의 필드 구문을 이용하여 callback을 올바르게 바인딩 할 수 있다. 12345handleClick = () =&gt; &#123; console.log(\"this is:\", this);&#125;;&lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt;; 클래스 필드(class field) 클래스 내부의 캡슐화된 변수를 말한다. 데이터 멤버 또는 멤버 변수라고도 부른다. 클래스 필드는 인스턴스의 프로퍼티 또는 정적 프로퍼티가 될 수 있다. 쉽게 말해, 자바스크립트의 생성자 함수에서 this에 추가한 프로퍼티를 클래스 기반 객체지향 언어에서는 클래스 필드라고 부른다. 12345class Foo &#123; name = \"\"; // SyntaxError constructor() &#123;&#125;&#125; constructor 내부에서 선언한 클래스 필드는 클래스가 생성할 인스턴스를 가리키는 this에 바인딩한다. 이로써 클래스 필드는 클래스가 생성할 인스턴스의 프로퍼티가 되며, 클래스의 인스턴스를 통해 클래스 외부에서 언제나 참조할 수 있다. 즉, 언제나 public이다. ES6의 클래스는 다른 객체지향 언어처럼 private, public, protected 키워드와 같은 접근 제한자(access modifier)를 지원하지 않는다. 화살표함수: 콜백에 화살표 함수를 사용할 수도 있다. 1&lt;button onClick=&#123;event =&gt; this.handleClick(event)&#125;&gt;&#123;\"Click me\"&#125;&lt;/button&gt; 주의: 콜백이 하위 컴포넌트에 prop으로 전달된다면, component가 리렌더링 될 수도 있다. 이러한 경우에는, 성능을 고려해서 1, 2번의 예제를 활용하는 것이 낫다. 👆 ¶How to pass a parameter to an event handler or callback? 이벤트 핸들러와 파라미터 전달을ㅇ 화살표 함수로 감쌀 수 있다. 1&lt;button onClick=&#123;() =&gt; this.handleClick(id)&#125; /&gt; 이는 .bind와 같다. 1&lt;button onClick=\"&#123;this.handleClick.bind(this,\" id)&#125; /&gt; 두 방식 이외에도, 아래와 같은 배열 함수 방식으로 정의해서 전달할 수도 있다. 1234&lt;button onClick=&#123;this.handleClick(id)&#125; /&gt;;handleClick = id =&gt; () =&gt; &#123; console.log(\"Hello, your ticket number is\", id);&#125;; 👆 ¶What are synthetic events in React? synthetic event (합성함수) 는 브라우저의 네이티브 이벤트를 위한 크로스 브라우저 래퍼다. 이 api는 브라우저의 네이티브 이벤트와 동일하며, 마찬가지로 stopPropagation() preventDefault()도 포함하고 있지만, 모든 브라우저에서 동일하게 작동한다는 점이 다르다. 👆 ¶What is inline conditional expressions? 조건부 렌더 표현을 위해 javascript의 if문이나 삼항연산자를 사용할 수 있다. 이외에도 중괄호로 묶어서 javascript의 논리식인 &amp;&amp;을 붙여서 jsx에서도 사용할 수 있다. 123456&lt;h1&gt;Hello!&lt;/h1&gt;; &#123; messages.length &gt; 0 &amp;&amp; !isLogin ? (&lt;h2&gt;You have &#123;messages.length&#125; unread messages.&lt;/h2&gt;) : (&lt;h2&gt;You don't have unread messages.&lt;/h2&gt;); &#125; 👆 ¶What are “key” props and what is the benefit of using them in arrays of elements? key는 특별한 string 속성으로, 배열을 사용할 때 이용해야 한다. key는 리액트에서 어떤 item이 변화하고, 추가되고, 삭제되었는지 구별하는데 도움을 준다. 대부분 key로 id를 사용한다. 123const todoItems = todos.map(todo =&gt;&lt;li key=\"&#123;todo.id&#125;\"&gt;&#123;todo.text&#125;&lt;/li&gt;); 만약 이런 ID가 없다면, index를 사용할 수 있다. 12345const todoItems = todos.map((todo, index) =&gt;&lt;li key=\"&#123;index&#125;\"&gt; &#123;todo.text&#125;&lt;/li&gt;) 주의 index를 key로 사용하는 방식은, 아이템의 순서가 바뀌는 경우가 발생할 수 있는 케이스에는 별로 추천할만하지 못하다. 이는 퍼포먼스에 악영향을 미치고, component state에 악영향을 미칠 수 있다. list를 별도 컴포넌트로 뽑아서 사용하는 경우, key를 리스트 컴포넌트가 아닌 li 태그에 사용해야 한다. 리스트 아이템에 key가 없으면 콘솔에 경고 메시지가 뜬다. ¶What is the use of refs? ref는 element의 참조값을 반환한다. 대부분 이러한 경우는 피해야 하지만, DOM이나 component에 다이렉트로 접근해야할 때 유용하다. 👆 ¶How to create refs? 최근에 추가된 방식으로, React.createRef() 메소들를 사용하면, React element는 ref를 통해서 접근할 수 있다. ref를 컴포넌트에서 접근하기 위해서는, 생성자 안에 ref를 instance property로 할당하면 된다. 123456789class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.myRef = React.createRef(); &#125; render() &#123; return &lt;div ref=&#123;this.myRef&#125; /&gt;; &#125;&#125; React 버전과 상관없이 ref 콜백을 활용하는 방식이 있다. 예를 들어, SearchBar 컴포넌트의 인풋 요소들은 아래와 같은 방식으로 접근 가능하다. 12345678910111213141516171819202122class SearchBar extends Component &#123; constructor(props) &#123; super(props); this.txtSearch = null; this.state = &#123; term: \"\" &#125;; this.setInputSearchRef = e =&gt; &#123; this.txtSearch = e; &#125;; &#125; onInputChange(event) &#123; this.setState(&#123; term: this.txtSearch.value &#125;); &#125; render() &#123; return ( &lt;input value=&#123;this.state.term&#125; onChange=&#123;this.onInputChange.bind(this)&#125; ref=&#123;this.setInputSearchRef&#125; /&gt; ); &#125;&#125; 또한 컴포넌트의 함수 내에서 클로져를 ref를 사용할 수도 있다. 주의: 추천할만한 방법은 아니지만, 인라인 ref callback을 이용하는 방식도 있다. 👆 ¶What are forward refs? Ref forwarding은 일부 컴포넌트에서 ref를 받아서 자식 컴포넌트에게 전달하는 것을 의미한다. 123456789const ButtonElement = React.forwardRef((props, ref) =&gt; ( &lt;button ref=&#123;ref&#125; className=\"CustomButton\"&gt; &#123;props.children&#125; &lt;/button&gt;));// Create ref to the DOM button:const ref = React.createRef();&lt;ButtonElement ref=&#123;ref&#125;&gt;&#123;\"Forward Ref\"&#125;&lt;/ButtonElement&gt;; 👆 ¶Which is preferred option with in callback refs and findDOMNode()? callback ref를 쓰는 것이 더 선호된다. 왜냐하면 findDOMNode()는 향후에 있을 리액트의 개선사항이 반영되지 않기 때문이다. 레거시에서 findDOMNode를 사용하는 방법이 있다. 123456789class MyComponent extends Component &#123; componentDidMount() &#123; findDOMNode(this).scrollIntoView(); &#125; render() &#123; return &lt;div /&gt;; &#125;&#125; 그래서 선호하는 방법은 다음과 같다. 12345678910111213class MyComponent extends Component &#123; constructor(props) &#123; super(props); this.node = createRef(); &#125; componentDidMount() &#123; this.node.current.scrollIntoView(); &#125; render() &#123; return &lt;div ref=&#123;this.node&#125; /&gt;; &#125;&#125; 👆 ¶Why are String Refs legacy? 예전에 React를 다뤄보았다면, 옛날 방식인 ref를 string으로 쓰는, ref={'textInput'} 와 같이 ref속성이 string이고, DOM Node인 refs.textInput로 접근하는 방법에 익숙할 것이다. 그러나 이러한 string ref는 하단에서 언급할 문제들 때문에, 레거시로 보는 것이 맞다. 그리고 string ref는 React v16에서 제거 되었다. String ref는 실행중인 component 요소를 추적하도록 강제한다. 그리고 React Module을 stateful하게 만들기 때문에, 이는 번들시 react module이 중복 되는 경우 이상한 오류를 발생시킨다. 라이브러리를 추가하여 String ref를 child component에 전달한다면, 사용자는 다른 ref를 추가할 수 없다. 그러나 callback ref를 사용하면 이런 문제를 해결할 수 있다. Flow와 같은 정적 분석에서는 동작하지 않는다. Flow는 string ref를 this.refs와 같은 형태로 표시하도록 만드는 트릭을 추적할 수 없다. callback ref는 string ref보다 flow에 더 잘맞다. 대부분이 render callback 패턴으로 동작하기를 기대하지만, 그렇게 동작하지 않는다. 12345678910111213class MyComponent extends Component &#123; renderRow = index =&gt; &#123; // 동작하지 않는다. ref는 MyComponent가 아닌 DataTable에 연결될 것이다. return &lt;input ref=&#123;\"input-\" + index&#125; /&gt;; // 이거는 동작한다. callback ref가 짱이다. return &lt;input ref=&#123;input =&gt; (this[\"input-\" + index] = input)&#125; /&gt;; &#125;; render() &#123; return &lt;DataTable data=&#123;this.props.data&#125; renderRow=&#123;this.renderRow&#125; /&gt;; &#125;&#125; 👆 ¶What is Virtual DOM? Virtual DOM은 메모리 내에서 표현되는 Real DOM 이다. UI는 메모리 상에서 표현되며, 그리고 real DOM과 동기화 된다. 이는 렌더 함수 호출과 화면에 elements 표시 하는 사이에 일어난다. 이 모든 과정을 reconciliation이라고 한다. 👆 ¶How Virtual DOM works? 어디서든 데이터가 편하면, Virtual DOM내에서 전체 UI가 다시 렌덜이 된다. 그런 다음 이전 DOM과 새로운 DOM을 비교한다. 계산이 끝나면, Real DOM 중에서 실제로 업데이트가 있었던 부분 만 변경을 가한다. 👆 ¶What is the difference between Shadow DOM and Virtual DOM? Shadow DOM은 web component의 scope및 CSS scope 지정을 위해 설계된 web browser 기술이다. Virtual DOM은 브라우저 API 위에 자바스크립트에서 구현되는 개념이다. 👆 ¶What is React Fiber? Fiber는 React v16에서 새로운 reconciliation 엔진, 그리고 코어 알고리즘을 새로 작성한 것으로 볼 수 있다. React Fiber의 목적은 애니메이션, 레이아웃, 제스쳐, 작업일시정지 및 중단, 여려 유형의 업데이트 우선순위 조절, 동시성 등 여러가지 기본 사항에 대한 성능을 높이는 것이다. 👆 ¶What is the main goal of React Fiber? React Fiber 의 목표는 애니메이션, 레이아웃, 제스처등의 성능을 높이는 것이다. 렌더링 작업을 chunk별로 작업하고, 여러 프레임 별로 이를 펼치면서 작업하는 점진적 렌더링을 통해 이를 구현했다. 👆 ¶What are controlled components? 입력요소를 제어하는 component를 controlled components라고 부른다. 모든 상태변경에 연관뢴 handler function이 존재한다. 예를 들어, 모든 이름을 대문자로 쓰기 위해서는, handleChange를 아래와 같이 쓰게 된다. 123handleChange(event) &#123; this.setState(&#123;value: event.target.value.toUpperCase()&#125;)&#125; 👆 ¶What are uncontrolled components? uncontrolled components란 내부적으로 자기 자신의 state를 가지고 있는 component다. 현재 필요한 값을 찾기 위해 ref를 사용하여 DOM query를 할 수 있다. 이는 전통적인 HTML 과 비슷하다. UserProfile Component를 아래에서 보자면, name input이 ref를 통해서 접근할 수 있다. 123456789101112131415161718192021222324class UserProfile extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); this.input = React.createRef(); &#125; handleSubmit(event) &#123; alert(\"A name was submitted: \" + this.input.current.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; &#123;\"Name:\"&#125; &lt;input type=\"text\" ref=&#123;this.input&#125; /&gt; &lt;/label&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt; ); &#125;&#125; 대부분의 경우, 폼에서는 controlled component를 사용하기를 추천한다. 👆 ¶What is the difference between createElement and cloneElement? JSX는 React.createElement() 함수로 UI에 나타낼 React element를 생성한다. 반면 cloneElement는 element를 props로 보낼 때 사용한다. 👆 ¶What is Lifting State Up in React? 여러 component 들이 동일한 변경 데이터를 공유해야하는 경우 가까운 부모 component 로 state를 올리는 것이 좋다. 즉, 두개의 자식 component가 부모에 있는 동일한 데이터를 공유할 때. 두개의 자식 component 들은 local state를 유지하는 대신, 부모로 state를 올려야 한다. 👆 ¶What are the different phases of component lifecycle? React lifecycle에는 세 개의 phase가 있다. mounting: 컴포넌트가 browser DOM에 마운트 될 준비가 된 상태다. 이 phase에는 constructor() getDerivedStateFromProps() render() componentDidMount()가 있다 updating: 이 단계에서는, 컴포넌트가 두가지 방법으로 업데이트 된다. 새로운 props를 보내거나, setState() forceUpdate()를 통해서 state를 업데이트 하는 방법이 있다. 이 단계에서는, getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() componentDidUpdate() 가 포함된다. unmounting: 이단계에서는, browser DOM이 더 이 더이상 필요 없어지거나 unmount된다. 여기에는 componentWillUnmount()가 포함된다. DOM에서의 변경을 적용할 때, 내부에서 어떤 과정을 거치는지 알아볼 필요가 있다. 각 단계는 아래와 같다. Render 컴포넌트가 어떠한 사이드 이펙트 없이 렌더링 된다. 이는 Pure Component에 적용되며, 이 단계에서는 일시정지, 중단, 렌더 재시작등이 가능하다. Pre-commit: 컴포넌트가 실제 변화를 DOM에 반영하기 전에, 리액트가 DOM을 getSnapshotBeforeUpdate() 통해서 DOM 을 읽을 수도 있다. Commit: React는 DOM과 함꼐 작동하며, 각각의 라이프 사이클 마지막에 실행되는 것들이 포함된다. componentDidMount() componentDidUpdate() componentWillUnmount() 16.3 이후 16.3 이전 👆 ¶What are the lifecycle methods of React? React 16.3+ getDerivedStateFromProps: 모든 render()가 실행되기 바로 직전에 호출된다. props의 변화의 결과로 내부 state 변화를 가능하게 해주는 메서드로, 굉장히 드물게 사용된다. componentDidMount: 첫렌더링이 다 끝나고, 모든 ajax 요청이 완료, DOM이나 state 변화, 그리고 이벤트 리스너가 모두 설정된 다음에 호출된다. shouldComponentUpdate: 컴포넌트가 업데이트 될지 말지를 결정한다. default로 true를 리턴한다. 만약 state나 props 업데이트 이후에 컴포넌트가 업데이트 될 필요가 없다고 생각한다면, false를 리턴하면 된다. 컴포넌트가 새로운 props를 받은 후에, 리 렌더링을 방지해서 성능을 향상시키기에 가장 좋은 위치다. getSnapshotBeforeUpdate: 렌더 결과물이 DOM에 커밋되기 직전에 호출된다. 여기서 리턴된 모든 값은 componentDidUpdate()로 넘겨진다. 스크롤 포지션 등, DOM에서 필요한 정보를 사용할 때 유용하다. componentDidUpdate: prop/state의 변화d의 응답으로 DOM을 업데이트 할 때 필요하다. 이 메소드는 만약 shouldComponentUpdate()가 false를 리턴하면 호출되지 않는다. componentWillUnmount: 네트워크 요청을 취소하거나, 컴포넌트와 관련된 이벤트 리스너를 삭제할 때 쓰인다. before 16.3은 따로 번역하지 않겠습니다. componentWillMount: Executed before rendering and is used for App level configuration in your root component. componentDidMount: Executed after first rendering and here all AJAX requests, DOM or state updates, and set up event listeners should occur. componentWillReceiveProps: Executed when particular prop updates to trigger state transitions. shouldComponentUpdate: Determines if the component will be updated or not. By default it returns true. If you are sure that the component doesn’t need to render after state or props are updated, you can return false value. It is a great place to improve performance as it allows you to prevent a re-render if component receives new prop. componentWillUpdate: Executed before re-rendering the component when there are props &amp; state changes confirmed by shouldComponentUpdate() which returns true. componentDidUpdate: Mostly it is used to update the DOM in response to prop or state changes. componentWillUnmount: It will be used to cancel any outgoing network requests, or remove all event listeners associated with the component. 👆 ¶What are Higher-Order Components? Higher-order Component (이하 HOC)는 컴포넌트를 받아서 새로운 컴포넌트를 리턴하는 컴포넌트다. 기본적으로, 이러한 패턴은 리액트의 컴포넌트적인 특성에서 유래되었다. 이를 Pure Component라고 부르는데, 동적으로 제공되는 하위 component를 그대로 사용하지만, 입력받은 component를 수정/복사하지 않기 때문이다. HOC는 아래와 같은 use case에서 사용할 수 있다. 코드 재사용, 로직 추상화 render 하이재킹 state 추상화 또는 조작 props 조작 👆 ¶How to create props proxy for HOC component? props proxy pattern을 아래와 같이 사용한다면, 컴포넌트에 넘겨진 props를 추가/수정할 수 있다. 1234567891011121314function HOC(WrappedComponent) &#123; return class Test extends Component &#123; render() &#123; const newProps = &#123; title: \"New Header\", footer: false, showFeatureX: false, showFeatureY: true &#125;; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125;;&#125; 👆 ¶What is context? Context는 props을 탑다운으로 주지 않고도, 어느 레벨에서든 데이터를 컴포넌트 트리에 넘기는 방법이다. 예를 들어 인증받은 사용자, 언어 설정, UI theme 등 어플리케이션 단위에서 다양한 컴포넌트가 사용해야 하는 데이터를 context를 통해서 줄 수 있다. 1const &#123; Provider, Consumer &#125; = React.createContext(defaultValue); 👆 ¶What is children prop? Children은 prop (this.prop.children) 으로, 다른 컴포넌트에 컴포넌트를 넘길 수 있는 방법으로, 다른 prop를 사용하는 것과 동일하다. 컴포넌트 트리는 이 children을 여닫는 태그 사이에 두며, 이는 컴포넌트를 children prop으로 건내게 된다. React API에서 이러한 형태로 다양한 prop을 제공하고 있다. React.Children.map React.Children.forEach React.Children.count React.Children.only React.Children.toArray 사용예제는 아래와 같다. 12345678910111213const MyDiv = React.createClass(&#123; render: function() &#123; return &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt;; &#125;&#125;);ReactDOM.render( &lt;MyDiv&gt; &lt;span&gt;&#123;\"Hello\"&#125;&lt;/span&gt; &lt;span&gt;&#123;\"World\"&#125;&lt;/span&gt; &lt;/MyDiv&gt;, node); 👆 ¶How to write comments in React? React/JSX의 주석은 자바스크립트의 다중 주석과 비슷하지만, { }에 쌓여있다는 것이 다르다. 한 줄 1234&lt;div&gt; &#123;/* Single-line comments(In vanilla JavaScript, the single-line comments are represented by double slash(//)) */&#125; &#123;`Welcome $&#123;user&#125;, let's play React`&#125;&lt;/div&gt; 여러 줄 1234&lt;div&gt; &#123;/* Multi-line comments for more than one line */&#125; &#123;`Welcome $&#123;user&#125;, let's play React`&#125;&lt;/div&gt; 👆 ¶What is the purpose of using super constructor with props argument? 자식 클래스 생성자는 super()메소드가 호출되기 전까지 this 레퍼런스를 쓸 수 없다. 이와 동일한것이 es6의 서브 클래스에 구현되어 있다. super() 메소드에 props를 파라미터로 호출하는 주요 이유는 this.props를 자식 생성자에서 쓰기 위해서다. props 넘기는 경우 1234567class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); console.log(this.props); // prints &#123; name: 'John', age: 42 &#125; &#125;&#125; props 안 넘기는 경우 123456789101112131415class MyComponent extends React.Component &#123; constructor(props) &#123; super(); console.log(this.props); // prints undefined // but props parameter is still available console.log(props); // prints &#123; name: 'John', age: 42 &#125; &#125; render() &#123; // no difference outside constructor console.log(this.props); // prints &#123; name: 'John', age: 42 &#125; &#125;&#125; 👆 ¶What is reconciliation? 컴포넌트의 props나 state에 변경이 있을때, React는 이전에 렌더링 된 element와 새롭게 렌더링된 것을 비교하여 실제 DOM이 업데이트 되어야 할지를 결정한다. 똑같지 않을때, React는 DOM을 업데이트 한다. 이 과정을 reconciliation이라고 한다. 👆 ¶How to set state with a dynamic key name? JSX코드 내에서 es6또는 바벨 트랜스파일러를 쓰고 있다면, computed property 명을 쓸 수 있다. 123handleInputChange(event) &#123; this.setState(&#123; [event.target.id]: event.target.value &#125;)&#125; 👆 ¶What would be the common mistake of function being called every time the component renders? 함수를 파라미터로 넘기는 과정에서 함수가 호출되지 않는지 확인해야 한다. 👆 ¶Is lazy function supports named exports? 아니다. 현재 React.lazy함수는 default export만 지원한다. named exports된 모듈을 import 하고 싶을 경우에는, 사이에 디폴트로 reexports 하는 모듈을 만들수 있다. 이는 트리쉐이킹을 도와주고, 사용하지 않는 컴포넌트를 pull하지 않을 수 있다. 밑에서 예를 살펴보자. 123// MoreComponents.jsexport const SomeComponent = /* ... */;export const UnusedComponent = /* ... */; 이 컴포넌트 중간에 IntermediateComponent.js를 만들어서 다시 export 한다. 12// IntermediateComponent.jsexport &#123; SomeComponent as default &#125; from \"./MoreComponents.js\"; 그리고 lazy 함수를 이용해서 아래와 같이 임포트 할 수 있다. 12import React, &#123; lazy &#125; from \"react\";const SomeComponent = lazy(() =&gt; import(\"./IntermediateComponent.js\")); 👆 ¶Why React uses className over class attribute? class는 자바스크립트의 예약어 이고, JSX는 javascript를 확장해 만든 것이다. 따라서 class를 쓰면 충돌이 일어나기 자바스크립트 예약어와 충동리 발생하기 때문에 className을 사용한다. className prop에 string을 넘겨 주면 된다. 123render() &#123; return &lt;span className=&#123;'menu navigation-menu'&#125;&gt;&#123;'Menu'&#125;&lt;/span&gt;&#125; 👆 ¶What are fragments? React에서는 하나의 컴포넌트가 여러개의 elements를 리턴하는 것이 일반적인 패턴이다. Fragments는 추가로 DOM 노드를 사용하지 않더라도 여러개의 노드들을 묶을 수 있게 해준다. 123456789render() &#123; return ( &lt;React.Fragment&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/React.Fragment&gt; )&#125; 123456789render() &#123; return ( &lt;&gt; &lt;ChildA /&gt; &lt;ChildB /&gt; &lt;ChildC /&gt; &lt;/&gt; )&#125; 👆 ¶Why fragments are better than container divs? Fragment는 실제로 추가적인 DOM을 만들지 않기 때문에 더 빠르고 메모리 사용량도 적다. 이는 매우 크고 깊은 트리를 만들 때 상당한 이점으로 작용한다. CSS Grid나 firefox같은 일부 특수한 CSS 메커니즘은 특별한 부모-자식 관계를 가지고 있는데, div를 중간에 추가하는 것은 원하는 레이아웃을 그리기 어렵게 한다. DOM Inspector를 사용할 때 덜 혼잡스럽다. 👆 ¶What are portals in React? portals 은 상위 Component 의 DOM 계층 구조 외부에 존재하는 DOM 노드로, 자식을 render 하는데 권장되는 방법이다. 1ReactDOM.createPortal(child, container); 첫번째 인자는 React Child에서만 렌더링이 가능하며, 여기에는 element, string, fragment 가 포함된다. 두번째 인자는 DOM 엘리먼트다. 👆 ¶What are stateless components? 컴포넌트의 동작이 state와 독립되어 있다면, 이는 stateless 컴포넌트다. 함수나 클래스를 이용해서 stateless 컴포넌트를 만들 수 있다. 하지만 컴포넌트의 라이프 사이클 훅이 필요하지 않다면, 함수형으로 가는 것이 좋다. 함수형 컴포넌트를 선택한다면 많은 이점을 가져갈 수 있다. 코드 사용 및 이해가 쉽고, 조금더 빠르며, 그리고 this 키워드의 충돌을 막을 수 있다. 👆 ¶What are stateful components? state의 사용에 종속적인 컴포넌트를 stateful component라고 한다. 이 컴포넌트는 항상 class 컴포넌트로 만들어 져야 하며, constructor를 통해서 초기화 되어야 한다. 12345678910class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125;; &#125; render() &#123; // ... &#125;&#125; 👆 ¶How to apply validation on props in React? React가 development로 실행한다면, 자동으로 컴포넌트에 있는 props의 타입을 올바르게 체크해 준다. 만약 타입이 올바르지 않다면, React는 콘솔에 경고 메시지를 띄운다. 성능 상의 이슈를 위해 production에서는 이 기능이 꺼져 있다. 필수적인 prop은 isRequired다. 사용할 수 있는 prop type의 종류는 아래와 같다. PropTypes.number PropTypes.string PropTypes.array PropTypes.object PropTypes.func PropTypes.node PropTypes.element PropTypes.bool PropTypes.symbol PropTypes.any 아래와 같이 쓸수 있다. 123456789101112131415161718import React from \"react\";import PropTypes from \"prop-types\";class User extends React.Component &#123; static propTypes = &#123; name: PropTypes.string.isRequired, age: PropTypes.number.isRequired &#125;; render() &#123; return ( &lt;&gt; &lt;h1&gt;&#123;`Welcome, $&#123;this.props.name&#125;`&#125;&lt;/h1&gt; &lt;h2&gt;&#123;`Age, $&#123;this.props.age&#125;`&#125;&lt;/h2&gt; &lt;/&gt; ); &#125;&#125; 주의: 리액트 v15.5부터 PropType이 React.PropTypes에서 prop-types로 이동했다. 👆 ¶What are the advantages of React? Virtual DOM으로 어플리케이션의 성능을 향상시킬 수 있음 JSX를 통해 코들르 쉽게 읽고 쓸수 있음 클라이언트와 서버사이드 양쪽에서 렌더링 라능 뷰만 다루는 라이브러리이기 때문에, 다른 프레임워크 (Angular, Backbone) 등과 쉽게 연동 가능 Jest와 같은 툴로 쉽게 유닛/인티그레이션 테스트 가능 👆 ¶What are the limitations of React? 풀 프레임워크가 아니라, view만 다루고 있음. 뉴비 웹 개발자들에게 러닝 커브가 존재 전통적인 MVC 프레임워크와 인터그레이팅을 하기 위해서는 추가적인 설정이 필요 inline 템플릿과 JSX로 인해 코드의 복잡성 증가 오버엔지니어링/보일러플레이팅을 야기하는 작은 단위의 컴포넌트가 너무 많이 존재 👆 ¶What are error boundaries in React v16? Error boundaries란 하위 component tree 에서 자바스크립트 에러 를 catch 하고, 기록하고, 에가 발생한 component tree가 아닌 대체 UI를 표현해 주는 component를 말한다. 새롭게 추가된 라이프사이클 메서드인 componentDidCatch(error, info)나 static getDerivedStateFromError()를 사용한다면, 클래스 컴포넌트는 error boundary가 될 수 있다. 123456789101112131415161718192021222324class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // 에러 리포틍 서비스를 위해 로그를 기록할 수도 있고 logErrorToMyService(error, info); &#125; static getDerivedStateFromError(error) &#123; // fallback UI를 표현하기 위해여 state를 업데이트 할 수도 있다. return &#123; hasError: true &#125;; &#125; render() &#123; if (this.state.hasError) &#123; // custom Fallback UI를 그릴 수 있다. return &lt;h1&gt;&#123;\"Something went wrong.\"&#125;&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; 그리고 이 컴포넌트는 아래와 같이 사용할 수 있다. 123&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; 👆 ¶How error boundaries handled in React v15? unstable_handleError 메서드를 활용한 기본적인 error boundaries만 제공하고 있다. 그리고 v16에서 componentDidCatch로 변경되었다. 👆 ¶What are the recommended ways for static type checking? 보통 PropTypes를 많이 사용한다. 그러나 크기가 큰 어플리케이션의 경우에는, Flow나 타입스크립트같은, 컴파일 단계에서 타입체킹을 제공하고 자동완성을 지원해주는 정적 타입 체커를 사용하는 것이 좋다. 👆 ¶What is the use of react-dom package? react-dom은 앱 최 상단 레벨에서 사용되는, DOM을 다루는데 필요한 메서드를 제공한다. 대부분의 컴포넌트는 이 모듈을 필요로 하지 않는다. 여기에 있는 메소드를 몇가지 나열하면 render() hydrate() unmountComponentAtNode() findDOMNode() createPortal() 👆 ¶What is the purpose of render method of react-dom? render 메서드는 제공된 컨테이너의 DOM에 있는 React element를 render 하고 Component에 대한 참조를 반환하는데 사용된다. React element가 이전에 렌더링 되었다면 update 를 수행하고 최근의 변경사항을 반영하기 위해 필요에 따라 DOM을 변경하기도 한다. 1ReactDOM.render(element, container[, callback]) 옵셔널 콜백이 있따면, 컴포넌트가 렌더링/업데이트 된 이후로 실행된다. 👆 ¶What is ReactDOMServer? ReactDOMServer는 컴포넌트를 정적 마크업으로 렌더링할 수 있게 해준다. (보통 노드 서버에서 많이 사용 된다) 이 오브젝트는 서버사이드 렌더링을 할 때 사용된다. 아래 메서드들은 서버와 브라우저 환경 모두에서 사용할 수 있다. renderToString() renderToStaticMarkup() 예를 들어, 노드 베이스 웹서버인 Express, Hapi, Koa 등에서 서버를 실행한다면, renderToString메서드를 호출하여 이에 대한 응답으로 루트 컴포넌트를 string으로 렌더링할 수 있다. 1234567891011// using Expressimport &#123; renderToString &#125; from \"react-dom/server\";import MyPage from \"./MyPage\";app.get(\"/\", (req, res) =&gt; &#123; res.write(\"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\"); res.write('&lt;div id=\"content\"&gt;'); res.write(renderToString(&lt;MyPage /&gt;)); res.write(\"&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\"); res.end();&#125;); 👆 ¶How to use innerHTML in React? browser DOM에서 innerHTML대신 dangerouslySetInnerHTML를 사용할 수 있다. innerHTML과 마찬가지로, 이 속성 또한 크로스 사이트 스크립팅 공격 (XSS)에 취약하다. __html을 키로 하고 HTML text를 값으로 가지는 object를 리턴하면 된다. 1234567function createMarkup() &#123; return &#123; __html: \"First &amp;middot; Second\" &#125;;&#125;function MyComponent() &#123; return &lt;div dangerouslySetInnerHTML=&#123;createMarkup()&#125; /&gt;;&#125; 👆 ¶How to use styles in React? style 속성은 css 문자열 대신 camelCased속성이 있는 자바스크립트 오브젝트를 허용한다. 이는 DOM 스타일 자바스크립트 속성과 일치하며, 효율적이고, XSS 보안 허점을 막아준다. 👆 ¶How events are different in React? React 엘리먼트에서 이벤트를 다루는 것은 문법상 약간의 차이가 있다. 리액트 이벤트 핸들러는 lowerCase가 아닌 camelCase로 써야한다. JSX에서는 문자열이 아닌, 함수 이벤트 핸들러를 파라미터로 보낸다. 👆 ¶What will happen if you use setState() in constructor? setState()를 사용하면, 객체 상태가 할당되고, 자식을 포함한 모든 컴포넌트가 다시 렌더링된다. 그리고 아래와 같은 에러메시지가 나타난다. Can only update a mounted or mounting component. 따라서 this.state를 사용하여 생성자내에서 변수를 초기화 해야 한다. 👆 ¶What is the impact of indexes as keys? 키는 리액트에서 엘리먼트를 추적할 수 있도록 안정적이어야 하고, 예측가능해야 하고, 유니크해야 한다. 아래 코드에서 각 엘리먼트의 키는 데이터를 따르는 것이 아니라 단순히 순서에 따라 결정된다. 이는 React가 하는 최적화를 제한한다. harmony123&#123; todos.map((todo, index) =&gt; &lt;Todo &#123;...todo&#125; key=&#123;index&#125; /&gt;);&#125; 만약 데이터를 유니크 키로 사용한다면 위의 조건을 만족하기 때문에, React는 다시 연산할 필요 없이 재정렬할 수 있다. harmony123&#123; todos.map(todo =&gt; &lt;Todo &#123;...todo&#125; key=&#123;todo.id&#125; /&gt;);&#125; 👆 ¶Is it good to use setState() in componentWillMount() method? componentWillMount()에서 비동기 초기화를 하는 것은 피하도록 권장한다. componentWillMount()는 마운팅이 일어나기 직전에 바로 실행된다. 이는 render()함수가 불리우기 직전이며, 따라서 여기에서 state를 새로 값을 할당 한다 하더라도 리렌더링을 트리거 하지 않는다. 이 메소드 내에서는 사이드 이펙트나 subscription등은 피해야 한다. 따라서 비동기 초기화는 componentDidMount()에서 하는 것이 좋다. harmony12345678componentDidMount() &#123; axios.get(`api/todos`) .then((result) =&gt; &#123; this.setState(&#123; messages: [...result.data] &#125;) &#125;)&#125; 👆 ¶What will happen if you use props in initial state? 컴포넌트의 새로고칩 없이 props가 변경된다면, 현재 상태의 컴포넌트는 절대로 업데이트 하지 않기 때문에 새로운 prop값이 화면에 표시되지 않을 것이다. props를 통한 state값의 초기화는 컴포넌트가 딱 초기화 되었을 때만 실행된다. harmony1234567891011121314class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; records: [], inputValue: this.props.inputValue &#125;; &#125; render() &#123; return &lt;div&gt;&#123;this.state.inputValue&#125;&lt;/div&gt;; &#125;&#125; props를 render 함수 내에서 쓰면 값을 업데이트 한다. harmony12345678910111213class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; record: [] &#125;; &#125; render() &#123; return &lt;div&gt;&#123;this.props.inputValue&#125;&lt;/div&gt;; &#125;&#125; 👆 ¶How do you conditionally render components? 때로는 어떤 상태값에 따라서 렌더링을 다르게 해야하는 경우가 발생한다. JSX는 false나 undefined는 렌더링하지 않으므로, 특정 조건에 true를 주는 형식으로 조건부 렌더링을 할 수 있다. harmony123456const MyComponent = (&#123; name, address &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;&#123;name&#125;&lt;/h2&gt; &#123;address &amp;&amp; &lt;p&gt;&#123;address&#125;&lt;/p&gt;&#125; &lt;/div&gt;); if-else도 삼항연산자를 활용하면 아래와 같이 할 수 있다. harmony123456const MyComponent = (&#123; name, address &#125;) =&gt; ( &lt;div&gt; &lt;h2&gt;&#123;name&#125;&lt;/h2&gt; &#123;address ? &lt;p&gt;&#123;address&#125;&lt;/p&gt; : &lt;p&gt;&#123;\"Address is not available\"&#125;&lt;/p&gt;&#125; &lt;/div&gt;); 👆 ¶Why we need to be careful when spreading props on DOM elements? spread prop를 쓴다면, HTML에 알수없는 속성을 추가할 수 있는 위험이 있기 때문에 좋지 못하다. 대신 ...rest 연산자를 쓴다면, 필요한 props만 추가해서 넣을 수 있다. 1234567const ComponentA = () =&gt; ( &lt;ComponentB isDisplay=&#123;true&#125; className=&#123;\"componentStyle\"&#125; /&gt;);const ComponentB = (&#123; isDisplay, ...domProps &#125;) =&gt; ( &lt;div &#123;...domProps&#125;&gt;&#123;\"ComponentB\"&#125;&lt;/div&gt;); 👆 ¶How you use decorators in React? 클래스 컴포넌트에 데코레이터를 쓸 수 있으며, 이는 함수에 컴포넌트를 넘기는 것과 동일하다. 데코레이터는 유연하고 읽기 쉬운 방법으로 컴포넌트를 기능적으로 수정할 수 있도록 한다. 123456789101112131415@setTitle(\"Profile\")class Profile extends React.Component &#123; //....&#125;const setTitle = title =&gt; WrappedComponent =&gt; &#123; return class extends React.Component &#123; componentDidMount() &#123; document.title = title; &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;;&#125;; 주의: 데코레이터는 es7 문법에 포함되지 못하고 현재 stage2 단계에 있다. 👆 ¶How do you memoize a component? 함수형 컴포넌트를 기반으로한 메모이제이션이 가능한 라이브러리가 있다. 예를 들어, moize라이브러리를 활용하면, 다른 컴포넌트 내에서 컴포넌트를 메모이제이션 할 수 있다. 1234567891011import moize from \"moize\";import Component from \"./components/Component\"; // this module exports a non-memoized componentconst MemoizedFoo = moize.react(Component);const Consumer = () =&gt; &#123; &lt;div&gt; &#123;\"I will memoize the following entry:\"&#125; &lt;MemoizedFoo /&gt; &lt;/div&gt;;&#125;; 👆 ¶How you implement Server Side Rendering or SSR? React는 이미 노드 서버에서 렌더링을 다룰 수 있도록 지원되고 있다. 클라이언트 사이드와 동일하게 렌더링할 수 있는 특수한 버전의 DOM renderer가 제공되고 있다. 1234import ReactDOMServer from \"react-dom/server\";import App from \"./App\";ReactDOMServer.renderToString(&lt;App /&gt;); 이 메소드는 일반적인 HTML을 string으로 내보내며, 이는 서버의 응답 일부를 페이지 본문 내부에 위치시킬 수 있다. 클라이언트 사이드에서, 리액트는 미리 렌더링된 컨텐츠를 감지하고 나머지를 원활하게 렌더링할 수 있다. 👆 ¶How to enable production mode in React? Webpack의 DefinePlugin 메서드를 활용하여, NODE_ENV를 production으로 설정해야 propType의 유효성 검사 같은 추가적인 경고를 제거할 수 있다. production 모드와 별도로, 주석을 제거하고 코드르 압축시키는 uglify의 dead-code 코드를 사용하여 minify하면 번들링 사이즈를 줄일 수 있다. 👆 ¶What is CRA and its benefits? CRA(create-react-app)는 특별한 설정없이도 빠르고 간편하게 리액트 어플리케이션을 만들수 있도록 해주는 Cli tool이다. 1234567891011# Installation$ npm install -g create-react-app# Create new project$ create-react-app todo-app$ cd todo-app# Build, test and run$ npm run build$ npm run test$ npm start` 여기에는 리액트 앱을 만드는데 필요한 모든 것이 담겨져 있다. React, JSX, ES6, 문법 지원을 위한 Flow spread operator와 같은 es6 문법 auto prefixed css를 통해, -web-kit` 과 같은 접두어를 붙이지 않아도 됨 빠른 인터렉티브 유닛 테스트 러너와 함께 커버리지 리포팅 일반적인 실수에 대해 경고하는 라이브 dev 서버 배포를 위해 소스맵, 해쉬와 함께 제공되는 JS, CSS, 이미지 번들링 해주는 빌드 스크립트 👆 ¶What is the lifecycle methods order in mounting? 컴포넌트가 생성되고, DOM에 들어가는 과정에서 아래와 같은 라이프 사이클 메서드가 순서대로 호출된다. constructor() static getDerivedStateFromProps() render() componentDidMount() 👆 ¶What are the lifecycle methods going to be deprecated in React v16? 다음 lifecycle메서드는 안전하지 않은 코딩법이 될 수 있고, 비동기 렌더링시 문제가 발생할 수 있다. componentWillMount() componentWillReceiveProps() componentWillUpdate() v16.3 부터 UNSAFE_ prefix가 붙고, v17에서는 삭제된다. 👆 ¶What is the purpose of getDerivedStateFromProps() lifecycle method? 새로운 라이프 사이클 메서드 getDerivedStateFromProps()는 component가 인스턴스화 된 후, 다시 렌더링 되기전에 호출된다. object를 반환하여 state를 업데이트 하거나, null을 리턴하ㅕㅇ 새로운 props에서 state update가 필요하지 않도록 나타낼 수도 있다. 12345class MyComponent extends React.Component &#123; static getDerivedStateFromProps(props, state) &#123; // ... &#125;&#125; 이 메서드는 componentDidUpdate()와 함께 쓴다면, componentWillReceiveProps()의 모든 유즈케이스에 적용할 수 있다. 👆 ¶What is the purpose of getSnapshotBeforeUpdate() lifecycle method? 새로운 메서드 getSnapshotBeforeUpdate()는 DOM 업데이트 직전에 호출된다. 이 메서드의 반환값은 componentDidUpdate()의 세번째 파라미터로 전달된다. 12345class MyComponent extends React.Component &#123; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // ... &#125;&#125; 이 메서드는 componentDidUpdate()와 함께 쓴다면, componentWillUpdate()의 모든 유즈케이스에 적용할 수 있다. 👆 ¶Do Hooks replace render props and higher order components? render props와 HOC 모두 한개의 자식만 렌더링 하지만, 대부분의 경우 Hooks API를 아용하면 트리에 의존성을 줄이면서 간단하게 구현할 수 있다. 👆 ¶What is the recommended way for naming components? displayName을 쓰는 것 보다 컴포넌트에 레퍼런스를 주는 방법이 더 좋다. displayName을 쓰는 법 보다 1234export default React.createClass(&#123; displayName: \"TodoApp\" // ...&#125;); 이렇게 하는게 더 좋다. 123export default class TodoApp extends React.Component &#123; // ...&#125; 👆 ¶What is the recommended ordering of methods in component class? 마운팅에서 렌더링까지 아래와 같은 순서로 나열하길 권장한다. static 메서드 constructor() getChildContext() componentWillMount() componentDidMount() componentWillReceiveProps() shouldComponentUpdate() componentWillUpdate() componentDidUpdate() componentWillUnmount() 클릭 또는 이벤트 핸들러 onClickSubmit() onChangeDescription() 렌더를 위한 getter 메서드 getSelectReason() getFooterContent() 옵셔널 렌더 메서드 renderNavigation() renderProfilePicture() render() ¶What is a switching component? 스위칭 컴포넌트란 하나 이상의 컴포넌트를 렌더링하는 컴포넌트를 의미한다. prop을 map으로 받아서 해당하는 컴포넌트를 보여주면 된다. 아래 코드 참조. 123456789101112131415161718192021import HomePage from \"./HomePage\";import AboutPage from \"./AboutPage\";import ServicesPage from \"./ServicesPage\";import ContactPage from \"./ContactPage\";const PAGES = &#123; home: HomePage, about: AboutPage, services: ServicesPage, contact: ContactPage&#125;;const Page = props =&gt; &#123; const Handler = PAGES[props.page] || ContactPage; return &lt;Handler &#123;...props&#125; /&gt;;&#125;;Page.propTypes = &#123; page: PropTypes.oneOf(Object.keys(PAGES)).isRequired&#125;; 👆 ¶Why we need to pass a function to setState()? 그 이유는 setState()가 비동기로 작동하는데에 있다. React는 성능상의 문제로 인해, state의 변경작업을 배치로 하는데, 이 때문에 setState()를 바로 호출한다고 해서 바로 반영되지 않는다. 이 말은, setState()를 호출 할 때 그 당시 state의 값에 의존하면 안된다는 뜻이다. 따라서 setState()에는 이전 값에 접근할 수 있는 함수를 사용하는 것이 좋다. 이는 사용자가 비동기로 작동하는 setState()의 특징으로 인해 이전 값에 접근하는 것을 방지해 준다. 초기 값이 0 이라고 가정하자. 여기 1 씩 올리는 동작을 하는 코드가 세개 있다. 12345// assuming this.state.count === 0this.setState(&#123; count: this.state.count + 1 &#125;);this.setState(&#123; count: this.state.count + 1 &#125;);this.setState(&#123; count: this.state.count + 1 &#125;);// this.state.count === 1, not 3 만약 setState()에 함수를 넘겨준다면, 올바르게 동작할 것이다. 1234this.setState((prevState, props) =&gt; (&#123; count: prevState.count + props.increment&#125;));// this.state.count === 3 as expected 👆 ¶What is strict mode in React? React.StrictMode는 어플리케이션의 잠재적인 문제를 하이라이팅 해주는 유용한 컴포넌트다. &lt;Fragment&gt;와 마찬가지로, &lt;StrictMode&gt;는 추가적으로 DOM을 렌더링하지 않는다. 이는 단지 자식 컴포넌트의 추가적인 체크와 경고를 할 뿐이다. 그리고 이러한 체크는 development 에서만 가능하다. 12345678910111213141516import React from \"react\";function ExampleApplication() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;React.StrictMode&gt; &lt;div&gt; &lt;ComponentOne /&gt; &lt;ComponentTwo /&gt; &lt;/div&gt; &lt;/React.StrictMode&gt; &lt;Footer /&gt; &lt;/div&gt; );&#125; 위 예에서, ComponentOne ComponentTwo만 체크할 것이다. 👆 ¶What are React Mixins? Mixins은 공통적인 기능을 가질 수 있도록 컴포넌트를 분리하는 방법이다. 그러나 사용하지 말아야 한다. HOC 나 데레이터를 사용하면 된다. 가장 유명한 사용법중 하나는 PureRenderMixin이다. 이전 props또는 state와 얕은 비교를 했을 때 일치하는 경우, 리렌더링을 막아주는 역할을 한다. 123456const PureRenderMixin = require(\"react-addons-pure-render-mixin\");const Button = React.createClass(&#123; mixins: [PureRenderMixin] // ...&#125;); 👆 ¶Why is isMounted() an anti-pattern and what is the proper solution? isMounted()의 일반적인 사용사례는 컴포넌트가 언마운트 된 후에 setState()를 호출하는 것을 방지하기 위함이다. 123if (this.isMounted()) &#123; this.setState(&#123;...&#125;)&#125; setState()를 호출하기 전에 isMounted()를 검사하면 경고를 없앨수있지만, 경고의 목적을 잃어버리는 꼴이 된다. 컴포넌트의 마운트가 해제된 후에 reference를 가지고 있다고 판단하므로 이는 일종의 코드 스멜이라고 볼 수 있다. 좋은 해결책은 컴포넌트의 마운트가 해제된 후 setState()가 호출될 수 있는 위치를 찾아 수정하는 것이다. 이러한 상황은 대게 컴포넌트가 데이터를 기다리고 있다가 데이터의 도착전 마운트가 해제 되는, 콜백 상황에서 많이 발생된다. 콜백은 마운트가 해제되기 전에 componentWillUnMount에서 취소되어야 한다. 👆 ¶What are the Pointer Events supported in React? 포인터 이벤트는 모든 입력 이벤트를 다루는 통일된 방법을 제공한다. 과거에는 마우스 및 각각의 이벤트 리스너를 달았지만, 요즘에는 핸드폰 터치, 서피스, 펜 등 마우스 외에 다양한 입력기기가 나타나기 시작했다. 한가지 명심해야 할 점은 이러한 이벤트들이 포인트 이벤트 명세를 지원하는 브라우저에서만 동작할 것이라는 점이다. 아래의 이벤트 타입들이 React DOM에서 지원하는 것이다. onPointerDown onPointerMove onPointerUp onPointerCancel onGotPointerCapture onLostPointerCaptur onPointerEnter onPointerLeave onPointerOver onPointerOut 👆 ¶Why should component names start with capital letter? JSX를 이용해서 렌더링을 하다보면, 컴포넌트의 명이 대문자가 아닐 경우 태그 인식에 실패했다는 에러메시지를 뱉는다. 그 이유는 오직 HTML 엘리먼트와 SGV 태그만이 소문자로 시작하기 때문이다. 123class SomeComponent extends Component &#123; // Code goes here&#125;` 클래스 명을 소문자로 시작하게 컴포넌트를 만들 수 있지만, import 할 때는 대문자로 하면 된다. 1234567class myComponent extends Component &#123; render() &#123; return &lt;div /&gt;; &#125;&#125;export default myComponent; 1import MyComponent from \"./MyComponent\"; 👆 ¶Are custom DOM attributes supported in React v16? 가능하다. 과거 React는 알수없는 DOM 속성을 무시했다. JSX에 리액트가 알수 없는 속성을 넣었다면, 리액트는 이를 무시했다. 예를 들어, 과거에는 아래와 같이 동작했다. 1&lt;div mycustomattribute=&#123;\"something\"&#125; /&gt; 1&lt;div /&gt; 그러나 React v16부터는 알수없는 속성도 결국 DOM에 반영된다. 1&lt;div mycustomattribute=\"something\" /&gt; 이는 브라우저에 특화된 비표준 속성, 새로운 DOM api, 서드파티 라이브러리 등을 사용할 때 유용하다. 👆 ¶What is the difference between constructor and getInitialState? es6 클래스에서는 constructor로 state를 초기화 하고, React.createClass를 사용할 때는 getInitialState()으로 초기화 한다. es6 12345678class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; /* initial state */ &#125;; &#125;&#125; React.createClass() 1234567const MyComponent = React.createClass(&#123; getInitialState() &#123; return &#123; /* initial state */ &#125;; &#125;&#125;); 👆 ¶Can you force a component to re-render without calling setState? 기본적으로, state나 prop의 변화가 있을 때만 컴포넌트가 리렌더링 된다. 만약 render() 메서드가 외부의 다른 데이터에 의존적이라면, forceUpdate()를 통해서 컴포넌트를 리렌더링 할 수 있다. 1component.forceUpdate(callback); 다만 이러한 방법은 권장되지 않으며, render()메소드에서 this.props나 this.state를 참조하는 것이 권장된다. 👆 ¶What is the difference between super() and super(props) in React using ES6 classes? constructor()에서 this.props에 접근하고 싶다면, super()메서드에 this.props를 넘겨야 한다. 123456class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); console.log(this.props); // &#123; name: 'John', ... &#125; &#125;&#125; 123456class MyComponent extends React.Component &#123; constructor(props) &#123; super(); console.log(this.props); // undefined &#125;&#125; 👆 ¶How to loop inside JSX? Array.prototype.map을 es6의 화살표 함수 문법과 사용하면 된다. 1234&lt;tbody&gt; &#123;items.map(item =&gt; &lt;SomeComponent key=\"&#123;item.id&#125;\" name=\"&#123;item.name&#125;\" /&gt;)&#125;&lt;/tbody&gt; for루프는 사용할 수 없다. 12345&lt;tbody&gt; for (let i = 0; i &lt; items.length; i++) &#123; &lt;SomeComponent key=\"&#123;items[i].id&#125;\" name=\"&#123;items[i].name&#125;\" /&gt; &#125;&lt;/tbody&gt; JSX 태그는 함수호출로 트랜스파일이 되는데, 이 경우 표현식내에 제어문을 사용할 수 없다. 다만 이는 stage1에 있는 do proposal로 해결 될 수도 있다. 👆 ¶How do you access props in attribute quotes? React와 JSX는 속성 값에 string interpolation을 지원하지 않는다. 따라서 아래 코드는 작동하지 않는다. 1&lt;img className=\"image\" src=\"images/&#123;this.props.image&#125;\" /&gt; 하지만 {}와 함께 javascript 표현식을 넣으면 가능하다. 12&lt;img className='image' src=&#123;'images/' + this.props.image&#125; /&gt; &lt;imgclassName='image' src=&#123;`images/$&#123;this.props.image&#125;`&#125; /&gt; 👆 ¶What is React proptype array with shape? 만약 특정 object를 가진 array를 넘기고 싶다면, React.PropTypes.arrayOf()와 함께 React.PropTypes.shape()를 쓰면 된다. 12345678ReactComponent.propTypes = &#123; arrayWithShape: React.PropTypes.arrayOf( React.PropTypes.shape(&#123; color: React.PropTypes.string.isRequired, fontSize: React.PropTypes.number.isRequired &#125;) ).isRequired&#125;; 👆 ¶How to conditionally apply class attributes? 따옴표 안에 내용은 모두 string으로 인식하기 때문에 {}를 쓸 수 없다. 1&lt;div className=\"btn-panel &#123;this.props.visible ? 'show' : 'hidden'&#125;\"&gt;&lt;/div&gt; 다만 {}안에 모든 식을 넣으면 가능하다. (공백은 반드시 있어야 한다) 1&lt;div className=&#123;'btn-panel ' + (this.props.visible ? 'show' : 'hidden')&#125;&gt; 템플릿 string도 가능하다 1&lt;div className=&#123;`btn-panel $&#123;this.props.visible ? 'show' : 'hidden'&#125;`&#125;&gt; 👆 ¶What is the difference between React and ReactDOM? React 패키지내에는 엘리먼트와 컴포넌트 클래스에 도움을 줄 수 있는 React.createElement() React.Component React.children등을 가지고 있다. React 패키지 내에는 컴포넌트를 만드는데 도움이 되는 이러한 요소들이 있다고 보면 된다. 반면 React-dom패키지는 ReactDOM.render() 서버사이드 렌더링에 필요한 react-dom/server에 속한 ReactDOMServer.renderToString() ReactDOMServer.renderToStaticMarkUp() 이 있다. 👆 ¶Why ReactDOM is separated from React? React 팀은 DOM조작과 관련된 모든 기능을 ReactDOM 라이브러리로 옮겼다. 이는 React v0.14에서 처음으로 분리되었다. 이 때 패키지를 보자면, react-native react-art react-canvas react-three등 패키지 분리가 깔끔해졌으며, React패키지 자체에는 브라우저 DOM 조작과 관련된 라이브러리가 없다는 것이 명확해졌다. React가 다수의 환경에서 렌더링을 지원하기 위해, React팀은 React와 React-dom을 분리할 계획을 수립햇다. 이러한 방법론은 웹 버전에서 쓰이는 React와 React-Native사이에 컴포넌트를 쓰는 방법론을 공유할 수 있도록 해준다. 👆 ¶How to use React label element? 표준 for 속성을 사용하는 text input에 바인드된 &lt;label&gt;을 사용하려고 하면, 속성이 없는 HTML이 생성되고 콘솔에 경고가 출력된다. 12&lt;label for=&#123;'user'&#125;&gt;&#123;'User'&#125;&lt;/label&gt;&lt;input type=&#123;'text'&#125; id=&#123;'user'&#125; /&gt; for는 자바스크립트의 예약어이므로, htmlFor를 사용해야 한다. 12&lt;label htmlFor=&#123;'user'&#125;&gt;&#123;'User'&#125;&lt;/label&gt;&lt;input type=&#123;'text'&#125; id=&#123;'user'&#125; /&gt; 👆 ¶How to combine multiple inline style objects? spread 연산자를 사용하면 된다. 1&lt;button style=&#123;&#123;...styles.panel.button, ...styles.panel.submitButton&#125;&#125;&gt;&#123;'Submit'&#125;&lt;/button&gt; React Native라면 array를 사용하면 된다. 1&lt;button style=&#123;[styles.panel.button, styles.panel.submitButton]&#125;&gt;&#123;'Submit'&#125;&lt;/button&gt; 👆 ¶How to re-render the view when the browser is resized? componentDidMount()에서 resize이벤트를 걸어두고, width와 height를 업데이트 하면 된다. 그리고 이 이벤트는 componentWillUnmount()에서 제거해줘야 한다. 1234567891011121314151617181920212223242526class WindowDimensions extends React.Component &#123; constructor(props)&#123; super(props); this.updateDimensions = this.updateDimensions.bind(this); &#125; componentWillMount() &#123; this.updateDimensions() &#125; componentDidMount() &#123; window.addEventListener('resize', this.updateDimensions) &#125; componentWillUnmount() &#123; window.removeEventListener('resize', this.updateDimensions) &#125; updateDimensions() &#123; this.setState(&#123;width: window.innerWidth, height: window.innerHeight&#125;) &#125; render() &#123; return &lt;span&gt;&#123;this.state.width&#125; x &#123;this.state.height&#125;&lt;/span&gt; &#125;&#125; 👆 ¶What is the difference between setState() and replaceState() methods? setState()는 과거의 state값을 현재 값으로 합친다. 반면 replaceState()는 현재 state를 버리고 넘어오는 state로 바꾼다. 이전 key를 모두 제거하는 경우가 아니라면 보통 useState()를 사용한다. replaceState()대신 setState()에서 false/null을 사용할 수도 있다. 👆 ¶How to listen to state changes? 아래 라이프사이클 메서드는 state의 변화가 있을 때 호출된다. 여기에서 이전 state와 props과 현재 state/props 값을 비교하여 의미있는 변화가 있었는지 추적할 수 있다. 12componentWillUpdate(object nextProps, object nextState)componentDidUpdate(object prevProps, object prevState) 👆 ¶What is the recommended approach of removing an array element in React state? Array.prototype.filter()메서드가 올바른 방법이다. 12345removeItem(index) &#123; this.setState(&#123; data: this.state.data.filter((item, i) =&gt; i !== index) &#125;)&#125; 👆 ¶Is it possible to use React without rendering HTML? 16.2 이상의 버전에서는 가능하다. 123render() &#123; return false&#125; 123render() &#123; return null&#125; 123render() &#123; return []&#125; 123render() &#123; return &lt;React.Fragment&gt;&lt;/React.Fragment&gt;&#125; 123render() &#123; return &lt;&gt;&lt;/&gt;&#125; undefined의 경우에는 작동하지 않는다. 👆 ¶How to pretty print JSON with React? &lt;pre&gt; 태그안에 JSON.stringify()를 사용하면 된다. 12345678910111213const data = &#123; name: 'John', age: 42 &#125;class User extends React.Component &#123; render() &#123; return ( &lt;pre&gt; &#123;JSON.stringify(data, null, 2)&#125; &lt;/pre&gt; ) &#125;&#125;React.render(&lt;User /&gt;, document.getElementById('container')) 👆 ¶Why you can’t update props in React? props은 불변이며, 하향식으로 전달되는 것이 React의 철학이다. 이 말인 즉, 부모는 어떤 prop값이든 자식에세 보낼 수 있지만, 자식은 그 prop값을 수정할 수 없다는 것이다. 👆 ¶How to focus an input element on page load? input 엘리먼트에 ref를 만들고, 이를 componentDidMount()에서 쓰면 된다. 123456789101112131415161718192021class App extends React.Component&#123; componentDidMount() &#123; this.nameInput.focus() &#125; render() &#123; return ( &lt;div&gt; &lt;input defaultValue=&#123;'Won\\'t focus'&#125; /&gt; &lt;input ref=&#123;(input) =&gt; this.nameInput = input&#125; defaultValue=&#123;'Will focus'&#125; /&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('app')) 👆 ¶What are the possible ways of updating objects in state? state를 병합할 object를 setState()에 서 사용하는 법 `Object.assign()로 Object의 복사본을 만든다. 12const user = Object.assign(&#123;&#125;, this.state.user, &#123; age: 42 &#125;)this.setState(&#123; user &#125;)- spread 연산자를 사용하는 법 12const user = &#123; ...this.state.user, age: 42 &#125;this.setState(&#123; user &#125;) setState()와 함수를 사용하는 법 123456this.setState(prevState =&gt; (&#123; user: &#123; ...prevState.user, age: 42 &#125;&#125;)) 👆 ¶Why function is preferred over object for setState()? React는 성능의 문제로 인해 여러개의 setState()를 배치 형태로 호출하게 된다. 왜냐하면 this.props와 this.state는 비동기로 업데이트 될 수 있기 때문이다. 다음 state를 계산할 때 이전에 계산된 값을 신뢰하면 안된다. 아래 예제는 제대로 작동하지 않는다. 1234// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;) 이를 위해 함수로 setState()를 호출하는 것이 권장된다. 함수로 호출시 이전 state값을 받을 수 있고, 업데이트할 때 사용할 prop도 받아올 수 있다. 1234// Correctthis.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)) 👆 ¶How can we find the version of React at runtime in the browser? React.version을 사용하면 된다. 123456const REACT_VERSION = React.versionReactDOM.render( &lt;div&gt;&#123;`React version: $&#123;REACT_VERSION&#125;`&#125;&lt;/div&gt;, document.getElementById('app')) 👆 ¶What are the approaches to include polyfills in your create-react-app? core-js를 수동으로 임포트하는 법 polyfills.js과 같은 파일을 만들고, 이를 루트인 index.js에서 임포트 한다. 그리고 core-js를 설치하여 필요한 기능을 임포트 한다. 123import 'core-js/fn/array/find'import 'core-js/fn/array/includes'import 'core-js/fn/number/is-nan' 폴리필 서비스를 이용하는 방법 polyfill.io를 CDN으로 가져와서, index.html에 추가하는 방법 1&lt;script src='https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes'&gt;&lt;/script&gt; 👆 ¶How to use https instead of http in create-react-app? 환경설정에 HTTPS=true를 세팅하면 된다. pacakge.json 123\"scripts\": &#123; \"start\": \"set HTTPS=true &amp;&amp; react-scripts start\"&#125; 아니면 set HTTPS=true &amp;&amp; npm start로 실행하면 된다. 👆 ¶How to avoid using relative path imports in create-react-app? 루트 디렉토리에 .env를 만들고, 임포트 경로를 작성한다. NODE_PATH=src/app 개발서벌르 재시작하면, 상대경로 없이 src/app에 있는 파일을 import 할 수 있다. 👆 ¶How to add Google Analytics for React Router? history 객체에 리스너를 추가하여 각 페이지 뷰에 달아 둔다. 1234history.listen(function (location) &#123; window.ga('set', 'page', location.pathname + location.search) window.ga('send', 'pageview', location.pathname + location.search)&#125;) 👆 ¶How to update a component every second? setInterval()에 트리거를 걸어두면 되지만, unmount시에 이를 해제하여 메모리 누수와 에러를 방지해야 한다. 1234567componentDidMount() &#123; this.interval = setInterval(() =&gt; this.setState(&#123; time: Date.now() &#125;), 1000)&#125;componentWillUnmount() &#123; clearInterval(this.interval)&#125; 👆 ¶How do you apply vendor prefixes to inline styles in React? react는 자동으로 vender prefix를 붙여주지 않으므로, 수동으로 붙여야 한다. 12345&lt;div style=&#123;&#123; transform: 'rotate(90deg)', WebkitTransform: 'rotate(90deg)', // note the capital 'W' here msTransform: 'rotate(90deg)' // 'ms' is the only lowercase vendor prefix&#125;&#125; /&gt; 👆 ¶How to import and export components using React and ES6? default키워드를 사용하여 컴포넌트를 익스포트 한다. 123456789101112import React from 'react'import User from 'user'export default class MyProfile extends React.Component &#123; render()&#123; return ( &lt;User type=\"customer\"&gt; //... &lt;/User&gt; ) &#125;&#125; 위 예제에서는 MyProfile이 멤버가 되어 모듈로 익스포트 되는데, 이는 다른 컴포넌트에서 굳이 이름을 명세하지 않더라도 임포트 할 수 있게 해준다. 👆 ¶What are the exceptions on React component naming? 몇가지 예외적인 경우를 제외하고, 컴포넌트 명은 대문자로 시작해야 한다. 소문자와 . (속성 접근자)을 사용하는 경우 유효한 컴포넌트 명이다. 아래의 예가 그러한 유효한 경우다. 12345render()&#123; return ( &lt;obj.component /&gt; // `React.createElement(obj.component)` )&#125; 👆 ¶Why is a component constructor called only once? React의 reconciliation 알고리즘은 후속 렌더링 과정에서 사용자 정의 컴포넌트가 똒같은 위치에 나타나면, 이전과 동일 한 요소이므로 새로운 인스턴스를 만드는 대신 이전 인스턴스를 재사용한다고 가정한다. 👆 ¶How to define constants in React? es7의 static 필드를 사용하여 상수를 정의할 수 있다. 123class MyComponent extends React.Component &#123; static DEFAULT_PAGINATION = 10&#125; 현재 static 필드는 stage3에 있다. 👆 ¶How to programmatically trigger click event in React? callback을 통한 ref prop를 사용하여 HTMLInputElement 객체에 대한 참조를 가져와서 class property 로 저장한 다음, 이렇게 저장된 참조를 활용하여 HTMLElement.click 메서드를 사용해 이벤트 핸들러에서 클릭 이벤트를 트리거 할 수 있다. render 메서드에서 ref를 생성한다. 1&lt;input ref=&#123;input =&gt; this.inputElement = input&#125; /&gt; 이벤트 핸들러에서 클릭 이벤트를 트리거 한다. 1this.inputElement.click() 👆 ¶Is it possible to use async/await in plain React? React 에서 async/await 을 사용하고 싶다면 Babel 과 transform-async-to-generator 플러그인이 필요하다. React Native에서는 기본적으로 지원하고 있다. 👆 ¶What are the common folder structures for React? 크게 두가지 종류가 있다. 기능 또는 라우팅으로 분류하는 방법 기능과 라우팅에 따라서 css, js, 테스트 코드를 묶는 방법이다. 123456789101112131415161718common/├─ Avatar.js├─ Avatar.css├─ APIUtils.js└─ APIUtils.test.jsfeed/├─ index.js├─ Feed.js├─ Feed.css├─ FeedStory.js├─ FeedStory.test.js└─ FeedAPI.jsprofile/├─ index.js├─ Profile.js├─ ProfileHeader.js├─ ProfileHeader.css└─ ProfileAPI.js 파일 타입 별로 분류하는 법 123456789101112131415api/├─ APIUtils.js├─ APIUtils.test.js├─ ProfileAPI.js└─ UserAPI.jscomponents/├─ Avatar.js├─ Avatar.css├─ Feed.js├─ Feed.css├─ FeedStory.js├─ FeedStory.test.js├─ Profile.js├─ ProfileHeader.js└─ ProfileHeader.css 👆 ¶What are the popular packages for animation? React Transition Group과 React Motion이 React 생태계에서 유명한 애니메이션 패키지다. 👆 ¶What is the benefit of styles modules? 스타일 값을 하드코딩 하는 것은 권장하지 않는 방식이다. 서로다른 UI 컴포넌트에서 넓게 사용되는 값은 하나의 모듈에서 추출해서 쓰는 것이 좋다. 아래와 같은 방식을 사용하면, 서로다른 컴포넌트에서 동일한 스타일을 가져올 수 있다. 12345678910111213export const colors = &#123; white, black, blue&#125;export const space = [ 0, 8, 16, 32, 64] 그리고 각각의 컴포넌트에서 이를 임포트 하면 된다. 1import &#123; space, colors &#125; from './styles' 👆 ¶What are the popular React-specific linters? 자바스크립트 lint로는 eslint가 유명하다. 코드 스타일을 분석할 수 있는 다양한 플러그인이 있다. React에서 가장 유명한 것은 eslint-plugin-react다. 기본적으로 몇가지 베스트 프랙티스를 확인하여, 이 규칙을 바탕으로 iterator의 키에서 부터 prop type까지 확인해 준다. 다른 유명한 플러그인으로는 eslint-plugin-jsx-a11y가 있는데, 이는 접근성과 관련된 일반적인 문제를 해결하는데 도움을 준다. JSX는 alt tabindex와 같은 HTML과 약간 다른 문법을 제공하므로, 일반적인 플러그인으로 는 확인이 어렵다. 👆 ¶How to make AJAX call and in which component lifecycle methods should I make an AJAX call? Axios, jQuery Ajax, 브라우저 빌트인 fetch등을 활용하여 ajax를 활용할 수 있다. 이렇게 데이터를 가져오는 것은 반드시 componentDidMount()내에서 해야 한다. 이는 데이터를 받어온 뒤에 setState()로 컴포넌트를 업데이트 할 수 있게 해준다. 예를 들어, 아래 코드에서 employee 목록을 가져오고 state를 업데이트 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041class MyComponent extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; employees: [], error: null &#125; &#125; componentDidMount() &#123; fetch('https://api.example.com/items') .then(res =&gt; res.json()) .then( (result) =&gt; &#123; this.setState(&#123; employees: result.employees &#125;) &#125;, (error) =&gt; &#123; this.setState(&#123; error &#125;) &#125; ) &#125; render() &#123; const &#123; error, employees &#125; = this.state if (error) &#123; return &lt;div&gt;Error: &#123;error.message&#125;&lt;/div&gt;; &#125; else &#123; return ( &lt;ul&gt; &#123;employees.map(item =&gt; ( &lt;li key=&#123;employee.name&#125;&gt; &#123;employee.name&#125;-&#123;employees.experience&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt; ) &#125; &#125;&#125; 👆 ¶What are render props? Render Props는 값이 함수인 prop을 활용하여 컴포넌트 간에 코드를 share할 수 있게 해주는 방법이다. 아래 컴포넌트는 render prop을 활용하여 React element를 리턴한다. 123&lt;DataProvider render=&#123;data =&gt; ( &lt;h1&gt;&#123;`Hello $&#123;data.target&#125;`&#125;&lt;/h1&gt;)&#125;/&gt; React Router 와 DownShift 라이브러리가 이 패턴을 사용한다. 👆","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"타입스크립트 타입 단언","slug":"typescript-type-assertion","date":"2019-08-20T00:30:52.000Z","updated":"2019-08-20T01:45:44.780Z","comments":true,"path":"2019/08/20/typescript-type-assertion/","link":"","permalink":"https://www.yceffort.kr/2019/08/20/typescript-type-assertion/","excerpt":"¶문제의 시작 문제의 시작은 여기 였다. 내가 사용하는 코드는 아래와 같았다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 type GlobalColors = \"Red\" | \"Blue\" | \"Green\" | \"Black\"; // 기본값으로 색상을 선언한다. const enum ConstGlobalColorSet { Red = \"11, 11, 11\", Blue = \"22, 22, 22\", Green = \"33, 33, 33\", Black = \"44, 44, 44\" } // red, blue","text":"¶문제의 시작 문제의 시작은 여기 였다. 내가 사용하는 코드는 아래와 같았다. 123456789101112131415type GlobalColors = \"Red\" | \"Blue\" | \"Green\" | \"Black\";// 기본값으로 색상을 선언한다.const enum ConstGlobalColorSet &#123; Red = \"11, 11, 11\", Blue = \"22, 22, 22\", Green = \"33, 33, 33\", Black = \"44, 44, 44\"&#125;// red, blue, green, black에 대해서는 글로벌하게 지정해둔 컬러를 사용하되,// 그밖의 string이 오면 그냥 그 string을 리턴한다function GetGlobalColor(colorString: GlobalColors | string) &#123; return GlobalColorSet[colorString] || colorString;&#125; 그러나 다른 프로젝트에서 아래와 같은 에러가 발생했다. 12// Element implicitly has an 'any' type because index expression is not of type 'number'.return GlobalColorSet[colorString] || colorString; 파라미터로오는 colorString 이 enum의 키가 아닐 수도 있기 때문에 발생하는 에러 였다. 기존 lint 룰에서는 any를 accept했기 때문에 에러가 발생하지 않았던 것이다. ¶해결 as 키워드를 써서 문제를 해결했다. 123function GetGlobalColor(colorString: GlobalColors | string) &#123; return GlobalColorSet[colorString as GlobalColors] || colorString;&#125; ¶타입 단언 타입스크립트의 타입 추론은 매우 좋고 강력한 기능이지만, 어쩔수 없이 한계가 존재하는 경우가 더러 있다. 이를 보완하기 위해, 타입 단언은 컴파일러가 실제 런타임에 존재할 변수와 다르게 추론하거나, 너무 보수적으로 추론하는 경우에 개발자가 수동으로 컴파일러에 대해 타입의 힌트를 주는 것이다. 위의 코드로 돌아와 보자. 123456enum ConstGlobalColorSet &#123; Red = \"11, 11, 11\", Blue = \"22, 22, 22\", Green = \"33, 33, 33\", Black = \"44, 44, 44\"&#125; 위코드는 컴파일을 거치고 나면 다음과 같이 해석된다. 123456789var ConstGlobalColorSet;(function(ConstGlobalColorSet) &#123; ConstGlobalColorSet[\"Red\"] = \"11, 11, 11\"; ConstGlobalColorSet[\"Blue\"] = \"22, 22, 22\"; ConstGlobalColorSet[\"Green\"] = \"33, 33, 33\"; ConstGlobalColorSet[\"Black\"] = \"44, 44, 44\";&#125;)(ConstGlobalColorSet || (ConstGlobalColorSet = &#123;&#125;));// &#123;Red: \"11, 11, 11\", Blue: \"22, 22, 22\", Green: \"33, 33, 33\", Black: \"44, 44, 44\"&#125; 당연하지만 Red Blue Green Black에 대해서는 올바르게 리턴할테지만, 다른 string에 대해서는 null을 리턴할 것이다. 즉, 컴파일 에러가 날 일은 없을 것이다. 이런 경우, as 키워드를 통해서 타입단언을 해주면 컴파일 에러 없이 사용할 수 있다. 대부분의 경우 as any와 같은 치트키로 컴파일 문제를 해결할 수 있다. 그러나 이런 키워드가 득실 거릴수록 타입스크립트로 얻을 수 있는 장점이 사라지기 때문에, 가능한 적게 사용해야 한다. ¶타입선언과 타입 캐스팅의 차이 타입 단언은 런타임에 영향을 미치지 않는다. 그러나 타입 캐스팅은 컴파일 타임과 런타임 모두 타입을 변경 시킨다. 타입 단언은 컴파일러에서만 타입을 변경 시킨다 타입 단언은 두가지로 사용될 수 있다. 12colorString as GlobalColors;&lt;GlobalColors&gt;colorString; &lt;Type&gt;은 리액트의 JSX 문법과 겹치는 느낌이 있어서 보통 as type을 더 많이 쓴다. ¶타입 가드 타입 가드는 타입스크립트 컴파일러에 타입 체크를 알려주는 기능이다. 자바스크립트에서는 이런 느낌으로 처리했을 것이다. 1234567891011121314151617181920212223242526272829303132333435function doSomething(x: number | string) &#123; if (typeof x === \"string\") &#123; // string 만 들어오게 처리 해줬기 때문에 에러가 날 수 없음 console.log(x.substr(1)); &#125; x.substr(1); // 에러 날 수도 있음&#125;class Foo &#123; foo = 123; common = \"123\";&#125;class Bar &#123; bar = 123; common = \"123\";&#125;function doStuff(arg) &#123; if (arg instanceof Foo) &#123; console.log(arg.foo); // OK console.log(arg.bar); // undefined &#125; if (arg instanceof Bar) &#123; console.log(arg.foo); // undefined console.log(arg.bar); // OK &#125; console.log(arg.common); // OK console.log(arg.foo); // undefined? console.log(arg.bar); // undefined?&#125;doStuff(new Foo());doStuff(new Bar()); 이를 타입스크립트에서 처리하려면 어떻게 해야할까? 1234567891011121314interface A &#123; x: number;&#125;interface B &#123; y: string;&#125;function doStuff(q: A | B) &#123; if (\"x\" in q) &#123; // q: A &#125; else &#123; // q: B &#125;&#125; in키워드를 사용하거나 아래 처럼 is키워드를 사용할 수도 있다. 1234567891011121314151617181920212223242526272829interface Foo &#123; foo: number; common: string;&#125;interface Bar &#123; bar: number; common: string;&#125;/** * arg를 Foo라고 타입 가드를 선언 */function isFoo(arg: any): arg is Foo &#123; return arg.foo !== undefined;&#125;function doStuff(arg: Foo | Bar) &#123; if (isFoo(arg)) &#123; console.log(arg.foo); // OK console.log(arg.bar); // Error! &#125; else &#123; console.log(arg.foo); // Error! console.log(arg.bar); // OK &#125;&#125;doStuff(&#123; foo: 123, common: \"123\" &#125;);doStuff(&#123; bar: 123, common: \"123\" &#125;);","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"리액트 인터뷰 질문 & 답","slug":"reactjs-interview-questions","date":"2019-08-13T00:27:31.000Z","updated":"2019-09-06T00:30:12.749Z","comments":true,"path":"2019/08/13/reactjs-interview-questions/","link":"","permalink":"https://www.yceffort.kr/2019/08/13/reactjs-interview-questions/","excerpt":"원문-reactjs-interview-questions 1. Core React 2. React - Router, Internationalization, Redux, Native and supported libraries and Integration \b","text":"원문-reactjs-interview-questions 1. Core React 2. React - Router, Internationalization, Redux, Native and supported libraries and Integration \b","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"koa-nextjs-react-typescript-boilerplate","slug":"koa-nextjs-react-typescript-bolierplate","date":"2019-08-12T04:42:22.000Z","updated":"2019-08-13T08:28:42.915Z","comments":true,"path":"2019/08/12/koa-nextjs-react-typescript-bolierplate/","link":"","permalink":"https://www.yceffort.kr/2019/08/12/koa-nextjs-react-typescript-bolierplate/","excerpt":"github repository nextjs와 react 만 깔끔하게 쓰고 싶지만, 그러기엔 현실적인 문제가 몇가지 있다","text":"github repository nextjs와 react 만 깔끔하게 쓰고 싶지만, 그러기엔 현실적인 문제가 몇가지 있다","categories":[],"tags":[{"name":"browser","slug":"browser","permalink":"https://www.yceffort.kr/tags/browser/"}]},{"title":"브라우저는 어떻게 동작하는가? - 모던 웹브라우저가 동작하는 방법","slug":"how-browser-work","date":"2019-08-12T04:42:22.000Z","updated":"2019-08-19T10:24:26.105Z","comments":true,"path":"2019/08/12/how-browser-work/","link":"","permalink":"https://www.yceffort.kr/2019/08/12/how-browser-work/","excerpt":"¶🚧작성중 🚧 원문-How Browsers Work: Behind the scenes of modern web browsers 이 글을 요약/번역한 더 좋은 글이 네이버 d2에 있습니다. 개인적인 공부 차원에서 이 원문을 fully 한글로 번역하고 있습니다. 소개 웹 브라우저는 가장 널리 쓰이는 소프트웨어다. 이 글에서는, 브라우저가 어떻게 동작하는지 소개할 것이다. 이 글을 읽고 나면, google.com을 타이핑 한 시점 부터 구글페이지가 브라우저에 보이기 까지, 어떤 일련의 과정이 있는지 알게 될 것이다. ¶목차 1","text":"¶🚧작성중 🚧 원문-How Browsers Work: Behind the scenes of modern web browsers 이 글을 요약/번역한 더 좋은 글이 네이버 d2에 있습니다. 개인적인 공부 차원에서 이 원문을 fully 한글로 번역하고 있습니다. 소개 웹 브라우저는 가장 널리 쓰이는 소프트웨어다. 이 글에서는, 브라우저가 어떻게 동작하는지 소개할 것이다. 이 글을 읽고 나면, google.com을 타이핑 한 시점 부터 구글페이지가 브라우저에 보이기 까지, 어떤 일련의 과정이 있는지 알게 될 것이다. ¶목차 소개 이 글에서 소개하는 브라우저 브라우저의 주요 기능 브라우저의 상위 레벨 구조 렌더링 엔진 렌더링 엔진들 주요 흐름 주요 흐름 예제 파싱과 DOM 트리 구축 파싱: 일반 문법들 Parser-Lexer 조합 변환 파싱 예제 어휘와 구문에 대한 공식적인 정의 파서의 종류 자동으로 파서 생성 HTML 파서 HTML 문법 정의 문맥으로 부터 자유롭지 못함 HTML DTD DOM 파싱 알고리즘 토큰화 알고리즘 트리구조 알고리즘 파싱이 끝났을 경우 액션 브라우저 에러 처리 CSS 파싱 웹킷 css 파서 스크립트와 스타일시트를 프로세싱하는 순서 스크립트 예측 파싱 스타일 시트 렌더 트리 구축 돔 트리와 렌더 트리와의 관계 트리를 구축하는 순서 스타일 연산 스타일 데이터 공유 파이어폭스 규칙 트리 구조체로 분리 규칙 트리를 활용하여 스타일 컨택스트 연산 쉬운 매칭을 위한 규칙 다루기 다단계 순서에 따라 규칙 적용하기 스타일 시트 다단계 순서 특정성 규칙정렬 점진적 프로세스 레이아웃 Dirty bit system 글로벌 및 incremental 레이아웃 동기 및 비동기 레이아웃 최적화 레이아웃 프로세스 너비 계산 라인 브레이킹 페인팅 글로벌 및 incremental 페인팅 순서 파이어폭스 디스플레이 리스트 웹킷 사각형 저장소 다이나믹 변화 렌더링 엔진의 스레드 이벤트 루프 CSS2 비쥬얼 모델 캔버스 CSS box model 포지셔닝 스킴 박스 타입 포지셔닝 relative floats absolute &amp; fixed 층표현 리소스 ¶1. 소개 ¶1-1. 이 글에서 소개하는 브라우저 오늘날에는 5개의 메인 브라우저가 존재한다: 크롬, 익스플로러, 파이어폭스, 사파리 그리고 오페라. 모바일에서, 안드로이드 브라우저, 아이폰, 오페라 미니, 오페라 모바일, UC 브라우저 등등이 존재하는데, 웹킷을 베이스로 하는 오페라를 제외하고는 대부분이 크롬을 기반으로 하고 있다. 여기에서는 오픈소스 브라우저인 파이어폭스, 크롬, 사파리 (부분적으로 오픈소스)를 예로 들 것이다. stat counter에 따르면 2013년 6월 기준 이 세 브라우저가 차지하는 글로벌 데스크톱 브라우저 비중이 71%에 육박한다. 모바일에서는, 안드로이드 브라우저, 아이폰과 크롬 베이스 프라우저가 54%정도를 차지한다. 2019년 7월 현재 세 브라우저의 시장 점유율은 83% 정도를 차지한다. ¶1-2. 브라우저의 주요 기능 브라우저의 주요 기능은 사용자가 선택한 웹리소스를 서버에 요청하고, 브라우저 윈도우에 디스플레이하여 표현하는 것이다.일반적으로 리소스는 HTML 문서지만, 여기에는 PDF, 이미지, 혹은 기타 다른 유형이 있을 수도 있다. 이런 리소스의 위치는 사용자가 사용하는 URI(Uniform Resource Identifier)에 의해서 정해진다. 브라우저가 HTML 파일을 해석하고 표시하는 방법은 HTML과 CSS 명세에 따라서 정해진다. 이러한 명세는 웹 표준화 기구인 W3C(World Wide Web Consortium) 에서 정해진다. 수년 간 일부 브라우저는 사양의 일부만을 준수하고 자체 익스텐션을 개발했다. 이로인해 웹 개발자들 사이에서 심각한 호환성 문제가 발생했다. 오늘날 대부분의 브라우저는 이러한 명세를 거의 지킨다. 샤앙을 어긴 브라우저는… ^^ 브라우저의 UI는 서로 대부분의 공통점을 가지고 있다. 이러한 공통점들을 예로 들자면 URI를 넣을 수 있는 주소창 뒤로가기/앞으로가기 버튼 북마크 옵션 현재 문서를 새로 고치거나 멈출 수 있는 새로고침/멈춤 버튼 사용자의 홈페이지로 가는 홈버튼 이상하게도 이러한 공통점들은, 공식적인 명세로 지정된 것이 아님에도 불구하고 수년 동안 형성된 좋은 관행과 서로를 모방하는 브라우저의 특징에서 비롯된 것이다. HTML5 명세는 브라우저가 가져야하는 UI 요소를 정의하고 있지는 않지만, 일부 공통된 요소들을 나열한다. 그 중에는 주소 표시줄, 상태 표시줄, 도구 표시줄 등이 있다. 물론 파이어폭스나 크롬의 다운로드 관리자와 같은 특정 브라우저에만 있는 기능도 있다. ¶1-3 브라우저의 상위레벨 구조 유저 인터페이스: 주소창, 앞/뒤 버튼, 북마크 메뉴 등, 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분을 칭한다. 브라우저 엔진: 유저 인터페이스와 렌더링 엔진 사이의 동작을 제어 렌더링 엔진: 요청한 콘텐츠를 표시한다. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다. 네트워킹: HTTP 요청과 같은 네트워크 통신에 사용된다. 여기는 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다. UI 백엔드: 콤보 박츠, 창과 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로, OS 사용자 인터페이스 체계를 사용한다. 자바스크립트 인터프리터: 자바스크립트 코드를 파싱하고 실행을 위해 사용한다. 데이터 스토리지: 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이, 모든 종류의 자원을 하드디스크에 저장할 때 사용한다. HTML5 명세에는 브라우저가 지원해야하는 웹 데이터 베이스가 정의 되어 있다. 크롬과 같은 경우에는 각 탭마다 별도의 렌더링 엔진을 사용한다. 각 탭은 다른 프로세스에서 실행된다. ¶2. 랜더링 엔진 렌더링 엔진의 역할은… 말그대로 렌더링이다. 렌더링은 여기서 요청받은 콘텐츠를 브라우저 화면에 보여주는 역할이다. 기본적으로 렌더링엔진은 HTML, XML, 그리고 이미지를 표시할 수 있다. 플러그인이나 익스텐션을 활용한다면, 다양한 데이터 타입, 예를 들어 PDF 등 도 표시할 수 있다. 그러나, 이번 챕터에서는 일반적인 활용 예제인 CSS로 포맷된 HTML과 이미지를 표시하는 법에 대해서 다룰 것이다. ¶2-1. 렌더링 엔진들 브라우저 마다 서로다른 렌더링 엔진을 사용하고 있다. 익스프롤러는 Trident를, 파이어폭스는 Gecko를 사용하며 사파리는 Webkit을 사용한다. 그리고 크롬과 15버전 부터 오페라는 Webkit에서 포크된 Blink를 사용한다. Webkit은 오픈소스 렌더링 엔진으로, 리눅스 플랫폼에서 사용될 엔진으로 만들어졌다가 애플에 의해서 맥과 윈도우도 지원하게 되었다. 자세한 것은 webkit.org를 참조하면 된다. ¶2-2. 주요 흐름 렌더링 엔진은 통신을 통해 요청한 문서의 내용을 얻는 것부터 시작한다. 보통 문서내용은 8kb 단위로 전송된다. 렌더링 엔진의 기본적인 동작과정은 아래와 같다. DOM 트리 구축을 위한 HTML 파싱 렌더 트리 구축 렌더 트리 배치 렌더 트리 그리기 렌더링 엔진은 HTML 문서를 파싱하기 시작하며, 콘텐츠 트리 내부에서 태그를 DOM 노드로 변환한다.그리고 엔진은 CSS파일과 스타일 요소를 파싱하기 시작한다. 스타일 정보와 HTML 표시 규칙은 ‘렌더트리’ 라고 부르는 또다른 트리를 생성한다. 렌더 트리는 색상 또는 면적과 같은 시각적 속성이 있는 사각형을 포함하고 잇는데, 정해진 순서대로 화면에 표시된다. 렌더 트리 구축 이후에는, 레이아웃 프로세스로 넘어간다. 이 말은, 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다. 다음은 UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 모양을 만들어 내는 그리기 과정이다. ¶2-3. 주요 흐름 예제 웹킷의 주요 흐름 모질라 게코의 렌더링 엔진 주요 흐름 그림에서 보다시피, 웹킷과 게코가 약간 다른 용어를 쓰고 있지만 기본적인 흐름은 동일하다. 게코는 시각적으로 처리되는 렌더 트리를 프레임트리 라고 부르고, 각 요소를 프레임이라고 부르는 반면, 웹킷은 렌더 객체로 구성되어 있는 렌더 트리라는 용어를 사용한다. 웹킷은 요소를 배치하는데 레이아웃이라는 용어를 사용하지만, 개코는 리플로우라는 용어를 사용한다. attachment는 웹킷이 렌드 트리를 생성하기 위해 DOM노드와 시각정보를 연결하는 과정을 의미한다. 반면에 게코는 HTML과 DOM트리 사이에 콘텐츠 싱크라고 부르는 과정을 두는데, 이는 DOM 요소를 생성하는 과정으로 웹킷과 비슷하여 큰 의미 있는 차이점으로 보지는 않는다. ¶3. 파싱과 DOM 트리 구축 ¶3-1. 파싱 일반 파싱은 렌더링 엔진에서 아주 중요한 작업이라서, 파싱에 대해서 아주 깊게 다룰 예쩡이다. 파싱에 대한 짧은 소개와 함께 시작한다. 문서를 파싱한다는 것은 문서 구조를 읽을 수 있는 코드로 변환한다는 것을 의미한다. 파싱의 결과는 보통 노드의 트리로 나타나는데, 이 노드의 트리는 문서의 구조를 나타낸다. 이것을 파스트리 또는 신택스 트리 라고 한다. 예를 들어, 2+3-1은 아래와 같은 트리구조로 나타낼 수 있다. ¶3-1-1. 문법들 파싱은 문서에 작성된 언어 또는 형식의 규칙을 따른다. 파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙에 따라야 한다. 이것을 문맥 자유 문법이라고 한다. 인간의 언어는 이런 모습과는 다르기 때문에 기계적으로 파싱이 불가능하다. ¶3-1-2. Parser-Lexer 조합 파싱은 두가지 서브 프로세스로 나눌수 있다. 렉시컬 분석과 신택스 분석. 렉시컬 분석은 입력값을 토큰으로 나누는 과정이다. 토큰은 유효하게 구성된 단위의 집합이라고 볼 수 있다. 인간의 언어에서는 사전적으로 뜻이 있는 단어들을 의미한다. 신택스 분석은 언어를 신택스 규칙에 적용하는 것이다. 파서는 보통 두가지 일을 하는데 렉서 (토크나이저라고도 한다)는 입력값을 유효한 토큰 값으로 나누는 일을 하고, 파서는 언어 규칙에 따라 문서구조를 분석하여 파싱트리를 생성한다. 렉서는 공백, 줄바꿈 같은 의미 없는 문자를 제거한다. D2에서는 렉서를 어휘분석으로, 파서는 구문분석으로 정의했다. 파싱과정은 반복된다. 파서는 렉어세 새로운 토큰이 있는지 질의하고, 토큰을 신택스 규칙에 맞추려고 한다. 만약 맞는 규칙이 있다면, 토큰에 해당하는 노드가 파싱트리에 추가되고, 파서는 또다른 토큰을 요청하게 된다. 만약 일치하는 규칙이 없다면, 파서는 토큰을 내부에 저장하고 토큰과 일치하는 규칙이 발견될때 까지 요청한다. 맞는 규칙이 계속해서 없다면 예외처리를 하는데, 이는 문서가 유효하지 않고 신택스 오류가 있다는 것을 의미한다. ¶3-1-3. 변환 대부분의 경우 파스 트리가 마지막 결과물이 아니다. 파싱은 보통 변환과정에서 사용되는데, 이 과정은 입력된 문서를 다른 형식으로 변환하는 과정을 의미한다. 이와 같은 예로 컴파일이 있다. 소스 코드를 기계 코드로 만드는 컴파일러는, 파싱트리 생성후 기계 코드 문서로 변환한다. ¶3-1-4. 파싱 예제 이전 그림에서 수학식을 파스 트리로 만들어 보았다. 간단한 수학 언어를 정의하고, 파싱과정을 살펴보자. 언어: 이 수학언어에는 정수, 더하기, 빼기가 있다. 신택스: 기본적인 요소로는 표현식, 항, 연산자가 있다 언어에 포함되는 표현식 갯수에 제한이 없다 항 뒤에 연산자, 그뒤에 또다른 항이 나오는 형태로 정의한다 연산자는 더하기 토큰 또는 빼기 토큰이다 정수 토큰 또는 하나의 표현식은 항이다. 이제 아까 예제인 2+3-1을 분석해보자. 규칙에 맞는 첫 번째 문자열은 2다. 규칙 5에 따르면 이것은 하나의 항으로 볼 수 있다. 두 번째로 맞는 것은 2+3 인데 이것은 항 뒤에 연산자와 또 다른 항이 등장한다는 세 번째 규칙과 일치한다. 입력 값의 마지막 부분까지 진행하면 또 다른 일치를 발견할 수 있다. 2+3은 항과 연산자와 항으로 구성된 하나의 새로운 항이라는 것을 알고 있기 때문에 2+3-1은 하나의 표현식이 된다. 2++은 어떤 규칙과도 맞지 않기 때문에 유효하지 않은 입력이 된다. ¶3-1-5. 어휘와 구문에 대한 공식적인 정의 어휘는 보통 정규표현식을 활용한다. 예를 들어 이 수학언어는 아래처럼 표현할 수 있을 것이다. 123INTEGER: 0|[1-9][0-9]*PLUS: +MINUS: - 보시다시피, 정수도 정규표현식으로 정의했다. 신택스는 보통 BNF라고 부르는 형식을 따라서 정의한다. 123expression := term operation termoperation := PLUS | MINUSterm := INTEGER | expression 문법이 문맥 자유 문법이라면 언어는 정규 파서로 파싱할 수 있다. 문맥 자유 문법은 완전히 BNF로 표현 가능한 문법으로 보면 된다. ¶3-1-6. 파서의 종류 파서는 top-down 파서와 bottom up 파서 이렇게 두가지로 나누어진다. 직관적으로 설명하자면, top-down 파서는 위에서 부터 상위구조에서 부터 일치하는 부분을 찾기 시작하지만, bottom-up의 경우에는 밑에서 부터 점차 높은 수준으로 찾는다. 두 종류 파서가 예제를 어떻게 파싱하는지 살펴보자. top-down 파서는 상위 구조에서 부터 시작한다. 2+3에 해당하는 표현식을 찾는다. 그리고 2+3-1를 찾을 것이다. 표현식을 찾는 과정은, 다른 규칙을 점진적으로 계속해서 찾는 방식인데 가장 높은 수준의 규칙을 먼저 찾는 것을 시작한다. 반면에 bottom-up은 입력값이 규칙에 맞을때 까지 찾아서 맞는 입력값 규칙으로 바꾸는데, 이는 입력값의 끝까지 진행된다. 부분적으로 일치하는 표현식은 파서의 스택에 쌓인다. Stack input 2 + 3 - 1 항 + 3 - 1 항 연산자 3 -1 표현식 -1 표현식 연산자 1 표현식 bottom up 파서는 shift-reduce 파서라고도 불리우는데, 왜냐하면 입력값이 오른쪽으로 이동하면서 신택스 규칙으로 남는 것이 점차 감소하기 때문이다. ¶3-1-7. 파서 자동 생성 파서를 생성해 줄 수 있는 도구를 파서 생성기라고 한다. 이 생성기에 문법을 제공하고, 어휘와 신택스 규칙을 적용하여 파서를 생성한다. 파서를 작성하려면 파싱에 대한 깊은 이해가 필요하며, 수작업으로 최적화된 파서를 제공하는 것은 쉽지 않으므로 파서 생성기가 유용할 수 있다. Webkit의 경우에는 flex라고 불리우는 lexer와 bison이라고 불리우는 파서 생성기를 사용한다. Flex는 토큰의 정규 표현식 정의를 포함하는 파일을 입력값으로 받고, bison은 BNF형식의 언어 신택스 규칙을 입력 받는다.","categories":[],"tags":[{"name":"browser","slug":"browser","permalink":"https://www.yceffort.kr/tags/browser/"}]},{"title":"React Hooks Api (2)","slug":"react-hooks-api-2","date":"2019-08-12T02:03:51.000Z","updated":"2019-08-14T02:05:21.889Z","comments":true,"path":"2019/08/12/react-hooks-api-2/","link":"","permalink":"https://www.yceffort.kr/2019/08/12/react-hooks-api-2/","excerpt":"¶useReducer 1 const [state, dispatch] = useReducer(reducer, initialArg, init); useState의 대체 함수다. 다수의 하윗 값을 만드는 복잡한 로직, 혹은 다음 state가 이전 state의 의존적인 경우에 쓴다. 뭐가 뭔지 모르겠으니까 예제를 보자. useState를 쓰기전 1 2 3 4 5 6 7 8 9 10 11 function Counter({ initialCount }) { const [count, setCount] = useState(init","text":"¶useReducer 1const [state, dispatch] = useReducer(reducer, initialArg, init); useState의 대체 함수다. 다수의 하윗 값을 만드는 복잡한 로직, 혹은 다음 state가 이전 state의 의존적인 경우에 쓴다. 뭐가 뭔지 모르겠으니까 예제를 보자. useState를 쓰기전 1234567891011function Counter(&#123; initialCount &#125;) &#123; const [count, setCount] = useState(initialCount); return ( &lt;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 1234567891011121314151617181920212223const initialState = &#123; count: 0 &#125;;function reducer(state, action) &#123; switch (action.type) &#123; case \"increment\": return &#123; count: state.count + 1 &#125;; case \"decrement\": return &#123; count: state.count - 1 &#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"increment\" &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"decrement\" &#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 1234567891011121314151617181920212223242526272829303132function init(initialCount) &#123; return &#123; count: initialCount &#125;;&#125;function reducer(state, action) &#123; switch (action.type) &#123; case \"increment\": return &#123; count: state.count + 1 &#125;; case \"decrement\": return &#123; count: state.count - 1 &#125;; case \"reset\": return init(action.payload); default: throw new Error(); &#125;&#125;function Counter(&#123; initialCount &#125;) &#123; const [state, dispatch] = useReducer(reducer, initialCount, init); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"reset\", payload: initialCount &#125;)&#125; &gt; Reset &lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"increment\" &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: \"decrement\" &#125;)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 예제를 보니 대충 감이 온다. dispatch를 통해서 state값에 변화를 주지 않고 state값 변화에 트리거를 줄 수 있고, 이 트리거를 이용해 여러개의 state에 변화를 줄 수도 있다. ¶useCallback 메모이제이션된 콜백을 반환한다. 123const memoizedCallback = useCallback(() =&gt; &#123; doSomething(a, b);&#125;, [a, b]); 동일한 콜백을 바라봐야하는 자식 컴포넌트에게 사용할 때 유용하다. ¶useMemo 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 메모이제이션된 값을 반환한다. useMemo는 의존성이 변경되었을 때만, 메모제이션된 값을 다시 계산할 것이다. ¶useRef 123456789101112131415const refContainer = useRef(initialValue);function TextInputWithFocusButton() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; // `current` points to the mounted text input element inputEl.current.focus(); &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125; useRef는 .current에 변경가능한 ref값을 담을 수 있다. 부모 클래스에서 특정 dom객체를 계속 추적해야할 때 유용하다. 다만 .current를 변경한다고 해서 리렌더링이 일어나지는 않는다.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"React Hooks Api (1)","slug":"react-hooks-api-1","date":"2019-08-08T08:01:07.000Z","updated":"2019-08-14T02:05:21.889Z","comments":true,"path":"2019/08/08/react-hooks-api-1/","link":"","permalink":"https://www.yceffort.kr/2019/08/08/react-hooks-api-1/","excerpt":"Hooks API Hook은 react 16.8에서 추가된 개념으로, Hook을 시용하면 class를 갖성하지 않아도 state관리와 같은 react의 기능을 사용할 수 있다. ¶기본 Hook ¶useState 1 2 const [state, setState] = useState(initialState); setState(newState); 상태 유지값, 그리고 그 값을 수정하는 함수를 반환한다. 이전의 state값을 받아다가 수정할 수도 있다. 1 2 3 4 5 6 7 8 9 10 11 function Counter","text":"Hooks API Hook은 react 16.8에서 추가된 개념으로, Hook을 시용하면 class를 갖성하지 않아도 state관리와 같은 react의 기능을 사용할 수 있다. ¶기본 Hook ¶useState 12const [state, setState] = useState(initialState);setState(newState); 상태 유지값, 그리고 그 값을 수정하는 함수를 반환한다. 이전의 state값을 받아다가 수정할 수도 있다. 1234567891011function Counter(&#123; initialCount &#125;) &#123; const [count, setCount] = useState(initialCount); return ( &lt;&gt; Count: &#123;count&#125; &lt;button onClick=&#123;() =&gt; setCount(initialCount)&#125;&gt;Reset&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(prevCount =&gt; prevCount - 1)&#125;&gt;-&lt;/button&gt; &lt;/&gt; );&#125; 동일한 값으로 갱신하는 경우(Object.is) 값이 업데이트 하지 않고 처리를 종료한다. ¶useEffect 1useEffect(didUpdate); 화면에 렌더링이 완료된 이후에 수행한다. 또한, 컴포넌트가 화면에서 제거 될 때 정리 해야할 리소스도 선언할 수 있다. 123456useEffect(() =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; subscription.unsubscribe(); &#125;;&#125;); unsubscribe는 이제 ui에서 컴포넌트를 제거하기 직전에 수행한다. 그리고 만약, 컴포넌트가 여러번 렌더링 된다면 다음 effect가 수행되기 전에 이전 effect가 정리된다. 만약 조건부로 실행하기 위해서는 아래와 같은 방법을 활용할 수도 있다. 123456useEffect(() =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; subscription.unsubscribe(); &#125;;&#125;, [props.source]); 그럼 이제 props.source값이 변경 될때 만 useEffect가 발생하게 된다. ¶useContext ¶Context context를 이용하면, 매번 일일이 props를 넘겨주지 않아도, 컴포넌트 트리전체에 데이터를 제공할 수 있다. 즉, context는 react 컴포넌트 트리안에서 전역적으로 대이터를 공유할 수 있도록 고안된 방법이다. 123456789&lt;Page user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt; &lt;PageLayout user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt; &lt;NavigationBar user=&#123;user&#125; avatarSize=&#123;avatarSize&#125; /&gt; &lt;Link href=&#123;user.permalink&#125;&gt; &lt;Avatar user=&#123;user&#125; size=&#123;avatarSize&#125; /&gt; &lt;/Link&gt; &lt;/NavigatorBar&gt; &lt;/PageLayout&gt;&lt;/Page&gt; 실제로 user와 avatarSize를 사용하는 곳은 Link컴포넌트 인데, page 온갖 컴포넌트를 거치면서 값을 내려주는 것을 볼 수 있다. 이게 더 심해지는 경우, 같은 데이터를 트리안의 여러 레벨의 컴포넌트에게 주어야 할 때도 있다. 이렇게 데이터가 변할 때 마다 모든 하위 컴포넌트에게 해당 값을 알려주는 것이 context이다. 1const MyContext = React.createContext(defaultValue); Context객체를 만든다. Context 객체를 구독하고, 컴포넌트를 렌더링 할 때 트리 상위에서 가장 가까이 짝이 맞는 Provider로 부터 현재 값을 읽는다. 여기서 선언된 defaultValue는 트리안에서 적절한 Provider를 찾지 못했을 때에만 쓰는 값이다. 123&lt;MyContext.provider value=\"&#123;someValue&#125;\"&gt; &lt;SomeComponent /&gt;&lt;/MyContext.provider&gt; Provider는 context를 구독하는 컴포넌트들에게 context의 변화를 알리는 역할을 한다. Provider는 value에 있는 prop을 받아서 이 값을 하위 컴포넌트에 전달한다. 123&lt;MyContext.Consumer&gt; &#123;value =&gt; /* context 값을 이용한 렌더링 */&#125;&lt;/MyContext.Consumer&gt; context 변화를 구독하는 React Component다. 반드시 Context.Consumer의 자식은 함수여야만 한다. 이 함수는 context의 현재 값을 받고, React 노드를 반환해야 한다. 1const value = useContext(MyContext); 를 사용하면, context객체를 받아서, 현재 context의 값을 반환한다.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"HAProxy","slug":"haproxy","date":"2019-08-07T00:39:20.000Z","updated":"2019-08-08T01:31:17.637Z","comments":true,"path":"2019/08/07/haproxy/","link":"","permalink":"https://www.yceffort.kr/2019/08/07/haproxy/","excerpt":"¶로드밸런서 로드 밸런싱이란, 부하 분산을 위해서 가상 IP를 통해 여러 서버에 접속하도록 분배하는 기능을 말한다. 로드 밸런싱에서 사용하는 주요 기술은 * NAT(Network Address Translation): 사설 IP 주소를 공인 IP 주소로 바꾸는 데 사용하는 통신망의 주소 변조기이다. * DSR(Dynamic Source Routing protocol): 로드 밸런서 사용 시 서버에서 클라이언트로 되돌아가는 경우 목적지 주소를 스위치의 IP 주소가 아닌 클라이언트의 IP 주소로 전달해서 네트워크 스위치를 거치지","text":"¶로드밸런서 로드 밸런싱이란, 부하 분산을 위해서 가상 IP를 통해 여러 서버에 접속하도록 분배하는 기능을 말한다. 로드 밸런싱에서 사용하는 주요 기술은 NAT(Network Address Translation): 사설 IP 주소를 공인 IP 주소로 바꾸는 데 사용하는 통신망의 주소 변조기이다. DSR(Dynamic Source Routing protocol): 로드 밸런서 사용 시 서버에서 클라이언트로 되돌아가는 경우 목적지 주소를 스위치의 IP 주소가 아닌 클라이언트의 IP 주소로 전달해서 네트워크 스위치를 거치지 않고 바로 클라이언트를 찾아가는 개념이다. Tunneling: 인터넷상에서 눈에 보이지 않는 통로를 만들어 통신할 수 있게 하는 개념으로, 데이터를 캡슐화해서 연결된 상호 간에만 캡슐화된 패킷을 구별해 캡슐화를 해제할 수 있다. 로드 밸런서는, 네트워크에서 IP 주소와 MAC주소를 바탕으로 목적지 IP주소를 찾아가고, 다시 출발지를 되돌아 오는 구조로 작동된다. 출처: naver d2 ¶HAProxy HAProxy는 reserve proxy형태로 작동한다. 흔히 브라우저에서 사용하는 proxy는 클라이언트 앞에서 처리하는데, 이를 forward proxy라고 한다. 반대로 reserve proxy는 실제 서버 요청에 대해 서버 앞단에 존재하면서, 서버로 들어오는 요청을 대신 받아 서버에 전달하고, 요청한 곳에 그 결과를 다시 전달한다. ¶작동 흐름 최초 접근 시 서버에 요청 전달 응답 시 쿠키(cookie)에 서버 정보 추가 후 반환 재요청 시 proxy에서 쿠키 정보 확인 &gt; 최초 요청 서버로 전달 다시 접근 시 쿠키 추가 없이 전달 &gt; 클라이언트에 쿠키 정보가 계속 존재함(쿠키 재사용)","categories":[],"tags":[{"name":"infrastructure","slug":"infrastructure","permalink":"https://www.yceffort.kr/tags/infrastructure/"},{"name":"proxy","slug":"proxy","permalink":"https://www.yceffort.kr/tags/proxy/"}]},{"title":"Docker와 ECR, ECS 경험","slug":"experience-docker-aws-ecs","date":"2019-08-05T23:55:52.000Z","updated":"2019-08-07T00:33:26.794Z","comments":true,"path":"2019/08/06/experience-docker-aws-ecs/","link":"","permalink":"https://www.yceffort.kr/2019/08/06/experience-docker-aws-ecs/","excerpt":"제법 규모가 있었던 전 회사에서는 특별하게 인프라에 대해 고민을 별로 할 필요가 없었다. 많은 부분이 자동화되어 있었고, 또 적당한 툴로 잘 만들어져 있었기 때문에 개발에 온전히 집중할 수 있었다. 하지만 새롭게 온 스타트업은 (당연하게도) 그런게 없으므로, 회사에서 사용하고 있는 AWS 인프라와 배포 시스템에 대해서 직접 공부할 필요가 있었다. 그 중에서도 처음 접하는 것이 docker 였다. ¶Docker 예전 부터 이름은 많이 들어봤지만 이런저런 이유로 (귀찮아서) 한번도 써본적이 없었다. docker는 컨테이너 기반의 오픈","text":"제법 규모가 있었던 전 회사에서는 특별하게 인프라에 대해 고민을 별로 할 필요가 없었다. 많은 부분이 자동화되어 있었고, 또 적당한 툴로 잘 만들어져 있었기 때문에 개발에 온전히 집중할 수 있었다. 하지만 새롭게 온 스타트업은 (당연하게도) 그런게 없으므로, 회사에서 사용하고 있는 AWS 인프라와 배포 시스템에 대해서 직접 공부할 필요가 있었다. 그 중에서도 처음 접하는 것이 docker 였다. ¶Docker 예전 부터 이름은 많이 들어봤지만 이런저런 이유로 (귀찮아서) 한번도 써본적이 없었다. docker는 컨테이너 기반의 오픈소스 가상화 플랫폼 이라고 정의할 수 있다. 여기서 중요한 용어 중 하나가 컨테이너라고 생각한다. ¶컨테이너 docker의 컨테이너에 백엔드 프로그램, DB, 메시지 큐 등 다양한 프로그램을 컨테이너에 집어 넣어 추상화 한 다음, 이를 어디서든 배포할 수 있는 상태로 만들어 준다. docker는 기존의 virtual machine과는 다르게 프로세스를 격리 시키는 방법으로 가상화를 한다. docker가 동작하기 위한 cpu나 메모리만 격리해서 사용하므로, 성능적으로도 손실이 적은 방식이다. ¶이미지 이미지는 컨테이너의 실행에 필요한 파일 및 설정을 포함하고 있는 것 으로 별도의 상태값을 갖고 변하지 않는다. 컨테이너는 이미지를 실행하는 것이라 볼 수 있고, 추가되거나 변화가 필요한 값은 컨테이너에 저장된다. 말 그대로, 컨테이너를 실행하기 위한 모든 정보를 갖고 있기 때문에 의존성 파일을 컴파일/설치할 필요가 없다. docker를 이용한다면 이제 이미지를 다운받고 컨테이너를 생성면 된다. ¶Dockerfile을 시작으로 실제해보기 여기를 참고하자. 친절하게 정말 잘 써주셨다. ¶ECR 아마존 ECR은 docker 컨테이너 이미지를 손쉽게 저장, 관리 배포할 수 있게 도와주는 일종의 레파지토리 같은 개념이다. 이렇게 생성된 이미지를 푸쉬해서 관리 할 수 있다. ¶ECS docker를 사용하다보면 컨테이너를 적절하게 배치하거나 관리할 도구의 필요성을 느끼게 된다. docker에서 만든 swarm도 있지만서도, 가장 유명한건 구글의 쿠버네티스가 아닐까 싶다. 이런 컨테이너 오케스트레이션 도구 중 하나가 바로 aws의 elastic container system (이하 ECS) 다. ¶Cluster ecs의 가장 기본적인 단위는 클러스터다. 클러스터는 도커 컨테이너를 실행할 수 있는 가상의 공간, 일종의 논리적인 단위 수준이라고 볼 수 있다. ¶Task ECS에서 컨테이너를 실행하는 최소단위를 task라고 부른다. task는 하나이상의 컨테이너로 구성할 수 있다. 같은 task내 있는 컨테이너들은 모두 같은 컨테이너 인스턴스에서 실행되는 것이 보장된다. 이러한 task를 실행하기 위한 것이 task definition 이다. task definition에는 task를 실행하기 위한 다양한 것들을 설정할 수 있다. 귀찮아서 캡쳐는 안했지만, add container에는 이미지 주소, 컨테이너명, 컨테이너 사양, 환경변수 등을 정할 수 있도록 설정이 준비되어 있다. 그리고 설정 변경 / 이미지 변경이 필요할 때마다, task definition을 새롭게 만듦으로써 (create new revision) 이를 해결할 수 있다. ¶Service cluster는 두가지 방식으로 task를 실행할 수 있다. 한가지는 run task definition을 통해서 일회성으로 실행하는 것이다. 이 task는 곧바로 실행되고, 더이상 관리되지 않는다. 두 번째 방법은 서비스를 정의하는 것이다. 서비스는 하나이상의 task definition과 연결된다. 서비스는 크게 리플리카 타입과 데몬타입으로 나누어져 있는데, 우리는 리플리카 타입을 사용해서 n개의 태스크가 실행되도록 관리하고 있다. ¶어떻게 썼나 먼저 dockerfile을 통해서 이미지를 만들고, 해당 이미지를 ecr에 업로드한다. 그리고 배포가 필요할 때마다 task definition을 새롭게 만들고, 새롭게 만들어진 이미지를 넣었다. 그리고 서비스에서 실행할 이미지를 새롭게 만들어진 k번째 task definition으로 교체하면 끝이다. ¶써보니까 좋았던 점 의식의 흐름대로 나열해 보았다. 배포 히스토리를 남길 수 있었다 == 롤백이 쉬웠다. 배포할 때 마다 새롭게 만들어진 이미지를 ecr에 업로드 하였기 때문에 이미지 목록을 히스토리 느낌으로 남길 수 있었다. 그리고 롤백이 필요하면 이전에 잘 동작했던 이미지로 교체해주면 된다. 사실 이 방법보다 쉬운 것은 그냥 예전에 잘 동작했던 task-definition으로 service를 교체해 주는 것이다. 스테이지 별 로 다른 변수를 task definition - container의 환경변수로 관리할 수 있다. 기존에는 프로젝트에 .development .release 이런 형식으로 소스파일안에 스테이지마다 다른 변수 값을 두어야 했다. 따라서 이 글로벌 변수에 변동이 있을 때마다 배포를 새로 하는 번거로움이 있었는데, 이 방식 대로 하면 단지 task definition을 새롭게 만들고, 환경변수를 추가해서 service에 올려주기만 하면 된다. 추가로 dockerfile 혹은 docker 빌드 과정에 환경변수를 따로따로 주입하지 않는 다면, 어떤 스테이지 든지 간에 동일한 이미지로 대처할 수 있다. 3. 드디어 docker를 써볼 수 있었다. 4. 아마존에 많은 돈을 지출할 수 있다.","categories":[],"tags":[{"name":"infrastructure","slug":"infrastructure","permalink":"https://www.yceffort.kr/tags/infrastructure/"},{"name":"docker","slug":"docker","permalink":"https://www.yceffort.kr/tags/docker/"},{"name":"aws","slug":"aws","permalink":"https://www.yceffort.kr/tags/aws/"},{"name":"ecs","slug":"ecs","permalink":"https://www.yceffort.kr/tags/ecs/"}]},{"title":"Javascript Reduce","slug":"javascript-reduce","date":"2019-07-22T02:36:28.000Z","updated":"2019-07-22T04:03:28.635Z","comments":true,"path":"2019/07/22/javascript-reduce/","link":"","permalink":"https://www.yceffort.kr/2019/07/22/javascript-reduce/","excerpt":"멍청이라 그런지 reduce 함수가 잘 이해 되지 않았다. ¶Reduce 1 2 3 4 5 6 7 8 const list = [1, 2, 3, 4, 5]; const initValue = 10; const totalSum = list.reduce( (accumulator, currentValue, currentIndex, array) => { return accumulator + currentValue; }, initValue ); 1 25 * currentValue: 처리할 현재 요소 * cu","text":"멍청이라 그런지 reduce 함수가 잘 이해 되지 않았다. ¶Reduce 12345678const list = [1, 2, 3, 4, 5];const initValue = 10;const totalSum = list.reduce( (accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue; &#125;, initValue); 125 currentValue: 처리할 현재 요소 currentIndex (optional): 처리할 요소의 인덱스 accumulator: 콜백의 반환값을 계속해서 누적한다. 이 예제에서는 처음엔 1, 그 다음엔 1 + currentValue, 그 다음엔 (1 + currentValue) + currentValue 가 될 것이다. array (optional): reduce를 호출한 배열, 여기서는 list = [1, 2, 3, 4, 5]이 될 것이다. initValue (optional): reduce의 최초 값. 없으면 배열의 0번째 값이 된다. 이 예제에서는 initValue값이 10 이라서, 최종결과는 10 + (1 + 2 ... + 5) 이 될 것이다. call accumulator currentValue currentIndex array return 1st 10 1 0 [1,2,3,4,5] 11 2nd 11 2 1 [1,2,3,4,5] 13 3rd 13 3 2 [1,2,3,4,5] 16 4th 16 4 3 [1,2,3,4,5] 20 5th 20 5 4 [1,2,3,4,5] 25 ¶중첩 배열 펼치기 12345const complicatedList = [[0, 1], [2, 3], [4], [5, 6]];complicatedList.reduce( (accumulator, currentValue) =&gt; accumulator.concat(currentValue), []); 1[0, 1, 2, 3, 4, 5, 6] 이보다 더 괴랄한 array의 경우에도 재귀를 사용하여 가능하다. 123456789101112131415const moreComplicatedList = [[0, 1], [[[2, 3]]], [[4, 5]], 6];const flatten = function(arr, result = []) &#123; for (let i = 0, length = arr.length; i &lt; length; i++) &#123; const value = arr[i]; if (Array.isArray(value)) &#123; flatten(value, result); &#125; else &#123; result.push(value); &#125; &#125; return result;&#125;;flatten(moreComplicatedList); 1[0, 1, 2, 3, 4, 5, 6]","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"Javascript Set 그리고 Map","slug":"javascript-map-weakmap","date":"2019-07-18T02:30:52.000Z","updated":"2019-07-19T01:12:53.277Z","comments":true,"path":"2019/07/18/javascript-map-weakmap/","link":"","permalink":"https://www.yceffort.kr/2019/07/18/javascript-map-weakmap/","excerpt":"¶근데 사실… 컬렉션 필요없지 않을까 자바스크립트에서 일반적인 Object는 key-value쌍을 끊임 없이 추가할 수 있는 형태로 구성되어 있다. 그래서 사실 컬렉션이 필요하지 않은 것 처럼 보일 수도 있다. 그러나 이따금씩 object로 부족할 때가 있다. * key 충돌 위험이 존재하는 경우 * 문자열/심볼 이외의 키 값이 필요한 경우 * 객체에 얼마나 많은 속성이 있는지 알아낼 수 있는 효과적인 방법이 필요한 경우 * 객체가 iterable하지 않음. 따라서 for..of 나 ...를 사용할 수 없음 es6에 추가","text":"¶근데 사실… 컬렉션 필요없지 않을까 자바스크립트에서 일반적인 Object는 key-value쌍을 끊임 없이 추가할 수 있는 형태로 구성되어 있다. 그래서 사실 컬렉션이 필요하지 않은 것 처럼 보일 수도 있다. 그러나 이따금씩 object로 부족할 때가 있다. key 충돌 위험이 존재하는 경우 문자열/심볼 이외의 키 값이 필요한 경우 객체에 얼마나 많은 속성이 있는지 알아낼 수 있는 효과적인 방법이 필요한 경우 객체가 iterable하지 않음. 따라서 for..of 나 ...를 사용할 수 없음 es6에 추가된 컬렉션들은 따라서 멤버 데이터를 드러내기 위해 property를 사용하지 않는다. (obj.key, obj[key] 불가능.) 그리고 이들에는 자유롭게 메소드를 추가할 수 있다. ¶Set Set은 value로 이루어진 컬렉션이다. 그리고 수정가능하다. 배열과 같을 것 같지만, 다르다. 123let faces = new Set(\"😀 😁 😂 🤣 😃 😄 😅\");faces.size; // 8faces.add(\"😂\"); 일단 (당연하게도) Set에는 같은 value가 중복으로 포함될 수 없다. 기존에 있는걸 추가해도 아무런 변화가 없다. Set은 어떤데이터가 자신의 멤버인지 빠르게 확인하기 위한 목적으로 사용한다 그러나 Set은 index로 값을 조회할 수는 없다. ¶set 으로 할 수 있는 것 new Set(): 비어있는 set 생성 set.size: set 데이터 개수 조회 set.has(value): value가 set에 존재하는지 조회 set.add(value) set.delete(value) sets[Symbol.iterator](): set 안의 값을 순회할 수 있는 새로운 이터레이러를 리턴한다. set을 iterable하게 만들어 준다. 12345let faces = new Set(\"😀 😁 😂 🤣 😃 😄 😅\");iteratorFaces = faces[Symbol.iterator]();for (let i of iteratorFaces) &#123; console.log(i);&#125; set.forEach(f) set.clear set.keys() set.values() set.entries() ¶Map Map은 잘 알려진 것처럼, key-value pair로 이루어진 컬렉션이다. ¶Map으로 할 수 있는 것 new Map new Map(pairs) map.has(key) map.size mag.get(key) map.set(key, value) map.delete(key) map.clear() map[Symbol.iterator]() === map.entries() map.forEach(f) map.keys() map.values() ¶javascript 가 다른점 아래의 코드를 보자. 12345678let messi = new Set();const 리오넬메시 = &#123; name: \"리오넬메시\" &#125;;const 라이오넬멧시 = &#123; name: \"리오넬메시\" &#125;;messi.add(리오넬메시);messi.add(라이오넬멧시);console.log(messi.size); //2 ???? 리오넬메시와 라이오넬멧시는 내부의 값이 같아 보이기 때문에, set에 한개의 값만 추가 될 것 같지만 사실은 그렇지 않다. 자바스크립트에서는 두개의 값을 다르게 본다. 이유는 자바스크립트가 값을 비교할 때 두가지 다른 방법을 사용하기 때문이다. string, number같은 primitive는 값을 비교한다 array, date, object 등은 reference를 비교한다. (메모리의 같은 위치를 참조하고 있는가?) 1234567const 리오넬메시 = &#123; name: \"리오넬메시\" &#125;;const 라이오넬멧시 = &#123; name: \"리오넬메시\" &#125;;const 메석대 = 리오넬메시;메석대 === 리오넬메시; // true메석대 == 라이오넬멧시; // false리오넬메시 === 라이오넬멧시; //false 본질적으로 같은 메모리를 참조하는 값 끼리만 true를 반환하는 것을 볼 수 있다. (두 object를 비교하는 방법은 여기를 참조) 다시 Set으로 돌아와서, javascript는 저 두 값을 제대로 비교하지 못하기 때문에 set에 두개의 값이 들어가게 된다. 물론 해시코드를 사용하면 가능하지만, javascipt에는 그런거 없다 또 하나 다른 점이라고 한다면, map과 set에 추가한 순서가 곧 순회하는 순서와 같다는 것이다. 이 역시 다른 언어들과는 다른 점이다. ¶WeakMap, WeakSet WeakMap은 new .has() .get() .set() .delete() 만 지원한다 WeakSet은 new .has() .add() .delete() 만 지원한다. WeakSet과 WeakMap의 key는 반드시 object여야 한다. 그렇다. 열거형이 존재하지 않는다. 그 이유는 참조하고 있는 오브젝트가 사라지면 해당 key, value가 사라지는 WeakMap, WeakSet의 특징 때문이다. 12345let john = &#123; name: \"John\" &#125;;// 객체에 접근 가능, 해당 객체는 메모리에서 참조되고 있음.// 참조를 null로 overwritejohn = null;// 객체는 메모리에서 이제 삭제됨 12345678let john = &#123; name: \"John\" &#125;;let array = [john];john = null; // 참조를 null로 overwrite// john은 객체안에 살아 있기 때문에 가비지 컬렉팅이 되지 않음.// 그래서 array[0]으로 접근 가능array[0];// &#123; name: \"John\" &#125; 이는 기존 Map, Set에서도 동일하다. 123456789let john = &#123; name: \"John\" &#125;;let map = new Map();map.set(john, \"윅\");john = null; // 참조를 null로 overwrite// john은 맵안에서 살아있기 때문에// map.keys() 로 접근 가능 그러나 WeakMap, WeakSet은 다르다 12345678let john = &#123; name: \"John\" &#125;;let weakMap = new WeakMap();weakMap.set(john, \"윅\");john = null; // 참조를 null로 overwrite// john은 메모리에서 사라짐 (가비지 콜렉팅 당함) 그럼 도대체 이것은 언제 쓸까? 객체가 사라지면 자동으로 가비지 콜렉팅 해준다는 특성을 활용해, 아래와 같은 것이 가능하다. 1234567891011let john = &#123; name: \"John\" &#125;;// map: 유저 =&gt; 방문횟수let visitsCountMap = new Map();visitsCountMap.set(john, 123);// john이 사라짐john = null;// 그러나 Map에서는 계속 남아 있으므로, 따로 처리를 해주어야 함.// 또한 john은 map에서 key로 사용하고 있으므로 메모리에서도 존재함.console.log(visitsCountMap.size); // 1 그러나 여기서 WeakMap을 사용하면, 자동으로 가비지 콜렉팅이 되므로 Map에 남아있는 key에 대해서 까지 신경쓰지 않아도 된다.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://www.yceffort.kr/tags/es6/"}]},{"title":"Javascript Symbol","slug":"javascript-symbol","date":"2019-07-18T01:03:36.000Z","updated":"2019-07-19T01:12:49.639Z","comments":true,"path":"2019/07/18/javascript-symbol/","link":"","permalink":"https://www.yceffort.kr/2019/07/18/javascript-symbol/","excerpt":"¶Javascript Primitive 기존에 자바스크립트는 6가지의 primitive가 있었다. * Object * string * number * boolean * null * undefined 그러나 es6가 들어서면서 symbol이라는 7번째 primitive가 추가되었다. ¶Symbol 1 2 const helloSymbol = Symbol(); const hiSymbol = Symbol(); 새로운 심볼 값을 생성했다. 이 심볼로 생성한 값은 변경할 수 없으므로 const에 할당에도 상관없다. 그리","text":"¶Javascript Primitive 기존에 자바스크립트는 6가지의 primitive가 있었다. Object string number boolean null undefined 그러나 es6가 들어서면서 symbol이라는 7번째 primitive가 추가되었다. ¶Symbol 12const helloSymbol = Symbol();const hiSymbol = Symbol(); 새로운 심볼 값을 생성했다. 이 심볼로 생성한 값은 변경할 수 없으므로 const에 할당에도 상관없다. 그리고 이렇게 생성된 심볼 값은 프로그램 내에서 유일함을 보장해 준다. 1234let obj = &#123;&#125;;obj[helloSymbol] = \"hello\";obj[hiSymbol] = \"hi\";console.log(obj); 1&#123;Symbol(): &quot;hello&quot;, Symbol(): &quot;hi&quot;&#125; 물론 문자열이나 숫자를 key로 사용할 수 있지만, symbol은 유일함을 보장해주기 때문에 이렇게 키값으로 사용할 수 있다. 12const welcomeSymbol = Symbol(\"환영합니다\");console.log(welcomeSymbol); 1Symbol(환영합니다) Symbol안에 있는 문자열은 일종의 주석으로 보면 될 것 같다. ¶예제 1234567const isBlocked = Symbol(\"is blocked element?\");if (element[isBlocked]) &#123; openElement(element);&#125; else &#123; element[isBlocked] = true;&#125; element는 isBlocked라는 심볼을 키로 갖는 object다. 문자열이나 숫자가 아닌 심볼을 key로 갖는 속성이다. 이는 유일성을 보장해주기 때문에 다른 키들과의 충돌을 방지할 수 있다. 다만 obj.name과 같이 dot을 이용해서 접근할 수 없다. 반드시 []를 활용해서 접근해야 한다. 한가지 주의 해야할 것은 isBlocked 심볼 값이 스코프 내에 존재 할 때만 이러한 행위가 가능하다는 것이다. 어떤 모듈이 심볼을 스스로 만드는 경우, 해당 모듈은 해당 심볼을 모든 객체에 적용할 수 있다. 즉 다른 속성과의 충돌을 걱정할 필요가 없다. 그리고 심볼 키는 이러한 충돌을 방지하기 위해서 만들어 진 것이므로, 일반적인 javascript 객체 조사는 Symbol을 무시한다. 무슨 소리냐면… 1234567891011121314151617let 메시 = &#123;&#125;;메시[\"영문명\"] = \"Lionel Messi\";메시[\"별명\"] = \"라이오넬 멧시\";const Nationality = Symbol(\"선수의 국적\");메시[Nationality] = \"칠레\";for (let i in 메시) &#123; console.log(i);&#125;for (let i of Object.keys(메시)) &#123; console.log(i);&#125;for (let i of Object.getOwnPropertyNames(메시)) &#123; console.log(i);&#125; 123456&quot;영문명&quot;&quot;별명&quot;&quot;영문명&quot;&quot;별명&quot;&quot;영문명&quot;&quot;별명&quot; 이처럼 심볼 Nationality 키는 일반적인 상황에서 모두 무시 되는 것을 볼 수 있다. 물론 이를 조회하는 방법도 있다. 1Object.getOwnPropertySymbols(메시); 1[Symbol(선수의 국적)] 혹은 심볼을 포함해서 모든 키를 조회하고 싶다면 1Reflect.ownKeys(메시); 1[&quot;영문명&quot;, &quot;별명&quot;, Symbol(선수의 국적)] Reflect.ownKeys를 활용하면 된다. ¶심볼의 특징 일단 생성되면 변경되지 않는다 속성을 부여할 수 없다 object의 key 값으로 사용할 수 있다. 모든 심볼은 고유하다. 주석이 동일하다 하더라도 일단 생성되면 다르게 구별된다. 문자열로 자동으로 변환되지 않는다. 12345const newSymbol = Symbol( \"this symbol\")`symbol is $&#123;newSymbol&#125;`//Uncaught TypeError: Cannot convert a Symbol value to a string`symbol is $&#123;String(newSymbol)&#125; $&#123;newSymbol.toString()&#125;`;// symbol is Symbol(this symbol) Symbol(this symbol) ¶심볼을 갖는 방법 Symbol()을 호출한다. 이는 호출할 때 마다 새롭고 고유한 심볼을 만들어 준다. Symbol.for(string)을 호출한다. 이 메소드는 Symbol Registry라는 심볼목록을 참조하여 리턴하는데, 앞서와는 다르게 심볼 목록을 공유한다. Symbol.for('호날도')를 계속해서 호출한다면, 매번 같은 심볼을 리턴한다. 이는 심볼이 공유 되어야 하는 상황에서 유용하다. Symbol.length 처럼 표준에 정의된 심볼을 가져오는 법","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://www.yceffort.kr/tags/es6/"}]},{"title":"javascript event bubbling & capturing","slug":"javascript-event-bubbling-capturing","date":"2019-07-17T01:22:22.000Z","updated":"2019-07-17T01:55:37.340Z","comments":true,"path":"2019/07/17/javascript-event-bubbling-capturing/","link":"","permalink":"https://www.yceffort.kr/2019/07/17/javascript-event-bubbling-capturing/","excerpt":"¶Javascript Event Capturing See the Pen Event Capturing by yceffort (@yceffort) on CodePen. Event Capturing은 특정 요소에서 이벤트가 발생했을 때, 최상위 요소에서 부터 이벤트를 탐색하여 특정요소까지 찾아오는 이벤트 전파 방식을 의미한다. 위 예시에서 가장 내부의 element를 클릭했을 때, 최상위 요소 부터 해당 click이벤트를 전파시켜 이벤트가 실행되는 것을 볼 수 있다. ¶Javascript Event Bubbling See the","text":"¶Javascript Event Capturing See the Pen Event Capturing by yceffort (@yceffort) on CodePen. Event Capturing은 특정 요소에서 이벤트가 발생했을 때, 최상위 요소에서 부터 이벤트를 탐색하여 특정요소까지 찾아오는 이벤트 전파 방식을 의미한다. 위 예시에서 가장 내부의 element를 클릭했을 때, 최상위 요소 부터 해당 click이벤트를 전파시켜 이벤트가 실행되는 것을 볼 수 있다. ¶Javascript Event Bubbling See the Pen Event Bubbling by yceffort (@yceffort) on CodePen. 반대로 Event Bubbling은 특정요소에서 이벤트가 발생했을 때, 해당 요소에서 부터 이벤트를 전파시키는 것을 의미한다. 위 예시에서 가장 내부의 three를 클릭했을때, three, two, one으로 이벤트가 전파되는 것을 볼 수 있다. ¶stopPropagation stopPropagation는 이벤트의 전파 (Event Bubbling 및 Capturing)을 막는 것을 의미한다. 즉, 현재까지의 이벤트만 실행하고 이후의 이벤트를 막게된다. ¶preventDefault preventDefault는 해당 DOM에서 내가 원하는 이벤트만 실행하고, 기본적인 (취소할 수 있는) 이벤트를 취소하는 것을 의미한다. See the Pen preventDefault by yceffort (@yceffort) on CodePen. 해다아 예쩨에서는 preventDefault를 이용해서 a tag의 기본 이벤트인 href를 막는 것을 볼 수 있다.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"javascript class","slug":"javascript-class","date":"2019-07-09T07:01:24.000Z","updated":"2019-08-06T23:39:02.917Z","comments":true,"path":"2019/07/09/javascript-class/","link":"","permalink":"https://www.yceffort.kr/2019/07/09/javascript-class/","excerpt":"Class 클래스는 기본적으로 이렇게 생겼다. 1 2 3 4 5 6 7 8 class Member { getName() { return \"이름\"; } } let obj = new Member(); console.log(obj.getName()); ¶특징 ¶1. strict 모드에서 실행 딱히 'use strict';를 선언하지 않아도, 클래스의 코드는 기본적으로 strict모드에서 실행된다. 그렇게 되면, 당연히 strict모드의 여러가지 특징을 자동으로 따르게 된다. ¶2. 클래스 내 메서드 작성 1 2","text":"Class 클래스는 기본적으로 이렇게 생겼다. 12345678class Member &#123; getName() &#123; return \"이름\"; &#125;&#125;let obj = new Member();console.log(obj.getName()); ¶특징 ¶1. strict 모드에서 실행 딱히 'use strict';를 선언하지 않아도, 클래스의 코드는 기본적으로 strict모드에서 실행된다. 그렇게 되면, 당연히 strict모드의 여러가지 특징을 자동으로 따르게 된다. ¶2. 클래스 내 메서드 작성 123456789class Member &#123; setName(name) &#123; this.name = name; &#125; getName(name) &#123; this.name = name; &#125;&#125; 보이는 것처럼, function키워드와 :가 없이 메서드 이름만 사용한다. 그리고 메서드 사이에 ;가 불필요하다. 다만 function 을 선언하면 글로벌 오브젝트에 설정되는 것과 다르게, class는 그렇지 않다. 그리고 class의 object property는 for()문 등으로 열거할 수 없다. ¶3. 프로퍼티에 연결 12345class Member &#123; setName(name) &#123; this.name = name; &#125;&#125; 위 코드와 123Member.prototype.setName = function(namn) &#123; this.name = name;&#125;; 위 코드는 같다. ¶Constructor constructor는 클래스 인스턴스를 생성하고, 생성한 인스턴스를 초기화하는 역할을 한다. new Member()를 실행하면, Member.prototype.constructor가 먼저 호출된다. 클래스에 이를 작성하지 않으면, prototype의 디폴트 constructor가 호출된다. 그리고 이 constructor가 없으면 인스턴스를 생성할 수 없다. 기존 es5문법에서는 자바스크립트 엔진이 디폴트 constructor를 호출해서 이를 활용할 수 없었지만, es6에서 부터는 개발자가 이를 정의할 수 있게 되었다. 123456789101112class Member &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;let newMember = new Member(\"라이오넬 멧시\");console.log(newMember.getName()); 만약 constructor에서 이상한 값을 반환하면 어떻게 될까? 123constructor() &#123; return 1;&#125; constructor에서 number나 string을 반환하면, 이를 무시하고 생성한 인스턴스를 반환하게 된다. 그러나 object를 반환하면 어떻게 될까? 12345678910111213class Member &#123; constructor(name) &#123; return &#123; name: \"메켓트\" &#125;; &#125; getName() &#123; return this.name; &#125;&#125;let newMember = new Member(\"라이오넬 멧시\");console.log(newMember.name);console.log(newMember.getName); 12메켓트undefined name이 메켓트인 object를 반환하면서, newMember 클래스에는 name밖에 남지 않게 되었다. 그리고 getName은 존재하지 않아서 undefined가 출력된다. ¶getter, setter 123456789class Member &#123; set setName(name) &#123; this.name = name &#125; get getName(name) &#123; return this.name &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://www.yceffort.kr/tags/es6/"}]},{"title":"javascript 일반 함수와 화살표 함수의 차이","slug":"difference-between-function-and-arrow","date":"2019-07-09T00:39:42.000Z","updated":"2019-08-14T02:05:21.889Z","comments":true,"path":"2019/07/09/difference-between-function-and-arrow/","link":"","permalink":"https://www.yceffort.kr/2019/07/09/difference-between-function-and-arrow/","excerpt":"ES6에서부터 생긴 arrow function은 일반적으로 ()=>{}의 모양을 하고 있으며, 동작도 비슷해보인다. 하지만 이 두 선언방식은 두가지 분명한 차이를 가지고 있다. ¶1. this와 arguments의 차이 화살표 함수는 this와 arguments를 바인딩하지 않는다. 그 대신, 일반적인 this와 arguments와 동일한 범위를 가지고 있다. 1 2 3 4 5 6 7 8 9 10 11 function createObject() { console.log('Inside `createObject`:', thi","text":"ES6에서부터 생긴 arrow function은 일반적으로 ()=&gt;{}의 모양을 하고 있으며, 동작도 비슷해보인다. 하지만 이 두 선언방식은 두가지 분명한 차이를 가지고 있다. ¶1. this와 arguments의 차이 화살표 함수는 this와 arguments를 바인딩하지 않는다. 그 대신, 일반적인 this와 arguments와 동일한 범위를 가지고 있다. 1234567891011function createObject() &#123; console.log('Inside `createObject`:', this.foo); return &#123; foo: 42, bar: function() &#123; console.log('Inside `bar`:', this.foo); &#125;, &#125;;&#125;createObject.call(&#123;foo: 21&#125;).bar(); 위 함수의 결과는 12Inside `createObject`: 21Inside `bar`: 42 가 된다. 그러나 화살표 함수에서는 약간 다르다. 123456789function createObject() &#123; console.log('Inside `createObject`:', this.foo); return &#123; foo: 42, bar: () =&gt; console.log('Inside `bar`:', this.foo), &#125;;&#125;createObject.call(&#123;foo: 21&#125;).bar(); 결과는 12Inside `createObject`: 21Inside `bar`: 21 즉, 화살표 함수안에서의 this는 createObject안의 this를 따르게 된다. 이는 화살표 함수가 현재 환경의 this를 따르게 하고 싶을 때 유용하다는 뜻이다. 이 말인 즉슨, 화살표함수에서는 bind와 call을 사용할 수 없다는 뜻이기도 하다. ¶2. 화살표 함수는 new로 호출할수 없다. es2015에서는 callable한 것과 constructable한 것과의 차이를 두고 있다. 어떤 함수가 constructable하다면, 이는 new로 호출되어야 한다. ex) new User() 그리고 만약 함수가 callable하다면, 이 함수는 new없이도 호출이 되어야 한다 .ex) 일반적인 함수 호출 일반적인 함수의 경우 callable하며 constructable하다. 그러나 화살표 함수는 오로지 callable할 뿐이다. 반대로 class의 경우에는 오로지 constructable할 뿐이다. ¶정리 서로 바꿔서 쓸 수 있는 경우 this, arguments를 쓰지 않는 경우 bind(this)를 사용하는 경우 서로 바꿔쓸 수 없는 경우 constructable 함수 prototype에 추가된 함수나 메소드 arguments를 함수의 인자로 사용하는 경우","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"Intersection Observer","slug":"intersection-observer","date":"2019-06-24T00:01:35.000Z","updated":"2019-08-14T02:05:21.896Z","comments":true,"path":"2019/06/24/intersection-observer/","link":"","permalink":"https://www.yceffort.kr/2019/06/24/intersection-observer/","excerpt":"¶Intersection Observer Intersection Observer는 엘리먼트가 viewport에 노출되고 있는지 여부를 확인해주는 API다. 간단히 말해 브라우저의 어떤 요소가 화면에 노출되고 있는지 안되고 있는지를 확인해주는 라이브러리라고 생각하면 될 것 같다. 이 라이브러리가 없이 엘리먼트가 노출중인지 확인하려면 어떻게 해야할까? 이전까지 주로 사용되던 API는 getBoundingClientRect다. 이 메서드는 해당 엘리먼트의 크기와 viewport에서의 상대적인 위치를 알려준다. 1 2 3 4 5 6 7","text":"¶Intersection Observer Intersection Observer는 엘리먼트가 viewport에 노출되고 있는지 여부를 확인해주는 API다. 간단히 말해 브라우저의 어떤 요소가 화면에 노출되고 있는지 안되고 있는지를 확인해주는 라이브러리라고 생각하면 될 것 같다. 이 라이브러리가 없이 엘리먼트가 노출중인지 확인하려면 어떻게 해야할까? 이전까지 주로 사용되던 API는 getBoundingClientRect다. 이 메서드는 해당 엘리먼트의 크기와 viewport에서의 상대적인 위치를 알려준다. 123456789101112131415161718function isInViewport(element) &#123; // viewport의 height, width const viewportHeight = document.documentElement.clientHeight; const viewportWidth = document.documentElement.clientWidth; // 엘리먼트의 rect const rect = element.getBoundingClientRect(); if (!rect.width || !rect.height) &#123; return false; &#125; var top = rect.top &gt;= 0 &amp;&amp; rect.top &lt; viewportHeight; var bottom = rect.bottom &gt;= 0 &amp;&amp; rect.bottom &lt; viewportHeight; var left = rect.left &gt;= 0 &amp;&amp; rect.left &lt; viewportWidth; var right = rect.right &gt;= 0 &amp;&amp; rect.right &lt; viewportWidth; return (top || bottom) &amp;&amp; (left || right);&#125; 물론 이 함수로도 충분히 확인이 가능하다. 그러나 문제는 이 함수를 시도 때도 없이 불러야 할것이다. 문서가 처음로딩 되었을때, 스크롤 이벤트가 발생했을때, 브라우저 크키가 변경되었을때, (모바일의 경우) 화면이 회전 됐을 때 등 고려해야할 사황이 너무나도 많다. 그리고 결정적으로 getBoudingClientRect()는 호출이 될 때 마다 레이아웃을 다시 그리기 때문에 성능에 매우 부담이 간다. 참고 ¶사용법 1234567var options = &#123; root: document.querySelector(\"#scrollArea\"), rootMargin: \"0px\", threshold: 1.0&#125;;var observer = new IntersectionObserver(callback, options); root: 엘리먼트 노출을 감시할 viewport 영역이다. null이 기본값이고, null이라면 브라우저 전체를 감시하게 된다. rootMargin: css의 margin property와 사용법이 같다. root에 margin 값을 주는 것이다. threshold: number, 또는 array of number가 가능하다. 여기서 숫자는 viewport의 n%가 되었을 때 이벤트를 호출할 것인지 결정하는 것이다. array라면 해당 숫자만큼 노출될때 마다 이벤트가 발생하게 된다. 기본값은 0 으로, 단 1픽셀이라도 노출될 경우 이벤트가 발생된다. callback: 타겟이 노출될때 실행되는 콜백함수다. 여기서는 두개의 값을 반환한다. entries: IntersectionObserverEntry의 array이며, 각각 얼마나 노출되었는지 값이 나온다. observer: callback을 호출한 IntersectionObserver 12var target = document.querySelector(\"#listItem\");observer.observe(target); See the Pen basic intersect example by yceffort (@yceffort) on CodePen. 콘솔창을 보면, 50% 이상 나온 엘리먼트가 찍히는 것을 볼 수 있다. ¶활용해보기 ¶무한스크롤 See the Pen Infinite Scroll by Intersection Observer by yceffort (@yceffort) on CodePen. 문서의 맨 마지막에 height가 10px인 #watch_end_of_document를 넣어서, 이 엘리먼트가 브라우저에 노출되게 되면 스크롤의 마지막에 온것으로 간주하고 그 때마다 새로운 아이템들을 로딩하도록 명령을 내렸다. ¶이미지 레이지 로딩 See the Pen YoVvya by yceffort (@yceffort) on CodePen. 콘솔 - 네트워크 창으로 가보면 이미지가 동적으로 로딩되는 것을 알 수 있다. 각각의 엘리먼트들에 observer를 걸어두고, viewport에 걸칠때 마다 backgroundImage를 줘서 이미지가 로딩되도록 하였다.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"Typescript, React, NextJs, Koa, Styled Component 로 프론트엔드 환경 만들기","slug":"react-nextjs-koa","date":"2019-06-20T10:07:40.000Z","updated":"2019-08-14T02:05:21.896Z","comments":true,"path":"2019/06/20/react-nextjs-koa/","link":"","permalink":"https://www.yceffort.kr/2019/06/20/react-nextjs-koa/","excerpt":"¶사용한 오픈소스 ¶React 자세한 설명은 생략 한다 ¶Nextjs NextJs 리액트에서 서버사이드 렌더링을 할 수 있도록 해주는 프레임워크다. angular나 react 등은 SPA라서 불편한 점이 더러 있는데, React에서 NextJS를 활용하면 react를 ssr(server side rendering)이 되도록 바꿔줄 수 있다. 그리고 자동으로 code splitting이 되고, 파일 시스템을 기준으로 라우팅이 되며, … 뭐 이런저런 장점이 있다. ¶koa express를 만든 개발자들이 따로 떨어져 나와서 만든 w","text":"¶사용한 오픈소스 ¶React 자세한 설명은 생략 한다 ¶Nextjs NextJs 리액트에서 서버사이드 렌더링을 할 수 있도록 해주는 프레임워크다. angular나 react 등은 SPA라서 불편한 점이 더러 있는데, React에서 NextJS를 활용하면 react를 ssr(server side rendering)이 되도록 바꿔줄 수 있다. 그리고 자동으로 code splitting이 되고, 파일 시스템을 기준으로 라우팅이 되며, … 뭐 이런저런 장점이 있다. ¶koa express를 만든 개발자들이 따로 떨어져 나와서 만든 web framework가 바로 koa다. express와 비교했을 때는 koa가 비교적 가볍고, node.js v7의 async/await 를 자유자재로 쓸 수 있다는 데 있다. 그리고 es6를 도입해서 generator도 사용할 수 있다. IBM이 express를 인수해버린 관계로, 많은 개발자들이? koa로 넘어가는 추세라고 하는데, 아직은 잘 모르겠다. ¶Styled Component Styled Component ¶시작 ¶package.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; \"name\": \"hello-world\", \"version\": \"0.0.1\", \"description\": \"hello-world\", \"main\": \"main.js\", \"scripts\": &#123; \"build\": \"tsc --outDir dist server/index.ts &amp;&amp; next build\", \"start\": \"NODE_ENV=production node dist\", \"dev\": \"concurrently 'tsc -w --outDir dist server/index.ts' 'npm run watch-server -- --delay 2'\", \"watch-server\": \"nodemon --exec 'node dist' --watch dist -e '*'\" &#125;, \"author\": \"\", \"license\": \"UNLICENSED\", \"dependencies\": &#123; \"@zeit/next-typescript\": \"^1.1.1\", \"@zeit/next-css\": \"^1.0.1\", \"@zeit/next-stylus\": \"^1.0.1\", \"formik\": \"^1.5.7\", \"isomorphic-fetch\": \"^2.2.1\", \"koa\": \"^2.7.0\", \"koa-body\": \"^4.1.0\", \"koa-bodyparser\": \"^4.2.1\", \"koa-morgan\": \"^1.0.1\", \"koa-mount\": \"^4.0.0\", \"koa-proxies\": \"^0.8.1\", \"koa-router\": \"^7.4.0\", \"next\": \"^8.1.0\", \"react\": \"^16.8.6\", \"react-dom\": \"^16.8.6\", \"styled-components\": \"^3.4.10\" &#125;, \"devDependencies\": &#123; \"@types/isomorphic-fetch\": \"0.0.35\", \"@types/koa\": \"^2.0.48\", \"@types/koa-bodyparser\": \"^4.3.0\", \"@types/koa-morgan\": \"^1.0.4\", \"@types/koa-mount\": \"^3.0.1\", \"@types/koa-router\": \"^7.0.40\", \"@types/next\": \"^8.0.5\", \"@types/node\": \"^12.0.4\", \"@types/react\": \"^16.8.22\", \"babel-eslint\": \"^10.0.1\", \"babel-plugin-styled-components\": \"^1.10.0\", \"concurrently\": \"^4.1.0\", \"nodemon\": \"^1.19.1\", \"npm\": \"^6.9.0\", \"typescript\": \"^3.5.1\" &#125;&#125; ¶./typings/koa-proxies/index.d.ts 애석하게도 koa-proxies의 typing이 존재하지 않는다. ./typings/koa-proxies에 아래와 같이 추가하자. 123456declare module \"koa-proxies\" &#123; import &#123; Middleware &#125; from \"koa\"; namespace koaProxies &#123;&#125; function koaProxies(name: string, options?: any): Middleware; export = koaProxies;&#125; 타입스크립트로 nextjs를 사용하기 위하여 @zeit/next-typescript를 사용하였다. ¶./next.config.js 별도의 설정은 넣지 않았다. 1234567891011121314151617const withCSS = require(\"@zeit/next-css\");const withStylus = require(\"@zeit/next-stylus\");const withTypescript = require(\"@zeit/next-typescript\");module.exports = withTypescript( withStylus( withCSS(&#123; webpack: config =&gt; (&#123; ...config, plugins: [...(config.plugins || [])], node: &#123; fs: \"empty\" &#125; &#125;) &#125;) )); ¶./.babelrc 123&#123; \"presets\": [\"next/babel\", \"@zeit/next-typescript/babel\"]&#125; ¶./pages/index.tsx nextjs의 유일한 제약은 pages 폴더다. pages에 렌더링 할 페이지를 만들어 둬야 한다. 12345678910111213import * as React from \"react\";import styled from \"styled-components\";const MainHeading = styled.div` font-size: 50px; color: red;`;export default class IndexPage extends React.PureComponent &#123; render() &#123; return &lt;MainHeading&gt;hello?&lt;/MainHeading&gt;; &#125;&#125; ¶./server/index.ts 가장 중요한 서버 부분이다. koa를 사용한 이유는 */api/*로 요청이 오는 호출에 대해서는 외부에 있을지도 모르는 api서버를 활용하기 위함이다. 이를 별도로 처리 하지 않는다면 CORS이슈가 있을수 있기 때문이다. 그래서 koa를 통해서 nextjs를 호출하는 방식으로 바꾸었다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import * as next from \"next\";import * as Koa from \"koa\";import * as morgan from \"koa-morgan\";import * as Router from \"koa-router\";import * as proxy from \"koa-proxies\";import * as bodyparser from \"koa-bodyparser\";import * as mount from \"koa-mount\";const isDev = process.env.NODE_ENV !== \"production\";function renderNext(nextApp: next.Server, route: string) &#123; return (ctx: Koa.Context) =&gt; &#123; ctx.res.statusCode = 200; ctx.respond = false; nextApp.render(ctx.req, ctx.res, route, &#123; ...((ctx.request &amp;&amp; ctx.request.body) || &#123;&#125;), ...ctx.params, ...ctx.query &#125;); &#125;;&#125;async function main() &#123; const nextApp = next(&#123; isDev &#125;); const app = new Koa(); const router = new Router(); await nextApp.prepare(); const handle = nextApp.getRequestHandler(); router.get(\"/\", renderNext(nextApp, \"/index\")); app .use(morgan(\"combined\")) .use(bodyparser()) .use( proxy(\"/api\", &#123; target: \"https://jayg-api-request.test.com\", rewrite: (path: string) =&gt; path.replace(/^\\/api/, \"\"), changeOrigin: true &#125;) ) .use( mount(\"/health\", (ctx: Koa.Context) =&gt; &#123; handle(ctx.req, ctx.res); ctx.status = 200; &#125;) ) .use(router.routes()) .use( mount(\"/\", (ctx: Koa.Context) =&gt; &#123; handle(ctx.req, ctx.res); ctx.respond = false; &#125;) ) .listen(3000);&#125;main();","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://www.yceffort.kr/tags/typescript/"}]},{"title":"Typescript Type, Enum, Partial, Record로 글로벌 변수 관리하기","slug":"typescript-type-enum-partial-record","date":"2019-06-17T07:20:52.000Z","updated":"2019-08-14T02:05:21.896Z","comments":true,"path":"2019/06/17/typescript-type-enum-partial-record/","link":"","permalink":"https://www.yceffort.kr/2019/06/17/typescript-type-enum-partial-record/","excerpt":"¶고민지점 * Global 로 관리하는 Colorset Red, Blue, Green, Black이 있다. * 이 색들은 각각 지정된 칼라코드가 있다 * 그러나 때로는 그 컬러코드에 맞게 안쓰는 경우도 있다 * 그러나 때로는 저 네개를 다 안쓰고 1~3개만 쓰는 경우가 있다. ¶Union types Union Type 어떤 라이브러리에서 받는 파라미터의 값을 number와 string으로 제한한다고 하자. 그렇다면 코드는 아래와 같을 것이다. 1 2 3 4 5 6 7 8 9 10 function numberOrStr","text":"¶고민지점 Global 로 관리하는 Colorset Red, Blue, Green, Black이 있다. 이 색들은 각각 지정된 칼라코드가 있다 그러나 때로는 그 컬러코드에 맞게 안쓰는 경우도 있다 그러나 때로는 저 네개를 다 안쓰고 1~3개만 쓰는 경우가 있다. ¶Union types Union Type 어떤 라이브러리에서 받는 파라미터의 값을 number와 string으로 제한한다고 하자. 그렇다면 코드는 아래와 같을 것이다. 12345678910function numberOrString(parameter: any) &#123; if (typeof parameter === \"number\") &#123; return console.log(\"this is number\") &#125; if (typeof parameter === \"string\") &#123; return console.log(\"this is string\") &#125; throw new Error(`Expecting number of string, but got $&#123;typeof parameter&#125;`)&#125; 물론 이런식으로 처리할수도 있다. 그러나 문제는 컴파일 상에서만 괜찮다는 것이다. any는 typescript에서 어떤 값이든 들어갈 수 있으므로, 이 에러는 런타임상에서만 발생하게 된다. 일반적인 객체지향 코드에서는, 두 타입으로 하나 hierarchy 를 만들어서 처리할 수도 있지만, 약간 그건 과한 느낌이 있기도 하다. 이 코드를 이렇게 처리할 수도 있다. 123function numberOrString(parameter: string|number) &#123; // do something...&#125; 이런 방식을 Union Type 이라고 한다. Union Type는 하나의 값에 여러가지 타입을 표현할 수 있게 해준다. 사용할 값을 |로 구별해서 넣어주면 된다. 처음 문제로 돌아와서, Global한 컬러로 지정하려는 값이 네개 있다고 헀다. 이제 이것은 이렇게 처리하면 된다. 1export type GlobalColors = 'Red' | 'Blue' | 'Green' | 'Black' 자 그럼 이것이 어떻게 동작하는지 보자. 123function getColor(parameter: GlobalColors) &#123; console.log(parameter)&#125; getColor()에 GlobalColors가 아닌 다른 값을 넣으면 vscode에서 (물론 plugin덕분이지만) 네개의 값만 강제하는 것을 볼 수 있다. 만약 다른 값을 넣는다면 컴파일상에서 에러가 난다. 한 가지 신기 (당연) 한점은, 이 코드는 자바스크립트로 컴파일 되지 않는다는 것이다. 이점은 enum이랑 다른데, 암튼 지간에 저건 자바스크립트에서 처리할 수 없는 일이다. 이러한 타입체크는 나중에 컴파일 하게 된다면, *.d.ts에서 처리해준다는 것이다. ¶enum enum은 열거형이다. 그렇다. 123456enum GlobalColorSet &#123; Red, Blue, Green, Black&#125; 를 컴파일하면 1234567var GlobalColorSet;(function (GlobalColorSet) &#123; GlobalColorSet[GlobalColorSet[\"Red\"] = 0] = \"Red\"; GlobalColorSet[GlobalColorSet[\"Blue\"] = 1] = \"Blue\"; GlobalColorSet[GlobalColorSet[\"Green\"] = 2] = \"Green\"; GlobalColorSet[GlobalColorSet[\"Black\"] = 3] = \"Black\";&#125;)(GlobalColorSet || (GlobalColorSet = &#123;&#125;)); 로 나온다. 복잡한데, 결과적으로는 아래와 같다. 1var GlobalColorSet = &#123;0: \"Red\", 1: \"Blue\", 2: \"Green\", 3: \"Black\", Red: 0, Blue: 1, Green: 2, Black: 3&#125; 일반적인 map과 다르게 key로 값을 얻을 수 있고, 값으로도 key를 얻을 수 있다. 그러나 enum은 const로 선언될 경우 컴파일 결과가 조금다르다. 123456const enum ConstGlobalColorSet &#123; Red, Blue, Green, Black&#125; 다른게 아니고, 사실 아무것도 컴파일 되지 않는다. 이는 읽기 전용으로 생성된 객체이기 때문에 (const) 수정할 객체 자체가 생성되지 않는 것이다. 또한 앞서 보았던 값으로 키를 얻는 행위 또한 불가능해진다. 아무튼, 글로벌하게 쓸 색상을 enum으로 선언했다. 123456const enum ConstGlobalColorSet &#123; Red = '11, 11, 11', Blue = '22, 22, 22', Green = '33, 33, 33', Black = '44, 44, 44',&#125; ¶Record Record&lt;K, V&gt;로 쓰인다. 여기서 K는 key이고, V는 Value다. keyof Record&lt;K, T&gt;는 k로, Record&lt;K, T&gt;[K]는 T다. (느낌이 그렇다는 것) 밑에 예시를 보자. 이거는 1234//이거는type ColorProperties = Record&lt;GlobalColors, string&gt;//이거와 같다type ColorProperties = &#123; red: string, blue: string, green: string, black: string &#125; (말보다 코드가 쉽다) 위에 경우와 마찬가지로, js로 컴파일 됐을 때는 위 두 코드는 아무런 js로 변환되지 않는다. 12colorProp1['purple'] = 1;colorProp1['orange'] 위의 코드는 당연히 타입스크립트 컴파일에서 에러가 난다. ¶Partial Partial은 key를 옵셔널하게 해준다. 1234// 이거는let PartialColorProperties = Partial&lt;ColorProperties&gt;// 이거와 같다.let PartialColorProperties = &#123; red?: string, blue?: string, green?: string, black?: string &#125; ¶정리 123456789101112131415// 글로벌 색으로 4가지를 선언한다.export type GlobalColors = 'Red' | 'Blue' | 'Green' | 'Black'// 기본값으로 색상을 선언한다.const enum ConstGlobalColorSet &#123; Red = '11, 11, 11', Blue = '22, 22, 22', Green = '33, 33, 33', Black = '44, 44, 44',&#125;// 기본 색상값외에 다른 색상을 사용하고 싶다면 const CUSTOM_COLORS: Partial&lt;Record&lt;GlobalColors, string&gt;&gt; = &#123; gray: '55, 55, 55',&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://www.yceffort.kr/tags/typescript/"}]},{"title":"Javascript - Promise","slug":"javascript-promise","date":"2019-05-21T05:42:41.000Z","updated":"2019-05-21T05:59:50.687Z","comments":true,"path":"2019/05/21/javascript-promise/","link":"","permalink":"https://www.yceffort.kr/2019/05/21/javascript-promise/","excerpt":"¶Promise 1 new Promise(executor) executor는 resolve및 reject 인수를 전달할 실행함수를 의미한다. 실행함수는 resolve와 reject를 받아 즉시 실행된다. 실행함수는 보통 비동기 작업을 시작한 후, 모든 작업을 끝내면 resolve를 호출해서 Promise를 이행하고, 오류가 발생한 경우 reject를 호출해 거부된다. Promise는 다음 중 하나의 상태를 가진다. * 대기(pending): 이행되거나 거부되지 않는 초기 상태 * 이행(fullfiled): 연산이 성공","text":"¶Promise 1new Promise(executor) executor는 resolve및 reject 인수를 전달할 실행함수를 의미한다. 실행함수는 resolve와 reject를 받아 즉시 실행된다. 실행함수는 보통 비동기 작업을 시작한 후, 모든 작업을 끝내면 resolve를 호출해서 Promise를 이행하고, 오류가 발생한 경우 reject를 호출해 거부된다. Promise는 다음 중 하나의 상태를 가진다. 대기(pending): 이행되거나 거부되지 않는 초기 상태 이행(fullfiled): 연산이 성공적으로 완료됨 거부(rejected): 연산이 실패 ¶Promise.all(iterable) iterable내에 모든 프로미스를 이행하는데, 대신 어떤 프로미스가 거부를 하게 되면 즉시 거부하는 프로미스를 반환한다. 모든 프로미스가 이행되는 경우, 프로미스가 결정한 값을 순서대로 배열로 반환한다. ¶Promise.race(iterable) iterable내에 가장 빠르게 이행/거부 한 값을 반환한다. ¶Promise.reject() 주어진 이유로 거부하는 Promise 객체를 반환한다 ¶Promise.resolve() 주어진 값으로 이행하는 Promise를 반환한다. then이 있는 경우, 반환된 프로미스는 then을 따라가고 마지막 상태를 취한다. 123456789function myAsyncFunction(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.onload = () =&gt; resolve(xhr.responseText); xhr.onerror = () =&gt; reject(xhr.statusText); xhr.send(); &#125;);&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"Javascript - Destructuring Assignment","slug":"javascript-destrucuring-assignment","date":"2019-05-21T01:18:46.000Z","updated":"2019-05-21T02:17:56.035Z","comments":true,"path":"2019/05/21/javascript-destrucuring-assignment/","link":"","permalink":"https://www.yceffort.kr/2019/05/21/javascript-destrucuring-assignment/","excerpt":"¶구조 분해 할당 구조 분해 할당은 배열이나 객체의 속성을 말그대로 분해하여, 분해 한 값을 개별변수에 담을 수 있게 도와주는 표현식이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 let a, b, rest; [a, b] = [10, 20]; console.log(a); // 10 console.log(b); // 20 // rest 패턴을 이용하여 나머지를 모두 할당 받을","text":"¶구조 분해 할당 구조 분해 할당은 배열이나 객체의 속성을 말그대로 분해하여, 분해 한 값을 개별변수에 담을 수 있게 도와주는 표현식이다. 123456789101112131415161718192021222324252627282930313233343536373839let a, b, rest;[a, b] = [10, 20];console.log(a); // 10console.log(b); // 20// rest 패턴을 이용하여 나머지를 모두 할당 받을 수 있다.[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50]// 객체 리터럴 식에서 구조 분해 할당을 하기 위해서는, 객체 리터럴 형식과 마찬가지로 &#123; &#125;로 표기하면 된다.(&#123; a, b &#125; = &#123; a: 10, b: 20 &#125;);console.log(a); // 10console.log(b); // 20(&#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;);console.log(a); // 10console.log(b); // 20console.log(rest); // &#123;c: 30, d: 40&#125;function f() &#123; return [1, 2];&#125;var a, b;[a, b] = f();console.log(a); // 1console.log(b); // 2// 값을 아래 처럼 무시할 수도 있다.function f() &#123; return [1, 2, 3];&#125;var [a, , b] = f();console.log(a); // 1console.log(b); // 3 ¶객체 구조 분해 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485var o = &#123;p: 42, q: true&#125;;var &#123;p, q&#125; = o;console.log(p); // 42console.log(q); // truevar o = &#123;p: 42, q: true&#125;;var &#123;p: foo, q: bar&#125; = o;// p와 q는 무시된다.console.log(foo); // 42console.log(bar); // truevar metadata = &#123; title: \"Scratchpad\", translations: [ &#123; locale: \"de\", localization_tags: [ ], last_edit: \"2014-04-14T08:43:37\", url: \"/de/docs/Tools/Scratchpad\", title: \"JavaScript-Umgebung\" &#125; ], url: \"/en-US/docs/Tools/Scratchpad\"&#125;;var &#123; title: englishTitle, translations: [&#123; title: localeTitle &#125;] &#125; = metadata;console.log(englishTitle); // \"Scratchpad\"console.log(localeTitle); // \"JavaScript-Umgebung\"var people = [ &#123; name: \"Mike Smith\", family: &#123; mother: \"Jane Smith\", father: \"Harry Smith\", sister: \"Samantha Smith\" &#125;, age: 35 &#125;, &#123; name: \"Tom Jones\", family: &#123; mother: \"Norah Jones\", father: \"Richard Jones\", brother: \"Howard Jones\" &#125;, age: 25 &#125;];for (var &#123;name: n, family: &#123; father: f &#125; &#125; of people) &#123; console.log(\"Name: \" + n + \", Father: \" + f);&#125;function userId(&#123;id&#125;) &#123; return id;&#125;function whois(&#123;displayName: displayName, fullName: &#123;firstName: name&#125;&#125;)&#123; console.log(displayName + \" is \" + name);&#125;// \"Name: Mike Smith, Father: Harry Smith\"// \"Name: Tom Jones, Father: Richard Jones\"var user = &#123; id: 42, displayName: \"jdoe\", fullName: &#123; firstName: \"John\", lastName: \"Doe\" &#125;&#125;;console.log(\"userId: \" + userId(user)); // \"userId: 42\"whois(user); // \"jdoe is John\"let key = \"z\";let &#123; [key]: foo &#125; = &#123; z: \"bar\" &#125;;console.log(foo); // \"bar\" 12&#123; innerHeight &#125; // &#123;innerHeight: 441&#125;&#123;( innerHeight )&#125; // 441 여기에서 //는 전역객체 window일 것이다. ¶객체 리터럴 표기법과 JSON의 차이 JSON은 “key”: value 구문만 허용한다. key값은 큰 따옴표로 묶여 있어야한다. 그리고 값은 단축(명)일 수는 없다. JSON에서 값은 문자열, 숫자, 배열, true, false, null또는 다른 JSON객체만 가능하다. 함수는 JSON값에서 할당될 수 없다. Date 객체는 JSON.parse()를 거치고 나면 문자열이 된다.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"React 공부하기 7 - 컴포넌트 라이프 사이클","slug":"react-study-7-component-life-cycle","date":"2019-05-20T06:17:09.000Z","updated":"2019-08-14T02:05:21.870Z","comments":true,"path":"2019/05/20/react-study-7-component-life-cycle/","link":"","permalink":"https://www.yceffort.kr/2019/05/20/react-study-7-component-life-cycle/","excerpt":"¶React Component Life Cycle 라이프 사이클은 총 10가지다. Will접두사는 어떤 작업을 작동하기전에 실행하는 메소드가, Did는 어떤 작업을 한 후에 실해오디는 메서드다. 이 메서드들은 컴포넌트 클래스에서 덮어써서 선언하여 사용할 수 있다. 라이프사이클은 총 3가지 카테고리로 나눌 수 있는데, mount, unmount, update다. ¶Mount DOM이 생성되고, 웹 브라우저 상에 나타나는 것을 mount라고 한다. 이 때 호출되는 메서드는 다음과 같다. 1. 컴포넌트 만들기 2. constru","text":"¶React Component Life Cycle 라이프 사이클은 총 10가지다. Will접두사는 어떤 작업을 작동하기전에 실행하는 메소드가, Did는 어떤 작업을 한 후에 실해오디는 메서드다. 이 메서드들은 컴포넌트 클래스에서 덮어써서 선언하여 사용할 수 있다. 라이프사이클은 총 3가지 카테고리로 나눌 수 있는데, mount, unmount, update다. ¶Mount DOM이 생성되고, 웹 브라우저 상에 나타나는 것을 mount라고 한다. 이 때 호출되는 메서드는 다음과 같다. 컴포넌트 만들기 constructor: 컴포넌트를 새로 만들 때 마다 호출되는 클래스 생성자 메서드 getDerivedStateFormProps: props에 있는 값을 state와 동기화 시키는 메서드다. render: UI를 렌더링하느 메서드 componentDidMount: 컴포넌트가 웹 브라우저 상에 나타난 후 호ㅓ출하는 메서드 ¶update 컴포넌트를 업데이트 하는 경우는 아래 4가지다. props가 바뀔때 state가 바뀔때 부모컴포넌트가 리렌더링 될때 this.forceUpdate를 통하여 강제로 렌더링을 트리거할 때 호출되는 메서드들은 아래와 같다. props변경 / 부모 컴포넌트가 리렌더링 getDerivedStateFromProps: props에 있는 값을 state와 동기화 시키는 메서드다. state가 변경 shouldComponentUpdate: 컴포넌트가 리렌더링 해야하는지 결정하는 메서드다. 여기에서 false가 리턴되면 아래 메서드들을 더이상 호출 하지 않는다. forceUpdate 호출 render getSnapshotBeforeUpdate: Component 변화를 DOM에 반영하기 전에 호출하는 메서드 웹브라우저의 dom이 변화 componentDidUpdate: 컴포넌트의 업데이트 작업이 끝난 후 호출하는 메서드 ¶Unmount 컴포넌트를 DOM에서 제거하는 것을 말한다. 언마운트 componentWillUnmount: 컴포넌트가 웹 브라우저 상에서 사라지기 전에 호출되는 메서드다. ¶render() { … } 컴포넌트의 모양새를 정의한다. 라이프사이클 메서드중 유일하게 필수 메서드이기도 하다. 여기에서 this.props this.state에 접근할 수 있으며, 리액트 요소를 반환한다. 다만 이 안에서는 절대 state를 변경해서는 안되며, 웹브라우저에 접근해서도 안된다. ¶constructor 컴포넌트의 생성자 메서드로 컴포넌트를 만들 때 최초로 실행된다. 여기에서 초기 state를 정할 수 있다. ¶getDerivedStateFromProps v16.3 이후에 등장한 메서드로, props로 받아온 값을 state에 동기화 시키는 용도로 사용되며, 컴포넌트를 마운트하거나 props를 변경할 때 호출된다. ¶componentDidMount 컴포넌트를 만들고, 첫 렌더링을 마친 후 실행된다. 이 안에서 다른 자바스크립트 라이브러리나 프레임워크 함수를 호출하거나, 이벤트 등록, setTimeOut, setInterval 네트워크요청과 같은 비동기 요청을 실행하면 된다. ¶shouldComponentUpdate props나 state를 변경했을 때, 리렌더링을 시작할지 여부를 결정하는 메서드다. 여기에서는 반드시 true, false를 반환해야 한다. false를 반환하면 이 후의 과정이 모두 멈춘다. 이 안에서 this.props this.states로 접근할 수 있고, 다음 값을 this.nextProps this.nextState로 다음 값을 접근할 수 있다. 성능을 최적화 하거나, 알고리즘을 작성하여 리렌더링을 방지하기 위해서 사용하기도 한다. ¶getSnapshotBerforeUpdate v16.3 이후에 등장한 메서드로, render를 호출한 후 DOM에 변화를 반영하기 바로 직전에 호출하는 메서드다. 여기에서 반환하는 값을 componentDidUpdate에서 세번째 파라미터인 snapshot으로 값을 전달 받을 수 있다. 주로 스크롤바의 위치와 같이 업데이트하기 직전에 값을 참고할 일이 있을 때 활용한다. 123456getSnapshotBeforeUpdate(prevProps, prevState) &#123; if (prevState.array !== this.state.array) &#123; const &#123;scrollTop, scrollHeight&#125; = this.list return &#123;scrollTop, scrollHeight&#125;; &#125;&#125; ¶componentDidUpdate 리렌더링을 완료한 후에 실행한다. 업데이트가 끝난 이후이므로, DOM관련 처리를 해도된다. 여기에서 prevProps prevState를 활용하여 이전의 값에 접근할 수 도 있다. getSnapshotBerforeUpdate에서 반환한 값이 있다면 여기서 snapshot값을 전달 받을 수 있다. ¶componentWillUnmount 컴포넌트를 DOM에서 제거할 때 실행한다. componentDidMount에서 등록한 이벤트, 타이머, DOM이 있다면 어기에서 제거해야 한다. 출처: https://code.likeagirl.io/understanding-react-component-life-cycle-49bf4b8674de","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"React 공부하기 8 - 함수형 컴포넌트","slug":"react-study-8-functional-component","date":"2019-05-20T06:17:09.000Z","updated":"2019-05-20T10:07:57.148Z","comments":true,"path":"2019/05/20/react-study-8-functional-component/","link":"","permalink":"https://www.yceffort.kr/2019/05/20/react-study-8-functional-component/","excerpt":"¶함수형 컴포넌트 1 2 3 4 5 6 7 import React from 'react'; function Hello(props) { return ( hello {props.name} ) } 함수형 컴포넌트는 컴포넌트에서 라이프사이클, state 등의 기능을 제거한 상태이므로 메모리 사용량이 다른 컴포넌트에 비해 적다. 따라서 성능을 최적화 하기 위해서는 위와 같이 함수형 컴포넌트를 많이 쓰는 것이 좋다.","text":"¶함수형 컴포넌트 1234567import React from 'react';function Hello(props) &#123; return ( &lt;div&gt;hello &#123;props.name&#125;&lt;/div&gt; )&#125; 함수형 컴포넌트는 컴포넌트에서 라이프사이클, state 등의 기능을 제거한 상태이므로 메모리 사용량이 다른 컴포넌트에 비해 적다. 따라서 성능을 최적화 하기 위해서는 위와 같이 함수형 컴포넌트를 많이 쓰는 것이 좋다.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"React 공부하기 6 - 컴포넌트 반복","slug":"react-study-6-component-repeat","date":"2019-05-20T06:16:08.000Z","updated":"2019-05-20T06:39:42.269Z","comments":true,"path":"2019/05/20/react-study-6-component-repeat/","link":"","permalink":"https://www.yceffort.kr/2019/05/20/react-study-6-component-repeat/","excerpt":"¶컴포넌트 반복해서 쓰기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import React, {Component} from 'react'; class IterationSample extends Component { render () { const names = ['눈사람', '얼음', '눈', '바람'] const nameList = names.map( (name) => ({name}) );","text":"¶컴포넌트 반복해서 쓰기 123456789101112131415161718import React, &#123;Component&#125; from 'react';class IterationSample extends Component &#123; render () &#123; const names = ['눈사람', '얼음', '눈', '바람'] const nameList = names.map( (name) =&gt; (&lt;li&gt;&#123;name&#125;&lt;/li&gt;) ); return ( &lt;ul&gt; &#123;nameList&#125; &lt;/ul&gt; ) &#125;&#125;export default IterationSample; 1234567class App extends Component &#123; render () &#123; return ( &lt;IterationSample/&gt; ) &#125;&#125; 특별한 거는 없지만, 콘솔에서 key가 없다는 에러가 발생한다. 가상 DOM을 비교한느 과정에서, Key값을 활용하여 변화가 일어나는지 확인하기 때문에, key값을 지정해줘야한다. 1234567891011121314class IterationSample extends Component &#123; render () &#123; const names = ['눈사람', '얼음', '눈', '바람'] const nameList = names.map( (name, index) =&gt; (&lt;li key=&#123;index&#125;&gt;&#123;name&#125;&lt;/li&gt;) ); return ( &lt;ul&gt; &#123;nameList&#125; &lt;/ul&gt; ) &#125;&#125; 이제 에러가 나지 않는다. 보통은 이렇게 정적인 데이터를 쓰기보다는, 동적인 데이터를 더 렌더링할 기회가 더 많을 것이다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123;Component&#125; from 'react';class IterationSample extends Component &#123; state = &#123; names: ['토니안', '강타', '문희준', '이재원', '장우혁'], name: '' &#125; handleChange = (e) =&gt; &#123; this.setState(&#123; name: e.target.value &#125;) &#125; handleInsert = (e) =&gt; &#123; this.setState(&#123; names: this.state.names.concat(this.state.name), name: '' &#125;) &#125; handleRemove = (index) =&gt; &#123; // this.state의 레퍼런스 const &#123;names&#125; = this.state; this.setState(&#123; names: names.filter((item, idx) =&gt; &#123;return idx !== index&#125;) &#125;) &#125; render() &#123; const nameList = this.state.names.map( (name, index) =&gt; (&lt;li onDoubleClick=&#123;() =&gt; this.handleRemove(index)&#125; key=&#123;index&#125;&gt;&#123;name&#125;&lt;/li&gt;) ); return ( &lt;div&gt; &lt;input onChange=&#123;this.handleChange&#125; value=&#123;this.state.name&#125;/&gt; &lt;button onClick=&#123;this.handleInsert&#125;&gt;추가&lt;/button&gt; &lt;ul&gt; &#123;nameList&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default IterationSample;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"Javascript - Closure","slug":"javascript-closure","date":"2019-05-09T02:11:56.000Z","updated":"2019-08-14T02:05:21.881Z","comments":true,"path":"2019/05/09/javascript-closure/","link":"","permalink":"https://www.yceffort.kr/2019/05/09/javascript-closure/","excerpt":"¶클로저 ¶자바스크립트는 어떻게 변수의 유효 범위를 정하는가? 1 2 3 4 5 6 7 8 9 10 function hello() { var name = 'yceffort'; // 내부함수이며, 클로저다. function showName() { // 부모함수가 선언한 변수를 사용한다. alert(`hello, ${name}`); } showName(); } hello(); 여기에서 hello()는 지역변수 name과 함수 showName()을 생성했다. show","text":"¶클로저 ¶자바스크립트는 어떻게 변수의 유효 범위를 정하는가? 12345678910function hello() &#123; var name = 'yceffort'; // 내부함수이며, 클로저다. function showName() &#123; // 부모함수가 선언한 변수를 사용한다. alert(`hello, $&#123;name&#125;`); &#125; showName();&#125;hello(); 여기에서 hello()는 지역변수 name과 함수 showName()을 생성했다. showName()은 내부함수이므로, hello()에서만 사용이 가능하다. showName()은 별도의 지역변수가 없지만 내부함수는 외부함수에 접근할 권한을 가지고 있으므로, name이 정상적으로 출력될 것이다. 만약 name이라는 다른 변수가 내부 함수에 있다면, 그 변수를 우선적으로 사용할 것이다. Lexical은 변수가 사용가능한 범위를 결정하기 위해 소스코드 내에서 변수가 선언된 위치를 사용한다는 것을 말한다. 따라서 내부 함수들은 그들의 외부 유효 범위 내에서 선언된 변수들에 접근할 권한을 가진다. ¶클로저란 무엇인가 12345678910function hello() &#123; var name = 'yceffort'; function showName() &#123; alert(`hello, $&#123;name&#125;`); &#125; return showName;&#125;let sayHello = hello();sayHello(); 이 전과 완전히 똑같은 결과를 보일 것이다. 차이점은, hello()가 내부 함수 showName를 리턴했다는 것, 그리고 그렇게 리턴한 정보를 sayHello변수에 저장헀다는 것이다. 얼핏보면 잘 이해가 되지 않는 모습이다. hello()는 showName()만을 리턴했는데, 계속해서 name변수에 접근하고 있기 때문이다. 그 이유는, 자바스크립트가 함수를 리턴할때, 리턴하는 함수가 클로저를 생성하기 때문이다. 클로저는 함수와 함수가 선언된 어휘적 환경의 조합이다. (함수가 선언된 환경을 기억한다.) 여기에서 환경은, 클로저가 생성된 시점에 유효범위내에 있는 모든 지역변수로 구성된다. (내부 함수가 외부 함수의 변수에 접근할 수 있었기 때문에 그 변수들을 기억하는 것) 1234567891011121314function add(x) &#123; var y = 1; return function(z) &#123; y = 100; return x + y + z &#125;&#125;// 클로저 선언let add5 = add(5);let add10 = add(10);console.log(add5(2)); console.log(add10(2)); add함수는, x를 인자로 받아서 새로운 내부 함수를 반환한다. 이 내부 함수는 z를 받아서 x+y+z를 반환한다. add5와 add10은 모두 클로저다. 이 두 함수의 결과는 어떻게 될까? 첫번째 선언 let add5 = add(5)에서 일단 x가 5로 할당이 되었다. 그리고 두번째 add5(2)에서는 z가 2로 할당이 되었다. 그리고 y가 두군데 할당이 되어있으므로, 내부를 우선시하여 y는 100이다. 따라서 $$ x+y+z=5+100+2=107 $$이 된다. 마찬가지로, add10은 $$ x+y+z=10+100+2=112 $$가 된다. 본질적으로, 이 두개는 같은 함수의 본문을 정의하지만, 서로 다른 환경을 저장한다. 이는 클로저가 리턴된 후에도 외부 함수의 변수에 접근이 가능하다는 것을 보여주며, 단순히 값 형태로 전달되는 것이 아니라는 것을 의미한다. ¶어디다 쓸까 클로저는 어휘적인 환경과 데이터를 조작하는 함수를 연관시켜 주기 때문에 유용하다. 이는 객체가 어떤 데이터 (속성)과 그 메소드를 연관시킨 다는 점에서 객체지향 프로그래밍과 같은 맥락에 있다. 따라서, 단 하나의 메소드 만을 가지고 있는 객체를 일반적으로 사용하는 모든 곳에 클로저를 사용할 수 있다. 이는 프론트엔드 자바스크립트 이벤트에서 흔히 볼 수 있다. 사전에 몇가지 동작을 정의한 후에, 사용자가 이벤트를 트리거 하면 이 동작들을 연결하는데 이는 이벤트에 응답하여 실행되는 단일 함수다. 12345678910111213function makeFontSize(size) &#123; return function() &#123; document.body.style.fontSize = size + 'px'; &#125;&#125;let size12 = makeFontSize(12);let size14 = makeFontSize(14);let size16 = makeFontSize(16);document.getElementById('size-12').onclick = size12;document.getElementById('size-14').onclick = size14;document.getElementById('size-16').onclick = size16; 프라이빗 메소드를 흉내내는 것도 가능하다. 프라이빗 메소드는 코드에 제한적인 접근만 허용할 수 있고, 전역 네임스페이스를 관리하는 방법을 제공하여 불필요한 메소드가 공용 인터페이스를 혼란스럽게 만들지 않도록 할 수 있다. 12345678910111213141516171819202122232425let counter = (function () &#123; let privateCounter = 0; function change(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; change(1); &#125;, decrement: function() &#123; change(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125;&#125;)();counter.increment();counter.value();counter.increment();counter.increment();counter.decrement();counter.value(); change() privateCounter는 모두 익명함수 내부에서 생성되었기 때문에 접근할 수 없다. 이 익명함수에서 접근할 수 있는건 익명래퍼에서 반환된 세개의 퍼블릭함수 increment() decrement() value() 뿐이다. 위 처럼 즉시실행익명함수가 아니라 별도의 함수로 만들어서 따로 쓴다면, 객체지향 프로그래밍의 은닉과 캡슐화 같은 이점들을 얻을 수 있다. ¶루프에서의 클로저 이 함수는 생각처럼 작동하지 않는다. 그 이유는 onfcus에 연결된 함수가 클로저이기 때문이다. 이 클로저는 setupHelp() 함수범위에서 캡쳐된 환경으로 구성된다. 루프에서 세개의 세개의 클로저가 만들어졌지만, 각 클로저는 값이 변하는 변수 item.help가 있는 단일 환경을 공유한다. 따라서 계속해서 마지막 변수를 가르키게 되는 것이다. 첫번째 해결방안은 showHelp()를 감싸는 클로저를 만드는 것이다. showHelp()는 여전히 단일 환경에서 작동하지만, makeHelpCallback()는 매번 새로운 클로저를 만들어서 새로운 환경을 형성한다. 아니면 즉시실행익명함수를 만들어서 for 구문내의 환경이 별로 즉시로 실행되게 하는 방법도 있을 수 있다. 반드시 for 구문 내의 로직을 즉시실행함수로 감싸서 별도의 환경으로 구성되게 해야 한다. 아니면 let을 사용하여 item변수의 범위자체를 for문 내로 제한할 수도 있다. ¶성능 클로저가 필요하지 않은 작업에 다른 함수내에서 함수를 불필요하게 계속 선언하고 작성하는 것은 성능에 악영향을 미친다. 예를 들어, 새로운 객체나 클래스를 생성할때 메소드를 객체 생성자에 정의하는 것 보다는 객체의 프로토타입에 연결해야 한다. ¶안좋은 예 1234567891011function MyObject(name, message) &#123; this.name = name.toString(); this.message = message.toString(); this.getName = function() &#123; return this.name; &#125;; this.getMessage = function() &#123; return this.message; &#125;;&#125; 이렇게 하기보다는 prototype에 정의하는 것이 훨씬 낫다. 12345678910function MyObject(name, message) &#123; this.name = name.toString(); this.message = message.toString();&#125;MyObject.prototype.getName = function() &#123; return this.name;&#125;;MyObject.prototype.getMessage = function() &#123; return this.message;&#125;; 123456789101112function MyObject(name, message) &#123; this.name = name.toString(); this.message = message.toString();&#125;(function() &#123; this.getName = function() &#123; return this.name; &#125;; this.getMessage = function() &#123; return this.message; &#125;;&#125;).call(MyObject.prototype); 이렇게 쓴다면 좀더 섹시해 보일 것이다.","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"React 공부하기 5 - Reference","slug":"react-study-5-reference","date":"2019-05-09T00:22:14.000Z","updated":"2019-05-20T02:50:56.476Z","comments":true,"path":"2019/05/09/react-study-5-reference/","link":"","permalink":"https://www.yceffort.kr/2019/05/09/react-study-5-reference/","excerpt":"¶Reference (Ref) 특정 DOM요소에 작업을 하기 위해서 id를 부여하는 것 처럼, React에서 DOM에 이름을 다는 방식이 있는데 이것이 바로 ref (Reference)다. 반드시, DOM에 직접적으로 접근하여 조작이 필요할 때 만 이용해야 한다. ¶컴퍼넌트 내부에서 사용 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import Re","text":"¶Reference (Ref) 특정 DOM요소에 작업을 하기 위해서 id를 부여하는 것 처럼, React에서 DOM에 이름을 다는 방식이 있는데 이것이 바로 ref (Reference)다. 반드시, DOM에 직접적으로 접근하여 조작이 필요할 때 만 이용해야 한다. ¶컴퍼넌트 내부에서 사용 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123;Component&#125; from 'react';import './ValidationSample.css';class ValidationSample extends Component &#123; state = &#123; password: '', clicked: false, validated: false, &#125; handleChange = (e) =&gt; &#123; this.setState(&#123; password: e.target.value, &#125;); &#125; handleButtonClick = () =&gt; &#123; this.setState(&#123; clicked: true, validated: this.state.password === '0000' &#125;); this.input.focus(); &#125; render() &#123; return ( &lt;div&gt; &lt;input ref=&#123;(ref) =&gt; this.input=ref&#125; type=\"password\" value=&#123;this.state.password&#125; onChange=&#123;this.handleChange&#125; className=&#123;this.state.clicked ? (this.state.validated ? 'success' : 'failure') : ''&#125; &gt; &lt;/input&gt; &lt;button onClick=&#123;this.handleButtonClick&#125;&gt;Validation&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default ValidationSample; 중요하게 봐야할 부분은 바로 여기 1&lt;input ref=&#123;(ref) =&gt; this.input=ref&#125;/&gt; ref 속성을 추가할 때는 props를 설정하듯이 하면 된다. ref 값으로는 콜백 함수를 전달하는데, 이 콜백함수는 ref를 파라미터로 가지며 함수 내부에서 멤버변수에 ref를 담으면 된다. 여기에서는 this.input에 담았다. this.input.focus()를 통해서 input 태그에 포커스를 달았다. ¶컴포넌트에 Ref 달기 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react';class ScrollBox extends Component &#123; scrollToBottom = () =&gt; &#123; const &#123; scrollHeight, clientHeight, width &#125; = this.box; this.box.scrollTop = scrollHeight - clientHeight; &#125; render() &#123; const style = &#123; border: '1px solid black', height: '300px', width: '300px', overflow: 'auto', position: 'relative', &#125; const innerStyle = &#123; width: '100%', height: '650px', background: 'linear-gradient(white, black)' &#125; return ( &lt;div style=&#123;style&#125; ref=&#123;(ref) =&gt; &#123;this.box=ref&#125;&#125;&gt; &lt;div style=&#123;innerStyle&#125;/&gt; &lt;/div&gt; ) &#125;&#125;export default ScrollBox; 12345678910111213141516import React, &#123;Component&#125; from 'react';import ScrollBox from './ScrollBox';class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;ScrollBox ref=&#123;(ref) =&gt; &#123;this.scrollBox=ref&#125;&#125; /&gt; &lt;button onClick=&#123;() =&gt; &#123;this.scrollBox.scrollToBottom()&#125;&#125;&gt;맨밑으로&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default App; ScrollBox에서 scrollToBottom 함수를 정의했다. 그리고 ScrollBox 컴포넌트를 this.scrollBox로 ref를 부여하여 다른 DOM에서 해당 함수를 호출 할 수 있었다.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"React 공부하기 4 - Event","slug":"react-study-4-event","date":"2019-05-08T04:53:58.000Z","updated":"2019-05-20T02:50:56.476Z","comments":true,"path":"2019/05/08/react-study-4-event/","link":"","permalink":"https://www.yceffort.kr/2019/05/08/react-study-4-event/","excerpt":"¶이벤트 리액트의 이벤트는 기본적으로 HTML의 이벤트와 비슷하지만, 주의사항이 몇가지 있습니다. 1. 이벤트 명은 카멜 케이스로 작성해야 한다. onclick → onClick 2. 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니고, 함수형태의 값을 전달해야 한다. 3. DOM요소에만 설정할 수 있다. Custom Component는 onClick이벤트가 설정되는 것이 아니고, onClick Prop에 값이 넘어가는 것이다. ¶지원하는 이벤트 종류 * Clipboard * Form * Composition","text":"¶이벤트 리액트의 이벤트는 기본적으로 HTML의 이벤트와 비슷하지만, 주의사항이 몇가지 있습니다. 이벤트 명은 카멜 케이스로 작성해야 한다. onclick → onClick 이벤트에 실행할 자바스크립트 코드를 전달하는 것이 아니고, 함수형태의 값을 전달해야 한다. DOM요소에만 설정할 수 있다. Custom Component는 onClick이벤트가 설정되는 것이 아니고, onClick Prop에 값이 넘어가는 것이다. ¶지원하는 이벤트 종류 Clipboard Form Composition Keyboard Selection Focus Touch UI Image Wheel Animation Media Transition 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import React, &#123;Component&#125; from 'react';class MyEventComponent2 extends Component &#123; state = &#123; message: '' &#125; handleChange = (e) =&gt; &#123; this.setState(&#123; message: e.target.value, &#125;) &#125; handleClick = (e) =&gt; &#123; alert(this.state.message); this.setState(&#123; message: '' &#125;) &#125; handleKeyPress = (e) =&gt; &#123; if (e.key === 'Enter') this.handleClick(); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;이벤트 연습&lt;/h1&gt; &lt;input type=\"text\" name=\"message\" placeholder=\"event가 달릴거야\" value=&#123;this.state.message&#125; onChange=&#123;this.handleChange&#125; onKeyPress=&#123;this.handleKeyPress&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125; &gt; 확인 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default MyEventComponent2; 이 값을 위 처럼 state에도 넣을 수 있다.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"React 공부하기 3 - Component","slug":"react-study-3-component","date":"2019-05-08T03:03:03.000Z","updated":"2019-05-20T02:50:56.475Z","comments":true,"path":"2019/05/08/react-study-3-component/","link":"","permalink":"https://www.yceffort.kr/2019/05/08/react-study-3-component/","excerpt":"¶컴포넌트 기본적인 컴포넌트를 만들어 보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 import React, {Component} from 'react'; class MyComponent extends Component{ render() { return ( brand new componenet ) } } export default MyComp","text":"¶컴포넌트 기본적인 컴포넌트를 만들어 보자. 12345678910111213import React, &#123;Component&#125; from 'react';class MyComponent extends Component&#123; render() &#123; return ( &lt;div className='hello'&gt; brand new componenet &lt;/div&gt; ) &#125;&#125;export default MyComponent; 1234567891011import React from 'react';import MyComponent from './MyComponent';function App() &#123; return ( &lt;MyComponent/&gt; );&#125;export default App; ¶Props 컴포넌트의 속성을 줄때 사용하는 값이다. 12345678910111213import React, &#123;Component&#125; from 'react';class MyComponent extends Component&#123; render() &#123; return ( &lt;div className='hello'&gt; brand new componenet is &#123;this.props.name&#125; &lt;/div&gt; ) &#125;&#125;export default MyComponent; 아런식으로 부모에서 값을 넘겨 줄 수 있다. 또한 default값을 설정할 수도 있다. 1234567891011121314151617181920import React, &#123;Component&#125; from 'react';class MyComponent extends Component&#123; render() &#123; return ( &lt;div className='hello'&gt; brand new componenet is &#123;this.props.name&#125;. &lt;/div&gt; &lt;div&gt; age: &#123;this.props.age&#125; &lt;/div&gt; ) &#125;&#125;MyComponent.defaultProps = &#123; name: 'yceffort',&#125;export default MyComponent; 유의할 점은 props에 아무값을 안넘겨줘도 (nane=&quot;&quot;) 값은 default 가 아닌 “” 가 나온다는 것이다. 왜냐하면 &quot;&quot;는 기본적으로 string으로 인식 되기 때문이다. 여기에 숫자등의 값을 넘기고 싶다면 {}를 써야 한다. props의 값을 검증하기 위해서는 propTypes를 사용한다. 123456789101112131415161718192021222324252627282930313233import React, &#123;Component&#125; from 'react';import PropTypes from 'prop-types';class MyComponent extends Component&#123; render() &#123; return ( &lt;div&gt; &lt;div className='hello'&gt; brand new componenet is &#123;this.props.name&#125; &lt;/div&gt; &lt;div&gt; age: &#123;this.props.age&#125; &lt;/div&gt; &lt;div&gt; company: &#123;this.props.company&#125; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;MyComponent.defaultProps = &#123; name: 'yceffort', age: 30&#125;MyComponent.propTypes = &#123; name: PropTypes.string, age: PropTypes.number, company: PropTypes.string.isRequired,&#125;export default MyComponent; 숫자에 문자열을 넣거나, required인데 값을 안넘겨주는 경우에도 렌더링은 된다. 다만 콘솔창에 에러가 출력된다. ¶state props는 부모 컴포넌트가 설정하는 읽기전용 값이다. 컴포넌트 내부에서 값을 또 읽고 업데이트를 하려면 state를 써야 한다. state는 항상 기본 값이 있어야 하며 this.setState()메소드로 만 값을 업데이트 해야 한다. 123456789101112131415161718192021222324252627282930313233class MyComponent extends Component&#123; constructor(props) &#123; super(props); this.state = &#123; number: 0 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;div className='hello'&gt; brand new componenet is &#123;this.props.name&#125; &lt;/div&gt; &lt;div&gt; age: &#123;this.props.age&#125; &lt;/div&gt; &lt;div&gt; company: &#123;this.props.company&#125; / &#123;this.state.number&#125; 개 &lt;/div&gt; &lt;button onClick=&#123;()=&gt; &#123; this.setState(&#123; number: this.state.number + 1 &#125;) &#125; &#125;&gt; 더하기 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 위와 같은 방식으로도 할 수 있지만, transform-class-properties문법을 사용하여, constructor 바깥에서도 state와 props를 정의할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123;Component&#125; from 'react';import PropTypes from 'prop-types';class MyComponent extends Component&#123; static defaultProps = &#123; name: 'yceffort', age: 30 &#125;; static propTypes = &#123; name: PropTypes.string, age: PropTypes.number, company: PropTypes.string.isRequired, &#125; state = &#123; number: 0 &#125;; render() &#123; return ( &lt;div&gt; &lt;div className='hello'&gt; brand new componenet is &#123;this.props.name&#125; &lt;/div&gt; &lt;div&gt; age: &#123;this.props.age&#125; &lt;/div&gt; &lt;div&gt; company: &#123;this.props.company&#125; / &#123;this.state.number&#125; 개 &lt;/div&gt; &lt;button onClick=&#123;()=&gt; &#123; this.setState(&#123; number: this.state.number + 1 &#125;) &#125; &#125;&gt; 더하기 &lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default MyComponent; transform-class-properties란 기존에 자바스크립트 클래스 syntax에서는 method외에는 아무것도 선언할 수 없게 되어 있는 것을, 조금 더 유연하게 만들어 주는 것이다. ¶before 123456789class Cat &#123; constructor(name, breed) &#123; this.name = name; this.breed = breed; &#125; getBreed() &#123; return this.name + ' is a ' + this.breed; &#125;&#125; ¶after 12345678class Cat &#123; name = \"Chairman Meow\"; breed = \"Sphynx\"; getBreed = function() &#123; return this.name + ' is a ' + this.breed; &#125;&#125; 또한, 화살표 함수가 더이상 그 구문내의 this를 생성해 내지 않고, 올바르게 this가 class를 가르킬 수 있도록 도와준다. 123getBreed = () =&gt; &#123; return this.name + ' is a ' + this.breed; &#125; 이렇게 쓰는 것도 가능해 진다는 뜻이다.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"React 공부하기 2 - JSX","slug":"react-study-2-jsx","date":"2019-05-08T02:58:18.000Z","updated":"2019-05-20T02:50:56.475Z","comments":true,"path":"2019/05/08/react-study-2-jsx/","link":"","permalink":"https://www.yceffort.kr/2019/05/08/react-study-2-jsx/","excerpt":"¶Create-react-app 라이브러리로 시작 1 2 3 4 5 yarn global add create-react-app create-react-app hello-react cd hello-react yarn start ¶app.js의 구조 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import React from 'react'; import logo from './logo.svg'; import './App.css'; functio","text":"¶Create-react-app 라이브러리로 시작 12345yarn global add create-react-appcreate-react-app hello-reactcd hello-reactyarn start ¶app.js의 구조 1234567891011121314151617181920212223242526import React from 'react';import logo from './logo.svg';import './App.css';function App() &#123; return ( &lt;div className=\"App\"&gt; &lt;header className=\"App-header\"&gt; &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt; &lt;p&gt; Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload. &lt;/p&gt; &lt;a className=\"App-link\" href=\"https://reactjs.org\" target=\"_blank\" rel=\"noopener noreferrer\" &gt; Learn React &lt;/a&gt; &lt;/header&gt; &lt;/div&gt; );&#125;export default App; 코드 첫줄은 node.js의 기능, 즉 react를 불러와서 모듈화 시키는 것이다. 이를 번들링하는 작업은 webpack에서 처리해 준다. css-loader로 ./App.css를, file-loader로 파일을 (log.svg), babel-loader로 es6를 es5로 변환해서 처리해줄 것이다. 원래는 이러한 작업을 위해서 세팅을 해줘야 하지만, react-scripts에서 이를 다 처리해주고 있다. 한가지 특이한 것은, class가아니고 className으로 되어있다는 것이다. 그렇다. jsx니까, javascript를 쓸테고, class는 자바스크립트의 예약어이니까 className을 대신 써야 하는 것이다. 그 다음으로 봐야할 것은 return() 구문에 있는 내용이다. 얼핏보면 html과 비슷하게 생긴 이 코드는, JSX라고 한다. 이 코드는 나중에 babel-loader로 번들링 되면서 자바스크립트로 변환된다. ¶before 12345var a = ( &lt;div&gt; &lt;h1&gt; hello &lt;b&gt;react&lt;/b&gt; &lt;/h1&gt; &lt;/div&gt;) ¶after 1234567891011121314var a = React.createElement( \"div\", null, React.createElement( \"h1\", null, \"hello \" React.createElement( \"b\", null, \"react\" ) )) ¶JSX 문법 1.컴포넌트에 여러개의 요소가 있다면 꼭 하나의 부모요소로 감싸야 한다. Virtual Dom에서 컴포넌트 변화를 감지내 낼 때, 효율적으로 비교할 수 있도록 컴포넌트 내부는 DOM 트리 구조 하나여야 한다는 규칙이 존재하기 때문이다. 만약 &lt;div&gt;를 쓰고 싶지 않다면, 리액트 v16에서 지원하는 &lt;Fragment&gt;를 사용하면 된다. 2.자바스크립트도 내부에서 표현할 수 있다. 12345678render () &#123; const text = '집에 가고 싶다'; return ( &lt;div&gt; &lt;h1&gt;&#123;text&#125;&lt;/h1&gt; &lt;/div&gt; )&#125; 3.내부 표현식에서 if문을 사용하려면, 조건부 연산자를 사용하면 된다. 같은 맥락으로, || &amp;&amp; condition ? 'true' : 'false' 등도 가능하다. 123456789render () &#123; const condition = true; &lt;div&gt; &#123; condition ? '참': '거짓' &#125; &lt;/div&gt;&#125; 4.인라인 스타일링도 가능하다. 키는 camel_case를 사용하면 된다. background-color는 backgroundColor로, -mos는 Mos로 쓰면된다. 단 -ms는 그냥 소문자 ms로 한다. 1234567render() &#123; const style = &#123; backgroundColor: 'gray', border: '1px solid black', height: Math.round(Math.random() * 100) + 50, width: Math.round(Math.random() * 100) + 50, &#125; 5.class를 쓰지말고 className을 써야 한다. 6.주석은 꼭 {}안에다가 써야 한다. 1234567891011121314&#123;/* jsx에서 주석은 이렇게 써야 한다.*/&#125;&#123; /* 여러 줄일 때는 이렇게 써야 한다.*/ &#125;return &#123; &lt;div&gt; &lt;div // 하지만 이렇게 주석을 쓰는 건 괜찮다.&gt; &lt;/div&gt; // 이렇게 쓰면 바로 이 줄 자체가 렌더링된다. &lt;/div&gt;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"React 공부하기 1 - background","slug":"react-study-1-background","date":"2019-05-08T01:46:42.000Z","updated":"2019-05-20T02:50:56.475Z","comments":true,"path":"2019/05/08/react-study-1-background/","link":"","permalink":"https://www.yceffort.kr/2019/05/08/react-study-1-background/","excerpt":"¶리액트 요약 기존에 많은 자바스크립트 기반 플게임워크들이 있었는데, 대부분의 프레임워크들은 MVC (Model-View-Controller), MVVM(Model-View-View Model), MVW(Model-View-Whatever) 아키텍쳐를 사용하여 개발되었다. 그러나 이 작업은 어플리케이션 규모가 커지면 복잡해지고, 제대로 관리하지 않으면 성능이 떨어진다는 문제점을 지니고 있다. 이렇게 부분적으로 찾아서 업데이트 하는 대신에, 데이터가 변할 때마다 기존 뷰를 날려 버리고 처음부터 새로 렌더링을 하면 어떨까? 이렇","text":"¶리액트 요약 기존에 많은 자바스크립트 기반 플게임워크들이 있었는데, 대부분의 프레임워크들은 MVC (Model-View-Controller), MVVM(Model-View-View Model), MVW(Model-View-Whatever) 아키텍쳐를 사용하여 개발되었다. 그러나 이 작업은 어플리케이션 규모가 커지면 복잡해지고, 제대로 관리하지 않으면 성능이 떨어진다는 문제점을 지니고 있다. 이렇게 부분적으로 찾아서 업데이트 하는 대신에, 데이터가 변할 때마다 기존 뷰를 날려 버리고 처음부터 새로 렌더링을 하면 어떨까? 이렇게 하면 어플리케이션 구조가 간단해지고, 작성할 코드의 양도 적어지며, 변화가 있으면 기존의 뷰를 날려버리고 그냥 다시 만들어 버리면 된다. 그러가 이 방식대로 하면 웹브라우저에 CPU 점유율도 늘어날 것이고, 메모리도 많이 사용 될 것이다. 그리고 사용자도 잠깐이지만 뷰가 날라가는 모습을 볼 수 있을지도 모른다. 리액트는 오직 V, 즉 View만 신경 쓰는 라이브러리다. 리액트에서 중요한 두가지는 초기렌더링과 리렌더링이다. 즁요한 것은 react자체는 view만을 담당하는 라이브러리 라는 것이다. ¶초기 렌더링 1render () &#123;...&#125; 이 함수는 컴포넌트가 어떻게 생겼는지 정의 한다. 여기에는 html 구문이 아니라, 뷰가 어떻게 생겼고 무슨 정보를 지니고 있는지에 대한 내용을 가지고 있다. 이 함수를 실행하면, 내부 컴포넌트들도 재귀적으로 실행해서,html 마크업을 만들고, 실제 페이지의 dom 요소에 주입하게 된다. ¶Reconcilation 앞서 말한 뷰를 새로 갈아끼는 과정을 Reconcilation이라고 한다. 이 작업도 render함수에서 진행된다. 이 작업은 render가 반환한 결과를 바로 적용하는 것이 아니라, 이전에 만들었던 컴포넌트 정보와 비교를 먼저한다. 이렇게 비교한 후, 둘의 차이를 알아내 최소한의 연산으로 dom 트리를 바꿔 치는 것이다. ¶Virtual Dom DOM (Document Object Model)은 동적 UI에 최적화되어 있지 못하다. HTML은 정적인 문서이지만, Javascript를 통해 동적으로 만드는 것이다. 흔히들 DOM은 느리다고 하지만, 이는 정확한 표현이 아니다. 정확히는 DOM에서 변화가 일어났을 때, 브라우저가 CSS를 연산하고 리페인트 하는 과정이 느린 것이다. 여기애서 React는 Virtual Dom 방식을 사용하여, DOM 업데이트를 추상화 하여 처리횟수를 최소화 하고 효율적으로 처리한다. Virtual Dom을 사용한다고 해서 무조건 빠른 것은 아니다. 작업이 매우 간단한 경우에는 리액트가 없는 편이 나을 수 있다. 어쨌거나, React Virtual Dom이 주는 것은 업데이트 처리의 간결성이다.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.yceffort.kr/tags/react/"},{"name":"javascript","slug":"javascript","permalink":"https://www.yceffort.kr/tags/javascript/"}]},{"title":"Disciplined Entrepreneruship","slug":"disciplined-entrepreneurship","date":"2019-05-03T01:45:29.000Z","updated":"2019-05-20T02:50:56.475Z","comments":true,"path":"2019/05/03/disciplined-entrepreneurship/","link":"","permalink":"https://www.yceffort.kr/2019/05/03/disciplined-entrepreneurship/","excerpt":"¶작동하는 가설을 만들어라 ‘가설’이라는 단어는 기업가정신, 이노베이션경영, 그리고 지금의 파괴적혁신에 이르기까지 가장 많이 접한 단어 중 하나 입니다. 그 만큼 많은 학자들이 기업을 경영하는데 있어 가설을 만들고 증명하는 일이 중요하다는 것에 공감대를 형성했다는 뜻일 것입니다. 이러한 가설에는 수많은 변수가 포함되어 있습니다. 이러한 변수에는 기술이 될 수도, 고객 수요가 될 수도, 경쟁업체가 될수도 있습니다. 그리고 불확실하기 때문에 ‘가설’이라는 이름으로 존재하게 됩니다. 변수 간의 상호작용은 가설을 더욱 복잡하게 만들며,","text":"¶작동하는 가설을 만들어라 ‘가설’이라는 단어는 기업가정신, 이노베이션경영, 그리고 지금의 파괴적혁신에 이르기까지 가장 많이 접한 단어 중 하나 입니다. 그 만큼 많은 학자들이 기업을 경영하는데 있어 가설을 만들고 증명하는 일이 중요하다는 것에 공감대를 형성했다는 뜻일 것입니다. 이러한 가설에는 수많은 변수가 포함되어 있습니다. 이러한 변수에는 기술이 될 수도, 고객 수요가 될 수도, 경쟁업체가 될수도 있습니다. 그리고 불확실하기 때문에 ‘가설’이라는 이름으로 존재하게 됩니다. 변수 간의 상호작용은 가설을 더욱 복잡하게 만들며, 예측하기 어렵게 만듭니다. 그렇기 때문에 가설을 잘 공식화하고 구성해야할 필요가 있습니다. 가설은 가변적이어야 한다. 가설은 어디까지나 가설이기 때문에 잠정적이고, 변화할 수 있음을 유념해야합니다. 그렇기 때문에 가설 설립에서는 융통성을 발휘할 필요가 있습니다. 회사를 이끌어갈 가설인 포트폴리오도 한 번쯤 변화를 거치는데 이는 자연스러운 일입니다. 가설이지만 이를 꼭 달성해야만 한다는 성공한다는 human bias를 경계할 필요가 있습니다. 가설에 스스로 목소리를 낼 수 있어야 한다.가설을 테스트 하기전에, 가설에서 한발짝 물러나 의견을 제시할 수 있어야 합니다. 이러한 의견을 제시하는 것은 불확실성을 이해하는 것이며, 이를 위해서는 산업, 고객, 기술에 대한 심층적인 이해가 필요합니다. 이러한 지식이 부족하다면 가설에 대한 의견을 낼 수 없다는 것이고, 이는 가설을 대한 올바른 질문을 내리지 못하게 될 것입니다. 가설을 망치거나 달성할 요소들을 선별해라. 기업가에게 기회란 극단적인 문제입니다. 엄청난 기회를 줄수도, 사업을 망쳐버릴 수도 있습니다. 그러나 다행히도, 이러한 극단적인 요소들은 사업 초기에 분별할 수 있습니다. 그리고 이러한 불확실성의 원천을 조기에 식별해야 합니다. 기업가들은 항상 ‘현재 기업을 망칠수 있는 무언가’에 대해 대답 할 수 있어야 합니다. 그리고 또한 사업을 성공시킬 핵심동력도 마찬가지로 파악해야 합니다. 이를 파악하기 위한 방법은 ‘우리가 여기에 무엇을 걸고 있는가’ 를 묻는 것입니다. 이렇게 가설을 망치거나 달성할 요소를 명확하게 파악한다면, 가설 테스트를 위한 초점을 맞추는데 도움을 줍니다. ¶자원을 모아라 가설을 테스트 하기 위해서는, 당연한 이야기 이지만 자원이 필요합니다. 여기에는 현금, 장비, 부동산 뿐만 아니라 지적자산, 네트워크, 파트너와의 관계, 유통능력 같은 무형자산도 포함됩니다. 자원을 만들어내는 것은 어렵습니다. 그렇기 때문에 이러한 자원을 잘 관리하고 통제하기 위하여 반복적으로 실험해야 합니다. 다음 실험을 위한 자원을 모아라. 기업의 경영을 반복적인 실험으로 틀을 잡는 것은 얼마나 많은 돈을 모아야 하는 지에 대한 방법론을 제공합니다. 다음 번에 실행될 실험을 위하여 충분한 자금을 항상 구축해 두어야 하며, 우발상황 또한 대비해야 합니다. 가설 증명에 따른 실험에 실패하면 투자를 제한하고, 성공한다면 다음 라운드에서 더 높은 평가를 받기 위해 투자자들을 유혹할 수 있습니다. 이렇게 항상 다음 실험을 위한 자금을 확보하는 행동은 그 다음 실험이 성공을 하든 실패를 하든 지간에 기업이 생존할 수 있는 원동력을 제공할 것입니다. 핵심인력을 고용하기 전에 비즈니스 모델을 안정화 시켜라. 인력을 고용한다는 것은 비즈니스 모델을 만드는데 기여하지 않았던 사람이 들어 온다는 것을 의미합니다. 때문에, 이러한 고용이 더 늦을 수록 안정된 사업모델을 만들 확률이 큽니다. 핵심인력을 너무 일찍 고용한다면 잘못된 비즈니스 모델에 인력을 끌어들이거나, 가설을 수정하지 못하는 위험에 빠질 수 있습니다. 따라서 초기 가설 실험 반복 과정에서 필요한 것은 핵심인력이 아닌 열정과 유연함 입니다. 시험에 핵심적인 요소 이외의 것은 아웃소싱해라. 기업과 경영자는 그들의 제한적인 자원을 불확실성을 감소시키는 가설을 증명하는 실험에 집중해야 합니다. 그리고 이러한 실험외의 것은 가능하다면 아웃소싱해야 합니다. 그러나 많은 기업들이 가설외의 것들도 무모하게 관리하려하거나, 무모하게 수많은 기업들과 파트너를 맺으려 합니다. 핵심이 되는 실험에 집중하기 위해 나머지의 것에 파트너를 맺는다면, 기업가와 관리자 모두 균형을 잡을 수 있습니다. ¶실험을 디자인하고 실행하는 방법 앞서 가설을 만들고, 이를 테스트하기 위한 자원을 모았다면, 기업가들은 철저하게 이를 현실세계에서 실험해 보아야 합니다. 누차 강조하지만, 실험이란 것은 추가 자원을 투입하기 전에 새로운 모험의 성공에 있을 불확실성의 원천을 줄이기 위한 것입니다. 실험 결과에 기초하여 가설을 수정하거나, 다른 실험을 실행하거나, 만들어진 가치를 수확할 수 도 있습니다. 부분실험. 부분실험은 불확실성의 불확실성의 단일 원천에 대한 중요한 정보를 제공합니다. 이 실험은 미지의 정보가 관련되어 있고, 정보를 얻는데 드는 가치와 비용을 정량화 할 수 있을 때 빛을 볼 수 있습니다. 또한 큰 베팅을 하기전에 테스트 하는 데도 부분적인 실험이 도움을 줍니다. 전체실험. 부분실험과는 대조적으로, 전체 실험은 여러변수와 그들 사이의 상호작용을 작은 규모로 동시에 실험하는 것을 의미합니다. 본격적으로 광범위하게 적용하기 전에 프로토타입을 만들어 보는 것이 예가 될 수 있습니다. 이는 미지의 것을 밝히는데 효과를 발휘하고, 사업 운영을 확장하기전에 비즈니스 모델을 테스트하고 수정하는데 도움을 줍니다. 단계별 실험. 값 비싼 전체적인 실험하기에 앞서, 비교적 저렴한 실험부터 단계적으로 시작해야 합니다. 이렇게 단계적으로 실험을 완료했다면, 전체적인 실험에서는 불확실성을 비롯하여 모든 중요한 요소들과 함께 실험하는 것이 중요합니다. 실험이 더뎌지는 것을 경계해라. 실험이 더뎌진다는 것은, 실험이 너무 오래 지체되거나, 비용이 과하게 들거나, 실험하려는 것에 대한 불확실성이 명확하지 않을 때 발생합니다. 이는 사람들이 성공에 대한 기득권을 갖게 되거나,객관성을 잃거나, 유리한 조건으로 결과를 변경하려고 할 때 발생하는 문제입니다. 기업가들은 앞으로 겪게될 무수한 좌절을 극복하기 위해 열정, 낙관적인 사고, 지속성을 유지해야 하기 때문에 이러한 문제는 굉장히 까다롭습니다. 이를 방지하기 위해서는 실험을 설계할 때 신중함을 유지해야 합니다. 그리고 실험의 설계 부터 결과에 이르는 모든 과정에 외부 참여자를 적극 유도하는 것도 좋은 방법입니다.","categories":[],"tags":[{"name":"entrepreneruship","slug":"entrepreneruship","permalink":"https://www.yceffort.kr/tags/entrepreneruship/"}]},{"title":"Computer Vision 01) - Image Representation","slug":"computer-vision-1-image-representation","date":"2019-03-31T15:00:00.000Z","updated":"2019-04-01T00:35:16.000Z","comments":true,"path":"2019/04/01/computer-vision-1-image-representation/","link":"","permalink":"https://www.yceffort.kr/2019/04/01/computer-vision-1-image-representation/","excerpt":"¶Image Representation & Classification ¶Images as Grids of Pixels 1 2 3 4 5 6 7 8 9 10 import numpy as np from skimage import io import matplotlib.image as mpimg import matplotlib.pyplot as plt import cv2 import urllib %matplotlib inline 먼저 이미지를 불러온다. 1 2 3 4 5 waymo_car_url = 'https://zdn","text":"¶Image Representation &amp; Classification ¶Images as Grids of Pixels 12345678910import numpy as npfrom skimage import ioimport matplotlib.image as mpimgimport matplotlib.pyplot as pltimport cv2import urllib%matplotlib inline 먼저 이미지를 불러온다. 12345waymo_car_url = 'https://zdnet2.cbsistatic.com/hub/i/r/2018/01/22/e270d68c-c028-421a-bc5b-5d2a9a9458d1/resize/770xauto/50e9d2f0fc86841ba455489d50651291/google-waymo-self-driving-atlanta.png'f = urllib.request.urlopen(waymo_car_url)image = mpimg.imread(f)print('Image dimensions:', image.shape) 1Image dimensions: (410, 770, 4) 123# 이미지를 회색으로 바꾼다.gray_image = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)plt.imshow(gray_image, cmap='gray') 12345# 특정 좌표의 grayscalex = 400y = 300print(gray_image[y,x]) 10.543404 1234567# 맥시멈 / 미니멈 grayscalemax_val = np.amax(gray_image)min_val = np.amin(gray_image)print('Max: ', max_val)print('Min: ', min_val) 12Max: 0.9646824Min: 0.040556863 ¶RGB colorspace 1plt.imshow(image) 1234## 각각의 RGB영역 확보r = image[:,:,0]g = image[:,:,1]b = image[:,:,2] 1234567fx, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(20,10))ax1.set_title('R channel')ax1.imshow(r, cmap='gray')ax2.set_title('G channel')ax2.imshow(g, cmap='gray')ax3.set_title('B channel')ax3.imshow(b, cmap='gray') ¶Color Threshold, Bluescreen 파란색 크로마키에 있는 사진을 합성하는 과정이다. 1234cromakey_blue = 'https://ak5.picdn.net/shutterstock/videos/548875/thumb/1.jpg'f = urllib.request.urlopen(cromakey_blue)image = mpimg.imread(f, 0)print('This image is:', type(image), 'with dimensions:', image.shape) 1This image is: &lt;class &apos;numpy.ndarray&apos;&gt; with dimensions: (480, 852, 3) 12345678# 이미지 복사image_copy = np.copy(image)# BGR이미지를 RGB로 변환image_copy = cv2.cvtColor(image_copy, cv2.COLOR_BGR2RGB)# 복사된 이미지 보여주기plt.imshow(image_copy) 12345678lower_blue = np.array([0,0,200]) upper_blue = np.array([250,250,255])# 마스킹될 영역을 선택한다.mask = cv2.inRange(image, lower_blue, upper_blue)# 마스킹 이미지 표시plt.imshow(mask, cmap='gray') 12345# 이미지를 카피한다음masked_image = np.copy(image_copy)# 마스킹 영역을 제외하고 모두 검정색으로 바꾼다면masked_image[mask != 0] = [0, 0, 0]plt.imshow(masked_image) 효과적으로 파란색 영역을 제거한 것을 알 수 있다. 여기에 배경을 합성해보자. 12345678910space_url = 'https://images.unsplash.com/photo-1496715976403-7e36dc43f17b?ixlib=rb-1.2.1&amp;w=1000&amp;q=80'sf = urllib.request.urlopen(space_url)image = np.asarray(bytearray(sf.read()), dtype=\"uint8\")background_image = cv2.imdecode(image, cv2.IMREAD_COLOR)background_image = cv2.cvtColor(background_image, cv2.COLOR_BGR2RGB)crop_background = background_image[0:480, 0:852]# 이번엔 반대로 마스킹 해야할 영역을 검정색으로 처리한다.crop_background[mask == 0] = [0, 0, 0]plt.imshow(crop_background) 123# 두 이미지를 합치면complete_image = masked_image + crop_backgroundplt.imshow(complete_image)","categories":[],"tags":[{"name":"computer-vision","slug":"computer-vision","permalink":"https://www.yceffort.kr/tags/computer-vision/"}]},{"title":"Deep Learning 01) - Neuron","slug":"deep-learning-1-neuron","date":"2019-03-04T15:00:00.000Z","updated":"2019-03-05T09:08:28.000Z","comments":true,"path":"2019/03/05/deep-learning-1-neuron/","link":"","permalink":"https://www.yceffort.kr/2019/03/05/deep-learning-1-neuron/","excerpt":"Deep Learning 01) Neuron ¶Neron 뉴런은 딥러닝의 핵심이 되는 개념이다. 뉴론 하나 자체로는 별다른 기능을 할 수 없지만, 여러개의 뉴런이 모여야 진정하게 기능을 할 수 있다. 일단 뉴런의 구조를 살펴보자. 뉴런은 보이는 것처럼 n개의 input signal을 받아서 output signal을 내보내는 구조를 가지고 있다. input value는 독립변수이며, 이를 받아서 어떻게 output을 내보낼 것인가가 핵심이다. 일단 이러한 input value들의 값은 특성에 따라 제각각 일 것이므로, 일반","text":"Deep Learning 01) Neuron ¶Neron 뉴런은 딥러닝의 핵심이 되는 개념이다. 뉴론 하나 자체로는 별다른 기능을 할 수 없지만, 여러개의 뉴런이 모여야 진정하게 기능을 할 수 있다. 일단 뉴런의 구조를 살펴보자. 뉴런은 보이는 것처럼 n개의 input signal을 받아서 output signal을 내보내는 구조를 가지고 있다. input value는 독립변수이며, 이를 받아서 어떻게 output을 내보낼 것인가가 핵심이다. 일단 이러한 input value들의 값은 특성에 따라 제각각 일 것이므로, 일반적으로 표준화하여 0과 1사이에서 존재하도록 처리한다. 이렇게 처리된 input value 에는 가중치 (weight)를 각각 적용한다. 이는 이 input value가 결과에 얼마나 영향을 미치는지 결정하게 되는데, 이 weight값은 값을 예측하는 과정에서 점차 보정이 이루어진다. output value는 연속적인 값이 될수도, binary한 값이 될수도, categorical한 값이 될 수 있다. 이는 우리가 무엇을 예측하려고 하느냐에 따라 다르다. ¶Weight weight은 nerual network에서 굉장히 중요한 부분이다. nerual network에서 weight을 조정하면서 뉴런은 이 값들을 어떻게 가중치를 가해서 결과 값을 냘지 결정한다. 그리고 이 weight 을 조정하는 과정을 학습하는 과정이라고 볼 수 있다. wiehgt을 조정하면서, 어떤 input이 중요한지, 덜 중요한지를 판단하게 된다. 이 weight을 조정하는 과정이 전체 neural network에서 이뤄지게 되며, 이를 위해서 나중에 설명할 gradient descent나 backpropagation이 이뤄지게 된다. ¶뉴런안에서는 무슨일이 일어날까? 모든 input value에 각각의 가중치를 곱한 값을 합한다. $$ \\sum_{i=1}^{m} WiXi $$ activation function을 적용한다. $$ \\text{Activation Function}(\\sum_{i=1}^{m} WiXi) $$ activation function, 활성함수는 1번에서 처리된 값을 어떻게 내보낼지 결정하는 함수다. 이 함수들은 주로 비선형 함수이다. (선형함수는 아무리 여러 계층을 쌓아봐야 결국 선형함수일 뿐이므로, 즉 층을 깊게하는 의미가 없어지므로) 이 활성함수의 종류에 대해서는 나중에 다루도록 한다. 다음 neuron으로 값을 전달한다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Deep Learning 03) - How do neural networks work/learn?","slug":"deep-learning-3-how-do-nn-work","date":"2019-03-04T15:00:00.000Z","updated":"2019-03-05T10:43:15.000Z","comments":true,"path":"2019/03/05/deep-learning-3-how-do-nn-work/","link":"","permalink":"https://www.yceffort.kr/2019/03/05/deep-learning-3-how-do-nn-work/","excerpt":"How do neural networks work/learn? ¶신경망은 어떻게 동작하는가? 다양한 정보를 바탕으로 부동산 가격을 예측하는 일을 해보도록 하자. 가장 일반적으로 할 수 있는 접근은, 각각의 데이터에 적절한 가중치를 적용한 값을 바탕으로 가격을 예측하는 것이다. 여기에는 여러가지 방식이 적용될 수 있다. Regression이 될 수도 있고, 대부분의 머신러닝 알고리즘이 여기에 해당 될 것이다. 즉, 히든레이어가 없어도 어떻게서든 적절한 output을 찾아내는 것은 가능할 것이다. 하지만 신경망은 Hidden l","text":"How do neural networks work/learn? ¶신경망은 어떻게 동작하는가? 다양한 정보를 바탕으로 부동산 가격을 예측하는 일을 해보도록 하자. 가장 일반적으로 할 수 있는 접근은, 각각의 데이터에 적절한 가중치를 적용한 값을 바탕으로 가격을 예측하는 것이다. 여기에는 여러가지 방식이 적용될 수 있다. Regression이 될 수도 있고, 대부분의 머신러닝 알고리즘이 여기에 해당 될 것이다. 즉, 히든레이어가 없어도 어떻게서든 적절한 output을 찾아내는 것은 가능할 것이다. 하지만 신경망은 Hidden layer를 활용한다는 것이 다르다. 그리고 이는 예측하는데 있어서 조금더 유연함을 제공해준다. 위의 그림에서는 hidden layer들이 존재한다. 그리고 각각의 hidden layer들은 서로 다른 파라미터들을 input으로 받으면서, 각자 다른방식으로 추측을 한다. 그리고 이렇게 값을 내보낸 hidden layer들로 최종적으로 결과를 만들어 낸다. 결과적으로, 단 하나의 함수를 적용하는 것보다 다양한 input value와 다양한 가중치를 적용함으로써, deep learning은 학습하는데 있어 조금더 유연함을 가져갈 수 있다. ¶어떻게 신경망이 학습하는가? 위와 같은 뉴런(이제 퍼셉트론이라고 칭하겠다.)이 있다고 가정하자. activation function을 통해 특정 값이 나왔을 것이고, 우리는 이를 $$\\hat{y}$$라고 부른다. 실제값인 $$y$$와는 차이가 있을 것이다. 여기에서 이 차이를 계산하는 함수를 cost function이라고 부른다. 물론 이 cost function에도 여러종류가 있다. 아무튼, 이 cost function에서 나오는 값이 작을 수록 정확한 값을 예측했다고 할 수 있을 것이다. cost function을 통해서 전달 받은 값은 다시 퍼셉트론으로 돌아간다. 그리고 이 값을 바탕으로 weight를 업데이트 하게 된다. 위 그림에서 보이느 8개의 퍼셉트론은 하나의 같은 퍼셉트론이다. 첫 epoch에서 8개의 데이터로 학습을 한 뒤에 cost function으로 전체 error를 구해낸다. 그리고 그 값을 바탕으로 w1, w2, w3를 업데이트 해나가면서 cost를 점차 줄여나간다. 이 과정을 정해진 epoch동안 반복해 나가면서 cost를 줄여나가게 된다. 그리고 이 과정을 backpropagation (역전파)이라고 한다. 참고자료 ¶Gradient Descent 그렇다면 정확히 어떻게 weight가 조정되는 것일까? weight값을 무작위로 마구잡이로 집어 넣어서 (brute force) 최소값을 찾아낸다고 가정해보자. 그렇게 한다면 위와 같은 형태가 될 것이다. $$ \\frac{1}{m} \\sum_{i=1}^{m}((\\hat{y} - y))^2 $$ 분명 어느지점에서는 cost가 최소화 될 것이고, 우리는 저 지점을 찾는 것을 목표로 한다. 그러나 신경망은 수많은 퍼셉트론을 가지고 있기 때문에, 이와 연결되는 weight도 엄청나게 많을 것이다. 따라서 이 모든 값들을 무작위로 때려 넣어서 맞춘다는 것은 사실상 불가능하다. 그래서 사용하는 것이 Gradient descent 다. 첫 weight로 위의 지점에서 cost를 구했다고 가정하자. 해당 지점에서 기울기를 구하고, 그 지점에서의 기울기가 양라면 (미분해서) 오른쪽은 오르막, 왼쪽은 내리막이라는 뜻이므로 왼쪽으로 간다. 반대로 기울기가 음이라면 오른쪽이 내리막, 왼쪽이 오르막이라는 뜻이므로 오른쪽으로 간다. 이 과정을 반복해서 점차 가장 낮은 곳을 찾아나가는 것이다. 이 과정에서, 움직이는 값이 너무 크다면, 영영 최소점을 찾지 못할 것이고, 반대로 너무 작다면 최소점을 찾는데 너무 오랜 시간이 걸릴 것이다. ¶Stochastic Gradient Descent 위에서 본 예제에서는 cost function 이 convex한 모양을 가지고 있었기 때문에 가능했다. 최소점도 단 하나여서 찾기 쉽다. 만약 cost function 을 바꾸거나, 다차원의 형태를 띄고 있다면, 아마도 cost function의 모양은 저런 모양이 될 것이다. 이경우에는 최적의 최저점을 찾지 못하게 될 수도 있다. 그래서 사용하는 것이 Stocahstic Gradient desecent(이하 SGD)다. SGD는 모든 데이터를 바탕으로 weight를 조정하는 것이 아니라, 데이터를 나눠서 gradient desecent를 적용하는 것이다. 이렇게 함으로써 국소최저점에 빠지는 것을 방지할 수 있고, 더빠르게 연산해 낼 수 있다. 요약하자면, batch형태로 하나의 데이터셋 전체로 Gradient Descent 하는 것이 아니고, mini-batch 형태로 데이터를 쪼개서 Gradient Descent하는 것이라 할 수 있다. 참고1 참고2 ¶신경망이 작동하는 과정 가중치를 0에 가까운 작은수로 랜덤하게 설정한다. input layer 각각의 노드에 데이터를 집어 넣는다. Foward Propagataion - 순전파: 각각의 퍼셉트론이 주어진 가중치에 따라서 activation여부를 결정한다. 이 과정은 output layer에서 결과가 나올때까지 지속된다. 실제 결과와 신경망이 예측한 결과를 비교한다. 그리고 이 두값을 바탕으로 에러를 산출해낸다. Back Progatation - 역전파: 3번의 과정을 반대로 진행한다. 4번에서 나온 에러값을 바탕으로 각각의 가중치가 얼마나 에러에 책임이 있는지를 계산한 후에, 각중치를 업데이트 한다. learning rate가 얾라나 가중치를 업데이트 할지 결정하게 된다. 1번에서 5번과정을 각 observation마다 반복하거나 (Reinforcement Learning) batch크기만큼 반복 (Batch Learning) 모든 training set에서 한번 거치는 이 과정을 epoch이라고 한다. epoch을 설정한 수치만큼 반복한다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Deep Learning 02) - Activation Function","slug":"deep-learning-2-activation-function","date":"2019-03-04T15:00:00.000Z","updated":"2019-03-05T09:41:30.000Z","comments":true,"path":"2019/03/05/deep-learning-2-activation-function/","link":"","permalink":"https://www.yceffort.kr/2019/03/05/deep-learning-2-activation-function/","excerpt":"Deep Learning 02) Activation Function ¶Activation Function 활성화 함수 활성화 함수는 가중치가 더해진 input value를 어떻게 처리할 것인지 결정하는 함수다. 이러한 활성화 함수에는 몇가지 종류가 있다. ¶1. Threshold Function $$ 1 f x \\geq 0 $$ $$ 0 f x < 0 $$ 매우매우 간단한 형태의 함수다. ¶2. Sigmoid Function $$ \\frac{1}{1 + e^{-x}}$$ 위 함수와 다르게 부드러운 형태를 띄고","text":"Deep Learning 02) Activation Function ¶Activation Function 활성화 함수 활성화 함수는 가중치가 더해진 input value를 어떻게 처리할 것인지 결정하는 함수다. 이러한 활성화 함수에는 몇가지 종류가 있다. ¶1. Threshold Function $$ 1 f x \\geq 0 $$ $$ 0 f x &lt; 0 $$ 매우매우 간단한 형태의 함수다. ¶2. Sigmoid Function $$ \\frac{1}{1 + e^{-x}}$$ 위 함수와 다르게 부드러운 형태를 띄고 있다. 0과 1을 구분하는 곳은 경사가 급하고, 나머지 부분에서는 경사가 매우 완만하다. 이 함수는 결과값으로 확률을 구해야할 때 굉장히 유용하게 사용되고 있다. ¶3. ReLU $$ \\text{max}(0, x) $$ 딥러닝에서 가장 유명한 활성화 함수중 하나다. 0이하의 값에서는 0을, 0이상에서는 x의 값을 그대로 가져간다. 다른함수에 비해 속도가 빠르고, 구현도 쉽고 따라서 연산비용도 저렴해서 많이 애용하는 함수다. 그러난 x가 0보다 작아지면 그 값을 모두 무시해버리기 때문에 (0으로 처리하기 때문에) 뉴런이 죽어버릴수도 있다는 단점이 존재한다. ¶4. tanh $$ \\frac{1 - e^{-2x}}{1+e^{-2x}} $$ 시그모이드와 비슷하게 생긴 쌍곡선 함수다. sigmoid가 중간값이 $$\\frac{1}{2}$$인데 반에 이 함수는 중간값을 0으로 옮겨왔다. 따라서 값이 다른 함수와는 다르게 -1에서 1사이에서 형성된다. 참고논문: Deep Sparse Rectifier Neural Networks","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch 09) - Transfer Learning","slug":"pytorch-09-transfer-learning","date":"2019-02-25T15:00:00.000Z","updated":"2019-02-26T05:17:54.000Z","comments":true,"path":"2019/02/26/pytorch-09-transfer-learning/","link":"","permalink":"https://www.yceffort.kr/2019/02/26/pytorch-09-transfer-learning/","excerpt":"Pytorch - 09) Transfer Learning ¶Transfer Learning 기존에 만들어진 모델을 이용하여, 새로운 모델이 조금더 빠르게 학습하고 예측을 더 높이는 방법이다. 실질적으로, CNN을 처음부터 학습시키는 일은 많지 않다. 이 모델은 고려해야할 사항이 많고, (Layer의 숫자, 활성화함수의 종류, 기타 hyper parameter 등) 실질적으로 학습을 시키기 위해서는 엄청난 자원과 시간이 소비되기 때문이다. 그래서 기존에 학습되어 있는 모델을 바탕으로 새로운 모델을 만들어 학습하는 것을 transf","text":"Pytorch - 09) Transfer Learning ¶Transfer Learning 기존에 만들어진 모델을 이용하여, 새로운 모델이 조금더 빠르게 학습하고 예측을 더 높이는 방법이다. 실질적으로, CNN을 처음부터 학습시키는 일은 많지 않다. 이 모델은 고려해야할 사항이 많고, (Layer의 숫자, 활성화함수의 종류, 기타 hyper parameter 등) 실질적으로 학습을 시키기 위해서는 엄청난 자원과 시간이 소비되기 때문이다. 그래서 기존에 학습되어 있는 모델을 바탕으로 새로운 모델을 만들어 학습하는 것을 transfer learning이라고 한다. ¶언제 써야 하는가? Labeled 된 data 가 많지 않을 때 (학습시킬 데이터가 많지 않을 때) 효과적으로 훈련된 모델이 이미 존재할 때 ¶AlexNet 2012년 ImageNet Large Scale Visual Recognition Challenge에서 우승한 팀 논문의 첫번째 저자가 Alex 머시기 인데, 그 사람의 이름을 따서 개발한 CNN을 AlexNet이라 한다. 구조적인 관점에서는 LeNet과 크게 다르지 않지만, GPU를 사용하여 의미있는 결과를 얻었다. 이후 연구자들은 CNN구조를 설계 할 때 GPU를 고려하는 것이 유행처럼 번졌다. 총 5개의 Convolutional Layer와 3개의 fully-connected layer로 구성되어 있으며, 맨마지막 1000개의 category분류를 위해 Softmax를 사용한다. 이렇게 만들어진 AlexNet은 65만개의 perceptron, 6000만개의 parameter와 6억 3천만개의 connection으로 구성되어 있다. LeNet은 32x32크기의 흑백영상이라 크기가 매우작았찌만, AlexNet은 227x227x3로 구성되어 있기 때문에, 첫번째 kernel의 크기가 11x11x3으로 크다. (stride=4) 결과적으로 96개의 필터를 생성하기 때문에 결과는 55x55x96이 된다. 아무튼 위와 같은 구조다. ¶VGG16 주요 특징은 아래와 같다. 입력: 224*224 크기의 고정된 RGB 이미지 구조: Convoluitional Layer (3x3 filter, stride=1, padding=True) Max-Pooling Layer (2x2 filtter, stride=2) 1x1 Conv Layer (1x1 filter, stride=1) Fully Connected Layer (4096 &gt; 4096 &gt; 1000) 특징: 모든 레이어에 3x3 필터 적용 1x1 Conv Layer 사용 다섯장의 Max-Pooling Layer 사용 ¶코드 123456789import torchimport matplotlib.pyplot as pltimport numpy as npimport torch.nn.functional as Ffrom torch import nnfrom torchvision import datasets, transforms, modelsmodel = models.alexnet(pretrained=True)model 1234567891011121314151617181920212223242526AlexNet( (features): Sequential( (0): Conv2d(3, 64, kernel_size=(11, 11), stride=(4, 4), padding=(2, 2)) (1): ReLU(inplace) (2): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False) (3): Conv2d(64, 192, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2)) (4): ReLU(inplace) (5): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False) (6): Conv2d(192, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): ReLU(inplace) (8): Conv2d(384, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (9): ReLU(inplace) (10): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (11): ReLU(inplace) (12): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False) ) (classifier): Sequential( (0): Dropout(p=0.5) (1): Linear(in_features=9216, out_features=4096, bias=True) (2): ReLU(inplace) (3): Dropout(p=0.5) (4): Linear(in_features=4096, out_features=4096, bias=True) (5): ReLU(inplace) (6): Linear(in_features=4096, out_features=1000, bias=True) )) AlexNet의 구조가 나온다. 12for params in model.features.parameters(): params.requires_grad = False 여기에서 feature exrtaction부분은 이미 train 된 부분 이므로, 따로 역전파를 하는 과정에서 gradient를 계산할 필요가 없다. 따라서 위의 코드가 꼭 필요하다. 그리고 우리가 할 것은 딱 두개, 개미와 벌을 구별하는 것이므로 https://github.com/jaddoescad/ants_and_bees.git 마지막 out을 2로 맞출 필요가 있다. 1234567import torch.nn as nnn_inputs = model.classifier[-1].in_featureslast_layer = nn.Linear(n_inputs, len(classes))model.classifier[-1] = last_layermodel 1234567891011121314151617181920212223242526AlexNet( (features): Sequential( (0): Conv2d(3, 64, kernel_size=(11, 11), stride=(4, 4), padding=(2, 2)) (1): ReLU(inplace) (2): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False) (3): Conv2d(64, 192, kernel_size=(5, 5), stride=(1, 1), padding=(2, 2)) (4): ReLU(inplace) (5): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False) (6): Conv2d(192, 384, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (7): ReLU(inplace) (8): Conv2d(384, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (9): ReLU(inplace) (10): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1)) (11): ReLU(inplace) (12): MaxPool2d(kernel_size=3, stride=2, padding=0, dilation=1, ceil_mode=False) ) (classifier): Sequential( (0): Dropout(p=0.5) (1): Linear(in_features=9216, out_features=4096, bias=True) (2): ReLU(inplace) (3): Dropout(p=0.5) (4): Linear(in_features=4096, out_features=4096, bias=True) (5): ReLU(inplace) (6): Linear(in_features=4096, out_features=2, bias=True) )) 이제 훈련시켜 보자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748===================================================epoch: 1training loss: 0.03956, acc: 0.573770validation loss: 0.01909, acc: 0.836601===================================================epoch: 2training loss: 0.03207, acc: 0.733607validation loss: 0.01858, acc: 0.843137===================================================epoch: 3training loss: 0.02075, acc: 0.774590validation loss: 0.01699, acc: 0.869281===================================================epoch: 4training loss: 0.02153, acc: 0.778688validation loss: 0.01905, acc: 0.862745===================================================epoch: 5training loss: 0.02300, acc: 0.774590validation loss: 0.02242, acc: 0.856209===================================================epoch: 6training loss: 0.01945, acc: 0.840164validation loss: 0.01588, acc: 0.882353===================================================epoch: 7training loss: 0.01738, acc: 0.836066validation loss: 0.01681, acc: 0.908497===================================================epoch: 8training loss: 0.01634, acc: 0.840164validation loss: 0.01626, acc: 0.888889===================================================epoch: 9training loss: 0.01587, acc: 0.844262validation loss: 0.01711, acc: 0.888889===================================================epoch: 10training loss: 0.01863, acc: 0.807377validation loss: 0.01947, acc: 0.888889===================================================epoch: 11training loss: 0.01724, acc: 0.856557validation loss: 0.01790, acc: 0.882353===================================================epoch: 12training loss: 0.01554, acc: 0.864754validation loss: 0.02125, acc: 0.869281 데이터 자체가 작아서 그래프가 요상한 모양이지만, 데이터가 작은 것 치고도 정확하게 분류했다. 마찬가지 방법으로 vgg16을 적용할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748===================================================epoch: 1training loss: 0.02633, acc: 0.733607validation loss: 0.01347, acc: 0.901961===================================================epoch: 2training loss: 0.01908, acc: 0.856557validation loss: 0.01464, acc: 0.921569===================================================epoch: 3training loss: 0.01473, acc: 0.901639validation loss: 0.01444, acc: 0.915033===================================================epoch: 4training loss: 0.01205, acc: 0.885246validation loss: 0.01606, acc: 0.908497===================================================epoch: 5training loss: 0.00824, acc: 0.913934validation loss: 0.02344, acc: 0.901961===================================================epoch: 6training loss: 0.01456, acc: 0.864754validation loss: 0.02176, acc: 0.888889===================================================epoch: 7training loss: 0.01378, acc: 0.864754validation loss: 0.01917, acc: 0.915033===================================================epoch: 8training loss: 0.00952, acc: 0.909836validation loss: 0.02024, acc: 0.921569===================================================epoch: 9training loss: 0.00945, acc: 0.918033validation loss: 0.02147, acc: 0.901961===================================================epoch: 10training loss: 0.01164, acc: 0.918033validation loss: 0.02123, acc: 0.921569===================================================epoch: 11training loss: 0.00972, acc: 0.897541validation loss: 0.01810, acc: 0.941176===================================================epoch: 12training loss: 0.00840, acc: 0.922131validation loss: 0.03352, acc: 0.882353 VGG16이 더 정확한 모습을 보였다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch 08) - CIFAR 10 학습","slug":"pytorch-08-CIFAR-10","date":"2019-02-24T15:00:00.000Z","updated":"2019-02-25T00:03:38.000Z","comments":true,"path":"2019/02/25/pytorch-08-CIFAR-10/","link":"","permalink":"https://www.yceffort.kr/2019/02/25/pytorch-08-CIFAR-10/","excerpt":"Pytorch - 08) CIFAR 10 CIFAR 10 는 열가지 단어별 이미지가 있는 데이터 셋이다. 기존에 손글씨를 분류하는 것 보다는 확실히 어려운 작업이 될 것이다. ¶전처리 작업 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import torch import matplotlib.pyplot as plt import numpy as np from torch import","text":"Pytorch - 08) CIFAR 10 CIFAR 10 는 열가지 단어별 이미지가 있는 데이터 셋이다. 기존에 손글씨를 분류하는 것 보다는 확실히 어려운 작업이 될 것이다. ¶전처리 작업 1234567891011121314151617181920212223242526272829303132333435363738import torchimport matplotlib.pyplot as pltimport numpy as npfrom torch import nnfrom torch.nn import functional as Ffrom torchvision import datasets, transformstransformer = transforms.Compose([transforms.Resize((32, 32)), transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)) ])training_dataset = datasets.CIFAR10(root='./data', train=True, download=True, transform=transformer)validation_dataset = datasets.CIFAR10(root='./data', train=False, download=True, transform=transformer)training_loader = torch.utils.data.DataLoader(dataset=training_dataset, batch_size=100, shuffle=True)validation_loader = torch.utils.data.DataLoader(dataset=validation_dataset, batch_size=100, shuffle=False)def im_convert(tensor): image = tensor.clone().detach().numpy() image = image.transpose(1, 2, 0) image = image * np.array([0.5, 0.5, 0.5] + np.array([0.5, 0.5, 0.5])) image = image.clip(0, 1) return imageclasses = (\"plane\", \"car\", \"bird\", \"cat\", \"deer\", \"dog\", \"frog\", \"horse\", \"ship\", \"truck\")dataiter = iter(training_loader)images, labels = dataiter.next()fig = plt.figure(figsize=(25, 4))for i in np.arange(20): # row 2 column 10 ax = fig.add_subplot(2, 10, i+1, xticks=[], yticks=[]) plt.imshow(im_convert(images[i])) ax.set_title(classes[labels[i].item()])CIFA ¶Optimizer 와 Criterion 12criterion = nn.CrossEntropyLoss()optimizer = torch.optim.Adam(model.parameters(), lr=0.001) ¶training 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061epochs = 12running_loss_history = []running_correct_history = []validation_running_loss_history = [] validation_running_correct_history = []for e in range(epochs): running_loss = 0.0 running_correct = 0.0 validation_running_loss = 0.0 validation_running_correct = 0.0 for inputs, labels in training_loader: inputs = inputs.to(device) labels = labels.to(device) outputs = model(inputs) loss = criterion(outputs, labels) optimizer.zero_grad() loss.backward() optimizer.step() _, preds = torch.max(outputs, 1) running_correct += torch.sum(preds == labels.data) running_loss += loss.item() else: # 훈련팔 필요가 없으므로 메모리 절약 with torch.no_grad(): for val_input, val_label in validation_loader: val_input = val_input.to(device) val_label = val_label.to(device) val_outputs = model(val_input) val_loss = criterion(val_outputs, val_label) _, val_preds = torch.max(val_outputs, 1) validation_running_loss += val_loss.item() validation_running_correct += torch.sum(val_preds == val_label.data) epoch_loss = running_loss / len(training_loader) epoch_acc = running_correct.float() / len(training_loader) running_loss_history.append(epoch_loss) running_correct_history.append(epoch_acc) val_epoch_loss = validation_running_loss / len(validation_loader) val_epoch_acc = validation_running_correct.float() / len(validation_loader) validation_running_loss_history.append(val_epoch_loss) validation_running_correct_history.append(val_epoch_acc) print(\"===================================================\") print(\"epoch: \", e + 1) print(\"training loss: &#123;:.5f&#125;, acc: &#123;:5f&#125;\".format(epoch_loss, epoch_acc)) print(\"validation loss: &#123;:.5f&#125;, acc: &#123;:5f&#125;\".format(val_epoch_loss, val_epoch_acc)) ¶1st try LeNet을 활용하여, 기존에 손글씨를 분류했을 때 썼던 파라미터 그대로 해보자. ¶Model 123456789101112131415161718192021222324class LeNet(nn.Module): def __init__(self): super().__init__() # RGB세개 1채널, 20개 특징 추출, filter 크기, stride 1 self.conv1 = nn.Conv2d(3, 20, 5, 1) # 전에서 20개 self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(5*5*50, 500) # 0.5 가 권장 할 만하대 self.dropout1 = nn.Dropout(0.5) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) # flatten x = x.view(-1, 5*5*50) x = F.relu(self.fc1(x)) x = self.dropout1(x) x = self.fc2(x) return x ¶결과 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748===================================================epoch: 1training loss: 1.51251, acc: 44.908001validation loss: 1.27473, acc: 54.189999===================================================epoch: 2training loss: 1.16539, acc: 58.480003validation loss: 1.07463, acc: 61.829998===================================================epoch: 3training loss: 1.00764, acc: 64.464005validation loss: 1.04436, acc: 63.349998===================================================epoch: 4training loss: 0.90411, acc: 68.162003validation loss: 0.96203, acc: 66.619995===================================================epoch: 5training loss: 0.82512, acc: 71.142006validation loss: 0.92654, acc: 67.889999===================================================epoch: 6training loss: 0.76343, acc: 73.138000validation loss: 0.90890, acc: 69.029999===================================================epoch: 7training loss: 0.70817, acc: 75.176003validation loss: 0.90005, acc: 69.639999===================================================epoch: 8training loss: 0.66021, acc: 76.596001validation loss: 0.91046, acc: 69.409996===================================================epoch: 9training loss: 0.61744, acc: 78.116005validation loss: 0.91911, acc: 69.799995===================================================epoch: 10training loss: 0.57813, acc: 79.522003validation loss: 0.94296, acc: 69.189995===================================================epoch: 11training loss: 0.53510, acc: 80.990005validation loss: 0.95957, acc: 69.209999===================================================epoch: 12training loss: 0.50244, acc: 82.116005validation loss: 0.98390, acc: 69.419998 ¶총평 딱봐도 Overfitting이 일어났고, 정확도도 구리다. ¶2nd Model Convolution을 하나더 추가해서, 특징을 조금더 뽑아내는 방향으로 바꿔보자. 123456789101112131415161718192021222324class LeNet_2(nn.Module): def __init__(self): super().__init__() # 32px 이었다가, conv를 거치면서 절반으로 감소 self.conv1 = nn.Conv2d(3, 16, 3, 1, padding=1) self.conv2 = nn.Conv2d(16, 32, 3, 1, padding=1) self.conv3 = nn.Conv2d(32, 64, 3, 1, padding=1) self.fc1 = nn.Linear(4*4*64, 500) self.dropout1 = nn.Dropout(0.5) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv3(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4*4*64) x = F.relu(self.fc1(x)) x = self.dropout1(x) x = self.fc2(x) return x 첫번째 Conv에서는 입력채널이 3개, 추출할 filter는 3개이며 filter의 크기는 3, stride는 1이다. 그리고 padding을 1씩 넣어서 크기가 줄어드는 것을 방지했다. 따라서 각각의 convolution을 거칠 때마다 입력값이 절반으로 줄어들게 된다. (MaxPooling 사이즈가 2, 2 이므로) input conv1 pool1 conv2 pool2 conv3 pool3 32 32 16 16 8 8 4 ¶결과 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748===================================================epoch: 1training loss: 1.51715, acc: 44.712002validation loss: 1.25653, acc: 55.230000===================================================epoch: 2training loss: 1.16654, acc: 58.526001validation loss: 1.09924, acc: 60.959999===================================================epoch: 3training loss: 1.02785, acc: 63.822002validation loss: 1.02541, acc: 64.019997===================================================epoch: 4training loss: 0.91954, acc: 67.690002validation loss: 1.01354, acc: 64.529999===================================================epoch: 5training loss: 0.84753, acc: 70.680000validation loss: 0.92927, acc: 67.639999===================================================epoch: 6training loss: 0.79165, acc: 71.830002validation loss: 0.88947, acc: 69.279999===================================================epoch: 7training loss: 0.73852, acc: 73.806000validation loss: 0.92085, acc: 68.559998===================================================epoch: 8training loss: 0.68945, acc: 75.670006validation loss: 0.91607, acc: 68.529999===================================================epoch: 9training loss: 0.64567, acc: 77.178001validation loss: 0.93162, acc: 69.290001===================================================epoch: 10training loss: 0.61021, acc: 78.222000validation loss: 0.89344, acc: 70.389999===================================================epoch: 11training loss: 0.57332, acc: 79.376007validation loss: 0.93702, acc: 70.189995===================================================epoch: 12training loss: 0.53661, acc: 80.696007validation loss: 0.92468, acc: 70.689995 정확도가 향상된 모습이지만, 여전히 Overfitting이 발생하고 있다. ¶3rd try Data Augmentation, 데이터에 인위적인 변화를 주어서 학습이 용이하게 끔 해보자. 1234567891011121314151617181920transform_train = transforms.Compose([transforms.Resize((32, 32)), transforms.RandomHorizontalFlip(), transforms.RandomRotation(10), transforms.RandomAffine(0, shear=10, scale=(0.8, 1.2)), transforms.ColorJitter(brightness=0.2, contrast=0.2, saturation=0.2), transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)) ])transformer = transforms.Compose([transforms.Resize((32, 32)), transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)) ])training_dataset = datasets.CIFAR10(root='./data', train=True, download=True, transform=transform_train)validation_dataset = datasets.CIFAR10(root='./data', train=False, download=True, transform=transformer)training_loader = torch.utils.data.DataLoader(dataset=training_dataset, batch_size=100, shuffle=True)validation_loader = torch.utils.data.DataLoader(dataset=validation_dataset, batch_size=100, shuffle=False) transform_train에 적용된 augmentation을 살펴보자 transforms.RandomHorizontalFlip() 0.5확률로 이미지를 뒤집음 transforms.RandomRotation(10) 10도 이하로 랜덤하게 기울인다. transforms.RandomAffine(0, shear=10, scale=(0.8, 1.2) 기하학(…)에서 쓰이는 아핀변환이다. transforms.ColorJitter(brightness=0.2, contrast=0.2, saturation=0.2) 밝기, 대비, 채도를 랜덤하게 조절한다. ¶결과 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748===================================================epoch: 1training loss: 1.69155, acc: 38.206001validation loss: 1.47858, acc: 46.969997===================================================epoch: 2training loss: 1.39742, acc: 49.534004validation loss: 1.23282, acc: 54.919998===================================================epoch: 3training loss: 1.27040, acc: 54.270004validation loss: 1.14570, acc: 58.629997===================================================epoch: 4training loss: 1.17016, acc: 58.068005validation loss: 1.06811, acc: 61.609997===================================================epoch: 5training loss: 1.11306, acc: 60.408005validation loss: 1.02522, acc: 63.559998===================================================epoch: 6training loss: 1.07079, acc: 61.996002validation loss: 0.98546, acc: 65.559998===================================================epoch: 7training loss: 1.01881, acc: 63.968002validation loss: 0.91596, acc: 68.080002===================================================epoch: 8training loss: 0.98842, acc: 65.208000validation loss: 0.89914, acc: 68.000000===================================================epoch: 9training loss: 0.96484, acc: 65.940002validation loss: 0.88494, acc: 68.619995===================================================epoch: 10training loss: 0.93930, acc: 66.904007validation loss: 0.88999, acc: 68.830002===================================================epoch: 11training loss: 0.91366, acc: 67.650002validation loss: 0.84115, acc: 70.619995===================================================epoch: 12training loss: 0.89831, acc: 68.562004validation loss: 0.83667, acc: 70.750000 어떻게 하면 정확도를 더 올릴 수 있을까~~~?","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch 06) - Convolutional Neural Network (1)","slug":"pytorch-06-convolutional-neural-network(1)","date":"2019-02-20T15:00:00.000Z","updated":"2019-02-21T03:05:35.000Z","comments":true,"path":"2019/02/21/pytorch-06-convolutional-neural-network(1)/","link":"","permalink":"https://www.yceffort.kr/2019/02/21/pytorch-06-convolutional-neural-network(1)/","excerpt":"Pytorch - 06) Convolutional Neural Network (1) ¶Convolutional Neural Network (CNN) ¶Fully Connected Layer의 문제점 Convolutional Neural Network (이하 CNN)은 이미지, 비디오, 텍스트, 사운드를 분류하는 딥러닝에서 가장 많이 사용되는 알고리즘 중 하나다. CNN은 패턴을 찾는데 특히 유용하며, 데이터에서 직접 학습하며, 패턴을 사용하여 이미지를 분류하여 특징을 수동으로 추출할 필요가 없다. 기존 신경망은 인접하는 계층의","text":"Pytorch - 06) Convolutional Neural Network (1) ¶Convolutional Neural Network (CNN) ¶Fully Connected Layer의 문제점 Convolutional Neural Network (이하 CNN)은 이미지, 비디오, 텍스트, 사운드를 분류하는 딥러닝에서 가장 많이 사용되는 알고리즘 중 하나다. CNN은 패턴을 찾는데 특히 유용하며, 데이터에서 직접 학습하며, 패턴을 사용하여 이미지를 분류하여 특징을 수동으로 추출할 필요가 없다. 기존 신경망은 인접하는 계층의 모든 뉴런이 연결되어 있는 fully-connected 구조다. 이전에 28281 짜리 이미지를 학습했을때, 3차원적인 정보는 모두 무시하고 1차원 배열로 변환하여 학습하였다. 이는 공간적인 정보를 모두 잃게 된다. 예를 들어 가까운 픽셀은 값이 비슷하거나, rgb값이 비슷하거나 하는 ㄹ등의 정보가 있을 수 있지만, 1차원으로 쭉 늘어트리게 되면 이러한 정보 (패턴)가 모두 무시되어 버린다. 또한, 큰이미지가 인풋으로 들어오게되면 weight로 설정해야 하는 값이 기하급수적으로 많아지게 되며, 이는 성능저하를 불러온다. ¶Convolution 합성곱연산은, 특징정 크기 (width, height)를 갖는 필터(filter, kernel)를 일정간격(stride)로 이동해가며 입력데이터에 적용하는 것을 의미한다. 원본이미지에서 필터를 곱하는 것을 합성곱(convolution)이라고 한다. 이렇게 주어진 필터를 이미지 전체에 stride에 따라서 적용하면서, 이미지의 특징을 찾아내는 것이다. 이렇게 하게 되면, 해당 필터는 필터가 갖고 있는 특징이 데이터에 있는지 없는지를 검출 해 줄 수 있다. 왼쪽이 곡선의 특징을 찾는 필터라면, 오른쪽과 같은 모양을 필터가 찾아내는 것이라고 보면 된다. 이런 식으로, 쥐의 엉덩이에 있는 곡선의 특징을 이미지에서 찾아내게 되는 것이다. Linear에 비유하자면, weight가 filter가 되는 것이다. 마찬가지로 bias (편향) 도 포함될 것이다. ¶padding cnn을 하기전에, 입력데이터 주변을 특정값으로 채우는 단계로, 이는 주로 입력 데이터와 출력데이터의 크기를 맞추기 위해서 쓴다. 32x32x3의 입력값에서 5x5x3 필터를 적용 시키게 되면, feature map의 크기는 28x28x3이 된다. 이렇게 사이즈가 안 맞는것을 막기 위해서 Padding을 쓴다. 입력데이터 주위에 2의 두께로 0을 둘러 쌓아주면, 36x36x3이 되고, 5x5x3 필터를 적용하더라도 결과값은 32x32x3 로 유지된다. 이러한 패딩은 특징이 유실되는 것을 방지해주고, 또한 과적합도 방지하는 효과가 있다. 주로 0을 적용하는 zero-padding을 쓴다. ¶stride 필터를 적용하는 위치의 간격을 의미한다. stride가 커지면, 당연히 간격이 넓어지므로 출력크기가 작아진다. 위의 이미지에서는 한칸씩 (1의 크기로) stride를 적용하고 있다. ¶출력 크기 계산 입력크기: H, W 필터크기: FH, FW 출력크기: OH, OW 패딩: P 스트라이드 S $$ OH = \\frac{H + 2P - FH}{S} + 1 $$ $$ OW = \\frac{W + 2P - FW}{S} + 1 $$ 두 결과는 모두 정수로 나누어 떨어지는 값이어야 한다. ¶3차원 데이터 (RGB 이미지) 3차원 이미지 데이터에 대해서는, 필터도 이미지와 마찬가지로 같은 수의 채널을 갖고 있어야 한다. ¶Pooling 이렇게 input에서 filter 를 적용하여 특징을 추출했다면, 이를 어떻게 판단할지가 중요 하다. 이렇게 추출된 map을 인위적으로 줄이는 작업을 pooling이라고 한다. pooling 하는 방법은 크게 max와 average가 있는데, 위 샘플 이미지에서는 최대값을 가져오는 MaxPooling 을 수행했다. 이는 큰값이 다른 주변 값(특징)을 대표한다는 개념을 적용시키게 된다. 이는 과적합을 방지하고, 컴퓨팅 리소스를 줄이는 효과를 가져온다. ¶Convolutaional Layer 자동차 인식을 위해 CNN을 적용한 모습이다. Conv-Relu-Conv-Relu-Pool-Conv-Relu-Conv-Relu-Pool-Conv-Relu-Conv-Relu-Pool를 적용해서 인식을 해낸 모습이다. 정리하자면, 이미지에서 특징을 추출해내는 작업을 몇번 거치고, 그뒤에 이를 fully connect 하여 perceptron을 바탕으로 최종적으로 예측을 하는 것이라고 할 수 있다. ¶ReLU를 쓰는이유 대부분의 실제 예제는 linear한 상황이 별로 없다. ReLU는 negative값을 모두 무시하기 때문에, 조금 더 낫다. tanh와 sigmoid는 vanishing gradient 문제를 갖고 있다. Deep Neural Netwrok는 Backpropagation (역전파)를 하기 위해서 gradient descent (경사하강법)을 적용하여 parameter를 조정한다. 그러나 이 gradient 값이 매우 작아지게 되면, 이것을 효율적으로 개선해나가는 것이 쉽지 않아지고, 느려진다. sigmoid는 중간 값에서는 경사가 있지만, 값이 작거나 커질 수록 극도로 경사가 작은 값을 갖게 된다. (0과 가까워 진다.) 따라서 아무리 계산을 누적해도 굉장히 작은 값이 나오게 된다. Relu는 input이 음수면 그냥 0을 리턴, 양수면 같은 값을 리턴한다. 따라서 값이 극도로 작아지거나 커진다고 해서 gredient가 사라지지 않는다. MNIST 손글씨 데이터셋에 CNN을 적용한다면 위의 이미지와 같은 \\모습이 될것이다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch 05) - Image Recognition","slug":"pytorch-05-image-recognition","date":"2019-02-20T15:00:00.000Z","updated":"2019-02-21T00:58:00.000Z","comments":true,"path":"2019/02/21/pytorch-05-image-recognition/","link":"","permalink":"https://www.yceffort.kr/2019/02/21/pytorch-05-image-recognition/","excerpt":"Pytorch - 05) Image Recognition 마지막으루다가 손글씨 분류해보는 실습을 해보겠습니다. ¶Dataset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import torch import matplotlib.pyplot as plt import numpy as np from torch import nn from torch.nn import functional as F from torchvision import datasets,","text":"Pytorch - 05) Image Recognition 마지막으루다가 손글씨 분류해보는 실습을 해보겠습니다. ¶Dataset 1234567891011121314151617181920212223242526import torchimport matplotlib.pyplot as pltimport numpy as npfrom torch import nnfrom torch.nn import functional as Ffrom torchvision import datasets, transforms# 리사이즈# 텐서화# channel, height, width를 정규화 한거임# 처음 세개는 mean# 그 다음 세개는 sdtransformer = transforms.Compose([transforms.Resize((28, 28)), transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)) ])training_dataset = datasets.MNIST(root='./data', train=True, download=True, transform=transformer)validation_dataset = datasets.MNIST(root='./data', train=False, download=True, transform=transformer)# 6000개를 100개 배치로 나눠서 돌림training_loader = torch.utils.data.DataLoader(dataset=training_dataset, batch_size=100, shuffle=True)validation_loader = torch.utils.data.DataLoader(dataset=validation_dataset, batch_size=100, shuffle=False) 텐서를 받아서 image로 보여주는 메소드를 만들자. 1234567891011def im_convert(tensor): # 복제하고, 자동미분 끄고, numpy로 image = tensor.clone().detach().numpy() # 데이터 형태는 color channel 1 28 px 28 px , 즉 1, 28, 28로 되어있음 # 이거를 28, 28, 1 로 변경 image = image.transpose(1, 2, 0) # denormalize image = image * np.array([0.5, 0.5, 0.5] + np.array([0.5, 0.5, 0.5])) # 데이터를 0과 1사이로만 있도록 보정 image = image.clip(0, 1) return image 맛보기로 이미지를 한번 보자. 12345678910dataiter = iter(training_loader)images, labels = dataiter.next()fig = plt.figure(figsize=(25, 4))for i in np.arange(20): # row 2 column 10 ax = fig.add_subplot(2, 10, i+1, xticks=[], yticks=[]) plt.imshow(im_convert(images[i])) ax.set_title(labels[i].item()) ¶Model 12345678910111213class Classifier(nn.Module): def __init__(self, n_input, H1, H2, n_output): super().__init__() self.linear1 = nn.Linear(n_input, H1) self.linear2 = nn.Linear(H1, H2) self.linear3 = nn.Linear(H2, n_output) def forward(self, x): x = F.relu(self.linear1(x)) x = F.relu(self.linear2(x)) x = self.linear3(x) return x hidden layer2개에, linear와 활성화 함수로 relu를 사용했다. sigmoid와 다르게 relu는 값 그자체가 확률을 나타내지 않으므로, 마지막에는 ReLU를 쓰지 않았다. 12model = Classifier(784, 125, 65, 10)model 12345Classifier( (linear1): Linear(in_features=784, out_features=125, bias=True) (linear2): Linear(in_features=125, out_features=65, bias=True) (linear3): Linear(in_features=65, out_features=10, bias=True)) 이미지가 28*28이므로 784개의 input, 총 10개 (0~9)로 구별해야 하므로 output은 10개로 나타넀다. 가운데 125와 65는 그냥 임의로 넣어봤다. 해보면서 조절해보면 된다. 12criterion = nn.CrossEntropyLoss()optimizer = torch.optim.Adam(model.parameters(), lr=0.005) classification 문제라서 CrossEntroypyLoss를, 그리고 optimizer로는 Adam을 사용하였다. ¶training 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758epochs = 12running_loss_history = []running_correct_history = []validation_running_loss_history = [] validation_running_correct_history = []for e in range(epochs): running_loss = 0.0 running_correct = 0.0 validation_running_loss = 0.0 validation_running_correct = 0.0 for inputs, labels in training_loader: inputs = inputs.view(inputs.shape[0], -1) outputs = model(inputs) loss = criterion(outputs, labels) optimizer.zero_grad() loss.backward() optimizer.step() _, preds = torch.max(outputs, 1) running_correct += torch.sum(preds == labels.data) running_loss += loss.item() else: # 훈련팔 필요가 없으므로 메모리 절약 with torch.no_grad(): for val_input, val_label in validation_loader: val_input = val_input.view(val_input.shape[0], -1) val_outputs = model(val_input) val_loss = criterion(val_outputs, val_label) _, val_preds = torch.max(val_outputs, 1) validation_running_loss += val_loss.item() validation_running_correct += torch.sum(val_preds == val_label.data) epoch_loss = running_loss / len(training_loader) epoch_acc = running_correct.float() / len(training_loader) running_loss_history.append(epoch_loss) running_correct_history.append(epoch_acc) val_epoch_loss = validation_running_loss / len(validation_loader) val_epoch_acc = validation_running_correct.float() / len(validation_loader) validation_running_loss_history.append(val_epoch_loss) validation_running_correct_history.append(val_epoch_acc) print(\"===================================================\") print(\"epoch: \", e + 1) print(\"training loss: &#123;:.5f&#125;, &#123;:5f&#125;\".format(epoch_loss, epoch_acc)) print(\"validation loss: &#123;:.5f&#125;, &#123;:5f&#125;\".format(val_epoch_loss, val_epoch_acc)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748===================================================epoch: 1training loss: 0.34698, 89.241669validation loss: 0.18939, 94.029999===================================================epoch: 2training loss: 0.17725, 94.583336validation loss: 0.16674, 94.790001===================================================epoch: 3training loss: 0.15004, 95.341667validation loss: 0.16987, 94.989998===================================================epoch: 4training loss: 0.12949, 95.991669validation loss: 0.13101, 96.040001===================================================epoch: 5training loss: 0.11537, 96.478333validation loss: 0.14699, 95.970001===================================================epoch: 6training loss: 0.10967, 96.628334validation loss: 0.11986, 96.410004===================================================epoch: 7training loss: 0.10788, 96.681664validation loss: 0.16216, 95.400002===================================================epoch: 8training loss: 0.10198, 96.928337validation loss: 0.13875, 96.029999===================================================epoch: 9training loss: 0.09768, 97.044998validation loss: 0.13843, 96.129997===================================================epoch: 10training loss: 0.09128, 97.230003validation loss: 0.14281, 96.349998===================================================epoch: 11training loss: 0.09073, 97.208336validation loss: 0.15617, 95.629997===================================================epoch: 12training loss: 0.09084, 97.209999validation loss: 0.13772, 96.470001 ¶Loss 123plt.plot(running_loss_history, label='training loss')plt.plot(validation_running_loss_history, label='validation loss')plt.legend() ¶Accuracy 12plt.plot(running_correct_history, label='training accuracy')plt.plot(validation_running_correct_history, label='validation accuracy') 정확도는 95% 안팎으로 나왔다. 그러나 validation loss가 training loss보다 커지는 것을 보아, 훈련하는 과정에서 overfitting이 일어났다고 봐야할 것이다. hyperparameter를 조금씩 조절할 필요가 있어 보인다. ¶Test 12345678import requestsfrom PIL import Imageimport PILurl = 'https://images.homedepot-static.com/productImages/007164ea-d47e-4f66-8d8c-fd9f621984a2/svn/architectural-mailboxes-house-letters-numbers-3585b-5-64_1000.jpg'response = requests.get(url, stream=True)img = Image.open(response.raw)plt.imshow(img) 1234567# 반전img = PIL.ImageOps.invert(img)# 흑백으로 좀더 또렷하게img = img.convert('1')img = transformer(img)plt.imshow(im_convert(img)) 1234img = img.view(img.shape[0], -1)outputs = model(img)_, pred = torch.max(outputs, 1)print(pred.item()) 15 맞췄다. 한번 validation dataset에 다시 해보자. 12345678910111213dataiter = iter(validation_loader)images, labels = dataiter.next()images_ = images.view(images.shape[0], -1)output = model(images_)_, preds = torch.max(output, 1)fig = plt.figure(figsize=(25, 4))for i in np.arange(20): # row 2 column 10 ax = fig.add_subplot(2, 10, i+1, xticks=[], yticks=[]) plt.imshow(im_convert(images[i])) ax.set_title(\"&#123;&#125; (&#123;&#125;)\".format(str(preds[i].item()), str(labels[i].item())), color=('green' if preds[i] == labels[i] else 'red')) 하나 빼고 다 맞췄는데, 저건 내가봐도 6으로 볼 수도 있을 것 같다. 착한 분류기 ㅇㅈ 합니다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch 07) - Convolutional Neural Network (2)","slug":"pytorch-07-convolutional-neural-network(2)","date":"2019-02-20T15:00:00.000Z","updated":"2019-02-21T13:21:57.000Z","comments":true,"path":"2019/02/21/pytorch-07-convolutional-neural-network(2)/","link":"","permalink":"https://www.yceffort.kr/2019/02/21/pytorch-07-convolutional-neural-network(2)/","excerpt":"Pytorch - 07) Convolutional Neural Network (2) 이번에는 코드로 구현해보자. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class LeNet(nn.Module): def __init__(self): super().__init__() # 흑백이라 1채널, 20개 특징 추출, filter 크기, stride 1 self.conv1 = nn.Conv2d(1, 20, 5, 1) # 전에서 2","text":"Pytorch - 07) Convolutional Neural Network (2) 이번에는 코드로 구현해보자. 123456789101112131415161718192021222324class LeNet(nn.Module): def __init__(self): super().__init__() # 흑백이라 1채널, 20개 특징 추출, filter 크기, stride 1 self.conv1 = nn.Conv2d(1, 20, 5, 1) # 전에서 20개 self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4*4*50, 500) # 0.5 가 권장 할 만하대 self.dropout1 = nn.Dropout(0.5) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) # flatten x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.dropout1(x) x = self.fc2(x) return x 먼저 첫번째 conv1애서는 1개의 필터, 20개의 특징을 추출 해 낼 것이다. 필터는 5x5 크기로, 이미지가 그리 크지 않으므로 stride는 1로 할것이다. 두번 conv2는 입력값이 20이고 (이전 conv의 ouput), 50개의 특징을 같은 크기와 stride로 찾는다. 그리고 마지막에는 fully conncted layer를 linear로 취한다. 여기서 주목할 것은 첫번째 fc의 input 값이다. 필터의 크기가 5x5 이기 때문에, 5x5필터는 width 와 heigt를 각각 4씩 줄인다. 1x1 필터: 원래크기 유지 2x2 필터: 크기 1 감소 3x3 필터: 크기 2 감소 4x4 필터: 크기 3 감소 5x5 필터: 크기 4 감소 따라서 각 conv layer를 거칠 때마다 크기가 4씩 줄어들게 된다. 그리고 max_pool2d를 2,2 크기로 사용할 것이므로 크기는 절반으로 줄어들게 된다. 요약하자면 다음과 같다. input conv1 pool1 conv2 pool2 28 24 12 8 4 4x4 크기의 이미지가, 50개의 특징으로 나오게 되므로, fully connected 의 input은 $$4\\times 4 \\times 50$$이 된다. 그리고 이를 500개의 output 으로 만들 것이다. 그리고 과적합을 방지하기 위하여, dropout을 0.5비율로 적용했다. 마지막 fc에서는, 10개의 숫자를 판별해야 하므로 500, 10을 적용했다. 활성화 함수로는 relu를 사용하였고, fully connected로 넘기기 위해, 평탄화를 작업(view적용)을 한다. 몇줄이 생길지는 모르겠지만, 암튼 row를 $$4\\times 4 \\times 50$$를 맞추기 위하여 .view(-1, 4*4*50) 을 적용했다. fc1을 쓰고, 그 사이에 dropout을 하고, 마지막에는 relu없이 값을 내보낸다. 이 것이 바로 LeNet이다. ¶training 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566criterion = nn.CrossEntropyLoss()optimizer = torch.optim.Adam(model.parameters(), lr=0.0001)epochs = 12running_loss_history = []running_correct_history = []validation_running_loss_history = [] validation_running_correct_history = []for e in range(epochs): running_loss = 0.0 running_correct = 0.0 validation_running_loss = 0.0 validation_running_correct = 0.0 for inputs, labels in training_loader: inputs = inputs.to(device) labels = labels.to(device) # inputs = inputs.view(inputs.shape[0], -1) outputs = model(inputs) loss = criterion(outputs, labels) optimizer.zero_grad() loss.backward() optimizer.step() _, preds = torch.max(outputs, 1) running_correct += torch.sum(preds == labels.data) running_loss += loss.item() else: # 훈련팔 필요가 없으므로 메모리 절약 with torch.no_grad(): for val_input, val_label in validation_loader: val_input = val_input.to(device) val_label = val_label.to(device) # val_input = val_input.view(val_input.shape[0], -1) val_outputs = model(val_input) val_loss = criterion(val_outputs, val_label) _, val_preds = torch.max(val_outputs, 1) validation_running_loss += val_loss.item() validation_running_correct += torch.sum(val_preds == val_label.data) epoch_loss = running_loss / len(training_loader) epoch_acc = running_correct.float() / len(training_loader) running_loss_history.append(epoch_loss) running_correct_history.append(epoch_acc) val_epoch_loss = validation_running_loss / len(validation_loader) val_epoch_acc = validation_running_correct.float() / len(validation_loader) validation_running_loss_history.append(val_epoch_loss) validation_running_correct_history.append(val_epoch_acc) print(\"===================================================\") print(\"epoch: \", e + 1) print(\"training loss: &#123;:.5f&#125;, acc: &#123;:5f&#125;\".format(epoch_loss, epoch_acc)) print(\"validation loss: &#123;:.5f&#125;, acc: &#123;:5f&#125;\".format(val_epoch_loss, val_epoch_acc)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748===================================================epoch: 1training loss: 0.57984, acc: 84.566666validation loss: 0.17183, acc: 95.019997===================================================epoch: 2training loss: 0.14266, acc: 95.785004validation loss: 0.10837, acc: 96.729996===================================================epoch: 3training loss: 0.09881, acc: 97.026672validation loss: 0.07965, acc: 97.529999===================================================epoch: 4training loss: 0.07957, acc: 97.633339validation loss: 0.06295, acc: 97.970001===================================================epoch: 5training loss: 0.06528, acc: 97.988335validation loss: 0.05194, acc: 98.389999===================================================epoch: 6training loss: 0.05605, acc: 98.290001validation loss: 0.04634, acc: 98.419998===================================================epoch: 7training loss: 0.05048, acc: 98.465004validation loss: 0.04152, acc: 98.779999===================================================epoch: 8training loss: 0.04411, acc: 98.653336validation loss: 0.03743, acc: 98.820000===================================================epoch: 9training loss: 0.03852, acc: 98.820000validation loss: 0.03573, acc: 98.869995===================================================epoch: 10training loss: 0.03615, acc: 98.881668validation loss: 0.03582, acc: 98.839996===================================================epoch: 11training loss: 0.03363, acc: 98.976669validation loss: 0.03422, acc: 98.820000===================================================epoch: 12training loss: 0.03024, acc: 99.063339validation loss: 0.03219, acc: 98.879997 약 99% 의 정확도로 이미지를 분류하였으며, 이전에 제대로 구별하지 못한 이미지도 제대로 구별해 내었다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch 04) - Deep Nueral Network","slug":"pytorch-04-deep-neural-network","date":"2019-02-19T15:00:00.000Z","updated":"2019-02-20T05:36:43.000Z","comments":true,"path":"2019/02/20/pytorch-04-deep-neural-network/","link":"","permalink":"https://www.yceffort.kr/2019/02/20/pytorch-04-deep-neural-network/","excerpt":"Pytorch - 04) Deep Neural Network ¶Deep Neural Network 이전 Perceptron에서 한개의 Perceptron으로는 XOR연산을 효과적으로 분류하지 못한다는 것을 이야기 했었다. 그리고 이런 XOR 이 아니더라도, 선형이 아닌 형태의 데이터를 분류 할 수 없을 것이다. 이런형태의 데이터는 어떻게 classification 해야 될까? 라는 생가에서 시작된게, perceptron을 여러개 배치하는 것이다. Tensorflow playground 예제다. input laye","text":"Pytorch - 04) Deep Neural Network ¶Deep Neural Network 이전 Perceptron에서 한개의 Perceptron으로는 XOR연산을 효과적으로 분류하지 못한다는 것을 이야기 했었다. 그리고 이런 XOR 이 아니더라도, 선형이 아닌 형태의 데이터를 분류 할 수 없을 것이다. 이런형태의 데이터는 어떻게 classification 해야 될까? 라는 생가에서 시작된게, perceptron을 여러개 배치하는 것이다. Tensorflow playground 예제다. input layer 와 output layer 사이에 4개의 perceptron을 배치했는데, 각각의 perceptron이 선형으로 되어 있으며, 이 4개의 선형이 이루는 사각형 형태로 classification이 되어 있음을 알 수 있다. $$x1, x2$$에 대한 입력값이 각각 있고, 이 입력 값에 대해서 서로다른 perceptron이 다른 weight을 바탕으로 각각 다른 구별을 하고, 이 두가지 값을 또다른 weight로 보는 작업들을 반복하여 작업을 수행한다. ¶Feedforward input layer의 값이 hidden layer 로 전달되고, hidden layer가 ouput layer로 전파하는 과정 (hidden layer가 여러개면 hidden layer간 전파도 있을 것이다)을 feedforward, 순전파라고 한다. 말그대로, 앞쪽의 입력값을 뒤로 보내는 것을 의미한다. hidden layer에 있는 각각의 노드는 퍼셉트론의 활성함수라고 볼 수 있다. ¶Backpropagation 임의의 값을 기반으로 보낸 feedforward가 당연히 제대로된 classification을 해낼리가 없다. 그래서 Backpropagation(역전파)를 한다. 역전파는 input의 역방향으로 오차를 돌려보내서 weight을 재업데이트 하는 것이다. 각 파라미터 별로 Loss에 대한 그래디언트를 구한뒤, 그래디언트들이 향한 쪽으로 파라미터를 업데이트 한다. ¶Code ¶데이터셋 1234567891011121314151617import torchimport numpy as npimport matplotlib.pyplot as pltimport torch.nn as nnfrom sklearn import datasetsn_pts = 500X, y = datasets.make_circles(n_samples=n_pts, random_state=123, noise=0.2, factor=0.3)x_data = torch.Tensor(X)y_data = torch.Tensor(y.reshape(500, 1))def scatter_plot(): plt.scatter(X[y==0, 0], X[y==0, 1], color='red') plt.scatter(X[y==1, 0], X[y==1, 1], color='blue')scatter_plot() 가운데 파란색 점들이 1이고, 빨간색이 0 이다. 1234567891011121314class Model(nn.Module): def __init__(self, input_size, H1, output_size): super().__init__() self.linear1 = nn.Linear(input_size, H1) self.linear2 = nn.Linear(H1, output_size) def forward(self, x): x = torch.sigmoid(self.linear1(x)) x = torch.sigmoid(self.linear2(x)) return x def predict(self, x): return 1 if self.forward(x) &gt;= 0.5 else 0 차이점은 hidden layer가 하나 추가됐다는 것이다. 두개 모두 linear로 처리되고 있으며, 활성화 함수로 sigmoid를 적용하였다. 12model = Model(2, 4, 1)print(list(model.parameters())) input, hidden, output이 각각 2, 4, 1 이다. 12345678[Parameter containing:tensor([[-0.1573, 0.6670], [-0.5144, 0.6607], [ 0.6625, 0.1984], [ 0.3064, -0.2649]], requires_grad=True), Parameter containing:tensor([-0.0411, 0.6752, -0.0167, 0.6902], requires_grad=True), Parameter containing:tensor([[-0.2804, -0.0074, 0.1881, 0.4310]], requires_grad=True), Parameter containing:tensor([-0.1316], requires_grad=True)] 이제 학습을 시켜보자. 12criterion = nn.BCELoss()optimizer = torch.optim.Adam(model.parameters(), lr=0.01) 12345678910111213epochs = 1000losses = []for i in range(epochs): y_pred = model.forward(x_data) loss = criterion(y_pred, y_data) print(\"epochs:\", i, \"loss:\", loss.item()) losses.append(loss.item()) optimizer.zero_grad() loss.backward() optimizer.step() 123456789101112131415161718192021epochs: 0 loss: 0.6942843198776245epochs: 1 loss: 0.6935287117958069epochs: 2 loss: 0.6930914521217346epochs: 3 loss: 0.6929344534873962epochs: 4 loss: 0.6929613351821899epochs: 5 loss: 0.6930437088012695epochs: 6 loss: 0.6930822730064392epochs: 7 loss: 0.6930424571037292epochs: 8 loss: 0.6929377913475037epochs: 9 loss: 0.6928017139434814...epochs: 990 loss: 0.12231576442718506epochs: 991 loss: 0.12226035445928574epochs: 992 loss: 0.12220513820648193epochs: 993 loss: 0.12215007096529007epochs: 994 loss: 0.12209513783454895epochs: 995 loss: 0.12204025685787201epochs: 996 loss: 0.12198563665151596epochs: 997 loss: 0.12193109095096588epochs: 998 loss: 0.12187661975622177epochs: 999 loss: 0.1218223124742508 1plt.plot(range(epochs), losses) 오차가 완만하게 감소하여 약 0.1에서 수렴함을 알수 있다. 12345678910111213141516def plot_decision_boundray(X, y): # x축 y축 min max 값을 구해 그래프의 상하좌우 길이를 세팅한다. x_span = np.linspace(min(X[:, 0]), max(X[:, 0])) y_span = np.linspace(min(X[:, 1]), max(X[:, 1])) # 이 두개로 그리드를 만든다. xx, yy = np.meshgrid(x_span, y_span) # .ravel()로 평탄화 하고 이 둘을 합쳐 tensor로 변환한다. grid = torch.Tensor(np.c_[xx.ravel(), yy.ravel()]) # 값 예측 pred_func = model.forward(grid) # xx와 모양을 맞춰 그래프에 넣을 수 있게 세팅한다. # detach를 하여 autograd를 off한다. # numpy()로 변환하여 그래프를 그릴 수 있게 한다. z = pred_func.view(xx.shape).detach().numpy() # 등고선 plt.contourf(xx, yy, z) 그래프가 완성되었다. 짙은 검은색일 수록 1일 확률이 높고, 그렇지 않은 영역은 하얀색에 가깝다. 대체로 overfitting되지 않고 제대로 예측한 것을 알 수 있다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch 01) - Tensor","slug":"pytorch-01-tensor","date":"2019-02-18T15:00:00.000Z","updated":"2019-02-19T00:16:25.000Z","comments":true,"path":"2019/02/19/pytorch-01-tensor/","link":"","permalink":"https://www.yceffort.kr/2019/02/19/pytorch-01-tensor/","excerpt":"Pytorch - 01) Tensor ¶Tensor 이제는 더 이상 기초를 다루지 않겠다. (마지막 기초 공부) 1 2 3 # 기초적인 배열 선언 v = torch.tensor([1, 2, 3]) v 1 tensor([1, 2, 3]) 1 2 # 타입 확인 v.dtype 1 torch.int64 1 2 3 4 # pytohn 배열과 마찬가지로 슬라이싱이 가능하다 v = torch.tensor([1, 2, 3, 4, 5, 6]) v[1:] v[1:4] 1 2 3 # Float 형태로 선언 f","text":"Pytorch - 01) Tensor ¶Tensor 이제는 더 이상 기초를 다루지 않겠다. (마지막 기초 공부) 123# 기초적인 배열 선언v = torch.tensor([1, 2, 3])v 1tensor([1, 2, 3]) 12# 타입 확인v.dtype 1torch.int64 1234# pytohn 배열과 마찬가지로 슬라이싱이 가능하다v = torch.tensor([1, 2, 3, 4, 5, 6])v[1:]v[1:4] 123# Float 형태로 선언f = torch.FloatTensor([1, 2, 3, 4, 5, 6])f 1tensor([1., 2., 3., 4., 5., 6.]) 12# 크기 확인f.size() 1torch.Size([6]) 12# view를 써서 배열 형태를 조작할 수도 있다.v.view(6, 1) 123456tensor([[1], [2], [3], [4], [5], [6]]) 12# 3만 줄테니 알아서 사이즈를 조절해라v.view(3, -1) 123tensor([[1, 2], [3, 4], [5, 6]]) 1234# numpy array를 tensor array를 상호간에 변환하는 것이 가능하다.a = np.array([1, 2, 3, 4, 5, ])tensor_cnv = torch.from_numpy(a)print(tensor_cnv, tensor_cnv.type()) 1tensor([1, 2, 3, 4, 5]) torch.LongTensor 12numpy_cnv = tensor_cnv.numpy()numpy_cnv 1array([1, 2, 3, 4, 5]) 1234# 0부터 10을 100개로 쪼갠다.torch.linspace(0, 10)# 0부터 10을 5개로 쪼갠다.torch.linspace(0, 10, 5) 1234# 이런 것도 가능하다.x = torch.linspace(0, 10, 100)y = torch.exp(x)y 1234567891011121314151617tensor([1.0000e+00, 1.1063e+00, 1.2239e+00, 1.3540e+00, 1.4979e+00, 1.6571e+00, 1.8332e+00, 2.0280e+00, 2.2436e+00, 2.4821e+00, 2.7459e+00, 3.0377e+00, 3.3606e+00, 3.7178e+00, 4.1130e+00, 4.5501e+00, 5.0337e+00, 5.5688e+00, 6.1606e+00, 6.8154e+00, 7.5398e+00, 8.3412e+00, 9.2278e+00, 1.0209e+01, 1.1294e+01, 1.2494e+01, 1.3822e+01, 1.5291e+01, 1.6916e+01, 1.8714e+01, 2.0704e+01, 2.2904e+01, 2.5338e+01, 2.8032e+01, 3.1011e+01, 3.4307e+01, 3.7954e+01, 4.1988e+01, 4.6450e+01, 5.1387e+01, 5.6849e+01, 6.2892e+01, 6.9576e+01, 7.6971e+01, 8.5153e+01, 9.4203e+01, 1.0422e+02, 1.1529e+02, 1.2755e+02, 1.4110e+02, 1.5610e+02, 1.7269e+02, 1.9105e+02, 2.1135e+02, 2.3382e+02, 2.5867e+02, 2.8616e+02, 3.1658e+02, 3.5023e+02, 3.8745e+02, 4.2864e+02, 4.7419e+02, 5.2459e+02, 5.8035e+02, 6.4204e+02, 7.1028e+02, 7.8577e+02, 8.6929e+02, 9.6168e+02, 1.0639e+03, 1.1770e+03, 1.3021e+03, 1.4405e+03, 1.5936e+03, 1.7630e+03, 1.9503e+03, 2.1576e+03, 2.3870e+03, 2.6407e+03, 2.9213e+03, 3.2318e+03, 3.5753e+03, 3.9554e+03, 4.3758e+03, 4.8409e+03, 5.3554e+03, 5.9246e+03, 6.5543e+03, 7.2510e+03, 8.0216e+03, 8.8742e+03, 9.8175e+03, 1.0861e+04, 1.2015e+04, 1.3292e+04, 1.4705e+04, 1.6268e+04, 1.7997e+04, 1.9910e+04, 2.2026e+04]) 1plt.plot(x.numpy(), y.numpy()) 123x = torch.linspace(0, 10, 100)y = torch.sin(x)plt.plot(x.numpy(), y.numpy()) ¶n차원 배열 123one_d = torch.arange(0, 9)two_d = one_d.view(3, 3)two_d 1234tensor([0, 1, 2, 3, 4, 5, 6, 7, 8])tensor([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) 12# dim으로 차원을 확인할 수 있다.two_d.dim() 12 123# 2개의 블록, 3로우, 3컬럼의 형태로 만들어진다.x = torch.arange(18).view(2, 3, 3)x 1234567891011tensor([[[ 0, 1], [ 2, 3], [ 4, 5]], [[ 6, 7], [ 8, 9], [10, 11]], [[12, 13], [14, 15], [16, 17]]]) 1234mat_a = torch.tensor([0, 3, 5, 5, 5, 2]).view(2, 3)mat_b = torch.tensor([3, 4, 3, -2, 4, -2]).view(3, 2)torch.matmul(mat_a, mat_b)mat_a @ mat_b matmul 과 @ 은 서로 곱할 수 있는 크기의 매트릭스를 곱하는 식이다. 고등학교때 행렬 열심히 하기를 잘했다. ¶autograd pytorch의 장점은 자동미분(autograd)을 지원한다는 점이다. $$x=2$$ $$y = 9x^4 + 2x^3 + 3x^2 + 6x+1$$ 이식을 미분해보자. 12x = torch.tensor(2.0, requires_grad=True)y = 9*x**4 + 2*x**3 + 3*x**2 + 6*x + 1 12tensor(2., requires_grad=True)tensor(185., grad_fn=&lt;AddBackward0&gt;) 자동미분을 True로 세팅하여, 모든 연산에 대해 추적을 할 수 있게 해둔 것이다. 계산작업이 모두 수행 되었으므로 (y) .backward를 수행하여, 모든 그라디어트를 자동으로 계산하게 할 수 있다. 그리고 그 그라디언트는 .grad에 누적되어 저장된다. 12y.backward()x.grad $$ 4 \\times 9x^3 + 3 \\times 2x^2 + 2 \\times 3 x + 6$$ 여기에 2를 대입하면 1tensor(330.) 1234x = torch.tensor(1.0, requires_grad=True)z = torch.tensor(2.0, requires_grad=True)y = x**2 + z**3y.backward() 12x.gradz.grad 각각 2와 12가 나올 것이다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch 02) - Linear Regression","slug":"pytorch-02-linear-regression","date":"2019-02-18T15:00:00.000Z","updated":"2019-02-19T00:46:13.000Z","comments":true,"path":"2019/02/19/pytorch-02-linear-regression/","link":"","permalink":"https://www.yceffort.kr/2019/02/19/pytorch-02-linear-regression/","excerpt":"Pytorch - 02) Linear Regression ¶Linear Regression Linear Regression이 한국말로 뭐였더라? 1 2 3 4 import torch import torch.nn as nn import matplotlib.pyplot as plt import numpy as np ¶데이터셋 만들기 대충 뭔가 있어보이는 데이터셋을 만들자. 1 2 3 4 5 X = torch.randn(100, 1)*10 y = X + 3*torch.randn(100, 1) plt.plot(X.numpy","text":"Pytorch - 02) Linear Regression ¶Linear Regression Linear Regression이 한국말로 뭐였더라? 1234import torchimport torch.nn as nnimport matplotlib.pyplot as pltimport numpy as np ¶데이터셋 만들기 대충 뭔가 있어보이는 데이터셋을 만들자. 12345X = torch.randn(100, 1)*10y = X + 3*torch.randn(100, 1)plt.plot(X.numpy(), y.numpy(), 'o')plt.ylabel('y')plt.xlabel('x') 12345678910111213# nn.Module은 사용자 정의 모듈을 생성하는데 있어서 가장 기초가 되는 모듈이다.class LR(nn.Module): # linear regression의 입력값과 출력값 갯수를 받는다. def __init__(self, input_size, output_size): super().__init__() # nn.Linear를 상속받는다. self.linear = nn.Linear(input_size, output_size) # 정방향 호출 함수. 이 함수를 통해서 linear regression을 수행하게 된다. def forward(self, x): pred = self.linear(x) return pred nn.Linear는 $$y = xA^{T} + b$$ 12345# random seedtorch.manual_seed(1)# 입력값이 한개고, 출력값이 한개model = LR(1, 1)print(model) 123LR( (linear): Linear(in_features=1, out_features=1, bias=True)) 파라미터를 살펴보면 1print(list(model.parameters())) 이렇게 weight와 bias 가 무작위로 들어가 있는 것을 알 수 있다. 123[Parameter containing:tensor([[0.5153]], requires_grad=True), Parameter containing:tensor([-0.4414], requires_grad=True)] 이제 Linear Regression을 해보자. 1234567891011121314151617w, b = model.parameters()def get_params(): return w[0][0].item(), b[0].item()def plot_fit(title): plt.title = title # weight 와 bias w1, b1 = get_params() # -30 부터 30까지 x1 = np.array([-30, 30]) # 선형 추정선을 그려본다. y1 = w1*x1 + b1 plt.plot(x1, y1, 'r') plt.scatter(X, y) plt.show()plot_fit('Initial Model') 회귀선,인지, 추정선,인지 암튼지간에 제대로 그리지 못했다는 것을 알 수 있다. 그래서 이를 학습시키려고 한다. 12criterion = nn.MSELoss()optimizer = torch.optim.SGD(model.parameters(), lr = 0.01) criterion은 Mean Squred Error를 , optimizer는 stochastic gradient descent (확률적 경사하강법)을 사용한다. learning_rate는 0.01 이다. 배치 경사하강법은, 매스텝에서 전체 훈련세트를 활용해서 그래디언트를 계산하기 대문에, 훈련세트가 커지면 속도가 매우 느려진다. 그러나 SGD는 매스텝에서 무작위 딱 한개의 샘플만을 처리하고, 그 샘플에 대한 그래디언트만 계산한다. 따라서 속도는 훨씬 빠르지만, 매 iteration 에서 적은 데이터만 처리하기 때문에 훨씬 불안정하다. 위아래로 요동치면서 감소하므로, 물론 시간이 지나면 최소값에 얼추 닿긴 하겠지만, 말그대로 얼추일 뿐이다. 이러한 무작위성은 국소최소값을 벗어나게 하므로 (무작위로 처리하므로), 전역 최소값을 찾을 확률이 더 크다. 암튼 지간에 123456789101112131415161718# 100 회 반복epochs = 100losses = []for i in range(epochs): # 예측 y_pred = model.forward(X) # 오차 계산 loss = criterion(y_pred, y) print(\"epoch:\", i, \"loss:\", loss.item()) # 오차 누적 (계산을 위해서) losses.append(loss) # optimzer 초기화 optimizer.zero_grad() # backward를 수행하여 그래디언트 계산 loss.backward() # learning rate 만큼 가중치를 주어서 hyper parameter 업데이트 optimizer.step() 123456789101112131415161718192021epoch: 0 loss: 31.671594619750977epoch: 1 loss: 22.02737808227539epoch: 2 loss: 16.717256546020508epoch: 3 loss: 13.792343139648438epoch: 4 loss: 12.180136680603027epoch: 5 loss: 11.290426254272461epoch: 6 loss: 10.798413276672363epoch: 7 loss: 10.525352478027344epoch: 8 loss: 10.372870445251465epoch: 9 loss: 10.286834716796875...epoch: 90 loss: 10.071357727050781epoch: 91 loss: 10.071175575256348epoch: 92 loss: 10.071000099182129epoch: 93 loss: 10.070833206176758epoch: 94 loss: 10.070671081542969epoch: 95 loss: 10.070516586303711epoch: 96 loss: 10.070366859436035epoch: 97 loss: 10.07022476196289epoch: 98 loss: 10.070086479187012epoch: 99 loss: 10.069954872131348 123plt.plot(range(epochs), losses)plt.ylabel('Loss')plt.xlabel('epoch') 시간이 지나면서 오차가 감소한 것을 알 수 있다. 1plot_fit(\"Trained Model\") 이전보다 잘 학습되었다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch 03) - Perceptron","slug":"pytorch-03-perceptron","date":"2019-02-18T15:00:00.000Z","updated":"2019-02-19T05:36:43.000Z","comments":true,"path":"2019/02/19/pytorch-03-perceptron/","link":"","permalink":"https://www.yceffort.kr/2019/02/19/pytorch-03-perceptron/","excerpt":"Pytorch - 03) Perceptron ¶Perceptron (마지막 정리가 되길 바라며) Perceptron은 우리 두뇌 (뉴런)의 인지능력을 모방하도록 만든 인위적인 네트워크다. 퍼셉트론은 다수의 신호를 받아서, 하나의 신호를 출력한다. 여기에서 x는 입력값이고 w는, 가중치라고 부르는 weight이다. 각 입력치에 가중치를 부여하여, 입력신호화 계산하고, 그 신호의 총합이 정해진 값을 넘으면 1을 출력한다. 각 입력신호에 weight가 부여되며, 이 weight가 클수록 해당 입력값이 중요한 역할을 한다고 볼","text":"Pytorch - 03) Perceptron ¶Perceptron (마지막 정리가 되길 바라며) Perceptron은 우리 두뇌 (뉴런)의 인지능력을 모방하도록 만든 인위적인 네트워크다. 퍼셉트론은 다수의 신호를 받아서, 하나의 신호를 출력한다. 여기에서 x는 입력값이고 w는, 가중치라고 부르는 weight이다. 각 입력치에 가중치를 부여하여, 입력신호화 계산하고, 그 신호의 총합이 정해진 값을 넘으면 1을 출력한다. 각 입력신호에 weight가 부여되며, 이 weight가 클수록 해당 입력값이 중요한 역할을 한다고 볼 수 있다. 머신러닝에서 하는 것은 이 weight을 조정하는 작업이라고 할 수 있다. 이렇게만 보면, 앞에서 보았던 linear classification 모형이라고도 볼 수 있다. 실수형의 input 벡터를 받아서, 이를 선형으로 계산하는 것이라고도 볼 수 있다. 처음에는 임의로 설정된 weight으로 시작하여, 여기에 training data를 모형에 입력하며 weight을 결과값에 맞도록 개선 나간다. $$ b + w1x1 + w2x2 &lt; 0 $$ $$ b + w1x1 + w2x2 \\geq 0 $$ 여기서 가중치 (weight)는 입력신호과 결과에 주는 영향도를 조절하며, 편향 (bias)는이 뉴런이 얼마나 쉽게 활성화(1을 출력하느냐?)화되는 지를 조정하는 변수다. 그러나 문제는, 말그대로 선형분류만 가능하다는 것이다. XOR 논리는 어느 한쪽이 1일때만 1을 출력하는 배타적인 논리연산인데, 이를 선으로 구별하지 못하는 것을 알 수 있다. xor 연산은 (1,0)이나 (0,1) 일 때 활성화되는데, 선으로는 이를 구별해내지 못한다. 그래서 이러한 문제를 해결하기 위해 여러개의 퍼셉트론을 layer화 하여 극복해 내었다. ¶perceptron in pytorch ¶데이터셋 만들기 12345678910111213141516import torchimport torch.nn as nnimport numpy as npimport matplotlib.pyplot as pltfrom sklearn import datasetsn_pts = 100centers = [[-0.5, 0.5], [0.5, -0.5]]X, y = datasets.make_blobs(n_samples=n_pts, random_state=123, centers=centers, cluster_std=0.4)x_data = torch.Tensor(X)y_data = torch.Tensor(y.reshape(100, 1))print(x_data[:5])print(y_data[:5]) 12345678910tensor([[-0.1372, -0.0715], [ 0.8044, -0.3706], [-0.6022, -0.6194], [ 0.5709, -0.5120], [ 0.0064, 0.1533]])tensor([[0.], [1.], [0.], [1.], [0.]]) 12345def scatter_plot(): plt.scatter(X[y==0, 0], X[y==0, 1]) plt.scatter(X[y==1, 0], X[y==1, 1]) scatter_plot() 이런 형태의 만들어 냈다. ¶모델만들기 123456789101112class Model(nn.Module): def __init__(self, input_size, output_size): super().__init__() self.linear = nn.Linear(input_size, output_size) def forward(self, X): pred = torch.sigmoid(self.linear(X)) return pred def predict(self, x): return 1 if pred &gt;= 0.5 else 0 활성화 함수로 sigmoid함수를 사용하였다. $$ s(z) = \\frac{1}{1 + e ^ {-z}} $$ 모양에서도 알 수 있듯이, 이함수의 특징은 0/1 을 구별하는 부분은 경사가 급격하고, 나머지는 완만하다. 활성함수의 값을 성공확률이라는 의미로 해석이 가능하다. 123torch.manual_seed(2)model = Model(2, 1)list(model.parameters()) 123[Parameter containing: tensor([[ 0.1622, -0.1683]], requires_grad=True), Parameter containing: tensor([0.1939], requires_grad=True)] input 값이 두개이고, output은 하나인 model을 만들어 냈다. 123456789[w, b] = model.parameters()w1, w2 = w.view(2)b1 = b[0]def get_params(): return w1.item(), w2.item(), b.item() print(w1.item(), w2.item(), b1.item()) 10.16220331192016602 -0.1682732105255127 0.19390898942947388 랜덤으로 가중치 2개와 bias가 생성되었다. 12345678910def plot_fit(title): plt.title = title w1, w2, b1 = get_params() # 0 = w1*x1 + w2*x2 + b x1 = np.array([-2.0, 2.0]) # 0 = w1*x1 + w2*x2 + b # 를 x2 입장에서 계산 x2 = (w1*x1 + b1) / -w2 plt.plot(x1, x2, 'red') scatter_plot() 아직은 회귀선이 나타나지 않은 것을 알 수 있다. 이제 이것을 학습시켜 보자. 12criterion = nn.BCELoss()optimizer = torch.optim.SGD(model.parameters(), lr=0.01) 이번에 사용해볼 손실함수는 Cross Entropy Loss 다. (binary의 경우에는 Binary Cross Entropy Loss, BCELoss를 사용해야하며, 활성함수로 sigmoid를 꼭써줘야 한다.) Regression에서는 MSE를, Classification에서는 Cros Entropy를, 여러 class를 구별하는 경우에는 Softmax를 쓴다. 공식은 아래와 같다. $$ \\text{Cross Entropy} = P(X) * -log(Q(x)) $$ 여기서 $$P(x)$$는 실제값을, $$Q(x)$$는 예상값이다. 예측이 맞을때에는 0으로 수렴하고, 틀릴 경우에는 무한대로 발산하는 특성을 가지고 있다. 즉, 틀릴수록 loss를 크게 두어서 가중치를 조절할 수 있게 하는 것이다. ¶training 123456789101112epochs = 1000losses = []for i in range(epochs): y_pred = model.forward(x_data) loss = criterion(y_pred, y_data) print(\"epoch: \", i, \"loss: \", loss.item()) losses.append(loss.item()) optimizer.zero_grad() loss.backward() optimizer.step() 123456789101112131415161718192021epoch: 0 loss: 0.6185115575790405epoch: 1 loss: 0.6174639463424683epoch: 2 loss: 0.6164201498031616epoch: 3 loss: 0.6153794527053833epoch: 4 loss: 0.614342451095581epoch: 5 loss: 0.6133086681365967epoch: 6 loss: 0.6122783422470093epoch: 7 loss: 0.6112515330314636epoch: 8 loss: 0.6102280616760254epoch: 9 loss: 0.6092080473899841...epoch: 990 loss: 0.25722837448120117epoch: 991 loss: 0.2571081817150116epoch: 992 loss: 0.25698813796043396epoch: 993 loss: 0.2568681538105011epoch: 994 loss: 0.2567485272884369epoch: 995 loss: 0.2566289007663727epoch: 996 loss: 0.2565094828605652epoch: 997 loss: 0.25639018416404724epoch: 998 loss: 0.2562710642814636epoch: 999 loss: 0.2561522126197815 loss가 0.25에 수렴하고 있다. 123plt.plot(range(epochs), losses)plt.ylabel('loss')plt.xlabel('epoch') 점점 loss가 줄어들고 육안으로 보기에도, 정확히 분류하는 것을 알 수 있었다. ¶Test 1234567891011121314point1 = torch.Tensor([1.0, -1.0])point2 = torch.Tensor([-1.0, 1.0])plt.plot(point1.numpy()[0], point1.numpy()[1], 'ro')plt.plot(point2.numpy()[0], point2.numpy()[1], 'ko')print(\"Red point positive probability = &#123;&#125;\".format(model.forward(point1).item()))print(\"black point positive probability = &#123;&#125;\".format(model.forward(point2).item()))print(\"Red point in class = &#123;&#125;\".format(model.forward(point1).item()))print(\"black point in class = &#123;&#125;\".format(model.forward(point2).item()))plot_fit('Trained Model') 1234Red point positive probability = 0.9424158334732056black point positive probability = 0.05055497586727142Red point in class = 1black point in class = 0","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"AI Programming with Python Nanodegree 끝","slug":"ai-programming-python-nanodegree-complete","date":"2019-02-16T15:00:00.000Z","updated":"2019-02-17T14:40:13.000Z","comments":true,"path":"2019/02/17/ai-programming-python-nanodegree-complete/","link":"","permalink":"https://www.yceffort.kr/2019/02/17/ai-programming-python-nanodegree-complete/","excerpt":"AI Programming with Python Nanodegree를 끝냈습니다. Pytorch를 본격적으로 배우기 위해서 큰 맘먹고 수강한 수업인데, pytorch가 정작 얼마 없어서 맥이 좀 빠졌네요. 그래도 더 공부하러 가보겠습니다. (총총)","text":"AI Programming with Python Nanodegree를 끝냈습니다. Pytorch를 본격적으로 배우기 위해서 큰 맘먹고 수강한 수업인데, pytorch가 정작 얼마 없어서 맥이 좀 빠졌네요. 그래도 더 공부하러 가보겠습니다. (총총)","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"pytorch - Flower Classification","slug":"pytorch-flower-classification","date":"2019-02-14T15:00:00.000Z","updated":"2019-02-15T03:36:35.000Z","comments":true,"path":"2019/02/15/pytorch-flower-classification/","link":"","permalink":"https://www.yceffort.kr/2019/02/15/pytorch-flower-classification/","excerpt":"pytorch를 이용해서 꽃이미지를 구별해보도록 하자. 여기에서 활용할 데이터셋은 이거다. 총 102종류의 꽃이 있고, 각각 여러개의 이미지가 있다. 데이터셋을 다운로드 하면 train, valid, test로 나눠져 있고 이를 활용해서 꽃을 구별해보려고 한다. ¶1. 데이터 로딩 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 랜덤으로 학습하기 위해서 이미지를 약간씩 돌린다. # 마찬가지","text":"pytorch를 이용해서 꽃이미지를 구별해보도록 하자. 여기에서 활용할 데이터셋은 이거다. 총 102종류의 꽃이 있고, 각각 여러개의 이미지가 있다. 데이터셋을 다운로드 하면 train, valid, test로 나눠져 있고 이를 활용해서 꽃을 구별해보려고 한다. ¶1. 데이터 로딩 12345678910111213141516171819202122232425262728293031323334353637# 랜덤으로 학습하기 위해서 이미지를 약간씩 돌린다.# 마찬가지로 랜덤하게 크롭한다.# 또한 랜덤하게 상하 반전을 한다.# 데이터를 텐서로 바꾼다.# 이미지를 정규화 한다.train_transforms = transforms.Compose([transforms.RandomRotation(30), transforms.RandomResizedCrop(224), transforms.RandomHorizontalFlip(), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])# validation과 test에는 랜덤을 적용하지 않는다.# 리사이즈와, 가운데 크롭만 한다.valid_transforms = transforms.Compose([transforms.Resize(256), transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])test_transforms = transforms.Compose([transforms.Resize(256), transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])])# 이미지를 읽어드린후, 위에 메소드를 적용한다.image_datasets = dict()image_datasets['train'] = datasets.ImageFolder(train_dir, transform=train_transforms)image_datasets['valid'] = datasets.ImageFolder(valid_dir, transform=valid_transforms)image_datasets['test'] = datasets.ImageFolder(test_dir, transform=test_transforms)# 배치로 만든다.dataloaders = dict()dataloaders['train'] = torch.utils.data.DataLoader(image_datasets['train'], batch_size=64, shuffle=True)dataloaders['valid'] = torch.utils.data.DataLoader(image_datasets['valid'], batch_size=32)dataloaders['test'] = torch.utils.data.DataLoader(image_datasets['test'], batch_size=20) 폴더에 숫자가 있는데, 해당 숫자가 어떤 꽃인지 매칭 해준다. 1&#123;\"21\": \"fire lily\", \"3\": \"canterbury bells\", \"45\": \"bolero deep blue\", \"1\": \"pink primrose\", \"34\": \"mexican aster\", \"27\": \"prince of wales feathers\", \"7\": \"moon orchid\", \"16\": \"globe-flower\", \"25\": \"grape hyacinth\", \"26\": \"corn poppy\", \"79\": \"toad lily\", \"39\": \"siam tulip\", \"24\": \"red ginger\", \"67\": \"spring crocus\", \"35\": \"alpine sea holly\", \"32\": \"garden phlox\", \"10\": \"globe thistle\", \"6\": \"tiger lily\", \"93\": \"ball moss\", \"33\": \"love in the mist\", \"9\": \"monkshood\", \"102\": \"blackberry lily\", \"14\": \"spear thistle\", \"19\": \"balloon flower\", \"100\": \"blanket flower\", \"13\": \"king protea\", \"49\": \"oxeye daisy\", \"15\": \"yellow iris\", \"61\": \"cautleya spicata\", \"31\": \"carnation\", \"64\": \"silverbush\", \"68\": \"bearded iris\", \"63\": \"black-eyed susan\", \"69\": \"windflower\", \"62\": \"japanese anemone\", \"20\": \"giant white arum lily\", \"38\": \"great masterwort\", \"4\": \"sweet pea\", \"86\": \"tree mallow\", \"101\": \"trumpet creeper\", \"42\": \"daffodil\", \"22\": \"pincushion flower\", \"2\": \"hard-leaved pocket orchid\", \"54\": \"sunflower\", \"66\": \"osteospermum\", \"70\": \"tree poppy\", \"85\": \"desert-rose\", \"99\": \"bromelia\", \"87\": \"magnolia\", \"5\": \"english marigold\", \"92\": \"bee balm\", \"28\": \"stemless gentian\", \"97\": \"mallow\", \"57\": \"gaura\", \"40\": \"lenten rose\", \"47\": \"marigold\", \"59\": \"orange dahlia\", \"48\": \"buttercup\", \"55\": \"pelargonium\", \"36\": \"ruby-lipped cattleya\", \"91\": \"hippeastrum\", \"29\": \"artichoke\", \"71\": \"gazania\", \"90\": \"canna lily\", \"18\": \"peruvian lily\", \"98\": \"mexican petunia\", \"8\": \"bird of paradise\", \"30\": \"sweet william\", \"17\": \"purple coneflower\", \"52\": \"wild pansy\", \"84\": \"columbine\", \"12\": \"colt's foot\", \"11\": \"snapdragon\", \"96\": \"camellia\", \"23\": \"fritillary\", \"50\": \"common dandelion\", \"44\": \"poinsettia\", \"53\": \"primula\", \"72\": \"azalea\", \"65\": \"californian poppy\", \"80\": \"anthurium\", \"76\": \"morning glory\", \"37\": \"cape flower\", \"56\": \"bishop of llandaff\", \"60\": \"pink-yellow dahlia\", \"82\": \"clematis\", \"58\": \"geranium\", \"75\": \"thorn apple\", \"41\": \"barbeton daisy\", \"95\": \"bougainvillea\", \"43\": \"sword lily\", \"83\": \"hibiscus\", \"78\": \"lotus lotus\", \"88\": \"cyclamen\", \"94\": \"foxglove\", \"81\": \"frangipani\", \"74\": \"rose\", \"89\": \"watercress\", \"73\": \"water lily\", \"46\": \"wallflower\", \"77\": \"passion flower\", \"51\": \"petunia\"&#125; 그리고 이번 분석에는 이미 만들어져 있는 모델을 사용하려고 한다. VGG16 이다. ¶2. VGG16 입력: 224*224 크기의 고정된 RGB 이미지 구조: Convoluitional Layer (3x3 filter, stride=1, padding=True) Max-Pooling Layer (2x2 filtter, stride=2) 1x1 Conv Layer (1x1 filter, stride=1) Fully Connected Layer (4096 &gt; 4096 &gt; 1000) 특징: 모든 레이어에 3x3 필터 적용 1x1 Conv Layer 사용 다섯장의 Max-Pooling Layer 사용 ¶3. Classifier 만들기 123456789output_size = len(cat_to_name)vgg16_model = models.vgg16(pretrained=True)# 244x244input_size = vgg16_model.classifier[0].in_features# 미리 만들어진 모델이라 적용할 필요 없음.for param in vgg16_model.parameters(): param.requires_grad = False 12345678910111213141516171819202122232425262728classifier = nn.Sequential( OrderedDict([ ('fc1', nn.Linear(input_size, input_size // 8)), ('relu1', nn.ReLU()), ('droupout', nn.Dropout(p=0.20)), ('fc2', nn.Linear(input_size // 8, input_size // 32)), ('relu2', nn.ReLU()), ('droupout', nn.Dropout(p=0.20)), ('fc3', nn.Linear(input_size // 32, input_size // 128)), ('relu3', nn.ReLU()), ('droupout', nn.Dropout(p=0.20)), ('fc4', nn.Linear(input_size // 128, output_size)), ('softmax', nn.LogSoftmax(dim=1)) ]))vgg16_model.classifier = classifierdevice = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")epochs = 20learning_rate = 0.001criterion = nn.NLLLoss()optimizer = optim.Adam(vgg16_model.classifier.parameters(), lr=learning_rate)vgg16_model = vgg16_model.to(device) 오차 함수로는 NLLLoss를 Optimizer로 Adam을 사용하였다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# epochs만큼 훈련for e in range(epochs): running_loss = 0 # 트레이닝 셋 for index, (t_inputs, t_labels) in enumerate(dataloaders['train']): # cpu나 cuda로 변환 t_inputs, t_labels = t_inputs.to(device), t_labels.to(device) optimizer.zero_grad() t_ouputs = vgg16_model.forward(t_inputs) loss = criterion(t_ouputs, t_labels) loss.backward() optimizer.step() # 오차 축적 running_loss += loss.item() # 5번마다 validset으로 확인 if (index + 1) % 5 == 0: # eval 모드로 변환 vgg16_model.eval() v_loss = 0 accuracy = 0 # valid set for v_inputs, v_labels in dataloaders['valid']: v_inputs, v_labels = v_inputs.to(device), v_labels.to(device) optimizer.zero_grad() # 자동미분 off with torch.no_grad(): v_output = vgg16_model.forward(v_inputs) loss = criterion(v_output, v_labels) ps = torch.exp(v_output) top_p, top_class = ps.topk(1, dim=1) equals = top_class == v_labels.view(*top_class.shape) accuracy += torch.mean(equals.type(torch.FloatTensor)) vgg16_model.train() train_losses.append(running_loss / 5) valid_losses.append(loss / len(dataloaders['valid'])) accuracies.append(accuracy / len(dataloaders['valid'])) ## 결과 및 정확도 출력 print_accuracy = \"&#123;:.5f&#125;\".format(accuracies[-1]) if len(accuracies) &gt;= 2: change = accuracies[-1] - accuracies[-2] if change &gt; 0: print_accuracy += '↑' elif change == 0 : print_accuracy += '-' else: print_accuracy += '↓' running_loss = 0 print(\"Epoch: &#123;&#125;/&#123;&#125;\".format(e+1, epochs), \"Training Loss: &#123;:.5f&#125;\".format(train_losses[-1]), \"Valodation Loss: &#123;:.5f&#125;\".format(valid_losses[-1]), \"Accuracy: &#123;&#125;\".format(print_accuracy)) 123456789101112131415Epoch: 1/20 Training Loss: 4.69953 Valodation Loss: 0.21000 Accuracy: 0.02043Epoch: 1/20 Training Loss: 4.53161 Valodation Loss: 0.19509 Accuracy: 0.06490↑Epoch: 1/20 Training Loss: 4.50895 Valodation Loss: 0.19441 Accuracy: 0.09135↑Epoch: 1/20 Training Loss: 4.22797 Valodation Loss: 0.20272 Accuracy: 0.13582↑Epoch: 1/20 Training Loss: 4.13869 Valodation Loss: 0.21389 Accuracy: 0.17909↑Epoch: 1/20 Training Loss: 3.75459 Valodation Loss: 0.20136 Accuracy: 0.19952↑Epoch: 1/20 Training Loss: 3.63869 Valodation Loss: 0.19415 Accuracy: 0.24760↑...Epoch: 20/20 Training Loss: 0.36903 Valodation Loss: 0.00035 Accuracy: 0.89663↓Epoch: 20/20 Training Loss: 0.53348 Valodation Loss: 0.00012 Accuracy: 0.91106↑Epoch: 20/20 Training Loss: 0.50826 Valodation Loss: 0.00007 Accuracy: 0.90986↓Epoch: 20/20 Training Loss: 0.36002 Valodation Loss: 0.00102 Accuracy: 0.90385↓Epoch: 20/20 Training Loss: 0.58472 Valodation Loss: 0.00031 Accuracy: 0.90745↑Epoch: 20/20 Training Loss: 0.50919 Valodation Loss: 0.00016 Accuracy: 0.91346↑Epoch: 20/20 Training Loss: 0.49237 Valodation Loss: 0.00009 Accuracy: 0.91707↑ 아쉽게도 8번 째 부터는 90% 벽을 넘지 못하고 계속 같은 수준에서 머물렀다. Colab Notebook에서 돌렸는데, 이렇게 까지 오래 돌릴 필요가 있었나 싶을 정도로 오래 걸렸다. (4시간 정도) 1234567891011121314151617181920vgg16_model.eval()vgg16_model.to(device)accuracy = 0test_error = 0for images, labels in dataloaders['test']: images, labels = images.to(device), labels.to(device) with torch.no_grad(): output = vgg16_model.forward(images) test_error += criterion(output, labels).item() ps = torch.exp(output).data equal = Variable(labels.data == ps.max(1)[1]).float() accuracy += torch.mean(equal) print(\"Test Error: &#123;:.5f&#125;\".format(test_error/len(dataloaders['test'])))print(\"Test Accuracy: &#123;:.5f&#125;\".format(accuracy/len(dataloaders['test']))) 12Test Error: 0.38797Test Accuracy: 0.90456 90%의 정확도가 나왔다. 기초적인 것만 활용한 것 치고는 괜찮은 결과 였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# 이미지를 위에서 변환한 것 처럼 변환해 준다.def process_image(image): ''' Scales, crops, and normalizes a PIL image for a PyTorch model, returns an Numpy array ''' image = Image.open(image) transformer = transforms.Compose([transforms.Resize(256), transforms.CenterCrop(224), transforms.ToTensor(), transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])]) return transformer(image) # TODO: Process a PIL image for use in a PyTorch model img_path = '/content/flowers/test/1/image_06743.jpg'img = process_image(img_path)img.shape# 예측def predict(image_path, model, topk=5): ''' Predict the class (or classes) of an image using a trained deep learning model. ''' # eval, cpu모드로 전환 model.eval() model.cpu() image = process_image(image_path) image = image.unsqueeze(0) with torch.no_grad(): output = model.forward(image) top_prob, top_labels = torch.topk(output, topk) top_prob = top_prob.exp() top_prob_array = top_prob.data.numpy()[0] top_prob_array = list(map(lambda x: round(float(x), 5), top_prob_array)) class_to_idx = &#123;v: k for k, v in model.class_to_idx.items()&#125; top_labels_data = top_labels.data.numpy() top_labels_list = top_labels_data[0].tolist() top_classes = [class_to_idx[x] for x in top_labels_list] return top_prob_array, top_classes# 이미지 보기def imshow(image, ax=None, title=None): \"\"\"Imshow for Tensor.\"\"\" if ax is None: fig, ax = plt.subplots() # PyTorch tensors assume the color channel is the first dimension # but matplotlib assumes is the third dimension image = image.numpy().transpose((1, 2, 0)) # Undo preprocessing mean = np.array([0.485, 0.456, 0.406]) std = np.array([0.229, 0.224, 0.225]) image = std * image + mean image = np.clip(image, 0, 1) ax.imshow(image) return axdef check(image_path, image_label=None): probs, classes = predict(image_path, vgg16_model) class_names = [cat_to_name[x] for x in classes] print('is this &#123;&#125;?'.format(class_names[0])) if image_label: print('this is &#123;&#125;.'.format(cat_to_json.get(classes[0]))) fig, ax = plt.subplots() image_to_show = process_image(image_path) imshow(image_to_show, ax, class_names[-1]) fig, ax = plt.subplots() y_pos = np.arange(len(class_names)) plt.barh(y_pos, probs) plt.yticks(y_pos, class_names) plt.xlabel('Probability') plt.show() 12is this fritillary?this is fritillary.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"업무 자동화 (1) - 구글 스프레드 시트 API 활용하기","slug":"do-boring-stuff-with-python-1","date":"2019-02-13T15:00:00.000Z","updated":"2019-02-14T01:56:22.000Z","comments":true,"path":"2019/02/14/do-boring-stuff-with-python-1/","link":"","permalink":"https://www.yceffort.kr/2019/02/14/do-boring-stuff-with-python-1/","excerpt":"구글 스프레드 시트를 파이썬에서 조작해보자. 내가 할일은 1. 스프레드시트를 읽고 2. 스프레드시트에 쓰는 두가지 작업이다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import pickle import os.path from googleapiclient.discovery import build from google_auth_oauthlib.flow import InstalledAppFlow from google.auth.tran","text":"구글 스프레드 시트를 파이썬에서 조작해보자. 내가 할일은 1. 스프레드시트를 읽고 2. 스프레드시트에 쓰는 두가지 작업이다. 1234567891011121314151617181920212223242526272829import pickleimport os.pathfrom googleapiclient.discovery import buildfrom google_auth_oauthlib.flow import InstalledAppFlowfrom google.auth.transport.requests import RequestSCOPES = ['https://www.googleapis.com/auth/spreadsheets']class GoogleSheetInit(): def __init__(self): self.creds = None def initialize(self): creds = None if os.path.exists('token.pickle'): with open('token.pickle', 'rb') as token: creds = pickle.load(token) if not creds or not creds.valid: if creds and creds.expired and creds.refresh_token: creds.refresh(Request()) else: flow = InstalledAppFlow.from_client_secrets_file('../credentials.json', SCOPES) creds = flow.run_local_server() with open('token.pickle', 'wb') as token: pickle.dump(creds, token) self.creds = creds 구글 docs에 접근하는 방법은 두가지인데, 한가지는 oauth2기반 인증과, 다른 한가지는 api_key방식 인증이다. api_key 인증 방식은 요청시에 parameter로 api key를 보내는 방식인데, 안타깝게도 보안상의 문제로 인해 전체 공개된 문서에만 접근할 수 있다. 따라서 제한적으로 공개되어 있는 문서에 접근하기 위해서는 oauth2 방식을 활용해야 한다. 12google_sheet = GoogleSheetInit()google_sheet.initialize() 실행하게 되면 브라우저에서 구글 계정 인증을 받게 된다. 계정인증을 거친 뒤에는 인증 정보가 token.pickle에 남아서 이 후부터는 별도의 인증없이 접근할 수 있다. 그리고 해당 인증정보를 파이썬 코드에서 사용할 수 있도록 creds가 반환된다. 자세한 api 스펙은 여기에서 참조하면 된다. ¶스프레드시트 읽기 1234service = build('sheets', 'v4', credentials=self.creds)sheet = service.spreadsheets()result = sheet.values().get(spreadsheetId=self.sheet_id, range=self.sheet_range).execute()values = result.get('values', ) sheet_id는 해당 스프레드 시트의 id인데, url에 나와있다. 그리고 sheet_range는 시트이름!A1:Z1 이런식으로 접근하면 된다. 1enumerate(values) 으로 접근할 수 있다. ¶스프레드시트 쓰기 12request = sheet.values().update(spreadsheetId=self.sheet_id, range=range, valueInputOption='RAW', body=&#123; \"values\": [[value]]&#125;)response = request.execute() body영역은 실제 스프레드시트에 쓰려고 하는 영역의 크기만큼 설정하면 된다. 위의 예제에서는 단순히 셀 1개에만 쓰는 케이스다.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://www.yceffort.kr/tags/python/"}]},{"title":"pytorch -  fashion MNIST 분류 실습","slug":"pytorch-fashion-MNIST","date":"2019-02-12T15:00:00.000Z","updated":"2019-02-13T03:36:35.000Z","comments":true,"path":"2019/02/13/pytorch-fashion-MNIST/","link":"","permalink":"https://www.yceffort.kr/2019/02/13/pytorch-fashion-MNIST/","excerpt":"pytorch를 활용해서 옷 이미지를 구별하는 예제를 해봤었는데, 다시 한번 복습하는 차원에서 기본적인 기능으로 해보려고 한다. ¶1. 데이터셋 준비 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import torch from torchvision import datasets, transforms import helper # Define a transform to normalize the data transform = transforms.Compose([transforms.ToTensor(),","text":"pytorch를 활용해서 옷 이미지를 구별하는 예제를 해봤었는데, 다시 한번 복습하는 차원에서 기본적인 기능으로 해보려고 한다. ¶1. 데이터셋 준비 1234567891011121314import torchfrom torchvision import datasets, transformsimport helper# Define a transform to normalize the datatransform = transforms.Compose([transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])# Download and load the training datatrainset = datasets.FashionMNIST('~/.pytorch/F_MNIST_data/', download=True, train=True, transform=transform)trainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=True)# Download and load the test datatestset = datasets.FashionMNIST('~/.pytorch/F_MNIST_data/', download=True, train=False, transform=transform)testloader = torch.utils.data.DataLoader(testset, batch_size=64, shuffle=True) 먼저 데이터를 받기전에, 해당 데이터를 torch tensor로 바꾸고, Normalize할 수 있ㅅ는 transform을 준비했다. 그리고 굳이 test set과 train set을 손수 나누지 않아도 저렇게 구별할 수 있게 해주었다. 그리고 각각의 데이터를 dataloader에 실어 넣었다. 이미지를 잠깐 살펴보기 위하여, imshow라는 메소드를 하나 만들었다. 12345678910111213141516171819202122def imshow(image, ax=None, title=None, normalize=True): \"\"\"Imshow for Tensor.\"\"\" if ax is None: fig, ax = plt.subplots() image = image.numpy().transpose((1, 2, 0)) if normalize: mean = np.array([0.485, 0.456, 0.406]) std = np.array([0.229, 0.224, 0.225]) image = std * image + mean image = np.clip(image, 0, 1) ax.imshow(image) ax.spines['top'].set_visible(False) ax.spines['right'].set_visible(False) ax.spines['left'].set_visible(False) ax.spines['bottom'].set_visible(False) ax.tick_params(axis='both', length=0) ax.set_xticklabels('') ax.set_yticklabels('') return ax 12image, label = next(iter(trainloader))imshow(image[0,:]); 이게 옷인가 싶은 모양이지만 (…) 암튼 원피스겠지 ¶2. 네트워크 만들기 만들어볼 네트워크는 아래와 같다. input layer: 28 * 28 = 764 hidden layer: 2개, 각각 256, 128 개의 뉴런을 갖고 있음 output layer: 10개 (구별할 옷이 열 종류) Adam Optimizer 와 NLLLoss 활용 12345678910111213141516class Classifier(nn.Module): def __init__(self): super().__init__() self.fc1 = nn.Linear(784, 256) self.fc2 = nn.Linear(256, 128) self.fc3 = nn.Linear(128, 64) self.fc4 = nn.Linear(64, 10) def forward(self, x): x = x.view(x.shape[0], -1) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = F.relu(self.fc3(x)) x = F.log_softmax(self.fc4(x), dim=1) return x ¶3. 네트워크 훈련하기 12345678910111213141516171819202122232425model = Classifier()criterion = nn.NLLLoss()optimizer = optim.Adam(model.parameters(), lr=0.003)epochs = 20for e in range(epochs): running_loss = 0 for images, labels in trainloader: # 모델에서 훈련 result = model(images) # 오차 계산 loss = criterion(result, labels) # 초기화 optimizer.zero_grad() # 역전파 loss.backward() # 스텝 optimizer.step() # 오차값을 총 오차에 더함 running_loss += loss.item() else: print(f\"Training loss: &#123;running_loss/len(trainloader)&#125;\") 1234567891011121314151617181920Training loss: 0.5118639363504168Training loss: 0.3933752618714182Training loss: 0.35750402640432183Training loss: 0.33432440921219425Training loss: 0.31787964060648416Training loss: 0.3047505217606325Training loss: 0.29022969397654663Training loss: 0.28075202265337335Training loss: 0.27226868114555314Training loss: 0.26422357173966193Training loss: 0.2592774396702679Training loss: 0.25201891171636737Training loss: 0.24683423794265877Training loss: 0.24124097148540305Training loss: 0.23825587014923852Training loss: 0.2335602915538018Training loss: 0.224308533554297Training loss: 0.22240888378592824Training loss: 0.21599145372634504Training loss: 0.21485247272354707 ¶4. 결과 123456789%matplotlib inline%config InlineBackend.figure_format = 'retina'dataiter = iter(testloader)images, labels = dataiter.next()img = images[0]img = img.resize_(1, 784)ps = torch.exp(model(img))view_classify(img.resize_(1, 28, 28), ps, version='Fashion') ¶5. 총 accuracy 구하기 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950model = Classifier()criterion = nn.NLLLoss()optimizer = optim.Adam(model.parameters(), lr=0.003)epochs = 30steps = 0train_losses, test_losses = [], []for e in range(epochs): running_loss = 0 for images, labels in trainloader: optimizer.zero_grad() log_ps = model(images) loss = criterion(log_ps, labels) loss.backward() optimizer.step() running_loss += loss.item() # for 문이 끝나면 실행한다. else: test_loss = 0 accuracy = 0 # Turn off gradients for validation, saves memory and computations # 자동 미분을 꺼서 pytorch가 쓸 떼 없는 짓을 안하게 한다. (어차피 test set에서 하는 작업이므로) with torch.no_grad(): for images, labels in testloader: log_ps = model(images) test_loss += criterion(log_ps, labels) # 로그 확률에 지수 적용 ps = torch.exp(log_ps) # topk는 k번째로 큰 숫자를 찾아내는 것이다. # dim=1 는 dimension을 의미한다. top_p, top_class = ps.topk(1, dim=1) # labels를 top_class와 똑같은 형태로 만든다음에, 얼마나 같은게 있는지 확인한다. equals = top_class == labels.view(*top_class.shape) # equals를 float으로 바꾸고 평균 정확도를 구한다. accuracy += torch.mean(equals.type(torch.FloatTensor)) train_losses.append(running_loss/len(trainloader)) test_losses.append(test_loss/len(testloader)) print(\"Epoch: &#123;&#125;/&#123;&#125;.. \".format(e+1, epochs), \"Training Loss: &#123;:.3f&#125;.. \".format(running_loss/len(trainloader)), \"Test Loss: &#123;:.3f&#125;.. \".format(test_loss/len(testloader)), \"Test Accuracy: &#123;:.3f&#125;\".format(accuracy/len(testloader))) 123456789101112131415161718192021222324252627282930Epoch: 1/30.. Training Loss: 0.521.. Test Loss: 0.461.. Test Accuracy: 0.833Epoch: 2/30.. Training Loss: 0.395.. Test Loss: 0.429.. Test Accuracy: 0.839Epoch: 3/30.. Training Loss: 0.357.. Test Loss: 0.393.. Test Accuracy: 0.862Epoch: 4/30.. Training Loss: 0.334.. Test Loss: 0.388.. Test Accuracy: 0.863Epoch: 5/30.. Training Loss: 0.318.. Test Loss: 0.380.. Test Accuracy: 0.867Epoch: 6/30.. Training Loss: 0.303.. Test Loss: 0.367.. Test Accuracy: 0.871Epoch: 7/30.. Training Loss: 0.292.. Test Loss: 0.386.. Test Accuracy: 0.869Epoch: 8/30.. Training Loss: 0.285.. Test Loss: 0.371.. Test Accuracy: 0.879Epoch: 9/30.. Training Loss: 0.274.. Test Loss: 0.357.. Test Accuracy: 0.878Epoch: 10/30.. Training Loss: 0.274.. Test Loss: 0.377.. Test Accuracy: 0.876Epoch: 11/30.. Training Loss: 0.261.. Test Loss: 0.369.. Test Accuracy: 0.871Epoch: 12/30.. Training Loss: 0.255.. Test Loss: 0.357.. Test Accuracy: 0.881Epoch: 13/30.. Training Loss: 0.251.. Test Loss: 0.385.. Test Accuracy: 0.873Epoch: 14/30.. Training Loss: 0.248.. Test Loss: 0.405.. Test Accuracy: 0.875Epoch: 15/30.. Training Loss: 0.240.. Test Loss: 0.368.. Test Accuracy: 0.882Epoch: 16/30.. Training Loss: 0.232.. Test Loss: 0.364.. Test Accuracy: 0.883Epoch: 17/30.. Training Loss: 0.230.. Test Loss: 0.413.. Test Accuracy: 0.872Epoch: 18/30.. Training Loss: 0.229.. Test Loss: 0.384.. Test Accuracy: 0.878Epoch: 19/30.. Training Loss: 0.221.. Test Loss: 0.376.. Test Accuracy: 0.883Epoch: 20/30.. Training Loss: 0.217.. Test Loss: 0.443.. Test Accuracy: 0.867Epoch: 21/30.. Training Loss: 0.217.. Test Loss: 0.382.. Test Accuracy: 0.880Epoch: 22/30.. Training Loss: 0.212.. Test Loss: 0.403.. Test Accuracy: 0.880Epoch: 23/30.. Training Loss: 0.209.. Test Loss: 0.403.. Test Accuracy: 0.879Epoch: 24/30.. Training Loss: 0.209.. Test Loss: 0.398.. Test Accuracy: 0.881Epoch: 25/30.. Training Loss: 0.202.. Test Loss: 0.406.. Test Accuracy: 0.880Epoch: 26/30.. Training Loss: 0.200.. Test Loss: 0.390.. Test Accuracy: 0.882Epoch: 27/30.. Training Loss: 0.194.. Test Loss: 0.405.. Test Accuracy: 0.878Epoch: 28/30.. Training Loss: 0.195.. Test Loss: 0.415.. Test Accuracy: 0.879Epoch: 29/30.. Training Loss: 0.193.. Test Loss: 0.418.. Test Accuracy: 0.883Epoch: 30/30.. Training Loss: 0.187.. Test Loss: 0.412.. Test Accuracy: 0.879 ¶6. loss 확인해보기 12345678%matplotlib inline%config InlineBackend.figure_format='retina'import matplotlib.pyplot as pltplt.plot(train_losses, label='training loss')plt.plot(test_losses, label='Validation loss')plt.legend(frameon=False) training loss는 점차 감소하지만, validation loss는 널뛰기 하고 있다. 이 말인 즉슨, 현재 overfitting 현상이 일어나고 있는 것이다. ¶7. dropout 드롭아웃은 Overfitting을 방지하기 위한 방법이다. 일부 노드들을 훈련에 참여시키지 않고 몇개의 노드를 끊어서, 남은 노드들을 통해서만 훈련시키는 방식이다. 이 때 끊어버리는 노드는 랜덤으로 선택한다. pytorch에서는 기본값이 0.5 다. 즉 절반의 노드를 dropout하고 계산한다. 이렇게 함으로써, training하는 과정에서 Overfitting이 발생하지 않게 할 수 있다. 12345678910111213141516171819202122class Classifier(nn.Module): def __init__(self): super().__init__() self.fc1 = nn.Linear(784, 256) self.fc2 = nn.Linear(256, 128) self.fc3 = nn.Linear(128, 64) self.fc4 = nn.Linear(64, 10) # 0.2정도를 무작위로 골라 dropout한다. self.dropout = nn.Dropout(p=0.2) def forward(self, x): x = x.view(x.shape[0], -1) x = self.dropout(F.relu(self.fc1(x))) x = self.dropout(F.relu(self.fc2(x))) x = self.dropout(F.relu(self.fc3(x))) # output은 dropout하면 안된다.. x = F.log_softmax(self.fc4(x), dim=1) return x dropout은 주의해야할 것이, training 과정에서만 이루어져야 한다는 것이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748model = Classifier()criterion = nn.NLLLoss()optimizer = optim.Adam(model.parameters(), lr=0.003)epochs = 30steps = 0train_losses, test_losses = [], []for e in range(epochs): running_loss = 0 for images, labels in trainloader: optimizer.zero_grad() log_ps = model(images) loss = criterion(log_ps, labels) loss.backward() optimizer.step() running_loss += loss.item() else: test_loss = 0 accuracy = 0 with torch.no_grad(): # test 과정에 들어간다. dropout을 안하게 된다. # 정확하게 말하면, dropout 하는 비율이 0이 된다. model.eval() for images, labels in testloader: log_ps = model(images) test_loss += criterion(log_ps, labels) ps = torch.exp(log_ps) top_p, top_class = ps.topk(1, dim=1) equals = top_class == labels.view(*top_class.shape) accuracy += torch.mean(equals.type(torch.FloatTensor)) # 다시 트레이닝 과정으로 돌아간다. model.train() train_losses.append(running_loss/len(trainloader)) test_losses.append(test_loss/len(testloader)) print(\"Epoch: &#123;&#125;/&#123;&#125;.. \".format(e+1, epochs), \"Training Loss: &#123;:.3f&#125;.. \".format(train_losses[-1]), \"Test Loss: &#123;:.3f&#125;.. \".format(test_losses[-1]), \"Test Accuracy: &#123;:.3f&#125;\".format(accuracy/len(testloader))) 123456789101112131415161718192021222324252627282930Epoch: 1/30.. Training Loss: 0.602.. Test Loss: 0.508.. Test Accuracy: 0.818Epoch: 2/30.. Training Loss: 0.482.. Test Loss: 0.454.. Test Accuracy: 0.835Epoch: 3/30.. Training Loss: 0.450.. Test Loss: 0.429.. Test Accuracy: 0.848Epoch: 4/30.. Training Loss: 0.434.. Test Loss: 0.418.. Test Accuracy: 0.851Epoch: 5/30.. Training Loss: 0.416.. Test Loss: 0.431.. Test Accuracy: 0.852Epoch: 6/30.. Training Loss: 0.413.. Test Loss: 0.399.. Test Accuracy: 0.855Epoch: 7/30.. Training Loss: 0.405.. Test Loss: 0.394.. Test Accuracy: 0.856Epoch: 8/30.. Training Loss: 0.397.. Test Loss: 0.386.. Test Accuracy: 0.858Epoch: 9/30.. Training Loss: 0.392.. Test Loss: 0.412.. Test Accuracy: 0.855Epoch: 10/30.. Training Loss: 0.388.. Test Loss: 0.380.. Test Accuracy: 0.865Epoch: 11/30.. Training Loss: 0.383.. Test Loss: 0.376.. Test Accuracy: 0.865Epoch: 12/30.. Training Loss: 0.375.. Test Loss: 0.392.. Test Accuracy: 0.863Epoch: 13/30.. Training Loss: 0.380.. Test Loss: 0.382.. Test Accuracy: 0.863Epoch: 14/30.. Training Loss: 0.374.. Test Loss: 0.370.. Test Accuracy: 0.876Epoch: 15/30.. Training Loss: 0.368.. Test Loss: 0.385.. Test Accuracy: 0.864Epoch: 16/30.. Training Loss: 0.371.. Test Loss: 0.371.. Test Accuracy: 0.871Epoch: 17/30.. Training Loss: 0.358.. Test Loss: 0.392.. Test Accuracy: 0.861Epoch: 18/30.. Training Loss: 0.354.. Test Loss: 0.371.. Test Accuracy: 0.872Epoch: 19/30.. Training Loss: 0.354.. Test Loss: 0.373.. Test Accuracy: 0.873Epoch: 20/30.. Training Loss: 0.353.. Test Loss: 0.386.. Test Accuracy: 0.867Epoch: 21/30.. Training Loss: 0.361.. Test Loss: 0.388.. Test Accuracy: 0.867Epoch: 22/30.. Training Loss: 0.350.. Test Loss: 0.385.. Test Accuracy: 0.869Epoch: 23/30.. Training Loss: 0.353.. Test Loss: 0.371.. Test Accuracy: 0.869Epoch: 24/30.. Training Loss: 0.343.. Test Loss: 0.368.. Test Accuracy: 0.872Epoch: 25/30.. Training Loss: 0.351.. Test Loss: 0.378.. Test Accuracy: 0.875Epoch: 26/30.. Training Loss: 0.339.. Test Loss: 0.371.. Test Accuracy: 0.872Epoch: 27/30.. Training Loss: 0.351.. Test Loss: 0.372.. Test Accuracy: 0.875Epoch: 28/30.. Training Loss: 0.350.. Test Loss: 0.375.. Test Accuracy: 0.871Epoch: 29/30.. Training Loss: 0.353.. Test Loss: 0.391.. Test Accuracy: 0.875Epoch: 30/30.. Training Loss: 0.340.. Test Loss: 0.385.. Test Accuracy: 0.876 다시 결과를 보자. 123plt.plot(train_losses, label='Training loss')plt.plot(test_losses, label='Validation loss')plt.legend(frameon=False) dropout이 overfitting을 방지해 주는 것을 알 수 있다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Matlab & Seaborn 기본적인 기능 정리","slug":"matlab-seaborn-summary","date":"2019-02-10T15:00:00.000Z","updated":"2019-02-11T07:39:48.000Z","comments":true,"path":"2019/02/11/matlab-seaborn-summary/","link":"","permalink":"https://www.yceffort.kr/2019/02/11/matlab-seaborn-summary/","excerpt":"Gist 짱짱맨. 그러나 높이 조절이 잘 안된다. (귀찮…)","text":"Gist 짱짱맨. 그러나 높이 조절이 잘 안된다. (귀찮…)","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Numpy 기본적인 기능 정리","slug":"numpy-summary","date":"2019-02-10T15:00:00.000Z","updated":"2019-02-11T01:29:05.000Z","comments":true,"path":"2019/02/11/numpy-summary/","link":"","permalink":"https://www.yceffort.kr/2019/02/11/numpy-summary/","excerpt":"귀찮아서 github gist로…","text":"귀찮아서 github gist로…","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pandas 기본적인 기능 정리","slug":"pandas-summary","date":"2019-02-10T15:00:00.000Z","updated":"2019-02-11T01:29:05.000Z","comments":true,"path":"2019/02/11/pandas-summary/","link":"","permalink":"https://www.yceffort.kr/2019/02/11/pandas-summary/","excerpt":"이것도 귀찮아서 github gist로…","text":"이것도 귀찮아서 github gist로…","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch (3-1) - CNN: 곤충 이미지 분류하기","slug":"pytorch-3-convolutional-neural-network(2)","date":"2019-01-29T15:00:00.000Z","updated":"2019-01-30T03:32:01.000Z","comments":true,"path":"2019/01/30/pytorch-3-convolutional-neural-network(2)/","link":"","permalink":"https://www.yceffort.kr/2019/01/30/pytorch-3-convolutional-neural-network(2)/","excerpt":"pytorch에서 주는 곤충 이미지를 분류하는 작업을 해보려고 한다. 벌과 개미 이미지가 있는데, 각각의 이미지를 잠깐 살펴보면 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import torch from torch.autograd import Variable import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from torch.utils.data import DataLoader, TensorDa","text":"pytorch에서 주는 곤충 이미지를 분류하는 작업을 해보려고 한다. 벌과 개미 이미지가 있는데, 각각의 이미지를 잠깐 살펴보면 12345678910111213141516import torchfrom torch.autograd import Variableimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torch.utils.data import DataLoader, TensorDatasetimport osfrom PIL import Imageimport numpy as npimport pandas as pdfrom sklearn import datasets, model_selectiontrain_path = '/content/gdrive/My Drive/Colab Notebooks/pytorch/data/hymenoptera_data/train/'val_path = '/content/gdrive/My Drive/Colab Notebooks/pytorch/data/hymenoptera_data/val/' 이미지를 분석한다. RGB컬러로 이루어진 이미지이므로, 이를 숫자로 변환해서 구별하고자 한다. 12345678910111213141516171819202122232425262728dirs = ['ants', 'bees']data = []label = []for i, d in enumerate(dirs): files = os.listdir(train_path+d) for f in files: img = Image.open(train_path + d + '/' + f, 'r') # 이미지를 128, 128로 일괄 리사이즈 한다. resize_img = img.resize((128, 128)) # 이미지를 RGB 컬러로 각각 쪼갠다. # https://pillow.readthedocs.io/en/3.1.x/reference/Image.html#PIL.Image.Image.split 참조 r, g, b = resize_img.split() # 각 쪼갠 이미지를 255로 나눠서 0~1 사이의 값이 나오도록 정규화 한다. r_resize_img = np.asarray(np.float32(r) / 255.0) b_resize_img = np.asarray(np.float32(g) / 255.0) g_resize_img = np.asarray(np.float32(b) / 255.0) rgb_resize_img = np.asarray([r_resize_img, b_resize_img, g_resize_img]) # 이렇게 가공한 이미지를 추가한다. data.append(rgb_resize_img) # 라벨 (ant: 0, bee: 1) label.append(i)pd.DataFrame(data[0][0]).shape 1(128, 128) 이제 각각의 데이터를 분석할 수 있도록 변경한다. 12345678910111213data = np.array(data, dtype='float32')label = np.array(label, dtype='int64')train_X, test_X, train_Y, test_Y = model_selection.train_test_split(data, label, test_size=0.1)train_X = torch.from_numpy(train_X).float()train_Y = torch.from_numpy(train_Y).long()test_X = torch.from_numpy(test_X).float()test_Y = torch.from_numpy(test_Y).long()train = TensorDataset(train_X, train_Y)train_loader = DataLoader(train, batch_size=32, shuffle=True) 이제 신경망을 구성해야 한다. 1234567891011121314151617181920212223# 신경망 구성class Net(nn.Module): def __init__(self): super(Net, self).__init__() # 합성곱층 self.conv1 = nn.Conv2d(3, 10, 5) # 입력 채널 수, 출력 채널 수, 필터 크기 self.conv2 = nn.Conv2d(10, 20, 5) # 전결합층 self.fc1 = nn.Linear(20 * 29 * 29, 50) # 29=(((((128-5)+1)/2)-5)+1)/2 self.fc2 = nn.Linear(50, 2) def forward(self, x): # 풀링층 x = F.max_pool2d(F.relu(self.conv1(x)), 2) # 풀링 영역 크기 x = F.max_pool2d(F.relu(self.conv2(x)), 2) x = x.view(-1, 20 * 29 * 29) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x)# 인스턴스 생성model = Net() 123456789101112131415161718192021criterion = nn.CrossEntropyLoss()optimizer = optim.Adam(model.parameters(), lr=0.001)for epoch in range(500): total_loss = 0 for train_x, train_y in train_loader: train_x, train_y = Variable(train_x), Variable(train_y) optimizer.zero_grad() output = model(train_x) loss = criterion(output, train_y) loss.backward() optimizer.step() total_loss += loss.data.item() if (epoch+1) % 50 == 0: print(epoch+1, total_loss)test_x, test_y = Variable(test_X), Variable(test_Y)result = torch.max(model(test_x).data, 1)[1]accuracy = sum(test_y.data.numpy() == result.numpy()) / len(test_y.data.numpy())accuracy 정확도는 0.6이 나왔다. 랜덤으로 때려 맞춰도 50%인 것을 감안했을때, 썩 좋은 수치라고는 할 수 없다. 문제는 covolutional layer의 크기와 개수다. 이를 조금더 조정해야 한다. 조정해서 조금더 정확치를 높여보자.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch (3-2) - CNN: Convolutional Neural Network ","slug":"pytorch-3-convolutional-neural-network(3)","date":"2019-01-29T15:00:00.000Z","updated":"2019-01-30T00:17:08.000Z","comments":true,"path":"2019/01/30/pytorch-3-convolutional-neural-network(3)/","link":"","permalink":"https://www.yceffort.kr/2019/01/30/pytorch-3-convolutional-neural-network(3)/","excerpt":"앞서 CNN네트워크를 진행하면서 모르는 부분이 좀 있어서, 이론적인 측면을 좀더 강조해서 글을 써보려고 한다. ¶구조 일단 중간층이 Convolutional Layer, Pooling Layer, Fully-connted Layer로 구성되어 있다. 그리고 마지막엔 Dropouut Layer를 넣는 경우도 있고, Softmax 함수로 마무리 한다. ¶Convolutional Layer 이른바 합성곱층이다. 입력데이터에 필터를 적용해서 특징값을 추출하는 레이어다. 필터를 적용해서 특징값을 추출하고, 이 필터의 값을 비선형 값으","text":"앞서 CNN네트워크를 진행하면서 모르는 부분이 좀 있어서, 이론적인 측면을 좀더 강조해서 글을 써보려고 한다. ¶구조 일단 중간층이 Convolutional Layer, Pooling Layer, Fully-connted Layer로 구성되어 있다. 그리고 마지막엔 Dropouut Layer를 넣는 경우도 있고, Softmax 함수로 마무리 한다. ¶Convolutional Layer 이른바 합성곱층이다. 입력데이터에 필터를 적용해서 특징값을 추출하는 레이어다. 필터를 적용해서 특징값을 추출하고, 이 필터의 값을 비선형 값으로 바꾸어주는 Activation 함수 (일반적으로 ReLU)로 이루어져 있다. {:width=“200px”} ¶Filter 필터는 찾으려는 특징이 입력 데이터에 존재하는지 여부를 검출해주는 함수다. {:width=“600px”} 먼저 왼쪽 과 같은 그림 이 있다고 가정하자. 그리고 해당 특징을 찾으려는 필터를 곱하면 (Convolutaionl) 일정한 결과 값이 나오게 될 것이다. 찾으려는 특징이 존재한다면 큰값이 나오고, 찾으려는 특징이 존재하지 않으면 0에 가까운 값이 나올 것이다. (Activation Layer로 처리하겠지만) 물론 적용하는 필터는 단순히 한개가 아니다. 여러 다양한 필터를 조합한다면, 원본 입력 데이터가 어떤 형태의 특징을 가지고 있는지를 판단할 수 있다. ¶Stride 필터를 적용하는 간격의 값을 Stride라고 한다. 그리고 필터를 적용해서 얻어낸 결과를 Feature Map이라고 한다. ¶Padding 위 움짤에서 보이는 것처럼, 필터를 적용하고 나면 그 크기가 필터 적용 이전보다 작아지게 된다. 5X5이미지는 3X3 필터의 1 stride를 적용하고 났더니, 결과 크기는 3X3으로 쪼그라 들었다. 그러나 문제는 단 한개의 레이어가 아니고, 여러개의 필터를 적용해서 특징을 추출해 나간다는 것이다. 이 과정이 반복되서 결과 크기가 줄어들게 되면, 처음에 비해서 그 특징을 많이 잃어버릴 수 가 있다. 이를 방지 하기 위한 기법으로 Padding을 쓴다. Padding은 입력값 주위로 특정 값을 넣어서 크기가 줄어드는 것을 인위적으로 방지한다. Padding에는 주로 0을 쓰는 Zero Padding을 많이 쓰게 된다. {:width=“600px”} 32x32x3의 입력값에서 5x5x3 필터를 적용 시키게 되면, feature map의 크기는 28x28x3이 된다. 이렇게 사이즈가 작아지는 걸 막기 위해서 Padding을 쓴다. 입력데이터 주위에 2의 두께로 0을 둘러 쌓아주면, 36x36x3이 되고, 5x5x3 필터를 적용하더라도 결과값은 32x32x3 로 유지된다. 이러한 패딩은 특징이 유실되는 것을 방지해주고, 또한 과적합도 방지하는 효과가 있다. ¶Activation Function 이렇게 해서 나온 Feature Map에 Activation Function을 적용한다. 신경망에는 보통 sigmoid 함수보다는 ReLU를 많이 쓴다. 신경망이 깊어질 수록 학습이 어려워 지기 때문에 역전파를 통해 오차를 다시 계산한다. 만약 sigmoid를 활성함수로 사용시, 레이어가 깊어지게 되면 역전파가 제대로 되지 않기 때문에 (Gradient Vanishing) ReLU를 보통 많이 쓴다. ¶Pooling Layer 이전에 Covolutional Layer에서 특징을 추출했다면, 그 특징을 어떻게 판단할지가 중요하다. 이렇게 인위적으로 추출된 Actiavtion Map을 인위적으로 줄이는 작업을 Pooling 이라고 한다. 이러한 Pooling에는 Max Pooling, Average Pooling등 다양한 것이 있는데, 보통 Max를 많이 사용한다. Max Pooling 의 예다. 각 섹션 별로 큰 값만 추출해 낸 모습이다. Average Pooling 이라면 평균값을 추출 할 것이다. 이렇게 함으로써, 큰 값이 다른 주변의 값을 (특징을) 대표한다는 개념을 적용시킬 수 있다. 이렇게 Pooling 을 적용하여 과적합을 방지하고, 리소스를 어느정도 줄일 수 있다. ¶Convolutaionl Layer 자동차 인식을 위해 CNN을 적용한 모습이다. Conv-Relu-Conv-Relu-Pool-Conv-Relu-Conv-Relu-Pool-Conv-Relu-Conv-Relu-Pool를 적용해서 인식을 해낸 모습이다. ¶Softmax Function 마지막에는 최종적으로 Softmax함수를 적용한다. Softmax도 일종의 Activation 함수인데, Sigmoid와 ReLU가 True, False (0, 1)만 표현한다면, Softmax Function은 여러개의 분류를 가질 수 있는 함수다. ¶Dropout 드롭아웃은 Overfitting을 방지하기 위한 방법이다. 일부 노드들을 훈련에 참여시키지 않고 몇개의 노드를 끊어서, 남은 노드들을 통해서만 훈련시키는 방식이다. 이 때 끊어버리는 노드는 랜덤으로 선택한다. pytorch에서는 기본값이 0.5 다. 즉 절반의 노드를 dropout하고 계산한다. 이렇게 함으로써, training하는 과정에서 Overfitting이 발생하지 않게 할 수 있다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch (3) - 합성곱신경망 (CNN - Convolutional Nerual Network)","slug":"pytorch-3-convolutional-neural-network","date":"2019-01-28T15:00:00.000Z","updated":"2019-01-29T01:03:00.000Z","comments":true,"path":"2019/01/29/pytorch-3-convolutional-neural-network/","link":"","permalink":"https://www.yceffort.kr/2019/01/29/pytorch-3-convolutional-neural-network/","excerpt":"합성곱신경망(CNN - Convolutaional Neural Network, 이하 CNN)은 말그대로, 합성곱 연산을 사용하는 인공신경망의 한 종류다. Convolution을 활용하면 3차원 데이터의 공간적 정보를 유지한 상태로 다음 레이어로 보내는 것이 가능하다. CN N역시 입력층, 중간층, 출력층으로 구성되어 있으며 각 층은 다시 노드로 이루어져 있으며, 층과 층사이에만 노드간 결합이 있다는 것도 다중 퍼셉트론과 동일하다. 마찬가지로, 지도학습 알고리즘 이기 때문에 설명변수와 목적변수가 들어 있다. 다만 차이가 있다면,","text":"합성곱신경망(CNN - Convolutaional Neural Network, 이하 CNN)은 말그대로, 합성곱 연산을 사용하는 인공신경망의 한 종류다. Convolution을 활용하면 3차원 데이터의 공간적 정보를 유지한 상태로 다음 레이어로 보내는 것이 가능하다. CN N역시 입력층, 중간층, 출력층으로 구성되어 있으며 각 층은 다시 노드로 이루어져 있으며, 층과 층사이에만 노드간 결합이 있다는 것도 다중 퍼셉트론과 동일하다. 마찬가지로, 지도학습 알고리즘 이기 때문에 설명변수와 목적변수가 들어 있다. 다만 차이가 있다면, 중간층이 합성곱층, 풀링충, 전결합충으로 구성되어 있다는 것이 다르다. ¶1. 합성곱층 가장 첫번째로 배치되는 레이어다. 입력 데이터에 필터를 적용해서 데이터에서 특징값을 추출한다. 첫번째 그림이 입력층이고, 가운데가 필터다. 가중치를 가진 필터를 입력데이터의 각 위치마다 적용하고, 각 노드의 값과 가중치의 곱셈합을 구하는 방식으로 특징값을 추출한다. 그리고 그 결과를 맵형태로 다음 레이어에 전달하는 것이다. ¶2. 풀링층 풀링층은 앞서 전달 받은 합성곱층의 데이터에서 일정영역마다 최댓값 (평균값을 구하는 경우도 있다) 을 남긴다. 이런 방법을 활용하여 중요한 특징만을 남기게 된다. 이렇게 되면, 데이터의 기존 크기에 비해서 특징이 추출된 맵의 개수가 적어지게 된다. 이 개수를 입력 데이터의 크기에 맞춰 유지하기 위해 입력 데이터에 패딩을 적용하기도 한다. CNN에서는 입력 데이터의 패딩영역을 0으로 채우는 제로 패딩을 주로 사용한다. 학습과정에서 이 방식으로 순전파와 역전파를 반복하며, Convolutional 필터의 가중치를 최적화 하는 방식으로 모형을 학습하게 된다. \b ¶손글씨 이미지 분류하기 일단 데이터 전처리 과정까지는 똑같다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import torchfrom torch.autograd import Variableimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torch.utils.data import DataLoader, TensorDatasetfrom sklearn.datasets import load_digitsfrom sklearn import datasets, model_selectionfrom matplotlib import pyplot as pltfrom matplotlib import cmimport pandas as pd%matplotlib inlineimport urllibfrom scipy.io import loadmatmnist_alternative_url = \"https://github.com/amplab/datascience-sp14/raw/master/lab7/mldata/mnist-original.mat\"mnist_path = \"./mnist-original.mat\"response = urllib.request.urlopen(mnist_alternative_url)with open(mnist_path, \"wb\") as f: content = response.read() f.write(content)mnist_raw = loadmat(mnist_path)mnist = &#123; \"data\": mnist_raw[\"data\"].T, \"target\": mnist_raw[\"label\"][0], \"COL_NAMES\": [\"label\", \"data\"], \"DESCR\": \"mldata.org dataset: mnist-original\",&#125;print(\"Success!\")mnist_data = mnist['data'] / 255mnist_label = mnist['target']train_size = 50000test_size = 500train_X, test_X, train_Y, test_Y = model_selection.train_test_split(mnist_data, mnist_label, train_size=train_size, test_size=test_size )device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")device 이제 달라진다. 기존에는 1차원 배열로 변환해서 flatten 구별했지만, 이제는 2차원 배열로 만들어서 작업을 한다. 12345678910111213141516171819202122# 1차원 배열을 28 * 28 이차원 배열로 만듬train_X = train_X.reshape((len(train_X), 1, 28, 28))test_X = test_X.reshape((len(test_X), 1, 28, 28))train_X = torch.from_numpy(train_X).float().to(device)train_Y = torch.from_numpy(train_Y).long().to(device)test_X = torch.from_numpy(test_X).float().to(device)test_Y = torch.from_numpy(test_Y).long().to(device)print(train_X.shape)print(train_Y.shape)# 설명변수와 목적변수 텐서를 합침train = TensorDataset(train_X, train_Y)# 텐서의 첫 번째 데이터를 확인print(train[0])# 미니배치 분할train_loader = DataLoader(train, batch_size=100, shuffle=True) 그리고 cuda를 사용해서 작업했다. 확실히 그냥 CPU로 작업하게 되면 엄청 느리다. 다음은 신경망 이다. 123456789101112131415161718192021222324252627282930class Net(nn.Module): def __init__(self): super(Net, self).__init__() # 합성곱층 # 입력채널 수(1), 출력채널수(6), 필터크기(5) self.conv1 = nn.Conv2d(1, 6, 5) self.conv2 = nn.Conv2d(6, 16, 5) # 전결합층 self.fc1 = nn.Linear(256, 64) self.fc2 = nn.Linear(64, 10) def forward(self, x): # 풀링층 x = F.max_pool2d(F.relu(self.conv1(x)), 2) x = F.max_pool2d(F.relu(self.conv2(x)), 2) x = x.view(-1, 256) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x) model = Net()model.cuda() 123456Net( (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=256, out_features=64, bias=True) (fc2): Linear(in_features=64, out_features=10, bias=True)) 일단 필터 사이즈는 5,5 로 구성했고, stride (필터의 이동) 은 한칸씩으로 구성했다. ¶Convolution Layer 크기 Convolution Layer의 출력 데이터 크기는 아래와 같이 산정한다. 입력 데이터 높이: H 입력 데이터 폭: W 필터 높이: FH 필터 폭: FW stride 크기: S 패딩사이즈: P $$ \\text{OutputHeight} = \\text{OH} = \\frac{(H + 2P - FH)}{S} + 1 $$ $$ \\text{OutputWeight} = \\text{OW} = \\frac{(HW+ 2P - FW)}{S} + 1 $$ 주의 할 점은 여기에서 이 숫자들은 자연수가 되어야 한다는 것이다. 또한 Covolutional layer 다음에 pooling layer가 온다면 pooling 크기의 배수가 되어야 한다. 1번째 Convolutional Layer 부터 살펴보자. 입력크기가 1 (그레이스케일 이미지의 채널수는 1), 출력크기는 6, 필터크기는 5다. 2번째 레이어는 입력크기가 6 (첫번째에서 6의 크기로 출렸했으므로) , 출력크기가 16, 필터크기는 5다. 출력크기 구하기 $$ \\text{OH} = \\frac{28 + 2*1 - 5}{5} + 1 = 6 $$ 12345678910111213141516171819202122232425criterion = nn.CrossEntropyLoss()optimizer = optim.SGD(model.parameters(), lr=0.01)for epoch in range(1000): total_loss = 0 for train_x, train_y in train_loader: train_x, train_y = Variable(train_x), Variable(train_y) optimizer.zero_grad() output = model(train_x) loss = criterion(output, train_y) loss.backward() optimizer.step() total_loss += loss.data.item() if (epoch+1) % 10 == 0: print(epoch+1, total_loss)test_x, test_y = Variable(test_X), Variable(test_Y)result = torch.max(model(test_x).data, 1)[1]accuracy = sum(test_y.cpu().data.numpy() == result.cpu().numpy()) / len(test_y.cpu().data.numpy())accuracy 정확도가 98.8% 가 나왔다. 98.8로 손글씨를 판별해 내었다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch (2-3) - 뉴스 카테고리 분류하기","slug":"pytorch-2-multi-perceptron(3)","date":"2019-01-27T15:00:00.000Z","updated":"2019-01-28T03:32:01.000Z","comments":true,"path":"2019/01/28/pytorch-2-multi-perceptron(3)/","link":"","permalink":"https://www.yceffort.kr/2019/01/28/pytorch-2-multi-perceptron(3)/","excerpt":"뉴스 말뭉치를 다운로드 받아서 분석해보자. 말뭉치는 여기에서 받을 수 있다. 과거 뉴스 데이터를 다운로드해서, 어떤 카테코리인지 분류하는 학습을 진행해보자. 먼저 구글드라이브에 해당 파일을 업로드해서 진행했다. 물론 아래와 같은 코드로 colab docker에 업로드 할 수 있지만 1 2 from google.colab import files upload = files.upload() 속도가 너무 느리다. ㅠ.ㅠ 그래서 그냥 구글 드라이브에 올려서 진행했다. 1 2 from google.colab import dri","text":"뉴스 말뭉치를 다운로드 받아서 분석해보자. 말뭉치는 여기에서 받을 수 있다. 과거 뉴스 데이터를 다운로드해서, 어떤 카테코리인지 분류하는 학습을 진행해보자. 먼저 구글드라이브에 해당 파일을 업로드해서 진행했다. 물론 아래와 같은 코드로 colab docker에 업로드 할 수 있지만 12from google.colab import filesupload = files.upload() 속도가 너무 느리다. ㅠ.ㅠ 그래서 그냥 구글 드라이브에 올려서 진행했다. 12from google.colab import drivedrive.mount('/content/gdrive') 이렇게하면, 구글드라이브의 내용을 /contnet/gdrive에 마운트 할 수 있다. 마운트 된 gdrive는 파일 시스템에 접근하는 것처럼 손쉽게 접근할 수 있다. 오오 구글신 오오… 그리고 한글 형태소를 분석해야 하므로, 한글 형태소 분석을 지원하는 라이브러리를 깔았다. 1!pip3 install konlpy 한글 형태소 라이브러리에 관한 글은 여기저기에 많으니 따로 설명하지 않겠다. 123456789101112import osimport refrom sklearn import datasets, model_selectionfrom sklearn.feature_extraction.text import CountVectorizerfrom sklearn.feature_extraction.text import TfidfVectorizerfrom konlpy.tag import Hannanumfrom konlpy.tag import Kkmaimport pandas as pdimport numpy as np 123456target_dir = 'HKIB-20000'cat_dirs = ['healths', 'economy', 'science', 'education', 'culture', 'society', 'industry', 'leisure', 'politics']cat_prefixes = ['건강', '경제', '과학', '교육', '문화', '사회', '산업', '여가', '정치']files = os.listdir(data_path+'/'+target_dir)files 1234567891011121314151617[&apos;hkib20000-cat03-file3.categories&apos;, &apos;hkib20000-cat07-all.categories&apos;, &apos;hkib20000-cat07-file3.categories&apos;, &apos;hkib20000-cat03-file1.categories&apos;, &apos;hkib20000-cat07-file4.categories&apos;, &apos;hkib20000-cat07-file2.categories&apos;, &apos;hkib20000-cat03-file4.categories&apos;, &apos;hkib20000-cat03-file5.categories&apos;, &apos;hkib20000-cat03-all.categories&apos;, &apos;hkib20000-cat07-file5.categories&apos;, &apos;hkib20000-cat03-file2.categories&apos;, &apos;hkib20000-cat07-file1.categories&apos;, &apos;HKIB-20000_003.txt&apos;, &apos;HKIB-20000_002.txt&apos;, &apos;HKIB-20000_001.txt&apos;, &apos;HKIB-20000_005.txt&apos;, &apos;HKIB-20000_004.txt&apos;] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 데이터 정리files = os.listdir(data_path+'/'+target_dir)# 5분할된 텍스트 파일을 각각 처리for file in files: # 데이터가 담긴 파일만 처리 if not file.endswith('.txt'): continue # 각 텍스트 파일을 처리 with open(data_path + 'HKIB-20000/' + file) as currfile: doc_cnt = 0 docs = [] curr_doc = None # 기사 단위로 분할하여 리스트를 생성 for curr_line in currfile: if curr_line.startswith('@DOCUMENT'): if curr_doc is not None: docs.append(curr_doc) curr_doc = curr_line doc_cnt = doc_cnt + 1 continue curr_doc = curr_doc + curr_line # 각 기사를 대주제 별로 분류하여 기사별 파일로 정리 for doc in docs: doc_lines = doc.split('\\n') doc_no = doc_lines[1][9:] # 주제 추출 doc_cat03 = '' for line in doc_lines[:10]: if line.startswith(\"#CAT'03:\"): doc_cat03 = line[10:] break # 추출한 주제 별로 디렉토리 정리 for cat_prefix in cat_prefixes: if doc_cat03.startswith(cat_prefix): dir_index = cat_prefixes.index(cat_prefix) break # 문서 정보를 제거하고 기사 본문만 남기기 filtered_lines = [] for line in doc_lines: if not (line.startswith('#') or line.startswith('@')): filtered_lines.append(line) # 주제별 디렉토리에 기사를 파일로 쓰기 filename = 'hkib-' + doc_no + '.txt' filepath = data_path + 'HKIB-20000/' + cat_dirs[dir_index] if not os.path.exists(filepath): os.makedirs(filepath) f = open(filepath + '/' + filename, 'w') f.write('\\n'.join(filtered_lines)) f.close() 이렇게 해서, 각각의 주제별로 나눈 다음에 txt파일을 생성하였다. 고오급 스킬이 필요한 것은 아니고, 단순 노가다의 문제다. 123456789101112131415161718192021222324252627282930313233dirs = cat_dirsx_ls = []y_ls = []tmp1 = []tmp2 = ''tokenizer = Kkma()for i, d in enumerate(dirs): files = os.listdir(data_path+'HKIB-20000/'+d) for file in files: f = open(data_path+'HKIB-20000/'+d+'/'+file, 'r', encoding='UTF-8') raw = f.read() reg_raw = re.sub(r'[-\\'@#:/◆▲0-9a-zA-Z&lt;&gt;!-\"*\\(\\)]', '', raw) reg_raw = re.sub(r'[ ]+', ' ', reg_raw) reg_raw = reg_raw.replace('\\n', ' ') tokens = tokenizer.nouns(reg_raw) for token in tokens: tmp1.append(token) tmp2 = ' '.join(tmp1) x_ls.append(tmp2) tmp1 = [] y_ls.append(i) f.close() 내용에서 특수문자를 제거하고, x_ls에 설명변수, y_ls에 목적변수를 각각 넣었다. 처음에는 딱 두개카테코리만 0, 1 로 분석해서 진행했다. 여유가 되다면 (시간이 남고 컴퓨터도 빠르다면…) 모든 파일을 분석해보는 것도 재밌을 수 있다. 12345678x_array = np.array(x_ls)y_array = np.array(y_ls)cntvec = CountVectorizer()x_cntvecs = cntvec.fit_transform(x_array)x_cntarray = x_cntvecs.toarray()pd.DataFrame(x_cntarray) CounterVectyorizer를 통해서 단어 별로 쪼갰다. 그 결과 1001행 * 33572열 크기의 표가 생성되었다. 프린트를 해보면 12for k, v in sorted(cntvec.vocabulary_.items(), key=lambda x: x[1]): print(k, v) 123456789101112가가 0가가치 1가검물 2가게 3가격 4가격등 5가격명 6가격문란 7가격변동 8가격산정 9가격상승요인 10.... 이런식으로 추출해 놓은 단어가 나온다. 이제 본격적으로 분석해보자. 12345678910111213141516train_X, test_X, train_Y, test_Y = model_selection.train_test_split(x_tfidf_array, y_array, test_size=0.2)import torchfrom torch.autograd import Variableimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torch.utils.data import DataLoader, TensorDatasettrain_X = torch.from_numpy(train_X).float()train_Y = torch.from_numpy(train_Y).long()test_X = torch.from_numpy(test_X).float()test_Y = torch.from_numpy(test_Y).float()train = TensorDataset(train_X, train_Y)train_loader = DataLoader(train, batch_size=100, shuffle=True) 이제 신경망을 구성해보자. 입력층에는 33572개의 단어가 있었고, 중간노드수는 256개, 128객 그리고 출력층은 2개 (두 개의 카테고리만 분석)로 구성해두었다. 12345678910111213141516171819202122# 신경망 구성class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.fc1 = nn.Linear(33572, 256) self.fc2 = nn.Linear(256, 256) self.fc3 = nn.Linear(256, 256) self.fc4 = nn.Linear(256, 128) self.fc5 = nn.Linear(128, 128) self.fc6 = nn.Linear(128, 2) def forward(self, x): x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = F.relu(self.fc3(x)) x = F.relu(self.fc4(x)) x = F.relu(self.fc5(x)) x = self.fc5(x) return F.log_softmax(x) # 인스턴스 생성model = Net() 1234567891011121314151617criterion = nn.CrossEntropyLoss()optimizer = optim.Adam(model.parameters(), lr=0.05)for epoch in range(20): total_loss = 0 for train_x, train_y in train_loader: train_x, train_y = Variable(train_x), Variable(train_y) optimizer.zero_grad() output = model(train_x) loss = criterion(output, train_y) loss.backward() optimizer.step() total_loss += loss.data.item() print(epoch + 1, total_loss) 1234test_x, test_y = Variable(test_X), Variable(test_Y)result = torch.max(model(test_x).data, 1)[1]accuracy = sum(test_y.data.numpy() == result.numpy()) / len(test_y.data.numpy())accuracy 10.9203980099502488 92%의 정확성으로 구별해 내었다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch (2-4) - 이상 날씨 탐지","slug":"pytorch-2-multi-perceptron(4)","date":"2019-01-27T15:00:00.000Z","updated":"2019-01-28T05:14:46.000Z","comments":true,"path":"2019/01/28/pytorch-2-multi-perceptron(4)/","link":"","permalink":"https://www.yceffort.kr/2019/01/28/pytorch-2-multi-perceptron(4)/","excerpt":"다층 퍼셉트론 마지막 예제로 이상 날씨 탐지를 진행해보자. 2011년 1월 1일 부터 2016년 12월 31일까지 서울시의 일 평균 기온데이터를 활용해 본다. 여기에서 데이터를 받을 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import torch from torch.autograd import Variable import torch.nn as nn import torch.nn.functional as F import torch.optim as opti","text":"다층 퍼셉트론 마지막 예제로 이상 날씨 탐지를 진행해보자. 2011년 1월 1일 부터 2016년 12월 31일까지 서울시의 일 평균 기온데이터를 활용해 본다. 여기에서 데이터를 받을 수 있다. 12345678910111213141516171819202122import torchfrom torch.autograd import Variableimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torch.utils.data import DataLoader, TensorDatasetimport pandas as pdimport numpy as npfrom matplotlib import pyplot as plt%matplotlib inlinefrom google.colab import filesupload = files.upload()import iostring_csv = io.StringIO(upload['ta_20190128205219.csv'].decode('euc-kr'))data = pd.read_csv(string_csv, skiprows=[0, 1, 2, 3, 4, 5])data.head() 날짜 지점 평균기온(℃) 최저기온(℃) 최고기온(℃) 0 2009-01-01 108 -5.8 -9.5 -2.5 1 2009-01-02 108 -2.8 -6.9 1.2 2 2009-01-03 108 -1.0 -5.6 4.0 3 2009-01-04 108 0.4 -2.8 4.5 4 2009-01-05 108 -1.6 -3.4 1.2 123temp = data['평균기온(℃)']temp.plot()plt.show() 시계열로 데이터가 보인다. 123456train_index = round(len(temp) * 0.8)train_x = temp[:train_index]test_x = temp[train_index:]train_x = np.array(train_x)test_x = np.array(test_x) 시계열 데이터에서는 훈련데이터를 어떻게 만들어야 할까? 위에서 본 그래프에 따르면, 우리나라는 아름다운 4계절 국가이기 때문에 파도 형태로 온도가 요동치고 있다. (ㅠㅠ) 또한 당연한 얘기지만 부드럽게 움직이는 것이아니고, 요동치고 있기 때문에 이 데이터를 그대로 사용하게 되면 overfitting 문제가 발생할 가능성이 크다. 따라서 시계열 데이터를 다룰 때는, 일정 폭의 윈도우를 정의하고, 이 데이터를 따라 윈도우를 슬라이드 시켜 얻는 연속열을 통해서 훈련데이터로 삼아야 한다. 대략 이런 느낌 123456789101112# 윈도우 크기 (180일, 6개월)WINDOW_SIZE = 180tmp = []train_X = []for i in range(0, len(train_x) - WINDOW_SIZE): tmp.append(train_x[i:i+WINDOW_SIZE])train_X = np.array(tmp)pd.DataFrame(train_X).head() 0 1 2 3 4 5 6 7 8 9 ... 170 171 172 173 174 175 176 177 178 179 0 -5.8 -2.8 -1.0 0.4 -1.6 -2.0 -0.5 -0.9 -3.5 -7.5 ... 22.7 25.1 23.0 23.4 24.5 24.8 24.4 26.1 26.0 26.1 1 -2.8 -1.0 0.4 -1.6 -2.0 -0.5 -0.9 -3.5 -7.5 -8.0 ... 25.1 23.0 23.4 24.5 24.8 24.4 26.1 26.0 26.1 24.4 2 -1.0 0.4 -1.6 -2.0 -0.5 -0.9 -3.5 -7.5 -8.0 -7.8 ... 23.0 23.4 24.5 24.8 24.4 26.1 26.0 26.1 24.4 23.5 3 0.4 -1.6 -2.0 -0.5 -0.9 -3.5 -7.5 -8.0 -7.8 -5.5 ... 23.4 24.5 24.8 24.4 26.1 26.0 26.1 24.4 23.5 20.7 4 -1.6 -2.0 -0.5 -0.9 -3.5 -7.5 -8.0 -7.8 -5.5 -6.6 ... 24.5 24.8 24.4 26.1 26.0 26.1 24.4 23.5 20.7 22.5 이제 신경망을 구성하려고 한다. 이상탐지를 위해서, 자기부호화기 (auto encoder)를 사용하려고 한다. 다시한번 자기부호화기를 설명하자면, 입력층의 데이터를 압축하여 크기를 축소하고, 그렇게 해서 축소된 정보를 바탕으로 다시 원래 데이터를 복구하는 방법이다. 즉 이 신경망의 목표는 입력층을 암호화하고 다시 바로 복호화 했을때, 이 입력을 다시 제대로 복호화 할 수 있는 파라미터를 찾는 것이다. 여기서 우리가 할 것은, 입력층과 출력층은 똑같이 (180개), 그리고 중간 층 3개에서 128, 64로 압축한뒤, 다시 128개, 180개로 복호화 하는 것이다. 123456789101112131415161718class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.fc1 = nn.Linear(180, 128) self.fc2 = nn.Linear(128, 64) self.fc3 = nn.Linear(64, 128) self.fc4 = nn.Linear(128, 180) def forward(self, x): x = F.relu(self.fc1(x)) x = self.fc2(x) x = F.relu(self.fc3(x)) x = self.fc4(x) return x; model = Net() 모형학습 123456789101112131415161718192021222324252627282930313233343536# 평균제곱 오차를 구한다.criterion = nn.MSELoss()# adam optimizeroptimizer = optim.Adam(model.parameters(), lr=0.001)for epoch in range(1000): total_loss = 0 d = [] # 훈련 데이터를 미니 배치로 분할 for i in range(100): # 훈련 데이터에 인덱스 index = np.random.randint(0, 1281) # 미니 배치로 구성 d.append(train_X[index]) # numpy로 변환후 다시 Variable로 d = np.array(d, dtype='float32') d = Variable(torch.from_numpy(d)) optimizer.zero_grad() # 순전파 output = model(d) # 오차 loss = criterion(output, d) # 역전파 loss.backward() # 가중치 업데이트 optimizer.step() total_loss += loss.data.item() if (epoch+1) % 100 == 0: print(epoch+1, total_loss) 12345678910100 9.88106632232666200 9.357300758361816300 9.327717781066895400 8.321449279785156500 7.5223541259765625600 7.002117156982422700 6.586050033569336800 6.0552496910095215900 5.2733039855957031000 5.39844274520874 결과값과 원래 데이터를 그래프로 보자. 1234plt.plot(d.data[0].numpy(), label='original')plt.plot(output.data[0].numpy(), label='output')plt.legend(loc='upper right')plt.show() 테스트 데이터 값과 테스트 데이터에 모형을 적용하고, 출력된 값을 확인 1234567891011121314151617tmp = []test_X = []tmp.append(test_x[0:180])tmp.append(test_x[180:360])tmp.append(test_x[360:540])tmp.append(test_x[540:720])test_X = np.array(tmp, dtype='float32')d = Variable(torch.from_numpy(test_X))output = model(d)plt.plot(test_X.flatten(), label='original')plt.plot(output.data.numpy().flatten(), label='prediction')plt.legend(loc='upper right')plt.show() 12345678910111213141516test = test_X.flatten()pred = output.data.numpy().flatten()total_score = []for i in range(0, 720): dist = (test[i] - pred[i]) score = pow(dist, 2) total_score.append(score) # 점수를 0과 1로 정규화 total_score = np.array(total_score)max_score = np.max(total_score)total_score = total_score / max_scoreplt.plot(total_score)plt.show()","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch (1) - 퍼셉트론 알고리즘과 신경망 알고리즘","slug":"pytorch-1-perceptron-nerual-network","date":"2019-01-26T15:00:00.000Z","updated":"2019-01-27T01:20:06.000Z","comments":true,"path":"2019/01/27/pytorch-1-perceptron-nerual-network/","link":"","permalink":"https://www.yceffort.kr/2019/01/27/pytorch-1-perceptron-nerual-network/","excerpt":"¶퍼셉트론 알고리즘 퍼셉트론 알고리즘은 머신러닝 기법 중 지도학습 기법이자 분류 알고리즘에 속한다. 각각의 input에 입력값과 가중치를 곱한 값을 합한 다음, 바이어스 (=1)를 더한 값이 된다. 그 다음에는 활성화 함수가 노드에 전달된 값을 변환하여 출력값을 만든다. 퍼셉트론의 경우에는, 활성화 함수로 스텝함수를 쓰는 경우가 많다. 함수에서도 보이지만, 입력값이 0 이상이면 출력값이 1이 되고, 그렇지 않으면 0이 된다. 퍼셉트론은 지도학습 알고리즘이다. 따라서 학습데이터는 설명변수와 그에 대한 정답인 목적변수를 포","text":"¶퍼셉트론 알고리즘 퍼셉트론 알고리즘은 머신러닝 기법 중 지도학습 기법이자 분류 알고리즘에 속한다. 각각의 input에 입력값과 가중치를 곱한 값을 합한 다음, 바이어스 (=1)를 더한 값이 된다. 그 다음에는 활성화 함수가 노드에 전달된 값을 변환하여 출력값을 만든다. 퍼셉트론의 경우에는, 활성화 함수로 스텝함수를 쓰는 경우가 많다. 함수에서도 보이지만, 입력값이 0 이상이면 출력값이 1이 되고, 그렇지 않으면 0이 된다. 퍼셉트론은 지도학습 알고리즘이다. 따라서 학습데이터는 설명변수와 그에 대한 정답인 목적변수를 포함해야 한다. 학습과정에서 출력, 그리고 정답과의 오차가 최대로 적어지게 가중치를 업데이트 한다. 먼저 출력과 정답의 차이를 오차로 계산한 다음, 오차와 학습률을 곱해 가중치가 실제 수정되는 값을 계산한다. 그러므로 학습률은 가중치가 조정되는 정도를 결정한다. 마지막으로 가중치 수정값을 기존 가중치에 더해주는 방법으로 가중치를 수정한다. ¶신경망 알고리즘 앞에서 설명한 퍼셉트론 알고리즘은, 비선형적인 문제를 풀 수 없다는 한계가 있다. 따라서 선형분리가 불가능한 문제는 퍼셉트론 한개가 아니라, 퍼셉트론을 여러개를 조합하는 신경망 알고리즘으로 풀 수 있다. 신경망은 입력층, 중간층, 출력층으로 구성되며, 각 층은 하나 이상의 노드로 구성된다. 그리고 서로 다른 층에 있는 노드들끼리만 연결된다. (동일레벨에서는 연결되지 않는다.) 신경망 또한 지도학습 알고리즘이므로 학습데이터도 설명변수와 목적변수를 포함한다. 퍼셉트론에서는 활성화 함수로 스텝함수를 썼는데, 신경망에서는 시그모이드 함수, 쌍곡선 함수, ReLU함수를 주로 사용한다. 여기에서도 주로 ReLU함수를 사용하는 듯 하다. 비교 글은 여기를 참고하면 잘 설명해주고 있다. 만약 풀려고 하는 문제가 '분류’에 관한 문제면, 출력층의 활성화 함수로 softmax 함수를 사용한다. 소프트맥스 함수는, 모든 출력층 노드 출력값의 합이 1이 된다는 특징을 가지고 있다. 따라서 이미지 분류를 예로 소프트맥스 함수를 사용한다면, 각 이미지 분류에 대한 적합도를 확률로 생각할 수 있을 것이다. 반대로 '회귀’문제라면 항등함수를 사용한다. 이렇게 입력층 부터 출력층까지 이어지는 계산과정을, 앞에서 부터 순서대로 정보가 전달된다는 의미로 순전파(Forward Propagation, FP)라고 한다. ¶신경망 모형 학습 신경망은 지도학습 알고리즘이므로, 설명변수 데이터 외에도 정답이 되는 목적변수 데이터가 필요하다. 즉, 신경망 가중치를 업데이트 하려면 오차와 오차함수가 필요하다. 분류 문제에는 교차엔트로피를 사용하며, 회귀문제에는 제곱오차를 사용한다. 초기 가중치에서 서서히 가중치를 업데이트하며, 가장 밑바닥에 있는, 오차가 가장 작은 부분까지 내려오면 된다. 오차 곡선에 접선을 그어, 오차와 가중치의 변화량으로 부터 기울기를 계산한다. 그리고 이 기울기를 ‘미분계수’ 라고 한다. pytorch에서 말하는 autograd, 자동미분 기능에서 말하는 미분이 바로 이것이다. 학습하는 방법 중에서는 배치 학습과, 미니배치 학습이 있다. 배치 학습은, 가중치를 한번 업데이트를 할때, 모든 데이터를 사용한다. 그러나 미니배치 학습은 데이터를 여러갈래 나누어 한갈래씩 사용해 가중치를 업데이트한다. 일반적으는 미니배치학습을 사용하는 경우가 많다. 배치학습을 사용할 경우, 최적해를 구하는 과정에서 국소 최적해에 빠지는 경우가 많기 때문이다. 진화적 절차와 최적해. 파란 곡선에서 가로축은 문제에 대한 해결책을 나타내고, 세로축의 깊이는 해결책이 얼마나 좋은지를 나타낸다. 깊이가 깊을수록 좋은 해결책이므로 가장 깊은 두번째 골이 전역 최적해이고 나머지 3개의 골은 국소 최적해가 된다. 진화적 절차에서는 점점 더 좋은 해결책을 향해 진화하므로, 세대를 거듭할수록 출발 지점 인근의 골을 향해 내려간다 (빨간 공들과 화살표) 출처 지금까지 설명한 과정을, 역전파 (backpropagation, BP)라고 한다. 출력층에서 입력층으로 거슬러 올라가면서 전달되므로, 오차 역전파라고 한다. 순전파와 역전파를 반복하면서 신경망 모형의 정확도를 높여가면 된다. ¶와인 분류해보기 지금까지 공부해본 신경망 알고리즘으로, 와인을 분류해보는 것을 진행해보자. 학습환경은 google colab을 사용할 것이다. 구글 colab에서 pytorch를 사용하려면 아래와 같이 pytorch를 받으면 된다. {:width=“200px”} 12!pip3 install https://download.pytorch.org/whl/cu80/torch-1.0.0-cp36-cp36m-linux_x86_64.whl!pip3 install torchvision 매 노트북 마다 설정해줘야 하는 불편함이 있지만, GPU를 사거나 대여하고, 설정하는 것보다는 백번 천번 낫다. 구글을 향해 절을 하자. 1234567891011import torchfrom torch.autograd import Variableimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torch.utils.data import DataLoader, TensorDatasetfrom sklearn.datasets import load_winefrom sklearn.model_selection import train_test_splitimport pandas as pd 12wine = load_wine()wine sklearn에서 제공하는 wine 에는 다음과 같은 필드가 있다. DESCR: 데이터 집합의 상세정보 data: 와인 성분 데이터 (설명변수) feature_names: 와인 성분명 target: 와인의 품종 데이터 (목적변수) target_names: 와인의 품종이름 대충 데이터를 보자. 1pd.DataFrame(wine.data, columns=wine.feature_names) alcohol malic_acid ash alcalinity_of_ash magnesium total_phenols flavanoids nonflavanoid_phenols proanthocyanins color_intensity hue od280/od315_of_diluted_wines proline 0 14.23 1.71 2.43 15.6 127.0 2.80 3.06 0.28 2.29 5.640000 1.04 3.92 1065.0 1 13.20 1.78 2.14 11.2 100.0 2.65 2.76 0.26 1.28 4.380000 1.05 3.40 1050.0 2 13.16 2.36 2.67 18.6 101.0 2.80 3.24 0.30 2.81 5.680000 1.03 3.17 1185.0 대충 잘랐지만, 178*13 정도 다. 1wine.target 123456789array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) 다음은 목적 변수다. 0 부터 2까지의 값을 갖는 numpy배열이다. 일단 0과 1 분류만 해보도록 하자. 그리고, 각각의 데이터를 훈련데이터, 테스트 데이터로 나눈다. 1234wine_data = wine.data[0:130]wine_target = wine.target[0:130]train_X, test_X, train_Y, test_Y = train_test_split(wine_data, wine_target, test_size=0.2) 그리고 각각의 데이터를, 파이토치가 다룰 수 있는 형태로 정리한다. 123456# 데이터를 텐서 형태로 변환train_X = torch.from_numpy(train_X).float()train_Y = torch.from_numpy(train_Y).long()test_X = torch.from_numpy(test_X).float()test_Y = torch.from_numpy(test_Y).float() 그리고 설명변수와 목적변수의 텐서를 합친다. 이를 미니배치로 분할한다. 미니배치 사이즈는 16이다. 12train = TensorDataset(train_X, train_Y)train_loader = DataLoader(train, batch_size=16, shuffle=True) 1train[0] 123(tensor([1.2330e+01, 9.9000e-01, 1.9500e+00, 1.4800e+01, 1.3600e+02, 1.9000e+00, 1.8500e+00, 3.5000e-01, 2.7600e+00, 3.4000e+00, 1.0600e+00, 2.3100e+00, 7.5000e+02]), tensor(1)) train 첫번째 데이터를 살짝 엿보면, 각각의 설명변수와 목적변수가 따로 담겨 있는 것을 알 수 있다. ¶신경망 구성 만들어볼 신경망 구성은 다음과 같다. 입력층, 중간층, 출력층이 각각 하나씩 있는 신경망을 구성한다. 입력층의 노드 개수는 13개 (설명변수가 13개 니깐)고, 중간층 노드의 개수는 96개 (내맘) 출력층 노드의 수는 2개 (목적변수가 0, 1 이니깐…) 다. 마지막 출력층에서는 0일 확률과 1일 확률을 뱉어낼 것이다. 123456789101112131415161718192021class Net(nn.Module): def __init__(self): super(Net, self).__init__() # 입력층과 중간층 사의의 정의. 13개의 입력변수를 받아서 96개의 중간층 노드를 만든다. self.fc1 = nn.Linear(13, 96) # 중간층과 출력층 사의의 정의. 96개의 중간변수를 받아서 2개의 최종 노드를 만든다. self.fc2 = nn.Linear(96, 2) # 순전파 def forward(self, x): # relu함수로 입력층을 변환한다. x = F.relu(self.fc1(x)) # 이를 중간층으로 넘긴다. x = self.fc2(x) # 출력 함수로 log_softmax를 사용한다. return F.log_softmax(x)# 선언model = Net() torch.nn.Module: 모든 신경망 모듈의 기본이 되는 클래스다. 이 안에 각 층, 함수, 신경망구조를 정의한다. torch.nn.Linear: 입력데이터에 대해서 선형 변환 $$y = Ax + b$$를 변환한다. torch.nn.functional.relu: ReLU torch.nn.fucntional.log_softmax: log softmax를 구현했다. ¶모형학습 12345678910111213141516171819202122232425262728293031323334353637# 오차함수. 분류 문제에는 교차 함수로 크로스 엔트로피를 사용한다고 했었다.criterion = nn.CrossEntropyLoss()# 최적화 담당. 경사 하강법을 적용하였다. 학습률은 0.01.optimizer = optim.SGD(model.parameters(), lr=0.01)#학습 300회 ㄱㄱ 씽for epoch in range(300): # 누적 오차를 담당할 변수 total_loss = 0 # 아까 만들어놓은 미니 배치에서 각각 변수를 꺼내온다. for train_x, train_y in train_loader: # 각각의 값을 변수로 만든다. train_x, train_y = Variable(train_x), Variable(train_y) # 경사 초기화 optimizer.zero_grad() # 순전파 output = model(train_x) # 오차계산. ouutput 과 train_y 비교 loss = criterion(output, train_y) # 역전파 계산 loss.backward() # 가중치 업데이트. learning rate만큼 optimizer.step() #총 오차 업데이트 total_loss += loss.data.item() # 50 회 마다 현재 오차를 출력 if (epoch + 1) % 50 == 0: print(epoch + 1, total_loss) 결과 12345650 4.854998767375946100 4.855347692966461150 4.854018688201904200 4.853011429309845250 4.853777766227722300 4.8532750606536865 정확도를 알아보자. 1234567# 테스트 데이터를 집어 넣는다.test_x, test_y = Variable(test_X), Variable(test_Y)# 테스트 데이터를 집어 넣어서 학습 시킨 다음, max 값(확률이 더 높은 값)을 출력한다.result = torch.max(model(test_x).data, 1)[1]# 정확도 계산accuracy = sum(test_y.data.numpy() == result.numpy()) / len(test_y.data.numpy())accuracy 와! 정확도 27%! 와!","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch (2-1) - 다층 퍼셉트론","slug":"pytorch-2-multi-perceptron(1)","date":"2019-01-26T15:00:00.000Z","updated":"2019-01-27T01:20:06.000Z","comments":true,"path":"2019/01/27/pytorch-2-multi-perceptron(1)/","link":"","permalink":"https://www.yceffort.kr/2019/01/27/pytorch-2-multi-perceptron(1)/","excerpt":"전에는 신경망에서 중간층을 하나로만 했지만, 이 중간층을 여러개로 늘린 것을 심층신경망 (deep neural network) 라고 한다. 벌써 부터 뭔가 있어보인다. 이는 딥러닝에서 주요 매커니즘이다. 신경망과 심층 신경망 모두 퍼셉트론을 여러개 조합해서 구성한 것으로, 다층 퍼셉트론 (multilayer perceptron, MLP)라고 한다. 어쩄거나, 입력층, 중간층, 출력층으로 구성되어 있는 것은 똑같다. 다만 차이점은 중간층이 여러개라는 것 뿐이다. 마찬가지로, 순전파와 역전파를 반복해서 학습이 이뤄지며 모형을 생","text":"전에는 신경망에서 중간층을 하나로만 했지만, 이 중간층을 여러개로 늘린 것을 심층신경망 (deep neural network) 라고 한다. 벌써 부터 뭔가 있어보인다. 이는 딥러닝에서 주요 매커니즘이다. 신경망과 심층 신경망 모두 퍼셉트론을 여러개 조합해서 구성한 것으로, 다층 퍼셉트론 (multilayer perceptron, MLP)라고 한다. 어쩄거나, 입력층, 중간층, 출력층으로 구성되어 있는 것은 똑같다. 다만 차이점은 중간층이 여러개라는 것 뿐이다. 마찬가지로, 순전파와 역전파를 반복해서 학습이 이뤄지며 모형을 생성한다. 다만 중간층이 여러개라는 차이점과 함께 또다른 차이가 있는데, 바로 학습 이전단계에 노드간 연결의 가중치를 조절하는 사전 학습을 거친다는 차이가 있다. 사전 학습 알고리즘으로는, 자기부호화기(Autoencoder)가 유명하다. ¶자기 부호화기 자기부호화기는 다층 퍼셉트론 처럼 입력층, 중간층, 출력층으로 구성된다. 다만 입력층과 출력층의 노드 수가 같아야 하며, 비지도학습, 차원축소에 쓰이는 알고리즘이므로 설명변수만으로 구성되어 있다. 그리고 순전파와 역전파를 반복하면서 출력값과 입력값이 비슷해지도록 (자기 자신을 재현하도록) 학습하고 모형을 생성한다. 이 때 입력층과 중간층에서는 정보 압축 (encoding)이 일어나고, 중간층과 출력층 사이에서는 복호화 (decoding)이 일어난다. 자기 부호화기를 이용하면, 다층 퍼셉트론을 한층씩 쌓아 올릴 수 있다. ¶최적화 기법 이전에는 최적화 기법으로 경사하강법을 사용했다. 이 밖에도 momentum, adam 등이 있는데, 특히 adam을 많이 사용한다. 경사하강법에서는 학습률이 고정이었지만, adam에서는 학습도중에 자동으로 학습률을 자동으로 조정한다. (오오…) 따라서 좀더 효율적인 학습이 가능하다. 최적화의 효과를 더 높이기 위한 방법도 있다. 가중치 감쇠는 가중치에 계수를 곱해서, 가중치 값이 크게 발산하는 현상을 방지, 최적화가 안정적으로 진행되게 한다. 배치 정규화는 미니배치의 평균과 분산값으로 각층 노드의 값을 평균 0, 분산 1이 되도록 표준화 해서학습 속도를 개선한다. ¶과적합 (Overfitting) ¶와인 분류하기 2 이번엔 다층 퍼셉트론으로 와인을 분석해보자. 텐서로 변환하고, 준비하는 과정까지는 똑같다. 1234567891011121314151617181920212223242526import torchfrom torch.autograd import Variableimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torch.utils.data import DataLoader, TensorDatasetfrom sklearn.datasets import load_winefrom sklearn.model_selection import train_test_splitimport pandas as pdwine = load_wine()wine_data = wine.data[0:130]wine_target = wine.target[0:130]train_X, test_X, train_Y, test_Y = train_test_split(wine_data, wine_target, test_size=0.2)# 데이터를 텐서 형태로 변환train_X = torch.from_numpy(train_X).float()train_Y = torch.from_numpy(train_Y).long()test_X = torch.from_numpy(test_X).float()test_Y = torch.from_numpy(test_Y).float()train = TensorDataset(train_X, train_Y) 신경망 구성 12345678910111213141516171819202122232425class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.fc1 = nn.Linear(13, 96) self.fc2 = nn.Linear(96, 96) self.fc3 = nn.Linear(96, 96) self.fc4 = nn.Linear(96, 96) self.fc5 = nn.Linear(96, 96) self.fc6 = nn.Linear(96, 2) def forward(self, x): x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = F.relu(self.fc3(x)) x = F.relu(self.fc4(x)) x = F.relu(self.fc5(x)) x = self.fc6(x) return F.log_softmax(x) model = Net() 계산은 똑같다. 1234567891011121314151617181920212223242526272829303132333435#오차함수criterion = nn.CrossEntropyLoss()#최적화 담당optimizer = optim.SGD(model.parameters(), lr=0.01)#학습 300회 ㄱㄱfor epoch in range(300): total_loss = 0 for train_x, train_y in train_loader: train_x, train_y = Variable(train_x), Variable(train_y) #경사 초기화 optimizer.zero_grad() #순전파 output = model(train_x) #오차 loss = criterion(output, train_y) #역전파 계산 loss.backward() #가중치 업데이트 optimizer.step() #총 오차 업데이트 total_loss += loss.data.item() if (epoch + 1) % 50 == 0: print(epoch + 1, total_loss) 1234test_x, test_y = Variable(test_X), Variable(test_Y)result = torch.max(model(test_x).data, 1)[1]accuracy = sum(test_y.data.numpy() == result.numpy()) / len(test_y.data.numpy())accuracy 결과: 0.8846153846153846 와 88%! 이번에는 좀 쓸 만해졌다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Pytorch (2-2) - 손 글씨 분류하기","slug":"pytorch-2-multi-perceptron(2)","date":"2019-01-26T15:00:00.000Z","updated":"2019-01-27T03:32:01.000Z","comments":true,"path":"2019/01/27/pytorch-2-multi-perceptron(2)/","link":"","permalink":"https://www.yceffort.kr/2019/01/27/pytorch-2-multi-perceptron(2)/","excerpt":"¶손글씨 분류하기 (MNIST) 머신러닝의 단골 주제다. 손글씨를 분류해보자. 이전 데이터와 다른 점이라고 한다면, 이전 데이터는 표 형식이었지만, 이제는 이미지 형식으로 구성되어 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import torch from torch.autograd import Variable import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from torch.utils.data","text":"¶손글씨 분류하기 (MNIST) 머신러닝의 단골 주제다. 손글씨를 분류해보자. 이전 데이터와 다른 점이라고 한다면, 이전 데이터는 표 형식이었지만, 이제는 이미지 형식으로 구성되어 있다. 12345678910111213141516import torchfrom torch.autograd import Variableimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimfrom torch.utils.data import DataLoader, TensorDatasetfrom sklearn.datasets import load_digitsfrom sklearn import datasets, model_selectionfrom matplotlib import pyplot as pltfrom matplotlib import cmimport pandas as pd%matplotlib inline 데이터를 가져오자. 근데 어찌된 일인지, MINST original데이터를 가져오는데 계속해서 여룽밍 있어서 다른 방법을 사용하였다. 123456789101112131415from scipy.io import loadmatmnist_alternative_url = \"https://github.com/amplab/datascience-sp14/raw/master/lab7/mldata/mnist-original.mat\"mnist_path = \"./mnist-original.mat\"response = urllib.request.urlopen(mnist_alternative_url)with open(mnist_path, \"wb\") as f: content = response.read() f.write(content)mnist_raw = loadmat(mnist_path)mnist = &#123; \"data\": mnist_raw[\"data\"].T, \"target\": mnist_raw[\"label\"][0], \"COL_NAMES\": [\"label\", \"data\"], \"DESCR\": \"mldata.org dataset: mnist-original\",&#125;print(\"Success!\") 1mnist 여기에는 다음과 같은 필드가 있다. COL_NAMES: 데이터 집합의 각 컬럼명 DESCR: 데이터 집합의 설명 data: 손글시 이미지 픽셀값 target: 손글씨 이미지 숫자 레이블 (0~9) 1234# 데이터 정규화mnist_data = mnist['data'] / 255pd.DataFrame(mnist_data) 첫번째 이미지 출력 12plt.imshow(mnist_data[0].reshape(28, 28), cmap=cm.gray_r)plt.show() 12mnist_label = mnist['target']mnist_label 테스트 데이터와 훈련 데이터 분리 1234567train_size = 50000test_size = 500train_X, test_X, train_Y, test_Y = model_selection.train_test_split(mnist_data, mnist_label, train_size=train_size, test_size=test_size ) 이번에는 gpu를 사용해 보고자 한다. 데이터의 크기도 그렇고, 훈련할게 많아서 좀더 빠르지 않을까…? 1234567891011device = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")train_X = torch.from_numpy(train_X).float().to(device)train_Y = torch.from_numpy(train_Y).long().to(device)test_X = torch.from_numpy(test_X).float().to(device)test_Y = torch.from_numpy(test_Y).long().to(device)print(train_X.shape)print(train_Y.shape) gpu를 사용하기 위해선 위와 같이 변수 부터 cuda로 지정해주어야 한다. 데이터셋을 만들고 100개 짜리 미니 배치로 만들자. 12train = TensorDataset(train_X, train_Y)train_loader = DataLoader(train, batch_size=100, shuffle=True) 신경망을 만든다. 이번에 만들 신경망은 다음과 같다. 입력층, 출력층이 각 1개씩 이고, 중간층이 5개다. 입력층의 노드는 784개 이고 (28x28픽셀 이미지라 784개의 입력변수가 있다.) 중간층 노드는 256개와 128개, 출력층 노드의 개수는 10개 (0~9 구별)다. 1234567891011121314151617181920212223class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.fc1 = nn.Linear(784, 256) self.fc2 = nn.Linear(256, 256) self.fc3 = nn.Linear(256, 256) self.fc4 = nn.Linear(256, 128) self.fc5 = nn.Linear(128, 128) self.fc6 = nn.Linear(128, 10) def forward(self, x): x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = F.relu(self.fc3(x)) x = F.relu(self.fc4(x)) x = F.relu(self.fc5(x)) x = F.dropout(x, training=self.training) x = self.fc6(x) return F.log_softmax(x) model = Net()model.cuda() 이전 예제와 다른게 있다. ¶Dropout 드롭아웃은 Overfitting을 방지하기 위한 방법이다. 일부 노드들을 훈련에 참여시키지 않고 몇개의 노드를 끊어서, 남은 노드들을 통해서만 훈련시키는 방식이다. 이 때 끊어버리는 노드는 랜덤으로 선택한다. pytorch에서는 기본값이 0.5 다. 즉 절반의 노드를 dropout하고 계산한다. 이렇게 함으로써, training하는 과정에서 Overfitting이 발생하지 않게 할 수 있다. 이제 훈련을 시키자. 123456789101112131415161718192021222324252627criterion = nn.CrossEntropyLoss()optimizer = optim.SGD(model.parameters(), lr=0.01)for epoch in range(1000): total_loss = 0 for train_x, train_y in train_loader: train_x, train_y = Variable(train_x), Variable(train_y) optimizer.zero_grad() output = model(train_x) loss = criterion(output, train_y) loss.backward() optimizer.step() total_loss += loss.data.item() if (epoch+1) % 100 == 0: print(epoch+1, total_loss) 훈련 시키는 과정은 크게 다를게 없다. 다만 cuda를 사용했음에도 엄청 느리다. 12345test_x, test_y = Variable(test_X), Variable(test_Y)result = torch.max(model(test_x).data, 1)[1]accuracy = sum(test_y.cpu().data.numpy() == result.cpu().numpy()) / len(test_y.cpu().data.numpy())accuracy 97.4%의 정확성을 보였다.","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"https://www.yceffort.kr/tags/pytorch/"}]},{"title":"Step by Step machine laerning - 05","slug":"step-by-step-machine-learning-05","date":"2018-12-16T15:00:00.000Z","updated":"2018-12-17T01:43:27.000Z","comments":true,"path":"2018/12/17/step-by-step-machine-learning-05/","link":"","permalink":"https://www.yceffort.kr/2018/12/17/step-by-step-machine-learning-05/","excerpt":"¶Training Models ¶정규 방정식을 활용한 선형 회귀 1 2 3 4 import numpy as np X = 2 * np.random.rand(100, 1) y = 4 + 3 * X + np.random.randn(100, 1) 테스트 용으로 데이터를 만들어 보겠습니다. 1 2 3 4 5 plt.plot(X, y, \"b.\") plt.xlabel(\"$x_1$\", fontsize=18) plt.ylabel(\"$y$\", rotation=0, fontsize=18) plt.axis([0, 2, 0, 15]) plt","text":"¶Training Models ¶정규 방정식을 활용한 선형 회귀 1234import numpy as npX = 2 * np.random.rand(100, 1)y = 4 + 3 * X + np.random.randn(100, 1) 테스트 용으로 데이터를 만들어 보겠습니다. 12345plt.plot(X, y, \"b.\")plt.xlabel(\"$x_1$\", fontsize=18)plt.ylabel(\"$y$\", rotation=0, fontsize=18)plt.axis([0, 2, 0, 15])plt.show() 123X_b = np.c_[np.ones((100, 1)), X]theta_best = np.linalg.inv(X_b.T.dot(X_b)).dot(X_b.T).dot(y)theta_best 12array([[4.21509616], [2.77011339]]) 위에서 $$y = 4+ 3x_1 + Gaussian Noise$$ 로 생성해서 $$\\theta_0=4$$ 와 $$\\theta_1=3$$를 기대했지만, 실제로는 $$\\theta_0=4.325$$ 와 $$\\theta_1=2.770$$가 나왔다. 이 값을 기반으로 예측을 한번 해보자. 1234X_new = np.array([[0], [2]])X_new_b = np.c_[np.ones((2, 1)), X_new]y_predict = X_new_b.dot(theta_best)y_predict 12array([[ 3.86501051], [10.14333409]]) 예측한 그래프를 그리자. 1234567plt.plot(X_new, y_predict, \"r-\", linewidth=2, label=\"Predictions\")plt.plot(X, y, \"b.\")plt.xlabel(\"$x_1$\", fontsize=18)plt.ylabel(\"$y$\", rotation=0, fontsize=18)plt.legend(loc=\"upper left\", fontsize=14)plt.axis([0, 2, 0, 15])plt.show() sci-kit learn으로 하면 아래와 같이 간단하게 할 수 있다. 1234from sklearn.linear_model import LinearRegressionlin_reg = LinearRegression()lin_reg.fit(X, y)lin_reg.intercept_, lin_reg.coef_ 1(array([3.86501051]), array([[3.13916179]])) 1lin_reg.predict(X_new) 12array([[ 3.86501051], [10.14333409]]) ¶Gradient Descent(경사하강법)를 활용한 선형 회귀 12345678eta = 0.1n_iterations = 1000m = 100theta = np.random.randn(2,1)for iteration in range(n_iterations): gradients = 2/m * X_b.T.dot(X_b.dot(theta) - y) theta = theta - eta * gradients 12thetaX_new_b.dot(theta) 12345array([[3.86501051], [3.13916179]])array([[ 3.86501051], [10.14333409]]) 123456789101112131415161718192021222324252627282930theta_path_bgd = []def plot_gradient_descent(theta, eta, theta_path=None): m = len(X_b) plt.plot(X, y, \"b.\") n_iterations = 1000 for iteration in range(n_iterations): if iteration &lt; 10: y_predict = X_new_b.dot(theta) style = \"b-\" if iteration &gt; 0 else \"r--\" plt.plot(X_new, y_predict, style) gradients = 2/m * X_b.T.dot(X_b.dot(theta) - y) theta = theta - eta * gradients if theta_path is not None: theta_path.append(theta) plt.xlabel(\"$x_1$\", fontsize=18) plt.axis([0, 2, 0, 15]) plt.title(r\"$\\eta = &#123;&#125;$\".format(eta), fontsize=16)np.random.seed(42)theta = np.random.randn(2,1) # random initializationplt.figure(figsize=(10,4))plt.subplot(131); plot_gradient_descent(theta, eta=0.02)plt.ylabel(\"$y$\", rotation=0, fontsize=18)plt.subplot(132); plot_gradient_descent(theta, eta=0.1, theta_path=theta_path_bgd)plt.subplot(133); plot_gradient_descent(theta, eta=0.5)plt.show() Learning Rate가 너무 작으면 최적의 솔루션을 찾는데 너무 오래 걸리고, 너무 클 경우에는 아예 찾지 못하고 벗어나 버린다.","categories":[],"tags":[{"name":"machine-learning","slug":"machine-learning","permalink":"https://www.yceffort.kr/tags/machine-learning/"},{"name":"scikit-learn","slug":"scikit-learn","permalink":"https://www.yceffort.kr/tags/scikit-learn/"}]},{"title":"IBM과 maersk가 글로벌 운송용 블록체인 파트너를 찾는데 어려움을 겪고 있어","slug":"ibm-blockchain-maersk-shipping-struggling","date":"2018-12-14T15:00:00.000Z","updated":"2018-12-15T03:14:55.000Z","comments":true,"path":"2018/12/15/ibm-blockchain-maersk-shipping-struggling/","link":"","permalink":"https://www.yceffort.kr/2018/12/15/ibm-blockchain-maersk-shipping-struggling/","excerpt":"서로 경쟁하는 기업들이 한 팀으로 함께 일하도록 하는 것듀 어렵지만, 그 경쟁자들 중 한 구성원이 그 팀을 소유할 때는 특히 까다롭다. 거대 해운회사인 머스크와 기술 제공업체인 IBM은 공급망을 위한 DLT(Distributed Ledger Technology) 플랫폼인 TradeLens와 이 문제와 씨름하고 있다. 약 10개월 전, 이 프로젝트는 지구상에서 가장 큰 컨테이너 운송 회사인 Maersk에서 IBM과 합작으로 시작되었다. 그러나 그 당시에 그 네트워크는 오직 하나의 다른 운송 회사들, 즉 아시아에서 8개의 선적선들","text":"서로 경쟁하는 기업들이 한 팀으로 함께 일하도록 하는 것듀 어렵지만, 그 경쟁자들 중 한 구성원이 그 팀을 소유할 때는 특히 까다롭다. 거대 해운회사인 머스크와 기술 제공업체인 IBM은 공급망을 위한 DLT(Distributed Ledger Technology) 플랫폼인 TradeLens와 이 문제와 씨름하고 있다. 약 10개월 전, 이 프로젝트는 지구상에서 가장 큰 컨테이너 운송 회사인 Maersk에서 IBM과 합작으로 시작되었다. 그러나 그 당시에 그 네트워크는 오직 하나의 다른 운송 회사들, 즉 아시아에서 8개의 선적선들 중 하나이고 화물 수량에 따라 세계에서 17번째인 Pacific International Lines (PIL)만이 플랫폼에 참가하고 있었다. 그러나 전문가들이 인정하듯이, 그것만으로는 충분하지 않다. 간단히 말해, IBM과 Maersk의 이러한 공동 협력은 더 많은 운송회사를 필요로 한다. 이 플랫폼은 Maersk의 경쟁사들이 “신뢰할 수 있는 앵커” 역할을 하고 네트워크에서 전체 블록체인 노드를 실행하도록 설계되었다. 게다가, 상품의 큰 운송업자들은 다중 운송업자와 화물 운송업자를 사용하며, 화물 및 화물 운송업자의 재고를 관리하는 것 또한 포함한다. IBM Blockchain의 TradeLens 대표인 Marvin Erdly가 인정한 바와 같이, 다른 대형 운송사들의 참여는 TradeLens에게 절대적으로 필요한 조건이다. “우리는 다른 운송 회사들을 플랫폼에 불러들일 필요가 있다. 그 네트워크가 없다면, 우리 제품은 없는 것과 마찬가지다. 그것이 현실이다” 라고 언급했다. 문제는 머스크의 경쟁 운송회사들이 평등하지 못한 기반 위에서 플랫폼에 합류하는 것에 대해 우려하고 있다는 것이다. 실제로 경쟁사인 CMA CGM(선박과 컨테이너로 3위)과 Hapag-Lloyd(5위)의 사장은 Maersk-IBM 블록체인 솔루션을 사용할 수 없다고 공개적으로 일축했다. TradeLens는 당초 청구된 합작회사보다 중립적으로 보이기 위해 약정을 “공동협력” 으로 재안함으로써 이 문제를 해결하려고 노력해 왔다. 그러나 실질적으로 Maersk와 IBM은 지적재산권에 대해 완전하고 동등한 권리를 가지고 있다. Erdly는 산업 자문 위원회가 변화를 일으킬 거버넌스 솔루션 중 하나이며, 플랫폼의 평등을 촉진하기 위한 작업이 진행 중이라고 말했다. 그러나 그는 경쟁사의 우려를 인정하며 다음과 같이 덧붙였다. Maersk가 이 일을 주도하고 있다는 사실은 정말 좋은 일이며 걱정스러운 일입니다. 당연히도, 그게 (고려하는데 있어) 하나의 요인이 될 겁니다. ¶누가 캡틴인가 코펜하겐에 본사를 둔 선박 분석 회사인 SeaIntelligence Consulting의 Lars Jensen CEO에게 IBM과 Maersk의 과제는 일찍이 분명했다. 젠슨은 CoinDesk에게 벤처가 발표된 지 3개월 후인 4월에 있었던 선적 회의에서 Maersk와 IBM의 블록체인 제안에 대해 이야기했다고 말했다. 젠슨에 따르면, “다른 운송사들은 기본적으로 ‘그런데, 우리가 그렇게 한다면 누가 IP 권리를 소유합니까?” 라는 질문을 제기한다. 그 후 그들은 Maersk와 IBM에 대한 IP 권리가 될 것이라는 대답을 받았다. 확실히, 아직 TradeLens에게는 아직 성공을 이야기 하기엔 이르다. IBM은 2년 전에 월마트와 함께 시작한 블록체인은 인상적이엇다. 그리고 IBM과 Maersk는 TradeLens 플랫폼에 합류하기 위해 운송 공급망의 다른 부분에서 온 수십 명의 참가자들과 계약했다. 여기에는 전 세계 항만 및 세관 당국, 이로운 화물 소유주, 화물 운송 및 물류 회사(몬트리올 항과 캐나다 국경 및 서비스 기관이 가장 최근에 추가되었다)가 포함된다. &quot;우리는 지금까지 우리 산업 전반에 걸쳐 기업들과 긍정적인 관계를 맺었으며, 우리는 이 건설적인 대화가 100명 이상의 생태계 참가자들이 적극적으로 참여하거나 해결책을 시험하는 결과를 낳았다는 것을 알게 되어 기쁘다,&quot;라고 마어스크의 트레이드렌스 리더인 Michael J. 화이트는 말했다. 젠슨에게 명백한 의문점은 왜 머스크가 거의 20년 전 진정한 중립적 사업으로 시작된 선박 예약용 디지털 플랫폼인 INTTRA를 블록체인으로 변경하는 것을 선택하지 않았다는 것이다. INTTRA의 사장 겸 COO인 Inna Kuznetsova는 서비스로서의 소프트웨어, 비블록체인 플랫폼에서 거래하는 60개의 통신사를 가지고 있다)는 운송업계의 블록체인 잠재력에 대한 &quot;부패&quot;가 아직 남아있다고 믿고 있는데, 그녀는 이 문제는 IT 자원이 미약하고 있기 때문에 실용적일 필요가 있다고 지적했다. &quot;오늘날의 해운업계는 ‘마지막의 큰 당근’ (처음에 인내하면 마지막에 큰 과실이 있을 것이라고하는 ) 프로젝트에 싫증이 났다.&quot;고 쿠즈네소바가 말했다. “IT 프로젝트를 선택하려면 투자 수익률에 중점을 두어야 하며, 6개월에서 1년 사이에 절감 효과를 가져오는 프로젝트에 높은 선호도를 보이고 있다.” Maersk의 White는 IBM과의 작업은 “솔루션과 기술 모두에서 INTTRA와 근본적으로 다른 초점과 접근 방식을 가지고 있다&quot;고 말했다. 우리는 INTTRA와 계속 대화를 하고 있다.” ¶중립적인 스탠스 TradeLens에 대한 또 다른 도전은 그것이 그 산업에서 유일한 게임이 아니라는 것이다. 엑센츄어는 싱가포르에 본사를 둔 해운회사인 APL(미국 사장 라인, 화물량 12위)과 대형 화물 운송업체인 Kuehne + Nagel, 양조관련 거대기업인 AB InBev와 유럽 세관기구가 참여하는 블록체인 프로젝트를 만들었다. Accenture Freight &amp; Logistics Services의 글로벌 리더인 Adriana Diener-Vinott은 PoC가 각 범주에서 한 명의 주주, 즉 운송업자, 운송업자, 관세청에서 시작되었다고 말했다. &quot;처음부터 모든 사람들은 그들의 경쟁자들이 합류할 것이고 그들은 같은 권리를 가질 것이라는 것을 인정한다. 이것이 산업 플랫폼을 성공으로 만드는 방법이다&quot;라고 그녀는 말했다. 디에너-비노트는 현재 누가 미니 컨소시엄의 IP를 소유하고 있는지 자유롭게 밝힐 수 없다고 말했다. 그러나 Accenture는 향후 몇 주 안에 추가 운송사를 발표하고 지배 절차에 대한 업데이트를 제공할 것이라고 말했다. Kuehne+Nagel의 대표는 액센츄어가 만든 요점에 반기를 들었다. “우리에게 알려진 것 중 한가지 요소는 컨소시엄 플랫폼 소유권이 설립 당사자들에게만 제한되지 않는다는 것이다.” 라고 대변인이 말했다. “지배구조 모델은 추가 파트너가 동등한 권리와 의무를 가지고 참여할 수 있도록 보장할 것이다.” 공정하게 말해서, 대형 블록체인 네트워크를 구축하는 것은 전례가 없는 사업이며, IBM은 이 문제에 대한 다른 접근 방식을 모색하고 있다. blockchain technologies의 제리 Cuomo 부사장은 자신의 경험상, 할 수 있는 두 가지 방법이 있다고 말한다. 그것은 신뢰 앵커 몇 개로 소규모로 시작해서 중앙 집중식으로 시작하거나, 큰 컨소시엄과 논쟁하는 것을 포함하여 더 많은 분권화된 접근을 선택하는 것이다. 그리고 이는 시작하는데 있어서 더 오랜 시간이 소요될 것이다. Cuomo는 &quot;우리는 한 사람이 옳고 그른지 확신할 수 없다&quot;고 말했다. “소규모의 중앙집중식으로 시작한다면, 도전은 차세대 대형 신뢰 앵커를 영입하는 것이 될 것이다. 반면에, 분산적인 접근법으로, 당신은 다수의 경쟁자들과 그들의 변호사들이 질문을 하도록 할 수 있으며, 이는 시간이 걸릴 것이다. 그리고 이중에 하나를 선택해야 할 것이다.” 그러나 만약 그렇게 된다면, TradeLens는 플랫폼의 성공을 보장하기 위해 IP를 다른 네트워크 구성원들과 동등하게 공유하기를 선택할 것인가? IBM의 Erdly는 어떤 일이 일어날지 그렇지 않을지에 대해 추측할 입장이 아니라고 말했지만, 그는 동료인 Cuomo의 주장을 되풀이하여 다음과 같이 결론 지었다. “우리는 일부 산업 컨소시엄 모델을 개발하는데 수 년과 수년을 소비할 수 있었다. 아니면 이 일을 추진해 볼 수도 있을 겁니다.” 이 이야기가 발표된 후, IBM은 Todd Scott으로부터 추가적인 성명을 발표했다. “더 많은 운송사들이 가입의 가치가 있는가? 물론이다” 그는 다음과 같이 덧붙였다. “비즈니스 가치를 극대화하고 회사 데이터를 보호하는 플랫폼, 이러한 거버넌스 모델의 특성은 생태계가 성장함에 따라 TradeLens의 향상된 가치 제안이 성장할 수 있도록 구축되었습니다.”","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"npm 'event-stream' 패키지, 비트코인 지갑을 노리는 악성코드에 감염","slug":"malicious-code-in-npm-event-stream-package-targets-a-bitcoin-wallet","date":"2018-11-29T15:00:00.000Z","updated":"2018-11-30T10:44:01.000Z","comments":true,"path":"2018/11/30/malicious-code-in-npm-event-stream-package-targets-a-bitcoin-wallet/","link":"","permalink":"https://www.yceffort.kr/2018/11/30/malicious-code-in-npm-event-stream-package-targets-a-bitcoin-wallet/","excerpt":"Malicious code in npm ‘event-stream’ package targets a bitcoin wallet and causes 8 million downloads in two months 원문 지난주 캘리포니아 주 CSUF 대학의 컴퓨터 사이언스 전공인 Ayrton Sparling는, 인기있는 npm 패키지인 event-stream에 스트림이라는 악의적인 패키지가 포함되어 있다고 발표했다. 그는 EventStream의 repository 에 이 문제를 공개했다. event stream npm 패키지는 원래 D","text":"Malicious code in npm ‘event-stream’ package targets a bitcoin wallet and causes 8 million downloads in two months 원문 지난주 캘리포니아 주 CSUF 대학의 컴퓨터 사이언스 전공인 Ayrton Sparling는, 인기있는 npm 패키지인 event-stream에 스트림이라는 악의적인 패키지가 포함되어 있다고 발표했다. 그는 EventStream의 repository 에 이 문제를 공개했다. event stream npm 패키지는 원래 Dominic Tarr라는 개발자가 제작하여 유지 관리했다. 그러나 이 인기있는 패키지는 오랫동안 업데이트되지 않았다. 토머스 헌터의 포스팅에 따르면, “event stream의 소유권은 악의적인 사용자인 right9ctrl에게 이관되었다. 악의적인 사용자는 패키지에 일련의 의미있는 기여를함으로써 원본 저자의 신뢰를 얻을 수 있었다. 악의적인 소유자는 flatmap stream이라는 악의적인 라이브러리를 이벤트 스트림 패키지에 종속성으로 추가했다. 이로 인해 모든 사용자가 이벤트 스트림 패키지 (3.3.6 버전 사용)를 다운로드하고 해당 기능을 호출했다. 악의적인 라이브러리의 다운로드는 2018년 9 월에 포함된 이후 약 8 백만 건의 다운로드가 이뤄졌다. 악의적인 패키지는 지정된 공격을 목표로 수행되었으며, bitpay/copay라는 오픈 소스 앱에 영향을 미친다. Copay는 데스크톱과 모바일 장치 모두를 위한 안전한 비트코인 지갑 플랫폼이다. 해당 모듈의 package.json (모듈에서 의존하고 있는 패키지 목록)에서 AES256 (암호화)를 디크립트 하는 패키지가 발견되었으며, 이는 copay앱을 타겟으로 하고 있는 것으로 보였다. Hey internet,Here is my statement on the event-stream issue: https://t.co/OmvlVuECHLThanks to everyone who sent me friendly emoji ;) I&#39;m okay. But this is really a much bigger issue (the viability of open source). I&#39;m glad that this incidence is raising awareness!&mdash; Dominic Tarr (@dominictarr) 2018년 11월 26일 My comment on this incident, since Dominic is getting a lot of blame and I work closely with him.1/ Yes he did a mistake (with huge proportions), but you have to understand Dominic has 700+ packages and this one is just one more. Each package has several issues and comments. https://t.co/XgYBBS7Ypb&mdash; André Staltz (@andrestaltz) 2018년 11월 26일 이 악의적인 코드의 영향을받는 사용자는 이벤트 스트림의 버전 3.3.4를 사용하거나, 제거하는 것이 좋다. 사용자 응용 프로그램이 Bitcoin을 처리하면 지난 3 개월 동안 채굴되거나 이전된 비트 코인이 지갑에 들어 가지 않았는지 확인해야 한다. 그러나 응용 프로그램이 비트 코인을 다루지 않지만 확인이 필요한 경우, 의심스러운 활동에 대한 지난 3 개월 동안의 활동을 검사하는 것이 좋다. 이는 네트워크에서 의도하지 않은 대상으로 전송된 데이터를 분석하는 것이 필요할 것이다. 참고","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"}]},{"title":"탈중앙화된 AI: 블록체인의 미래","slug":"decentralized-ai-benefits","date":"2018-11-22T15:00:00.000Z","updated":"2018-11-22T18:44:01.000Z","comments":true,"path":"2018/11/23/decentralized-ai-benefits/","link":"","permalink":"https://www.yceffort.kr/2018/11/23/decentralized-ai-benefits/","excerpt":"Decentralized AI: Blockchain’s bright future 원문 블록체인과 인공지능은 전 세계적으로 기술 혁신을 주도하고 있으며, 둘 다 우리의 개인 데이터뿐만 아니라 비즈니스의 미래에도 깊은 영향을 미친다. 두 기술이 어떻게 합쳐질 수 있을까? 분산된 인공지능에서 발생할 수 있는 기회에 대해서 알아보자. 블록체인과 인공지능이 분산된 인공지능으로 합쳐질 가능성을 살펴보기 전에 두 가지 각각의 이점을 살펴보자. 인공 지능 (AI)은 지능형 기계를 만드는 컴퓨터 과학 분야다. 기계 학습이라고도 알려진 AI는","text":"Decentralized AI: Blockchain’s bright future 원문 블록체인과 인공지능은 전 세계적으로 기술 혁신을 주도하고 있으며, 둘 다 우리의 개인 데이터뿐만 아니라 비즈니스의 미래에도 깊은 영향을 미친다. 두 기술이 어떻게 합쳐질 수 있을까? 분산된 인공지능에서 발생할 수 있는 기회에 대해서 알아보자. 블록체인과 인공지능이 분산된 인공지능으로 합쳐질 가능성을 살펴보기 전에 두 가지 각각의 이점을 살펴보자. 인공 지능 (AI)은 지능형 기계를 만드는 컴퓨터 과학 분야다. 기계 학습이라고도 알려진 AI는 전통적으로 사람들에게만 있었던 기술을 제공한다. 한편, 블록체인은 컴퓨터의 글로벌 네트워크인 분산된 기술이다. 강력한 플랫폼을 사용하면 유사한 정보 블록을 네트워크에 저장할 수 있다. PwC는 2030 년까지 AI가 세계 경제에 최대 15.7 조 달러를 추가할 것이며 결과적으로 세계 GDP는 14 % 증가할 것이라고 예측했다. 가트너의 예측에 따르면 블록체인 기술로 추가된 사업 가치는 같은 해에는 3조 1천억 달러로 증가할 것이다. 현재 암호화폐 부문은 블록체인 기술을 가장 많이 사용한다. 그렇다면 블록체인과 인공지능의 통합이 가능한가? 둘 다 하나로 합쳐서 다른 부문으로 들어갈 수 있을까? 실제로는 이미 그런 일이 일어나고 있고, 일부 기업들은 블록체인과 인공지능을 통합할 가능성을 인식하기 시작했다. ¶블록체인 기술의 이점 블록체인은 분산되어 있고 중앙통제 없이 데이터를 공유할 수 있다. 이는 블록 체인에서 트랜잭션을 중앙통제와 독립적으로 검증하고 처리할 수 있다. 블록체인은 분산된 특성으로 인해 변화에 저항할 수 있으며 일관성이 있다. 공격에 취약한 중앙점이 없기 때문에 시스템에 대한 악의적인 공격에 대처할 수 있다. 0 블록체인 기술에 의해 제공되는 정보는 모두 정확하다. ¶AI 기술의 이점 인공 지능 또는 기계 지능은 코딩 할 때 인간에 비해 오류율이 낮다. 결과적으로 AI는 더 높은 수준의 정확도, 속도 및 정밀도를 제공한다. AI는 감정이 없기 때문에 완전히 논리적이므로 오류가 없는 합리적인 결정을 한다. 기계는 지치지 않고 위험한 환경에서도 작업할 수 있다. 이를 통해 우주 탐사 또는 광업과 같은 위험한 작업을 수행할 수 있다. 데이터 분석을 통해 AI를 신뢰하는 것은 어떤 회사가 할 수 있는 최선의 결정이다. 인공 지능은 구조화되지 않은 데이터를 쉽게 계산할 수 있으며 데이터를 분석할 때 정확성을 보장하면서 실시간으로 결과를 얻을 수 있다. ¶이전에 있었던 블록체인과 AI의 결합 AI와 블록체인 사이에는 눈에 띄는 통합이 있었다. 그 중 하나는 스마트 컨트랙트 테스트를 향상시키기 위해 만들어진 Singularity.Net 인데, 이는 블록 체인 및 AI 프로그램을 포함한다. 재조사인 Nahame은 또한 블록 체인 기술과 AI를 통합하여 회사가 감사를 원활하게 할 수 있도록 지원했다. 피어투피어(Peer-to-Peer) 렌터카 회사가 블록체인 기술을 기반으로 자가용 자동차를 생산할 계획도 있다. ¶분산화된 AI - AI와 블록체인의 접점은 어디인가? ¶데이터 보호 인공 지능은 주로 데이터에 달려 있으며 기계 학습을 통해 스스로를 향상시키는 데 사용한다. 인공지능과 관련된 것은 인간 상호작용과 그 밖의 세부적인 것들에 대한 데이터를 수집하는 것이다. 블록 체인은 분산된 시스템에서 데이터 저장소를 암호화할 수 있는 기술이며 완전히 보안되고 보호된 데이터베이스만 권한이 있는 사용자만 액세스할 수 있다. 따라서 블록체인과 인공지능을 통합할 때, 그것은 금융이나 의료 데이터와 같은 민감한 데이터를 위해 보호된 분산형 인공지능 시스템을 가지고 있다는 것을 의미한다. 따라서 블록체인 기술은 보안상의 큰 이점이다. Spotify를 살펴보자. 사용자의 데이터를 사용하여 최근 검색 및 선호도를 기반으로 음악을 추천한다. 대부분의 경우 우리는 정보에 대해 특별히 신경 쓰지 않는다. 하지만 기업의 클라우드에 저장된 민감한 정보에 대해서는 사생활 보호와 사생활 보장에 대해 더 우려할 것이다. ¶보안 단일 프로세서에서 실행되는 중앙 집중식 시스템으로서 해커 또는 악성 프로그램은 AI 시스템에 침투하여 지침을 변경할 수 있다. 블록 체인을 사용하면 블록 체인 플랫폼에서 정보가 받아 들여 처리되기 전에 시스템의 네트워크 노드 또는 단계를 여러 번 통과해야 한다. 네트워크에 노드가 더 많을 때 블록 체인 기반 기술을 해킹하는 것이 더욱 어려워지게 된다. 불가능한 것은 아니지만 블록 체인 기반의 분산형 AI 플랫폼을 해킹하는 것이 훨씬 더 어려울 것이다. ¶신뢰 시스템에 대한 신뢰를 더 크게 가져갈 수 있다. 블록체인은 폐쇄형 인공지능 시스템보다 더 투명한 기술이다. 블록체인은 암호화를 통해 데이터를 보호한다. 이로 인해 허가받지 않은 당사자가 아무 것도 볼 수 없게 된다. 의료 분야의 블록체인 적용 사례에서 환자들은 허가받지 않은 사용자가 의료 정보를 이용할 수 있기를 원하지 않는다. 허가받지 않은 제 3자가 액세스하지 못하도록 의료 정보가 암호화되어 있다. 또한 의료 정보를 블록체인에 보관하면 의료 제공자가 환자의 파일에 쉽게 액세스할 수 있으므로 비상 사태시 의료 지원을 제공할 수 있다. 성능 향상 AI를 추가하면 구조화되지 않은 데이터에 쉽게 액세스할 수 있으므로 블록 체인에 저장할 수 있다. ¶AI와 블록체인의 장기적 이점 블록체인과 AI를 통합함으로써 기업이 얻을 수 있는 많은 혜택이 있다. XAIN AG와 제휴한 포르쉐차는 이미 고급 차량의 분산 AI 응용 프로그램을 연구하고 있다. AI 기반 애플리케이션 개발의 선두 주자인 JD.com은 이미 분산된 비즈니스 애플리케이션을 구축하기 위해이 통합을 사용하기 시작했다. 따라서 블록체인과 인공지능을 통합 기술로 고려할 가치가 있다. 블록체인을 이미 사용했거나, 단지 AI만 사용했더라도 문제가 되지 않는다. 기존 웹 사이트 API를 통해 두 기술을 통합할 수 있다. ¶IT 인프라의 에너지 절약과 비용 효율성 Deloitte의 2016년 보고서에 따르면 블록 체인에서 거래를 인증하는 연간 비용은 6 억 달러이며 그 중 대부분은 마이닝풀 운영에 사용된다. AI 통합 블록체인은 조직이 에너지 소비를 줄이는 데 도움이 될 것이다. 인공지능은 데이터를 예측하고 신속하게 계산할 수 있기 때문에 암호 통화 마이너가 덜 중요한 거래를 수행할 때 알 수 있다. 또한 기업은 거래를 더 빨리 실행할 수 있다. 사실, AI가 더욱 발전하고 AI와 블록 체인 기술이 통합된 후 AI가 블록 체인에서 마이닝 공정을 컨트롤할 수 있다. AI가 블록체인과 결합된 환경에 적응하고 학습한다는 사실을 감안할 때 블록체인 네트워크의 프로세스와 아키텍처를 배울 것이라는 데는 의심의 여지가 없다. ¶유연한 AI 블록체인과의 인공지능 통합은 일반 적인 인공지능 artificial general intelligence (AGI) 플랫폼 개발을 위한 길을 열어줄 것이다. 블록 체인 모델은 AGI 개발을 위해 분산 표본을 만들 수 있다. 블록체인과 인공지능의 통합은 아직 완전히 이륙하지 못했다. 두 기술을 분산된 AI에 결합하면 새로운 방식으로 데이터를 사용할 수 있는 잠재력이 커지게 된다. 두 기술을 성공적으로 통합하면 데이터 관리가 빠르고 원활하게 이루어지고 거래가 확인되고 불법적인 문서를 식별할 수 있다. 따라서 두 기술의 통합을 고려하고 있다면 망설이지 말고 실행하라!","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"Step by Step machine laerning - 03","slug":"step-by-step-machine-learning-03","date":"2018-11-22T15:00:00.000Z","updated":"2018-11-23T10:44:01.000Z","comments":true,"path":"2018/11/23/step-by-step-machine-learning-03/","link":"","permalink":"https://www.yceffort.kr/2018/11/23/step-by-step-machine-learning-03/","excerpt":"Classification 2 ¶ROC 커브 ROC 커브는 Binary Classification에서 가장 잘 사용하는 검증기다. 왼쪽 위로 그래프가 상승해 있을 수록 (우하단 면적이 넓을 수록) 좋은 분류기라고 할 수 있다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # ROC 커브는 binary classifiers에서 잘 사용하는 검증기다. # 왼쪽 위로 그래프로 올라갈 수록 좋은 분류기다. from sklearn.metrics import roc_curve fpr, tpr, thresho","text":"Classification 2 ¶ROC 커브 ROC 커브는 Binary Classification에서 가장 잘 사용하는 검증기다. 왼쪽 위로 그래프가 상승해 있을 수록 (우하단 면적이 넓을 수록) 좋은 분류기라고 할 수 있다. 12345678910111213141516# ROC 커브는 binary classifiers에서 잘 사용하는 검증기다.# 왼쪽 위로 그래프로 올라갈 수록 좋은 분류기다.from sklearn.metrics import roc_curvefpr, tpr, thresholds = roc_curve(y_train_5, y_scores)def plot_roc_curve(fpr, tpr, label=None): plt.plot(fpr, tpr, linewidth=2, label=label) plt.plot([0, 1], [0, 1], 'k--') plt.axis([0, 1, 0, 1]) plt.xlabel('False Positive Rate') plt.ylabel('True Positive Rate') plot_roc_curve(fpr, tpr)plt.show() 이런 그래프가 아니고, 점수를 보고 싶다면 123# 점수로 보고 싶다면, from sklearn.metrics import roc_auc_scoreroc_auc_score(y_train_5, y_scores) 10.963161488618153 이 ROC 커브를 활용하여 RandomForestClassifier와 비교해보자. 1234567891011from sklearn.ensemble import RandomForestClassifierforest_clf = RandomForestClassifier(random_state=42)y_probas_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=3, method='predict_proba')y_scores_forest = y_probas_forest[:, 1]fpr_forest, tpr_forest, thresholds_forest = roc_curve(y_train_5, y_scores_forest)plt.plot(fpr, tpr, 'b:', label=\"SGD\")plot_roc_curve(fpr_forest, tpr_forest, \"Random Forest\")plt.legend(loc=\"lower right\")plt.show() 1roc_auc_score(y_train_5, y_scores_forest) 10.9922948905208268 RandomForestClassifier가 더 낫다는 것을 알 수 있다. ¶Multiple Class Classifier 이런 다양한 클래스를 구분하는 Classifier에는 RandomForestClassifier와 BayesClassifier가 있다. 그리고 Binary Clasifier에는 SupportVectorMachine과 LinearClassifier가 있다.앞서서는 5인지 아닌지만 확인했다. 만약 1~10까지를 구별해야 한다면 어떻게 해야할까? MultipleClassifier 를 사용하는 법 One Versus All: OVA) 0~9를 구별하는 binary 분류기 10개를 만들기. 즉 이것이 무슨 숫자인지 10개의 분류기를 모두 거치는 방법이다. One Versus One: OVO) 이름 그대로, 각각 맞짱(?) 뜨는 방법이다. 0과 1분류기를 거치고, 0과 2분류기를 거치고, 0과 3분류기를 거치고… 이런식으로 가지수가 나올 수 있는 모든 분류기를 만드는 방법이다. 이 방법은 $$N\\times(N-1)$$ 개의 분류기가 필요할 것이다. OVO는 시간은 물론 오래걸리지만, (45개) 트레이닝세트가 적게 필요하므로 더 이점이 있다. SVM과 같은 일부 알고리즘은 트레이닝 세트의 크기에 민감해서, 크기가 커질 경우 성능이 뚝뚝 떨어지는데, OVO를 사용하면 더 빠르게 구별할 수 있다. 그러나, 이 외의 경우에는 OVA를 보통 선호 한다고 한다. scikit-learn의 경우, 다중 클래스 분류에 binary-classification를 사용할 경우, 알아서 자동으로 OvA (SVM은 OVO)를 사용한다. 아래의 예제를 보자. 12sgd_clf.fit(X_train, y_train)sgd_clf.predict([some_digit]) 1array([5.]) 이 코드에서는, 5만 구별한 y_train_5대신 원래 타겟을 사용하여 SGDClassifier를 훈련시켰다. 그런다음 예측을 하나 만들어 냈는데, 내부에서는 scikit-learn이 실제로 10개의 이진 분류기를 훈련시키고 각각의 결정점수를 얻어서 가장 높은 클래스 (5) 를 호출해 낸것이다. 12some_digit_scores = sgd_clf.decision_function([some_digit])some_digit_scores 1234array([[-210257.90046371, -417036.80313781, -405317.41607626, -81007.86225196, -357657.92769475, 32836.21879306, -743346.95995739, -210459.08988114, -826317.66173769, -523922.97081691]]) 1np.argmax(some_digit_scores) 15 이번에는 OvO 와 OvA를 수동으로 사용하게 해보자. 12345# OVOfrom sklearn.multiclass import OneVsOneClassifierovo_clf = OneVsOneClassifier(SGDClassifier(random_state=42, max_iter=5, tol=None))ovo_clf.fit(X_train, y_train)ovo_clf.predict([some_digit]) 1array([5.]) 5를 잘 예측하였다. RaondomForestClassifier의 경우는 더 쉽다. 12forest_clf.fit(X_train, y_train)forest_clf.predict([some_digit]) 1array([5.]) 각각에 대해서 확률을 보고 싶다면 1forest_clf.predict_proba([some_digit]) 1array([[0. , 0. , 0. , 0.1, 0. , 0.9, 0. , 0. , 0. , 0. ]]) 90%의 확률로 5임을 예측했다는 것을 알 수 있다. 이제 한번 테스트를 해보자. 1cross_val_score(sgd_clf, X_train, y_train, cv=3, scoring='accuracy') 1array([0.84953009, 0.84259213, 0.82712407]) 대략 85%의 확률로 맞추고 있는 것을 볼 수 있다. 여기서 성능을 더 향상 시키기 위해서는, input값을 조절해보면 될 것이다. 12345from sklearn.preprocessing import StandardScalerscaler = StandardScaler()X_train_scaled = scaler.fit_transform(X_train.astype(np.float64))cross_val_score(sgd_clf, X_train_scaled, y_train, cv=3, scoring='accuracy') 1array([0.90586883, 0.91309565, 0.91003651]) 정확도가 약 90%까지 향상한 것을 알 수 있다.","categories":[],"tags":[{"name":"machine-learning","slug":"machine-learning","permalink":"https://www.yceffort.kr/tags/machine-learning/"},{"name":"scikit-learn","slug":"scikit-learn","permalink":"https://www.yceffort.kr/tags/scikit-learn/"}]},{"title":"결제 수단으로서 비트코인 사용이 지속적으로 감소 중","slug":"us-crypto-currencies-payments-analysis:bitcoin-for-payments-a-distant-dream-as-usage-dries-up","date":"2018-11-21T15:00:00.000Z","updated":"2018-11-21T18:44:01.000Z","comments":true,"path":"2018/11/22/us-crypto-currencies-payments-analysis:bitcoin-for-payments-a-distant-dream-as-usage-dries-up/","link":"","permalink":"https://www.yceffort.kr/2018/11/22/us-crypto-currencies-payments-analysis:bitcoin-for-payments-a-distant-dream-as-usage-dries-up/","excerpt":"Bitcoin for payments a distant dream as usage dries up 원문 디지털 화폐가 지불 통화의 기본 기능 중 하나인 안정성을 충족했음에도 불구하고, 상업적 지불 수단으로서의 비트 코인의 사용양은 올해 급격히 감소했다. 블록체인 연구소인 Chainalysis의 자료에 따르면, 주요 지불 프로세서가 처리하는 비트코인의 가치는 9월까지 거의 80퍼센트가 감소했다. 이는 암호 통화가 투기 자산에서, 국가가 발행한 화폐에 대한 대안으로 성숙하기 위해 고군분투하고 있음을 시사한다. 지난 겨울의 격렬한","text":"Bitcoin for payments a distant dream as usage dries up 원문 디지털 화폐가 지불 통화의 기본 기능 중 하나인 안정성을 충족했음에도 불구하고, 상업적 지불 수단으로서의 비트 코인의 사용양은 올해 급격히 감소했다. 블록체인 연구소인 Chainalysis의 자료에 따르면, 주요 지불 프로세서가 처리하는 비트코인의 가치는 9월까지 거의 80퍼센트가 감소했다. 이는 암호 통화가 투기 자산에서, 국가가 발행한 화폐에 대한 대안으로 성숙하기 위해 고군분투하고 있음을 시사한다. 지난 겨울의 격렬한 스윙 이후 비트코인 가격이 상대적으로 평온한 몇 달 동안은, 비트코인이 지불 수단으로써 안정적으로 사용될 수 있다는 희망을 만들어 냈다. 그러나 지불 통화로 사용이 붕괴됨에 따라, 비트 코인이 지불 방법으로 이륙할 수 있도록 더 나은 기술 인프라를 모색하려는 움직임이 나타나고 있다. (비트코인 등 디지털 화폐가) 다른 형태의 돈이 되려면 안정성을 충족시켜야 할 것이다. 그러나 비트코인의 발목을 잡고 있는 것은 확장성이다. 즉, 기존의 돈이 처리하는 거래량을 처리할 수 있을지가 관건이다. 모든 비트코인 활동이 기록되고 검증되는 블록체인 기술은 주요 신용카드 회사가 할 수 있는 초당 거래의 일부만 처리할 수 있다. 그것은 디지털 화폐의 대량 사용을 어렵게 만든다. 비트코인은 여전히 가격 변동을 견뎌내고 있다. 이번 주 30퍼센트의 급락이 나타나고 있다. 하지만 지난달 한 달 동안 암호 통화는 미국 주식보다 안정적이었다. 안정성 향상에도 불구하고 비트코인 지불의 가치는 12월 최고치인 4억2천7백만 달러에서 9월에 9천6백만 달러로 하락하였다. 연구에서 애틀랜타에 본사를 둔 비트페이를 포함하여 17개의 비트코인 결제 프로세서를 조사했다. 비트 코인을 받아들이는 대부분의 상인들은 BitPay와 같은 중개자를 사용하여 비트 코인을 은밀하게 사용하여 통화를 은폐한다. 블록체인 분석 사이트 OXT에 따르면 1월과 10월 사이에 들어오는 거래와 나가는 거래가 절반 이상 감소했다고 밝혔다. “비트코인 지불 처리 과정은 느리지만 꾸준한 하락세를 보이고 있습니다,” 라고 리서 치 회사 Autonomous Next 핀테크 전략팀의 글로벌 디렉터가 말했다. ¶첫 10년 비트코인은 처음 10 년 동안 투자자들을 끌어 들였고, 일부는 전통적인 지불 수단을 대체하여 글로벌 금융을 재구성 할 수 있다고 확신했으며, 다른 사람들은 12 월에 2 만 달러에 가까운 빠른 이득으로 매력을 느꼈다. 그 후 화요일에 4,500 달러 이하로 떨어져, 종전 가치의 4 분의 3을 잃게 되었다. GPU 개발사 엔비디아는 지난주에 암호 화폐 마이닝 붐이 사그라 든 후, 판매하지 못한 (그래픽카드)칩이 쌓인 것에 대한 실망스러운 결과가 나타난 이후 주가가 급격히 떨어지고 말았다. 그럼에도 불구하고 올해 비트코인의 상대적 안정성은 개인과 기업의 지불 사용이 확산 될 것이라는 기대를 불러 일으켰다. “변동성 감소는 일부 비소매 사용 사례에서 실행 가능한 방향으로 나아가는 좋은 단계입니다.” 영국 최대의 암호 통화 교환 업체인 코인베이스의 CEO인 Jeeshan Feroz는 말했다. 그러나 주류 금융회사와 암호통화 기업가들은 안정성만으로는 충분하지 않다고 말한다. 견인력을 얻으려면 비트코인은 더 빠르고 저렴해야 한다고 그들은 말한다. 세계 금융 규제 기관을 괴롭히는 자산에 대한 명확한 규칙은 사용자에게 정당성을 부여하는 데 도움이 될 것이라고 UBS의 Teves는 말했다. ¶라이트닝 네트워크 (암호화폐에 대한 ) 조정된 규제는 아직 요원하지만, 소위 “확장성” 문제를 해결하기 위해 비트코인 네트워크에서 초당 많은 양의 트랜잭션을 처리하기 위한 노력이 지속되고 있다. 초기에는 보다 빠르고 저렴하게 지불할 수 있도록 설계된 비트코인 블록체인에 추가할 수 있는 라트ㅌ닝 네트워크의 사용 및 용량이 증가하고 있다. 라이트닝 네트워크는 4101개의 컴퓨터 노드에 도달했는데, 이는 8월 이후 1/4이 상 증가한 수치다. 라이트닝 네트워크는 사용자가 블록 체인에서 시간이 많이 걸리는 거래를 완료하지 않고 서로 돈을 보낼 수 있기 때문에 인기가 있다. “라이트닝 네트워크는 비트코인의 스케일링 문제를 해결해줍니다.” 핀테크 스타트업 리볼루트에서 암호 통화를 감독하는 에드 쿠퍼가 말했다. “이 네트워크는 돈을 야생에서 비트코인 네트워크로 보내고 있습니다&quot;","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"분산원장 기술은 사용하기 어렵다","slug":"transferwise-chairman-distributed-ledger-technology-is-very-hard-to-use","date":"2018-11-20T15:00:00.000Z","updated":"2018-11-20T18:44:01.000Z","comments":true,"path":"2018/11/21/transferwise-chairman-distributed-ledger-technology-is-very-hard-to-use/","link":"","permalink":"https://www.yceffort.kr/2018/11/21/transferwise-chairman-distributed-ledger-technology-is-very-hard-to-use/","excerpt":"TransferWise Chairman: Distributed Ledger Technology Is Very Hard To Use 원문 비트코인과 다른 디지털 자산을 지배하는 블록체인 기술은 서서히, 그러나 꾸준히 주류 금융으로 진출하고 있지만, 일부 금융 기관들은 잠재력에 대해 확신하지 못하고 있다. 런던에 본사를 둔 결제 플랫폼인 TransferWise는 (분산 원장 기술이)아직 좋은 점이 없다고 밝혔습다. ¶TransferWise는 블록체인 기술이 핵심이 아니다 에스토니아의 개발 및 영국에 본사를 둔 Transferwi","text":"TransferWise Chairman: Distributed Ledger Technology Is Very Hard To Use 원문 비트코인과 다른 디지털 자산을 지배하는 블록체인 기술은 서서히, 그러나 꾸준히 주류 금융으로 진출하고 있지만, 일부 금융 기관들은 잠재력에 대해 확신하지 못하고 있다. 런던에 본사를 둔 결제 플랫폼인 TransferWise는 (분산 원장 기술이)아직 좋은 점이 없다고 밝혔습다. ¶TransferWise는 블록체인 기술이 핵심이 아니다 에스토니아의 개발 및 영국에 본사를 둔 Transferwise는 고객이 빠르고 비용 효율적인 방식으로 70 개국에 돈을 보낼 수 있게 하는데 있어서, 블록 체인 기술에 좋은 점이 없다는 것을 분명히 했으며 따라서 곧 분산 원장 기술(DLT) 밴드 왜건에 참가하지 않을 것이라고 밝혔다. 트랜스퍼와이즈의 공동 설립자이자 회장인 Taavet Hinrikus 는 &lt;트랜스퍼와이즈&gt;의 인터뷰에서 블록체인 기술이 논문에는 잘 어울리지만 현실에서는 사용하도록 하는 것이, 장기적으로는 아무런 의미가 없는 힘든 일이라고 강조했다. “이러한 꿈 (블록체인 기술을 도입하는 것) 여러 곳에서 여러 번 들은 적이 있습니다. 하지만 그 일을 파헤치기 시작하면 논문에는 잘 어울리는 걸 알지만, 실제로는 그걸 이용하기가 어렵습니다.” TransferWise의 사장은 또한 회사가 Ripple을 포함한 광범위한 분산 원장을 실험했지만 블록체인을 활용하여 기존 시스템보다 저렴하거나 빠른 방식으로 돈을 이전할 수 있게함으로써 운영을 향상시키는데 성공하지 못헀다고 주장했다. TransferWise에서는 호주에서 영국으로 돈을 보내기 위해 15 초 밖에 걸리지 않으며 서비스 요금은 1 % 이하다. 또한, 그는 낮은 수수료에도 불구하고 회사가 2년 연속으로 수익성을 유지해 왔다고 주장했다. ¶변화 가능성은 열려 있다, 그러나 분산원장은 여전히 느리다. 2011년 설립된 Transferwise는 국경간 지불을 위해 SWIFT에 의존하고 있지 않다. 대신, 이 회사는 고유의 지불 네트워크를 사용하여 인터넷을 통해 고객의 은행 계좌로 돈을 보내 중개자를 제거하고 비용 효율적인 방식으로 운영합니다. 흥미롭게도, 매우 효율적인 비즈니스 프로세스에도 불구하고 TransferWise가 Ripple 및 블록 체인 기술의 열렬한 팬이며 그렇게할 필요성을 알게 되면 초기 기술을 운영에 통합하는 것을 주저하지 않을 것이라고 분명히 했다. “… 리플이나 다른 블록 체인이 우리가 더 저렴하고 빠르게하는 데 실질적으로 도움이된다면 실제로 기술을 도입하고 싶은 의향이 있으나, 아직까지는 그러한 점을 찾지 못햇다.” 트랜스퍼와이즈는 조만간 DLT에 참여하지 않을지 모르지만, 블록체인 기술이 전 세계의 전통적인 금융 기관에 더 쉽게 삶을 만들어 줄수도 있다는 점에서 주목할 가치가 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"폴크루그먼: 왜 내가 암호화폐에 비관적인가?","slug":"transaction-costs-and-tethers-why-im-a-crypto-skeptic","date":"2018-11-19T15:00:00.000Z","updated":"2018-11-19T22:44:01.000Z","comments":true,"path":"2018/11/20/transaction-costs-and-tethers-why-im-a-crypto-skeptic/","link":"","permalink":"https://www.yceffort.kr/2018/11/20/transaction-costs-and-tethers-why-im-a-crypto-skeptic/","excerpt":"Transaction Costs and Tethers: Why I’m a Crypto Skeptic 원문 통화 역사의 광범위한 스윕을 살펴보면 시간이 지남에 따라 변화의 방향이 분명해졌다. 즉, 비즈니스 수행의 마찰과 이러한 마찰을 처리하는 데 필요한 실제 자원의 양을 줄이는 것이다. 처음에는 무겁고, 간수하기 어려우며, 많은 자원을 소비하는 금과 은으로 만든 동전이 있었다. 그리고 나서 지불 준비금으로 뒷받침 되는 지폐가 있었다. 이들은 동전보다 다루기가 훨씬 쉬웠기 때문에 인기가 있었다. 그들은 또한 아담 스미스 가 말했듯","text":"Transaction Costs and Tethers: Why I’m a Crypto Skeptic 원문 통화 역사의 광범위한 스윕을 살펴보면 시간이 지남에 따라 변화의 방향이 분명해졌다. 즉, 비즈니스 수행의 마찰과 이러한 마찰을 처리하는 데 필요한 실제 자원의 양을 줄이는 것이다. 처음에는 무겁고, 간수하기 어려우며, 많은 자원을 소비하는 금과 은으로 만든 동전이 있었다. 그리고 나서 지불 준비금으로 뒷받침 되는 지폐가 있었다. 이들은 동전보다 다루기가 훨씬 쉬웠기 때문에 인기가 있었다. 그들은 또한 아담 스미스 가 말했듯, &quot;공중을 떠다니는 마차 길 (a sort of waggon-way through the air)&quot;을 제공하여 다른 용도로 자원을 확보하는 물리적 귀금속의 필요성을 줄였다. 그럼에도 불구하고, 그 시스템은 여전히 상당한 양의 상품 자금을 필요로 했다. 그러나 민간 은행들이 금이나 은이 아닌 예치금으로 보유했던 중앙은행은 이러한 필요를 크게 줄였고, 금융 자금으로의 전환은 거의 완전히 그것을 없앴다. 한편, 사람들은 현금 거래에서 점차 멀어져 처음에는 수표로 지불했고, 그 다음에는 신용카드와 직불카드 그리고 다른 디지털 방식으로 옮겨갔다. 이 역사에 비추어볼 때, 암호통화에 대한 열정은 매우 이상하게 보인다. 왜냐하면 그것은 장기적 경향과 정반대이기 때문이다. 거의 무손실 거래를 추구하는 대신에, 비트코인이나 다른 암호 단위를 이전하려면 과거 거래의 완전한 기록을 제공해야 하기 때문에 우리는 사업을 하는데 많은 비용이 든다. 마우스 클릭으로 돈을 버는 대신, 우리는 자원을 많이 사용하는 계산으로 돈을 벌어야 한다. 그리고 이러한 비용은 부수적인 것이 아니라 혁신을 일으킬 수 있는 것이다. Brunnermeier와 Abadi가 지적했듯이, 새로운 Bitcoin을 만들거나 기존 비트코인을 이전하는 데 비용이 많이 드는 높은 비용은 분산형 시스템에 대한 신뢰도를 높이는 프로젝트에 필수적이다. 은행권은 사람들이 은행들을 발행한 은행에 대해 뭔가를 알고 있었기 때문에 효과가 있었다. 그리고 이 은행들은 그들의 명성을 지키기 위한 인센티브를 가지고 있었다. 정부는 가끔 화폐를 만드는 특권을 남용해 왔지만 대부분의 정부나 중앙은행은 그들의 명성에 관심을 가지고 있기 때문에 자제한다. 하지만 여러분은 비트코인이 누가 발행했는지 모른 채 진짜임을 확신해야만 한다. 따라서 진짜 거래인지 확인하기 위해 금화를 물어뜯는 것과 같은 (금이 진짜인지 확인하기 위한) 디지털 방식이 필요하고, 그 실험을 행하는 비용은 사기를 억제할 만큼 높아야 한다. 즉, 암호 통화 애호가들은 화폐 시스템을 300 년으로 되돌리기 위해 최첨단 기술을 효과적으로 사용하고 있습니다. 왜 그런 일을 하고 싶어 하는 거야? 그게 무슨 문제야? 나는 아직 그 질문에 대한 명확한 답을 보지 못했다. 통용되는 돈은 일반적으로 그 일을 꽤 잘한다는 것을 명심해라. 거래 비용이 낮다. 지금부터 연간 1달러 구매력은 매우 예측 가능하며, 이는 비트코인보다 훨씬 더 예측 가능하다. 은행계좌를 사용하는 것은 은행을 신뢰하는 것을 의미하며, 대형 은행은 암호 통화 토큰을 보유한 회사보다 훨씬 더 많은 신뢰를 정당화한다. 그렇다면 왜 훨씬 덜 잘 작동하는 돈의 형태로 변하는 것일까? 실제로 비트코인이 출시된 지 8년이 지난 지금, 암호 화폐는 실제 상업에 거의 침투하지 못했다. 몇몇 회사들은 그것들을 지불수단으로 받아들이겠지만, 내 감각은 이것이 실제 유용성보다는 일종의 신호 전달에 더 가깝다는 것이다. 나를 봐, 나는 최첨단이다! 하지만 그들은 투기적인 놀이로 압도적으로 이용되고 있다. 그것은 교환의 매개체로서 유용하기 때문이 아니다. 이것은 암호화폐가 결국 아무 것도 아닌 순수한 거품이라는 것을 의미하는가? 통화와 비슷한 다른 자산들이 실제로 돈으로 많이 쓰이지 않지만 어쨌든 사람들이 보유하고 있다는 것을 지적할 가치가 있다. 금은 아주 오랫동안 실제 화폐가 아니었지만, 그 가치는 그대로이다. 그리고 현금의 상당 부분도 마찬가지라고 말할 수 있다. 현금거래는 일반적이지만, 그것들은 구매가치의 아주 작은 부분만을 차지한다. 그러나 달러 현금 보유는 1980 년대 이후 GDP의 점유율로 실제로 증가했으며, 이는 50 달러와 100 달러 지폐가 대부분을 차지 했다. 이제, 고액권 지폐는 보통 결제에 사용되지 않는다. 사실, 많은 상점들은 그것을 받아들이지 않습니다. 그럼 그 돈이 무슨 소용이야? 우리는 모두 그 답을 알고 있다: 탈세, 불법 행위 등 그리고 그것의 대부분은 미국 밖에 있으며, 외국인들이 미국 화폐의 절반을 가지고 있다고 추정하고 있다. 분명히 암호 통화는 사실상 동일한 사업의 일부와 경쟁하고 있습니다. 비트코인을 사용하여 청구서를 지불하는 사람은 거의 없지만 일부 사람들은 마약을 구입하고 선거를 전복하는 등 일부 사람들을 사용하고 있습니다. 그리고 금과 고액 지폐의 예는 이런 종류의 수요가 많은 자산 가치를 지원할 수 있음을 시사한다. 그렇다면 암호 화폐는 지지자들이 주장하는 기술이 아니라도 거품이 아닐 수도 있다는 뜻일까? 음, 여기가 바로 테더링(구속력, tethering)이 있는 곳이다. 더 정확하게는 암호통화에서는 없는 것이다. 평범한 삶에서 사람들은 죽은 대통령의 초상화가 담긴 녹색 종이의 가치가 어디에서 오는지에 대해 걱정하지 않는다. 다른 사람들이 달러 지폐를 수락하기 때문에 달러 지폐를 수락합니다. 그러나 달러 가치는 전적으로 자기 충족 기대에서 비롯된 것이 아니다. 궁극적으로 미국 정부가 세금 부채를 지불하는 것으로 달러를 받아 들일 것이라는 사실에 의해 지원되고 있다. 정부이기 때문에 시행할 수 있는 부채다. 원한다면, 총 든 남자들이 그렇게 말하기 때문에 화폐는 기본 가치를 가지고 있다. 그리고 이는 사람들이 믿음을 잃으면 무너질 수 있는 거품이 아니라는 뜻이다. 그리고 마약단속기 등에 놓여있는 100달러 지폐의 가치는 미국의 작은 액면가의 가치로 이어진다. 어느 정도까지는 금도 비슷한 상황에 있다. 대부분의 사람들은, 금이 가치를 지니고 있다고 믿기 때문에 금은 가치를 지닌채 존재하게 된다. 그러나 금은 보석과 치아를 채우는 것과 같은 실제 용도로 사용되며, 실제 경제에 약하지만 실질적인 구속력을 주는 실제적인 용도를 가지고 있다. 반면에 암호 통화는 지원되지도, 현실에서 사용되지도 않는다. 그들의 가치는 전적으로 자기 충족 기대에 달려 있다. 즉, 전체 붕괴가 실제 가능성임을 의미한다. 투기꾼들이 집단적으로 의심을 품고 갑자기 비트코인의 가치가 없다고 두려워한다면 비트코인은 쓸모없어질 것이다. 그런 일이 일어날까? 나는 그것이 그렇지 않은 것보다 더 가능성이 있다고 생각한다. 즉 비트코인 (다른 암호 통화는 아니지만)이 주로 암시장 거래 및 탈세에 사용되는 잠재적인 균형이 있을 수 있지만, 그것이 존재한다면, 그러한 균형점은 실망스러운 것이다. 일단 블록 체인된 미래의 꿈이 사라지면 실망은 아마도 모든 것을 무너 뜨릴 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"블록체인과 분산원장 기술은 어떻게 다른가?","slug":"distributed-ledger-technology-blockchain","date":"2018-11-18T15:00:00.000Z","updated":"2018-11-18T22:44:01.000Z","comments":true,"path":"2018/11/19/distributed-ledger-technology-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/11/19/distributed-ledger-technology-blockchain/","excerpt":"Here’s the difference between blockchain and distributed ledger technology 원문 블록체인(Blockchain)은 다양한 사람들에 의해 탐구되고 있으며, 은행이나 정부와 같은 전통적인 중앙집권 기관은 이 기술이 그들을 위해 무엇을 할 수 있는지에 관심을 갖기 시작하고 있다. 그러나 암호 통화 공간에서 더 자주 자라기 시작하는 새로운 용어가 있다. 그것은 바로 분산 원장 기술 이다(DLT). 영국 은행은 최근 블록체인과 분산형 원장 기술을 모두 사용하여 Real-Time","text":"Here’s the difference between blockchain and distributed ledger technology 원문 블록체인(Blockchain)은 다양한 사람들에 의해 탐구되고 있으며, 은행이나 정부와 같은 전통적인 중앙집권 기관은 이 기술이 그들을 위해 무엇을 할 수 있는지에 관심을 갖기 시작하고 있다. 그러나 암호 통화 공간에서 더 자주 자라기 시작하는 새로운 용어가 있다. 그것은 바로 분산 원장 기술 이다(DLT). 영국 은행은 최근 블록체인과 분산형 원장 기술을 모두 사용하여 Real-Time Gross Settlement (RTGS) 시스템에 활기를 불어넣을 계획이라고 발표했다. 하지만 이 단어들 (블록체인과 분산원장)은 서로 바꿔 쓸 수 없기 때문에, 이런 경우, 우리가 그들의 차이점을 인정하는 것이 중요하다. ¶분산 원장 기술 즉, 분산 원장 기술(DLT)은 하나의 중앙 기관이 저장하거나 확인하지 않은 기록 데이터베이스를 나타낸다. 마치 블록체인 같지만, 이는 사실 그렇지 않다. DLT에서 시스템을 구현하는 사람은 실제로 구현되는 방법을 더 잘 제어할 수 있다. 그들은 원칙적으로 그것의 서비스를 뒷받침하는 네트워크의 구조, 목적 및 기능을 지시할 수 있다. 그렇긴 하지만 DLT는 기술적으로 분산되어 있으며, 이를 막기 위해 유사한 합의 원리에 의존한다. 그러나 한 기관이 분산형 네트워크를 원칙적으로 통제할 수 있는 경우는 적어도 이념적인 관점에서는 분산되지 않는다. DLT는 블록체인을 향한 첫 번째 단계로 간주될 수 있지만, 중요한 것은 이것이 반드시 블록체인의 형태로 구성되지 않는 다는 것이다. 오히려 문제의 원장은 여러 서버에 걸쳐 저장되며, 이를 통해 트랜잭션의 가장 정확하고 최신 기록이 유지되도록 할 것입니다. 순수 블록체인보다 DLT를 선호하는 기업에는 Google이 이 있다. 최근 DLT 도구를 클라우드 서비스 고객에게 제공하고자 노력하고 있다. 폴크스바겐은 아이오타와의 협력도 분산형 원장 기술을 실험중 이라고 밝혔다. ¶블록체인 반면에, 블록체인도 있다. 블록체인은 사실 매우 특정한 기술적 기반을 가진 분산형 원장의 한 형태이다. 우리 모두가 알고 있듯이, 그것은 모든 기록이 합의에 의해 승인되는 분산형 네트워크에 의해 유지되는 변경 불가능한 기록 원장을 만드는 것이다. DLT와는 별도로 블록체인을 설정하는 것은 원장에 있는 레코드 그룹을 암호화하고 연결하는 것이다. 또한 블록체인의 구체적인 적용에 따라 대중과 사용자가 블록체인의 구조 및 운영에 대해 발언권을 가질 수도 있다. 비트코인의 경우를 블록체인 및 분산화의 진정한 예로 들 수 있다. 기술과 구조가 분산되어 있는 반면, 그것의 조직과 개발도 마찬가지로 분산되어 있다. DLT에서 기술은 분산되어 있지만, 회사의 조직은 그렇지 않을 수 있다. ¶DLT와 블록체인은 동일하지 않다. 여기서 주목할 중요한 점은 이러한 문구와 용어가 비록 그렇게 사용될 수 있다 하더라도 서로 바꿔 쓸 수 없다는 것이다. 영국은행과 같은 기관들은 DLT를 이용하여 자신을 차단하는 것과 관련된 과대 선전과 변동성을 멀리하는 것을 선호할 수 있다. 또는 같은 이유로, 기업은 블록체인이라는 단어를 활용하여 그들이 제공하는 것이 진정한 블록체인이 아니더라도 관심을 표현할 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인이 아일랜드 국경 문제를 해결할 수 있는가?","slug":"could-blockchain-solve-Irish-border-issue","date":"2018-11-16T15:00:00.000Z","updated":"2018-11-16T19:54:57.000Z","comments":true,"path":"2018/11/17/could-blockchain-solve-Irish-border-issue/","link":"","permalink":"https://www.yceffort.kr/2018/11/17/could-blockchain-solve-Irish-border-issue/","excerpt":"Could Blockchain solve Irish border issue? 원문 마침내, 브렉시트 이후의 아일랜드 국경 문제에 대한 기술 솔루션으로 블록체인이 떠오르고 있다. 필립 해먼드는 보수당 회의에서 국경 문제에 대한 해결책에 대해 물었을 때 \"(블록체인) 기술이 이용 가능 해지고 있다\"고 말했다. “나는 그것에 대한 전문가라고 주장하지 않지만 가장 명백한 해결책으로 작용할 수 있기술은 블록 체인이다.” 그러나 탈중앙화고 불변의 데이터베이스가 국경을 넘어 상품의 경로를 추적할 수 있을지는 분명하지 않습니다. 결국, 지","text":"Could Blockchain solve Irish border issue? 원문 마침내, 브렉시트 이후의 아일랜드 국경 문제에 대한 기술 솔루션으로 블록체인이 떠오르고 있다. 필립 해먼드는 보수당 회의에서 국경 문제에 대한 해결책에 대해 물었을 때 &quot;(블록체인) 기술이 이용 가능 해지고 있다&quot;고 말했다. “나는 그것에 대한 전문가라고 주장하지 않지만 가장 명백한 해결책으로 작용할 수 있기술은 블록 체인이다.” 그러나 탈중앙화고 불변의 데이터베이스가 국경을 넘어 상품의 경로를 추적할 수 있을지는 분명하지 않습니다. 결국, 지금까지 블록 체인의 유일한 대규모 솔루션은 비트코인의 인프라를 제공하는 것이었다. 비트코인은 경제학자 Nouriel Roubini의 말에 따르면 &quot;느린 에너지 비효율적인 공룡&quot;이 거래를 처리하는 것과 같다고 말했다. 나는 왜 블록체인이 답이 될 수 있는지 이해하려고 재무부에 전화를 걸었다. 내가 기록한 모든 것은 다음과 같다 : “우리는 영국이 EU를 탈퇴한 후에 무역상에게 나타날 수 있는 요구 사항을 간소화하기 위해 북 아일랜드와 아일랜드 국경에 대한 무역을 촉진하는 데 도움이 되는 기술을 적극적으로 고려하고 있다. 이러한 기술적 해결책은 국경에서 물리적 인프라에 추적을 지원할 것이다.” 블록체인은 그들이 보고 있던 수많은 기술 중 하나일 뿐이지만, 언제, 혹은 그것이 실용적인 해결책을 제공할 수 있을지 아직 모른다. 최근 몇 주 동안 나는 흥분한 홍보 담당자들과 연락을 취해서 고객들의 도움을 받아 HM 수익과 세관, 토지 등록부 정부 부서가 블록체인을 사용하고 있다고 말했다. 일단 그 부서들과 연락을 취하면, 화이트홀의 블록체인에 대한 열정이 다소 과장되었다는 의견을 받았다. 아이러니하게도 가장 열정적인 블록 체인 전도자 중 많은 사람들이 결국 중앙 은행 정부를 무너 뜨릴 것이라고 믿는 자유 주의자들이다. 하지만 지금은 인터넷보다 더 크고 새로운 것입니다.그러므로 더 많은 정치인들이 블록체인의 시류에 올라간다면 놀라지 마세요.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인 캐쉬 하드 포크에 관한 논쟁","slug":"bitcoin-cash-hard-fork","date":"2018-11-15T15:00:00.000Z","updated":"2018-11-15T19:54:57.000Z","comments":true,"path":"2018/11/16/bitcoin-cash-hard-fork/","link":"","permalink":"https://www.yceffort.kr/2018/11/16/bitcoin-cash-hard-fork/","excerpt":"What you need to know about the controversial Bitcoin Cash hard fork 원문 현재 비트코인캐시는 원래 비트코인(BTC) 네트워크의 가장 인기 있는 포크이며, 두개의 암호화폐가 존재하고 있다. 하지만 한가지 문제가 있다: 오직 하나 만이 진짜 비트코인캐시로 남게 될 수 있다. 비트코인캐시가 탄생한 이후 두 번째로 악명 높은 하드포크로 간주되는 분할은 약 3시간 내에 이루어질 것으로 예상된다. 하지만 이것이 여러분과 암호 화폐 시장에 정확히 무엇을 의미하는가? ¶비트코인캐시 백","text":"What you need to know about the controversial Bitcoin Cash hard fork 원문 현재 비트코인캐시는 원래 비트코인(BTC) 네트워크의 가장 인기 있는 포크이며, 두개의 암호화폐가 존재하고 있다. 하지만 한가지 문제가 있다: 오직 하나 만이 진짜 비트코인캐시로 남게 될 수 있다. 비트코인캐시가 탄생한 이후 두 번째로 악명 높은 하드포크로 간주되는 분할은 약 3시간 내에 이루어질 것으로 예상된다. 하지만 이것이 여러분과 암호 화폐 시장에 정확히 무엇을 의미하는가? ¶비트코인캐시 백스토리 비트코인캐시는 일년에 두 번 네트워크 업데이트를 받지만, 가장 최근의 것은 특히 분열적인 것으로 입증되고 있다. 근본적으로 다른 두 가지 네트워크 업데이트 제안 - 하나는 노드 소프트웨어 공급업체인 Bitcoin-ABC에 의해 개발되었고 다른 하나는 Craig Wright의 블록체인 리서치 회사인 nChain에 의해 개발되었다. ABC는 일련의 새로운 기능(Bitcoin Cash를 기반으로 애플리케이션을 구축하고 지불 범위 밖에서 최대한의 기능을 확장할 수 있는 기능)을 도입하려 하고, nChain의 버전은 블록 크기를 32MB에서 최대 128MB로 확대하여 확장 성 및 거래 속도를 향상시키는 것을 목표로 한다. 각 솔루션이 얼마나 잘 고려되었는지 여부는 누구에게 묻느냐에 따라 다르다. 그러나 여기에 문제가 있다: 두 가지 구현은 서로 양립할 수 없다. 그 결과, 비트코인캐시 블록체인은 하드포크가 되어 (결과적으로, 2개로 나뉘게 된다) 두개의 새로운 암호화폐가 탄생하게 된다. 비트코인 ABC가 운영하는 BAB와 nChain이 개발한 BSV. 그리고 BAB와 BSV의 최고를 결합한 세 번째 - 약간 포괄적인 제안이 있다. 또 다른 BCH 소프트웨어 제공 업체인 Bitcoin Unlimited는 SV와 nChain 사이의 불화를 해소하고 두 가지 비전을 모두 지원하는 솔루션을 구현하겠다고 이야기 했다. ¶좋은 것, 나쁜 것, 이상한 것 비트코인캐시 커뮤니티 전체에 오명을 부여하는 엄청나게 지저분한 대중 싸움 외에도, 다가오는 하드 포크는 본격적인 해싱 전쟁에서 마이너들을 서로 대적하는 결과를 낳았다. 현재, Coindance의 통계는 대부분의 마이너들이 비트코인캐시의 비트코인 SV 구현을 지지할 것이라는 신호를 보내고 있다. 실제로 SV는 최대 76%의 마이너들이 이 제도를 주도하고 있으며, 그 뒤를 ABC와 Unlimited가 각각 15-26%의 지지를 받고 있다. 암호화폐에 대한 커뮤니티는 어떤 구현을 지원해야 할지에 대해 여전히 마음을 정하고 있는 상태다. 논란이 되고 있는 비트파이넥스를 포함한 많은 거래 서비스들이 두 가지 구현을 모두 지원함으로써 각각의 가격을 인상할 것이라고 밝혔다. 그외에는 오직 ABC나 SV만 지원할 것이고, 그들이 지원하는 어떤 버전이든 진짜 BCH라고 계속 부를 것이다. 그리고 어떤 체인을 장기적으로 지지하는 것이 더 이치에 맞는지를 그저 기다리고 무게를 재는 집단이 있다. Coinbase와 Binance와 같은 주요 거래소는 비트코인캐시 포크를 지원하려는 의도를 밝혔지만, 그들이 돌아올 체인의 정확한 버전은 불분명하다. 그러나 새로운 ‘실제’ 비트코인캐시로 어떤 구현이 나왔든 간에, 하드포크는 사회에 돌이킬 수 없는 피해를 입혔다. 이번 주에 가격이 급격히 하락한 것 외에도, Wright(호주의 개발자이자 사업가로, 자신을 사토시 나카모토라고 (…) 했다가 엄청 욕을 먹은 사람이다. 비트코인 캐시를 세우는데 공을 세우기도 했고, 초창기 많은 지지를 받기도 했지만 현재는 이와 같은 논란의 중심에 있다.) 와 Bitcoin.com의 사장 Roger 간의 불화는 전체 블록체인 공간을 더럽혔다. 특히, 비트코인캐시는 유머 느낌으로 고안된 Dogecoin만큼도 쓰이지 못하고 있다는 것을 고려한다면, 이는 정말 부끄러운일이 아닐 수 없다. 참고: 하드포크 앞둔 비트코인캐시, 이것은 전쟁이다 현재까지는, 비트코인캐쉬 ABC 의 승리로 보입니다. 출처: Coin Dance 원문 비트코인캐시의 체인 분할은 블록 번호 556,766에서 활성화 되었다. 포크 3시간 후에, 포크의 주요 선동자들 중 한 명이 Bitcoin.com과 Bitmain의 강력한 결합 해시 레이트를 따라가기 위해 고군분투하고 있는 것으로 보인다. 암호통화통계 웹사이트 코인에서 제공한 자료에 따르면 당시, 비트코인 ABC의 하드 포크의 지지자인 BTC.com은 지금까지 만들어진 8개의 비트코인 ABC 블록 중 7개를 채굴한 것으로 보인다. 한편, SV 풀은 지금까지 만들어진 5개의 비트코인 SV 블록 중 4개만 채굴했다. Mempool은 남은 블락 보상을 받았다. SV 캠프에서 Bitcoin ABC를 51 % 공격할 수 있는 능력을 자랑하고 있음에도 불구하고, 특히 수장인 Craig Wright 박사의 논란에서 비롯된 Bitcoin SV 체인은 지금까지 가장 긴 체인으로 자리 매김하지 못했다. 그뿐만 아니라 분할 후 2 시간 만에 Bitcoin SV는 Wright와 회사가 최근에 만든 위협을 전달하기 위한 불필요한 것으로 까지 보인다. Wright는 채굴회사 CoinGeek 설립자인 캘빈 에이레와의 연계를 통해 총 비트코인캐시 레이트의 약 70%를 차지하겠다고까지 언급했었다. 하지만, 현재의 통계로 판단하건대, Wright의 야망을 지지하는 풀은 비트코인 ABC 체인의 보안이나 운영을 손상시키기 위해 필요한 해시 레이트에 다다르려고 애쓸 것이다. Wright는 비트코인캐시 포크의 Bitcoin ABC 쪽을 트위터로 공격하는데 많은 시간을 보냈다. 비트코인의 창조자라고 주장하는 사람은 기술 분석 전문가인 톤 베이스의 유튜브 채널에도 등장해 그가 주장하는 끝없는 해시 파워에 대해 자랑했다. 또한 그는 Roger Ver에게 초기 Bitcoin 지지자가 Wright을 지지하거나 불길하게 예견된 결과에 직면하도록 요구하는 다소 폭력적인 이메일을 보내기도 했다. 그러나 오늘 초, Bitcoin Cash의 가장 큰 지지자 중 한 명인 Roger Ver는 Bitcoin.com 풀이 Bitcoin Cash 네트워크 전체보다 더 많은 해시 속도를 자랑한다고 트윗을 했다. The https://t.co/6EeRmpfaH7 pool now has more hash rate on it than the entire BCH network had earlier today. Bitcoin is cash for the world! #BitcoinCash #bitcoincashfork pic.twitter.com/n2MqQ5mlfK&mdash; Roger Ver (@rogerkver) 2018년 11월 15일 Possible Bitcoin Cash hash war scenarioBitcoin dot com added 4 exahash. If Bitmain and Jihan&#39;s camp redirects more hash power to BCH (estimated to be 20 EH), it&#39;s game over for faketoshi.All depends on Calvin Ayre, but it&#39;s becoming more likely that faketoshi will lose out.&mdash; Joseph Young (@iamjosephyoung) 2018년 11월 15일 Possible Bitcoin Cash hash war scenarioBitcoin dot com added 4 exahash. If Bitmain and Jihan&#39;s camp redirects more hash power to BCH (estimated to be 20 EH), it&#39;s game over for faketoshi.All depends on Calvin Ayre, but it&#39;s becoming more likely that faketoshi will lose out.&mdash; Joseph Young (@iamjosephyoung) 2018년 11월 15일 중국 광산 하드웨어 제조업체인 Bitmain의 설립자와 가까운 소식통에 따르면 Wright의 51 % 공격의 심각한 위협이 발생할 경우 BTC 체인을 채굴하는 것으로 알려진 9만 개의 마이닝 유닛이 여전히 Bitcoin ABC로 전환 될 수 있다고 한다. 분명히 Wright는 현재 산출하는 것으로 보이는 것보다 많은 해시 속도를 필요로 한다. 지금은 51%의 공격과 몇 달 동안의 ‘2014년 가격’에 대한 그의 발언이 단지 위협에 그칠 것으로 보인다. 오늘의 하드 포크는 로저 베르가 말한 것처럼 빠르게 사그라 들 것으로 보인다. 초기 투자자이자 디지털 통화 옹호자는 이전에 이 상황을, 전 세계의 컴퓨터 시스템을 파괴하려는 Y2K 버그의 상황과 비교했다. 그러나 그런 일은 일어나지 않았고 그 사건은 빨리 잊혀졌다. 이는 Bitcoin ABC와 Bitcoin SV 사이의 오늘날의 분열의 운명일 수도 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"Step by Step machine laerning - 02","slug":"step-by-step-machine-learning-02","date":"2018-11-15T15:00:00.000Z","updated":"2018-11-16T10:44:01.000Z","comments":true,"path":"2018/11/16/step-by-step-machine-learning-02/","link":"","permalink":"https://www.yceffort.kr/2018/11/16/step-by-step-machine-learning-02/","excerpt":"¶Classification MNIST는 각 숫자를 손으로 쓴 이미지를 모아놓은 데이터 셋입니다. 이 데이터 셋을 학습시켜서, 이 손글씨가 과연 숫자 몇을 의미하는지 판별 할 수 있도록 학습시켜 보겠습니다. ¶1. 데이터 불러오기 원래대로 라면, sklearn에서 데이터를 잘 가져와야 하지만, 왠지 잘 안될 때가 있습니다. 그 때까지 고려해서 아래와 같은 코드를 작성했습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from six.moves import ur","text":"¶Classification MNIST는 각 숫자를 손으로 쓴 이미지를 모아놓은 데이터 셋입니다. 이 데이터 셋을 학습시켜서, 이 손글씨가 과연 숫자 몇을 의미하는지 판별 할 수 있도록 학습시켜 보겠습니다. ¶1. 데이터 불러오기 원래대로 라면, sklearn에서 데이터를 잘 가져와야 하지만, 왠지 잘 안될 때가 있습니다. 그 때까지 고려해서 아래와 같은 코드를 작성했습니다. 1234567891011121314151617181920212223from six.moves import urllibfrom sklearn.datasets import fetch_mldatatry: mnist = fetch_mldata('MNIST original')except urllib.error.HTTPError as ex: print(\"Could not download MNIST data from mldata.org, trying alternative...\") # Alternative method to load MNIST, if mldata.org is down from scipy.io import loadmat mnist_alternative_url = \"https://github.com/amplab/datascience-sp14/raw/master/lab7/mldata/mnist-original.mat\" mnist_path = \"./mnist-original.mat\" response = urllib.request.urlopen(mnist_alternative_url) with open(mnist_path, \"wb\") as f: content = response.read() f.write(content) mnist_raw = loadmat(mnist_path) mnist = &#123; \"data\": mnist_raw[\"data\"].T, \"target\": mnist_raw[\"label\"][0], \"COL_NAMES\": [\"label\", \"data\"], \"DESCR\": \"mldata.org dataset: mnist-original\", &#125; print(\"Success!\") 1mnist 12345678910&#123;&apos;COL_NAMES&apos;: [&apos;label&apos;, &apos;data&apos;], &apos;DESCR&apos;: &apos;mldata.org dataset: mnist-original&apos;, &apos;data&apos;: array([[0, 0, 0, ..., 0, 0, 0], [0, 0, 0, ..., 0, 0, 0], [0, 0, 0, ..., 0, 0, 0], ..., [0, 0, 0, ..., 0, 0, 0], [0, 0, 0, ..., 0, 0, 0], [0, 0, 0, ..., 0, 0, 0]], dtype=uint8), &apos;target&apos;: array([0., 0., 0., ..., 9., 9., 9.])&#125; 12X, y = mnist['data'], mnist['target']X.shape, y.shape 1((70000, 784), (70000,)) 한번 손글씨를 보도록 하겠습니다. 12345678910# 36000 번의 그림을 찍어보자.%matplotlib inlineimport matplotlibimport matplotlib.pyplot as pltsome_digit = X[36000]some_digit_image = some_digit.reshape(28, 28)plt.imshow(some_digit_image, cmap=matplotlib.cm.binary, interpolation=\"nearest\")plt.axis('off')plt.show() 1y[36000] y는 5가 나오는 것을 알수 있다. ¶2. 간단하게 학습시켜 보기 1234567891011121314# train 과 test 을 나누었다.X_train, X_test, y_train, y_test = X[:60000], X[60000:], y[:60000], y[60000:]# 무작위로 섞어버린다.import numpy as npshuffle_index = np.random.permutation(60000)X_train, y_train = X_train[shuffle_index], y_train[shuffle_index]# y값이 5인 것들만 y_train_5 = (y_train == 5)# y값이 5인 것들만 (true, false)로y_test_5 = (y_test == 5) 경사하강법, SGDClassifier를 사용해 보겠습니다. ¶경사하강법 경사하강법은, 초기값(Initial Weight)부터 경사를 따라 내려가서 최저값을 찾는 방법입니다. 초기값에서 서서히 내려가다보면, 손실이 최소화되는 부분을 찾는 방법입니다. 여기를 참조하시면 잘 설명되어있습니다. 12345# 경사하강법을 활용하여 손실점이 가장 적은 기울기를 찾아보겠습니다.from sklearn.linear_model import SGDClassifiersgd_clf = SGDClassifier(random_state=42)sgd_clf.fit(X_train, y_train_5) 정확도를 구해보겠습니다. 123# 정확도를 구해보자.from sklearn.model_selection import cross_val_scorecross_val_score(sgd_clf, X_train, y_train_5, cv=3, scoring=\"accuracy\") 1array([0.9661 , 0.95445, 0.96365]) 정확도가 무려 96%에 육박하고 있네요. 정말 대단합니다. 근데 과연 이게 정확하게 측정한걸까? 12345678910# 흠터레스팅.. 과연 근데 이게 맞는 정확도일까?# 무조건 5가 아니라고 하는 Classifier를 만들어서 한번 예측을 하게 해보자.from sklearn.base import BaseEstimatorclass Never5Classifier(BaseEstimator): def fit(self, Y, y=None): pass def predict(self, X): # X 만큼 데이터가 들어오면 모두 false로 예측을 한다. return np.zeros((len(X), 1), dtype=bool) 12never_5_clf = Never5Classifier()cross_val_score(never_5_clf, X_train, y_train_5, cv=3, scoring=\"accuracy\") 1array([0.90725, 0.90865, 0.91305]) 그렇다. 숫자가 10개니까, 대충 90%가 결과가 나온 것이다. ¶3. Confusion Matrix TN (True Negative): 실제 값이 false인데 예측을 false로 했다. (오류) FP (False Positive): 실제 값이 false인데 예측을 true로 했다. (정답) FN (False Negative): 실제 값이 true인데 예측을 false로 했다. (오류) TP (True Positive): 실제 값이 true인데 예측을 true로 헀다. (정답) 12345from sklearn.model_selection import cross_val_predictfrom sklearn.metrics import confusion_matrixy_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3)confusion_matrix(y_train_5, y_train_pred) 12array([[53884, 695], [ 1621, 3800]]) 이 Confusion Matrix를 평가하는 방법은 여러가지가 있다. ¶1) Precision (정밀도) $$precision = \\frac{TP}{TP+FP}$$ 실제 이게 맞다라고 예측했을때, 정말로 정답일 확률이다. ¶2) Recall (재현율) $$recall = \\frac{TP}{TP+FN}$$ 실제로 이게 정답일때, 이것을 정답으로 잘 맞출 수 있는 확률이다. 123from sklearn.metrics import precision_score, recall_score, f1_scoreprecision_score(y_train_5, y_train_pred)recall_score(y_train_5, y_train_pred) 10.8453837597330367, 0.7664380798709157 즉, 정확히 5라고 예측할 확률은 84%, 실제로 5를 5라고 판단할 확률은 76%가 되는 것이다. ㅠ.ㅠ ¶3) F1 Score 정밀도와 재현도를 바탕으로 각각의 가중치를 두어서 평균을 구하는 방식이다. $$F_1 = \\frac{2}{ \\frac{1}{precision} + \\frac{1}{recall} }$$ $$\\frac{TP}{TP + \\frac{FN+FP}{2}}$$ 1f1_score(y_train_5, y_train_pred) 10.7664380798709157 우리가 해야 할일은, Precision과 Recall을 적절히 올려주는 것이지만, 불행하게도, 이 둘 사이에는 Trade off가 존재한다. ¶4. Precision/Recall Tradeoff 둘 사이의 Tradeoff를 알기 위해서, SGDClassifer가 어떻게 classification을 만들어 내는지 알아보자. 각 인스턴스마다, SGDClassifier는 decision function(결정함수)를 사용하여 점수를 매기는데, 이 스코어가 threshold 보다 높으면 true로 그렇지 않으면 negative로 분류하게 된다. {:width=“400px”} 왼쪽에는 낮은 점수를 기록한 negative, 오른쪽에는 높은 점수를 기록한 positive가 존재한다. threshold가 가운데에 있다고 가정했을 때, 그리고 이 threshold가 어느정도이냐에 따라서 Precision 과 Recall값이 달라지게 된다. 즉 5라고 일단 예측해버리면, Recall은 성공하겠지만, 모두 5가 아니라고 판단하면, Precision이 높아지게 될 것이다. 실제 어떤지 살펴보자. 앞서 숫자 5짜리 이미지를 가지고 판단해본다. 12y_scores = sgd_clf.decision_function([some_digit])y_scores 1array([236922.67347034]) 점수가 20만점이 넘게 나왔다. 이제 threshold를 높여보자. 123threshold = 250000y_some_digit_pred = (y_scores &gt; threshold)y_some_digit_pred 1array([False]) threshold를 내려보자. 123threshold = 0y_some_digit_pred = (y_scores &gt; threshold)y_some_digit_pred 1array([True]) 예측이 달라지는 것을 확인할 수 있다. 이제 threshold에 따라 recall과 precision이 어떻게 달라지는지 그래프로 확인해보자. 1234567891011121314from sklearn.metrics import precision_recall_curvey_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3, method='decision_function')precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)def plot_precision_recall_vs_threshold(precisions, recalls, thresholds): plt.plot(thresholds, precisions[:-1], \"b--\", label='Precision') plt.plot(thresholds, recalls[:-1], \"g-\", label='Recall') plt.xlabel(\"Threshold\") plt.legend(loc=\"center left\") plt.ylim([0, 1])plot_precision_recall_vs_threshold(precisions, recalls, thresholds)plt.show() 이 Tradeoff를 감안해서 , 적절한 값을 찾아야 할 것이다.","categories":[],"tags":[{"name":"machine-learning","slug":"machine-learning","permalink":"https://www.yceffort.kr/tags/machine-learning/"},{"name":"scikit-learn","slug":"scikit-learn","permalink":"https://www.yceffort.kr/tags/scikit-learn/"}]},{"title":"산업 관점에서 본 블록체인 적용의 어려움","slug":"major-challenges-to-blockchain-mainstream-adoption-industry-view","date":"2018-11-14T15:00:00.000Z","updated":"2018-11-14T19:51:23.000Z","comments":true,"path":"2018/11/15/major-challenges-to-blockchain-mainstream-adoption-industry-view/","link":"","permalink":"https://www.yceffort.kr/2018/11/15/major-challenges-to-blockchain-mainstream-adoption-industry-view/","excerpt":"Major Challenges to Blockchain Mainstream Adoption: Industry View 원문 블록체인 기술은 여전히 기술 이론 수준에 그치고 있지만, 금융 부문 전반에 걸쳐 그 이점이 널리 인정되고 있으며, 다른 분야에도 점점 더 많이 영향을 미치고 있다. 하지만 비용 절감, 단순화 및 보안의 주요 이점에 더불어 비즈니스 부문에서 널리 보급되고 있는 분야는 무엇일까요? Blockchain 기술의 채택을 위한 주요 과제는 무엇인가? ¶비트코인의 평판과 신뢰의 부재 “대중의 신뢰와 이해 부족은 신뢰","text":"Major Challenges to Blockchain Mainstream Adoption: Industry View 원문 블록체인 기술은 여전히 기술 이론 수준에 그치고 있지만, 금융 부문 전반에 걸쳐 그 이점이 널리 인정되고 있으며, 다른 분야에도 점점 더 많이 영향을 미치고 있다. 하지만 비용 절감, 단순화 및 보안의 주요 이점에 더불어 비즈니스 부문에서 널리 보급되고 있는 분야는 무엇일까요? Blockchain 기술의 채택을 위한 주요 과제는 무엇인가? ¶비트코인의 평판과 신뢰의 부재 “대중의 신뢰와 이해 부족은 신뢰 없는 시스템(블록체인)에 관한 것이다. 많은 사람들에게 이름이나 얼굴이 없는 시스템에 신뢰를 두는 것은 특히 기술을 이해하지 못할 때 “비현실적&quot;입니다. 또한 비트코인의 나쁜 언론과 관심은 적을 방해하고 지연시킬 것입니다.” Paul Busch, Founder at Bitswift ¶사용하기 어렵다 “현재 형태의 블록체인 기술은 사용하기 매우 어렵습니다. 사용자는 퍼블릭/프라이빗 키가 어떻게 작동하는지 알아야 하며, 비트코인을 구입하여 사용하기 위해 수십 가지 단계를 수행해야 합니다.” Shawn Wilkinson, Founder and CEO/CTO at Storj “이 기술의 특성, 블록체인이 기존의 공유 데이터베이스와 어떻게 다른지, 그리고 이러한 차이가 적합한 사용 사례에 어떤 영향을 미치는지에 대해서는 여전히 많은 혼란이 존재합니다.” Dr. Gideon Greenspan, CEO and Architect at MultiChain “현재 퍼블릭 블록체인만 블록체인을 표준 데이터베이스와 다르게 차별화 시키는 특성을 보장한다. 즉, 규모의 합의로 인한 불변성 제공 및 결탁 (공격) 저항입니다. 불행하게도, 퍼블릭 블록체인들은 프라이버시와 확장성 면에서 심각한 단점을 가지고 있다고 생각한다. 블록체인 위에 영 지식 증명 / Homomorphic 암호화 솔루션을 개발할 때까지는 프라이버시 단점을 해결할 수 없으며, 최소 하나의 스마트 플랫폼 위에 샤딩이 이루어질 때까지 확장성 문제를 해결할 수 없다. 둘 다로부터 적어도 3년 가까이 기술 개발이 필요합니다. 또한 C++ 또는 Java 세계와 비교할 때 툴링이 미숙합니다. 고급 매뉴얼과 표준화된 과정을 기대하지 마십시오. 우리는 초기 기술에 대해 이야기하고 있습니다.” Stephan Tual, Founder and CCO at Slock IT “주요 과제는 개발자들이 블록체인 기술을 기반으로 (프로그램을) 쉽게 구축할 수 있도록 하는 것이었습니다. 우리는 블록체인의 도움으로 더 나은 소프트웨어를 만들 수 있는 도구를 개발자들에게 줄 필요가 있습니다. 우리의 로드맵에서 (블록체인의) 채택을 방해하는 주요 병목 현상으로 확장성, 가격 안정성 및 개인 정보 보호를 꼽았습니다. 각 Blockchain 프로젝트는 일부 문제를 해결하는 것을 목표로 하지만, 중요한 것은 Blockchains를 함께 통합하여 결국 모든 문제를 해결하도록 하는 것입니다. 미래는 단일 블록체인이나 단일 솔루션이 아니라, 각각 특정 문제를 해결하는 많은 블록체인 및 여러 솔루션이 있습니다.” SuperNET Team ¶규제 환경 “블록체인 기술의 가장 광범위한 채택을 위한 주요 과제는 규제입니다. 규제 환경은 혁신을 따라잡지 못했으며, 많은 경우 블록체인 기술을 모든 이점을 활용하는 방법으로 채택을 방지하거나 느리게 작동합니다. 규제 프레임워크가 확실하게 자리잡을수록, 많은 경우 소비자들이 변화를 인식하지 못할지라도 주류 소비자들이 사용하는 더 많은 제품과 서비스가 이 기술을 활용할 것이다.” Igor Telyatnikov‎, President &amp; Chief Operating Officer at Alphapoint “당신이 무엇에 집중하고 있는지, 어떻게 바라보느냐에 따라 다르지만, 결국에는 우리가 보기에, 그리고 은행처럼 시장에 있는 대형 업체들이 규제 준수와 관련 사안을 말하는 것이 무엇인지를 보면 이해하기 쉽습니다. 암호화폐 기업들은 그 문제를 다루기가 힘들고, 금융 기관들은 그 문제를 다루기가 힘들며, 전반적으로 매우 비용이 많이 들고 비효율적인 과정입니다.” Grant Blaisdell, Co-founder at Coinfirm ¶이해와 지식의 부족 “블록체인 기술은 정부와 대형 금융 회사의 인정을 받기 위해 높은 신뢰성을 증명해야 한다고 생각합니다. 소규모 업체나 소매업체 등에 대해서는 블록체인(Blockchain)을 사용하는 이유와 기존 업무용 툴을 대체하는 방법을 아직 파악하지 못하고 있습니다. 따라서 Blockchain 기술은 대중의 인식 캠페인을 크게 늘려야 합니다.” Livecoin team &quot;블록체인 기술에 대한 일반적인 인식 부족과 더불어 블록체인 기술의 진정한 기술적 능력에 대한 통찰은 현재 주류 채택에 대한 가장 중요한 장벽을 형성하고 있습니다. 많은 사람들은 여전히 블록체인이 무엇이고 무엇을 할 수 있는지 이해하지 못하고 있습니다. 비록 그들이 비트코인에 대해 들어봤을 수도 있고 심지어 그것을 사용했을 수도 있지만, 그들은 그것이 어떻게 작동하는지를 반드시 이해하지 못할 수도 있습니다. 이게 딱히 놀라운 일은 아니다. 사람들은 평생 동안 화폐를 사용하지만 그 화폐가 작동하기 위한 백엔드 시스템을 이해하고 있지 못하기 때문이다. 그러나 더 많은 사람들이 블록체인과 그 기능에 대해 알고 있다고 하더라도, 이 새로운 기술을 이용하기 위한 비용으로 인해 기존 시스템 변경에 대한 저항은 주류 채택을 가로막는 또 다른 하나의 중요한 장벽이다. 이러한 변경 작업을 수행할 때 대처 능력이 떨어지고 그에 따라 비용이 더 높은 대기업은 더욱 어려워집니다. 따라서 블록체인 기술을 채택할 경우 이러한 어려움을 겪고 있는 것을 정당화하기 위해 이러한 변화의 비용을 크게 초과해야 합니다.&quot; Travin Keith, Blockchain Consultant at NXT Foundation “이것은 우리가 개인/영구적인 블록체인 기술인지 아니면 비트코인이나 이더리움 같은 공공 블록체인 기술에 달려 있습니다. 나는 우리가 여전히 분산형 데이터베이스보다 큰 이점을 제공하는 사설 블록체인의 주요 활용 사례를 찾으려고 노력하고 있다고 믿습니다.\u001d 읽기 전용 뷰가 공공에 유용할 수 있는 경우도 있지만(예: 토지 등록과 같은 공공 등록) 주요 활용 사례는 찾아보기 어렵다. 공공 블록체인 기술에 대해서, 나는 우리의 활용성이 증가했다고 믿는다. 비트코인과 같은 금융 기반 기술은 이미 점점 더 많이 사용되고 있으며, 우리는 여전히 이더리움과 같은 더 넓은 기술의 힘을 발견하고 있을 뿐이다.” Marc Warne, Founder &amp; CEO at Bittylicious “블록체인 산업은 용어와 비현실적인 기대를 혼동하고 있다. 우리는 업계의 일부 당사자들이 그 기술에 대한 깊은 이해가 부족하다고 생각한다. 이는 블록체인 기술 자체가 디지털 통화인 비트코인에서 나왔기 때문일 것이다. 오늘날 기초기술(블록체인)과 디지털통화(비트코인)의 차이를 이해하고 경시하는 것이 대부분의 사람들에게 있어 여전히 입증 가능한 수수께끼이다. 또한 블록체인이 다양한 산업과 활용 사례에 현실적으로 제공할 수 있는 활용성에 관한 많은 과대 광고가 있었다. 이것은 대부분 블록체인이 다른 사람들에게 다른 의미를 가질 수 있다는 사실 때문이다. 예를 들어, 일부는 블록체인을 스토리지 방법론이라고 하는 반면, 다른 이들은 이를 플랫폼으로 봅니다. 전체적으로 이러한 근본적인 도전은 근거 없는 주장과 과대선전을 불러일으키고 있으며, 이로 인해 손해가 발생하며 결국 널리 부풀려지고 비현실적인 기대를 갖게 됩니다.” Dr. Naveed Sherwani, President and CEO at Peernova ¶블록체인에 대한 필요성이 떨어짐 “선진국의 소비자 대부분은 일상 생활에 비 블록체인 기술을 사용하기에 충분하다고 생각할 것이다. 그러므로, 긴급함을 느끼거나 그것을 채택할 필요가 없다. 주요 기업의 경우, 블록체인 기술을 위한 오늘날의 시스템을 정비하는 비용은 엄청난 기술적, 물류적 변화를 의미합니다. 이제는 소프트웨어 업그레이드가 아니라 전체 시스템을 처음부터 다시 점검하는 것입니다.” Kai Cheng Chng, CEO / Co-Founder at Digix “Blockchain 기술의 주류 채택에 있어 가장 큰 난제가 무엇인지 판단하려고 할 때 '관심’이라는 요소가 떠오릅니다. 문화적 기준, 연령 인구 통계, 돈에 대한 일반적인 태도, 그리고 현재의 통화 시스템이 일반적인 가치의 저장고로 인식되는 방법 등 몇 가지 기술적 장애물이 존재합니다. 확실히, 전 세계 모든 국가에서 법적 고려 사항과 확장 가능한 솔루션이 현재 주류의 채택을 가로막는 과제를 결정할 때 중요한 요소로 작용 합니다.” Fastcoin team","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 과연 써야할까?","slug":"to-blockchain-or-not-to-blockchain","date":"2018-11-13T15:00:00.000Z","updated":"2018-11-14T04:44:27.000Z","comments":true,"path":"2018/11/14/to-blockchain-or-not-to-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/11/14/to-blockchain-or-not-to-blockchain/","excerpt":"To Blockchain Or Not To Blockchain 원문 많은 사람들은 블록체인과 암호화에 대한 열정이 사라지고 있다고 주장하고 있다. 실제로, Gartner의 과대 광고 주기 에 따르면, 블록체인은 초기 암호 화폐 투기꾼이 가격을 널뛰기 시켰지만, 현재는 가격이 안정되어 가며 환멸의 늪으로 빠져들고 있다. 만약 암호화폐의 블록체인 거품이 터졌다면, 이 세상을 바꾸는 기술의 약속은 여기서 어디로 갈까? 이 기술에 대한 우리의 생각과, 디지털 혁신이 필요로 하는 암묵적인 변화에 대한 우리의 생각을 정리할 때인가? 블","text":"To Blockchain Or Not To Blockchain 원문 많은 사람들은 블록체인과 암호화에 대한 열정이 사라지고 있다고 주장하고 있다. 실제로, Gartner의 과대 광고 주기 에 따르면, 블록체인은 초기 암호 화폐 투기꾼이 가격을 널뛰기 시켰지만, 현재는 가격이 안정되어 가며 환멸의 늪으로 빠져들고 있다. 만약 암호화폐의 블록체인 거품이 터졌다면, 이 세상을 바꾸는 기술의 약속은 여기서 어디로 갈까? 이 기술에 대한 우리의 생각과, 디지털 혁신이 필요로 하는 암묵적인 변화에 대한 우리의 생각을 정리할 때인가? 블록체인은 테슬라가 오기 전에 40년 동안만 잠복해 있을 수 있는 초기 전기 자동차 프로토타입의 길을 갈 것인가? 클라우드 기반 스프레드시트가 블록체인 것처럼 가장할 경우 기술 투자 가치에 대한 열의가 높아지는가? 많은 의문점들이 남아있지만, 한가지 확실한 것은, 완전히 블록체인을 이용하는 것은 기술과 관련이 없고 경영 사고와 가능한 기술의 발전과 더 관련이 있다는 것이다. 상원 청문회에서 누리엘 루비니 같은 사람들이 블록체인 거품이 터졌다는 주장은 몇 가지 핵심을 놓치고 있다. 첫 번째이자 가장 중요한 것은 비트 코인과 그 기본 블록 체인이 올해 10 주년이 되었지만 기술이 2017 년에 베타 환경에서 처음으로 제대로 된 것이 나왔다는 것입이. 세계 50대 기업들이 시범 사업을 수행하고 있는 것(일부 산업은 ‘경쟁과 협업’을 선택하고 있다) 외에도 블록체인 기반 프로젝트가 늘어나고 있다. 클레이턴 크리스텐슨이 파괴적인 혁신을 생각하면서 빌린 파괴적인 기술인 인터넷과 달리 블록체인은 증강 기술이다. 그러나 이러한 권한이 해제되기 위해서는 기업, 기업가, 기술자 및 정책 입안자가 생각하는 통제를 포기해야 합니다. 이런 요구는 시장과 세계 경제의 구성 요소들이 점점 더 큰 목소리로 우리에게 말하고 있는 한 가지 사실, 그들은 현상 유지 또는 그로부터 가장 많은 것을 얻는 전통적인 중앙 집중식 구조를 신뢰하지 않습니다. 이 방법론에 반하여, 이러한 기준을 충족시키는 디지털 자산 카테고리인 비트 코인 이외의 또 다른 진정한 블록 체인 프로젝트를 식별하는 것은 어렵다. 심지어 암호화폐의 원더 키드인 Vitalik Buterin의 암호 통화인 이더리움 조차도 반 중앙화 도구로서의 운명을 이제 막 시작했다. 이 기술의 현재 상태와 프로젝트, ICO 및 기타 세계적인 변화의 응용에 대해 디지털 정체성, 지불, 공급망 출처, 심지어 전자 투표에서 진정한 의미의 불록체인을 사용하고 있는것인가? 아니면 이 새로운 기술로 혁신과 땜질이 이루어지고 있는가? 이로 인해 프로젝트의 출현과 몰락이 가속화되고 있는가? 블록체인은 인터넷의 초창기와 마찬가지로 꽃이 피는 천 개의 단계에 있다. 시장이 승자를 뽑고, 기술자들은 단지 정원사일 뿐이다. 블록체인 억만장자가 되는 길은 인터넷 기술의 타이탄이 차트로 작성한 길보다 더 어려울 수 있다는 사실을 알게 되면 실망할 수도 있다. 클라우드 컴퓨팅의 등장 또는 인터넷에 필요한 상상력의 흐름과 마찬가지로, 블록체인을 이용한 디지털 전환으로의 전환은 기술이나 정보 아키텍처보다는 관리 문화와 리더십에 관한 것이다. 많은 면에서, 기술은 쉬운 부분이다. 어려운 부분은 우리가 현재 운영하고 있는 높은 마찰 시장을 형성하기 위해 공모한, 신뢰, 투명성, 중개 통제, 가치 포획에 대한 불신과 오랫동안 지속된 규범들의 중단이다. 신뢰도가 낮고 마찰력이 높은 아날로그 세계의 결과는 많은 것을 예상할 수 있다. 현재 유통, 가격 책정 및 서비스 구조로 인해 시장 진입이 불쾌하고 경쟁이 치열하기 때문에 좌초된 자산 및 복잡한 글로벌 위협의 수만 명이 경제적으로 실행 가능한 한계에 부딪히고 있다. 기술로서의 블록체인은 이러한 격차를 충분히 해결할 수 있다. 가장 부족한 자원은 현 상태에서 가장 많은 것을 얻는 확고한 권력 구조로부터의 상상력과 의지의 부족으로 보인다. 블록체인을 이용한 진보는, 심지어는 대기업이나 권력구조의 경우에도 제로이 될 필요는 없다. 실제로 블록체인은 기존 시스템에서 파생된 가치 유형을 혼란시킬 필요가 없기 때문에 증강 기술이며, 시장이나 구성 요소와 완전히 새로운 서비스, 제품 및 관계 모델을 만드는 데 도움이 될 수 있다. 예를 들어, 아날로그 시절부터 발생했던 에이전트 및 브로커 기반 배포 모델에서 게이코와 같은 모델의 출현으로 인한 직접적인 인터넷 제공과 고객 상호 간의 신뢰가 보다 유사한 수준으로 발전했다고 상상해 보십시오. 마찬가지로, 캘리포니아가 2020년까지 주택 재고를 태양열로 활성화하려는 움직임에서 블록체인 기반의 마이크로 그리드의 출현은 더 탄력적인 에너지 매트릭스를 생산하는 경제적인 방법으로 과잉 에너지를 구입할 수 있도록 보장할 수 있다. 원자 시계만큼 충실성과 영속성으로 신뢰를 기록할 수 있는 분산 시스템의 블록체인과 관리 수용은 이러한 새로운 종류의 시장 제공은 불가능할 것이며, 자산은 시장 옆에서 고립될 것이다. 문제는 블록체인을 쓰냐 마느냐 가 아니라, 어떻게 블록체인을 쓰게 될 것인가 이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"암호화폐: 튤립 거품인가 다음세대를 위한 약속인가?","slug":"cryptocurrency-tulip-mania-or-digital-promise-for-the-millennial-generation","date":"2018-11-12T15:00:00.000Z","updated":"2018-11-13T04:44:27.000Z","comments":true,"path":"2018/11/13/cryptocurrency-tulip-mania-or-digital-promise-for-the-millennial-generation/","link":"","permalink":"https://www.yceffort.kr/2018/11/13/cryptocurrency-tulip-mania-or-digital-promise-for-the-millennial-generation/","excerpt":"Cryptocurrency: Tulip mania or digital promise for the millennial generation? 원문 ¶호주를 둘러싼 암호화폐, 특히 비트코인에 대해서 말이 많다. 암호화폐를 쉽게 말하면 무엇인가? 암호화폐/암호토큰은 디지털 또는 “가상” 자산이라는 이름으로 컴퓨터 시스템 내에서 불린다. 이 자산은 익숙한 통화처럼 거래의 수단 역할을 한다. 비트 코인은 가장 잘 알려진 암호 통화이지만, 현재 200 개가 넘는 다른 암호화폐가 존재하고 있다. 가장 인기있는 것은 Ethereum, Ripp","text":"Cryptocurrency: Tulip mania or digital promise for the millennial generation? 원문 ¶호주를 둘러싼 암호화폐, 특히 비트코인에 대해서 말이 많다. 암호화폐를 쉽게 말하면 무엇인가? 암호화폐/암호토큰은 디지털 또는 “가상” 자산이라는 이름으로 컴퓨터 시스템 내에서 불린다. 이 자산은 익숙한 통화처럼 거래의 수단 역할을 한다. 비트 코인은 가장 잘 알려진 암호 통화이지만, 현재 200 개가 넘는 다른 암호화폐가 존재하고 있다. 가장 인기있는 것은 Ethereum, Ripple, Dash, Litecoin 및 Monero입니다. 2018 년 9 월에 총 가치는 약 2,200 억 달러이며, 그 중 40 % 정도가 비트코인이 차지 하고 있다. 토큰은 서비스 개발에 자금을 지원하는 회사가 ICO를 통해 발행하며, 일종의 전통적인 기업이 IPO를 통해서 자금을 유치하는 것과 비슷하다. 토큰은 미래의 지불 또는 서비스 및 2 차 시장에서의 비트 코인 또는 알트 코인 거래에 대한 권리다. 2017 년에는 약 40 억 달러의 ICO가 있었고 2018년 상반기에는 170 억 달러가 있었다. 일반적인 명목 화폐는 중앙 은행과 상업 은행이 보관, 제어 및 모니터링하는 중앙 데이터베이스 (즉, 원장)에서 추적된다. 중앙 은행은 각각 고유 한 일련 번호가있는 은행 노트를 인쇄하여 돈을 만들어낸다. 각 지폐의 고유 한 일련 번호는 이중 지출의 발생을 방지한다.(즉, 개인이 동일한 금액을 두 번 지출하지 못하게 함). 고유한 일련 번호를 가진 합법적인 지폐만 은행 계좌와 같은 거래 데이터베이스에 입력할 수 있다. 예를 들어, 은행 계좌에 현금을 입금할 때 출납원이나 ATM은 당신이 제공한 지폐가 합법적임을 확인하고 거래를 은행 계좌에 입금하고 지불 계좌에서 인출하는 을 기록한다. 블록체인은 계정, 잔액, 거래의 분산형 데이터베이스(즉, 원장)이다. 그것들은 비트코인 거래를 기록하기 위해 처음 사용되었다. 사실 블록체인 기록은 비트코인을 1980년대 초부터 존재해온 전자 또는 디지털 현금 개념과 차별되는 수단이다. 비트코인 및 기타 암호화폐 외에 블록체인을 위한 많은 거래 어플리케이션이 현재 개발되고 있다. 블록체인 원장에 진입하는 것은 특정 조건을 충족해야만 가능하다. 다른 유형의 암호화통화나 기타 자산(예: 호주 재무부 채권)은 합법적인 거래가 분산형 데이터베이스에 기록되기 전에 서로 다른 특정 조건을 충족시켜야 한다. 기술적으로, 암호화는 분산형 트랜잭션의 원장으로 P2P(Peer-to-Peer) 블록체인을 사용한다. 거래는 P2P 네트워크로 브로드캐스트되며 사용자의 개인 키(디지털 지갑에 들어 있는 키)를 기준으로 인증을 받는다. 비트코인 마이너들은 복잡한 수학적 계산을 한 후에만 블록체인(즉, 해시 함수)에 트랜잭션을 추가할 수 있게 된다. 비트코인 마이너들은 블록체인에 합법적인 거래를 추가하는 것을 돕고,ㅡ 그렇게 하는 것에 대한 수수료(즉, 채굴된 비트코인)를 징수하기 때문에 이러한 노력을 기울이게 된다. 블록체인 역사적 거래의 불변의 기록이다. 채굴 과정(즉, 블록체인에 합법적인 거래 추가)은 비트코인을 생성할 수 있는 유일한 방법이다. 이것은 비트코인을 중앙 통화 당국이 돈을 인쇄할 수 있는 명목 통화와 구별하는 한 가지 요인이다. ¶비트코인이나 다른 암호화폐가 달러처럼 전세계적으로 영향을 미칠 수 있을까? 비트코인과 다른 암호화가 명목 통화에 미치는 영향은 장기적인 것으로 보인다. 현재 직면하고 있는 두 가지 주요 과제는 비트코인 가격의 변동성과 비트코인의 블록체인에 새로운 거래를 추가하는 데 걸리는 시간이다. 비트코인의 큰 가격 변동에 따라 기업들은 그 안에 있는 제품과 서비스의 가격을 매길 수 없다. 이것은 무역과 통화의 수단으로서의 사용성을 약화시킨다. 현재 비트코인의 하루 매출액은 약 1억 달러인 반면, 하루 거래 총액은 5조 1천억 달러이다. USD 준비금과 일대일 담보를 해 미 달러화에 묶여있는 테더라 불리는 동전은 USD에서 안정적인 암호 시장을 형성하기 위해 개발되었다. 비트코인은 달러 대비 약 0.002%만을 차지하고 있다. 장기적으로 비트코인(및 기타 암호체)의 가격 변동성이 해소되고 새로운 암호 체계/기술이 거래의 보다 효율적인 처리를 가능하게 할 것으로 기대한다. 이런 상황에서, 제품과 용역의 가격 책정 및 거래, 그리고 지불수단으로서의 그것의 활용 사례는 더욱 실행 가능할 것이다. 그렇더라도 비트코인은 잘 구축되어 있고 국민들이 자국 통화를 계속 거래할 수 있는 선진국 통화(예: USD, Yen, GBP, AUD, 유로 등)에 미치는 영향이 적을 것이다. 비트코인의 결과로 고통 받거나 사라질 수 있는 통화는 통화가 매우 휘발성이 높고 약한 국가(예를 들어 베네수엘라 볼리바르, 짐바브웨 달러) 나 정부가 자본 통제 등을 부과했을 수도 있는 국가다. ¶최근 암호화폐 가격 하락에 따라 월스트리트는 비트코인이 튤립 거품으로 보는 시각도 있고, 미래세대를 위한 화폐가 될것이라는 이야기도 있다. 이것은 양측 모두에 강한 의견을 가진 복잡한 질문이다. 회의론자들은 비트코인과 암호 통화를 ‘사기’와 ‘사각형 모양의 쥐약 (“probably rat poison squared&quot;)’(워런 버핏, 2018년 5월)등으로 이야기하고, 1600년대의 튤립 거품과 닷컴의 버블을 연상시키는 비합리적인 시장 거품을 암시한다. 이러한 회의론자들은 Bitcoin의 가격이 제로에 가깝게 되거나, 적어도 사악한 용도로만 사용 될 것이라고 이야기 한다. 반면에 지지자들은 인플레이션과 세금이 없는 가치 저장 역할을 하면서 거래 및 분산된 기록 보관에 혁명을 일으킬 수 있는 크립토의 “파괴적인” 잠재력을 지적한다. 비관자들은 비트코인 거래에 이미 약간의 견인력이 있다고 인정하지만, 비트코인 거래의 25퍼센트 정도가 암시장과 관련이 있다고 덧붙인다. 또한 중국과 한국의 정부는 자본 유출 제한과 돈세탁을 피하는 데있어서 역할을 한 ICO와 암호 거래 거래를 단속했다.반면에, 암호 거래의 배후에 있는 비제재 활동은 주로 포르노, 금지 상품 판매, 다른 로열티 탈취, 그리고 다른 로열티 탈취로 돈을 벌었던 웹 초창기 활동들보다 거의 다르지 않다. 돈세탁과 마약판매에 있어서 &quot;추적 할 수 없는 송금&quot;도 알려지지 않은 현상이 아니다! 암호통화의 명성은 의심할 여지 없이 &quot;Wild West&quot;와 비슷한 현재의 2차 거래로 세계적으로 도움을 받지 못하고 있으며, 여기에는 산재하고, 단편적이며, 그리고 규제되지 않은 거래, 가격 조작, 세탁 거래 등이 있다. 그러나 또 다시, 금융통화 거래가 신성불가침이 아니라는 준비된 반론은 런던에서의 최근의 추문에 의해 재래식 금융통화 시장에서 제기된다. 이론적으로, 정기적인 이익 지급을 통해 수익을 창출하는 반면, 투자자는 매도 시 일시불과 함께 그것들을 소유한다. 예를 들어, 투자자들이 집을 매입할 때, 그들은 집세(즉, 주식, 채권, 통화)를 받고, 집을 매각할 때 자본 이득(즉, 배당금, 이자)을 회수한다. 반면 비트코인과 튤립은 정기적으로 지급하지 않고 이 자산은 보유할 수 있다. 그러나 정기적 지급의 부재로 인해 자산 가격이 거품처럼 변하지는 않는다. 실제로, 네덜란드 튤립의 경우에도, 당시에 선물 계약의 기초가 되었던 튤립이 사실 합리적으로 가격이 책정되었다는 좋은 경제적 역사적 증거가 있다 2018년 닷컴 버블의 닷컴 주식이었던 외환(즉, 페이스북, 애플, 아마존, 넷플릭스, 구글) 주식은 터무니없이 비싸지 않은 것으로 보인다. 아마도, 어떤 사람은, 튤립 거품에 내재되어 있는 것으로 추측되는 군중들의 광기는 비이성적인 투자자 행동보다는, 실제로 애호가들이 몰려드는 것과 더 관련이 있다고 주장할 수 있을 것이다. 그러나 기술혁신의 초기 물결, 특히 기술혁신의 네트워크 측면이 중요한 경우, 성장 자산을 평가하는 것이 어렵다는 것에는 의심의 여지가 없다. 비트코인은 때때로 금과 비교된다. 비트코인이 결제시스템에서 사용될 수 있고 현재 금은 화장품(예: 보석류)과 산업(항공우주, 전자 제품 제조)에 사용되는 것과 같은 분명한 유사점이 있다. 금은 또한 희귀한 원소로서 귀중한 금속이며(지구 표면의 약 3.1 x 10-7%) 현재 기술은 금을 완전히 복제하거나 다시 만들 수 없다. 위에서 언급한 바와 같이, 비트코인은 알고리즘 적으로 공급이 제한적이다. 그러나 형성 될 수있는 대체 가능한 암호 통화의 수에 대해서는 이론적 인 제한이 없다. 실제로 이들 중 일부 (Ethereum과 같은)는 금 대신 백금보다 이점을 갖도록 설계되었다 (냉소적 인 사람은 백금은 제쳐두고 은이 많은 목적을 위해 금을 대체 할 수 있다고 주장 할 수도 있습니다.) 암호화 통화 블록체인 프로토콜 위에 놓여 있고 스마트폰의 앱과 암호랜드에서 ‘스마트 컨트랙트’에 대한 보상을 약속하는 토큰(알트코인)과 같은 귀중한 서비스를 제공할 가능성이 있는 컴퓨터 코드의 형태로 배포된 앱(응용 프로그램)이 있다. 가치 저장소로서의 암호화폐의 거래 기록은은 어떻게 됩는가? 과거에 체계적으로 데이터를 살펴본 연구자들은, 2013년에 50개의 상위 암호화폐에 가장 많이 왜곡되어 있었으며, 그 중 2.5%의 높은 점수를 받았습니다. 게다가, 그 증거는 비트코인 가격 변동에 대한 직렬 의존도가 없다는 것이다. 지난 며칠 또는 몇 달 동안 일어난 일은 내일 가격 변동을 예측하는 데 도움이 되지 않을 것입니다. 따라서, 2018년 현재 비트코인의 가치에 대한 시장 평가에서 약 65%의 하락이 있었지만, 비트코인 가격에 대한 측정 가능한 연쇄 의존도가 더 낮다는 점을 고려하면, 향후 50:50대 확률로 가격이 높아지거나 낮아질 확률이 있다. 그와 동시에, 달러 측면에서 비트코인 가격을 낮추면, 거래 단위로서 더 매력적일 수 있다. 이를테면 아마존에서 100달러 대신에 6700 비트코인으로 구매할 수 있게 되는 것이다. 역사적인 분석에 따르면 암호 화폐 가격은 비트코인과 밀접한 관련이 있는 것으로 나타났고, 투자 위험을 감소시킨다는 차원에서 다른 코인들을 다각화 하는 것은 별로 도움이 되지 않는다. 암호 블록체인 공간에서 가능한 개발 경로에 대한 흥미로운 사례 연구는 Napster를 사용한 P2P(Peer-to-Peer) 파일 공유의 가장 초기 형태 중 하나라는 것이다. 몇몇 주요 음악 상표에서 나온 반응은 이것이 저작권 침해이며 힘들게 번 저작권으로 부터 녹음된 예술가들을 강탈하는 것과 비슷하다는 것이다. 인터넷 기술이 발전함에 따라, P2P 공유는 영화와 TV 쇼로 확대되었다. 영화 제작사들은 영화 저작권 침해의 부정적인 영향을 알리기 시작했고, 불법 영화를 다운받는 고객들을 체포하는 데 있어서 인터넷 서비스 제공 업체들을 공동으로 선정하려고 했다. 애플사의 스티브 잡스와 같은 기업가들은 대다수의 대중들이 법을 어기고 불법으로 음악을 다운받기를 원하지는 않지만, 음악을 소비한 것이 사람들이 앨범이나 CD를 구입하기 위해 기꺼이 비용을 지불하기를 원하지 않을 정도로 변했다는 것을 인정했다. 그는 음악 레이블과 계약을 협상했고 이 곡당 지불 기능은 2003년 아이튠즈에 통합되었다. 오늘날, Spotify(즉, 2012년 주류)에서 음악을 쉽게 스트리밍하고 Netflix(즉, 2013년 메인스트림)에서 최소한의 월별 가입 비용을 지불할 수 있다. 이러한 기업의 성공과 가입 기반 규모는 그들이 어떻게 시장의 요구를 충족시켰는지 보여주는 증거이다. 기록 라벨, 영화 스튜디오, 인터넷 회사들이 어떻게 고객의 요구에 적응하고 진화해야 했는지에 대한 사례 연구였고, 이러한 변화가 오기까지 약 15년이 걸렸다. 한 가지 예측은 블록체인이 암호 화폐의 거래만을 넘어서 응용 프로그램을 사용하여 백 오피스 레거시 지불 시스템을 빼앗을 것이라는 것이다. 호주 예로서 커먼 웰스 뱅크는 블록체인 원장 기록 보관만 사용하는 &quot;본드 -I&quot;라는 영리하게 별명을 붙인 채권 문제를 관리하기 위해 세계 은행과 협력하고 있다고 발표했다. 분산 된 데이터베이스에 대한 금융 시장을 넘어서는 잠재적 인 응용 프로그램과 역사적 거래의 불변의 기록의 생성은 정치 (즉, 선거인 사기 방지), 의료 (즉, 개인에 대한 정확하고 최신 의료 기록), 정부 계약 (즉, 대규모 정부 인프라 인프라에서 하청 업체를 추적하는 것) 등에 이용할 수 있다. 시간이 지남에 따라 규제 기관과 시장에 더 잘 적응할 수 있는 다른 모양이나 형태로 진화할 것이다. 반면 블록체인 비방자들은 블록체인의 분산이 느리고 번거롭고 힘이 부족한 것으로 주장한다. 비트코인은 초당 3~4번의 거래(그리고 이더리움 20번)를 수행할 수 있는 것으로 추정되지만 중앙 집중식 비자는 초당 평균 1667번의 거래를 처리할 수 있다. 비트코인과 이더리움의 힘을 보태 기 위한 라이트닝 네트워크와 라이덴 네트워크는 초당 100만 개의 거래 규모를 처리할 만큼 확장될 수 있다고 하지만, 비자는 초당 56,000개의 거래를 달성할 수 있다고 반박한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"크립토 이코노미란 무엇인가?","slug":"what-is-crypto-economy","date":"2018-11-11T15:00:00.000Z","updated":"2018-11-12T04:44:27.000Z","comments":true,"path":"2018/11/12/what-is-crypto-economy/","link":"","permalink":"https://www.yceffort.kr/2018/11/12/what-is-crypto-economy/","excerpt":"What is a crypto economy? 원문 블록체인 위에 세워진 코인 발행으로 발생한 블록체인과 재산에 대한 모든 흥분 가운데, 이 혁신의 경제적 중요성은 무시되고 있는 듯 하다. 암호화폐 회사들이 높은 위험과 높은 수익률의 투자 가능성을 모색하기 위해 전통적으로 구상된 경제의 성장 부문으로 부상하고 있으며, 고용을 창출하고 자본을 유치하고 있다. 그러나 크립토 이코노미는 또 다른 기술 분야가 아니다. 그것은 경제를 만들어가는 또 다른 방법이다. ¶왜 지금 크립토 이코노미인가? 크립토 이코노미의 출현은 공개 키 암호","text":"What is a crypto economy? 원문 블록체인 위에 세워진 코인 발행으로 발생한 블록체인과 재산에 대한 모든 흥분 가운데, 이 혁신의 경제적 중요성은 무시되고 있는 듯 하다. 암호화폐 회사들이 높은 위험과 높은 수익률의 투자 가능성을 모색하기 위해 전통적으로 구상된 경제의 성장 부문으로 부상하고 있으며, 고용을 창출하고 자본을 유치하고 있다. 그러나 크립토 이코노미는 또 다른 기술 분야가 아니다. 그것은 경제를 만들어가는 또 다른 방법이다. ¶왜 지금 크립토 이코노미인가? 크립토 이코노미의 출현은 공개 키 암호 체계에서 시작하여, 이전 및 관련 프로그래밍과 컴퓨터 혁신을 포함한 비트코인 및 분산형 원장 기술의 혁신에 가장 크게 의존해 왔다. 그러나 경제와 금융의 역사와 관련된 크립토 이코노미를 보는 것도 필수적이다. 다른 많은 전통적인 지식, 관습, 관행에 있어서 붕괴가 있었고, 그 결합은 현재 크립토 이코노미 출현을 위한 실제 조건을 만들어냈다. 부채와 자본. 부채와 자본(환산채권, 우선주, 총수익스왑)이 구분이 무너지면 자금 투자에 대한 새로운 사고방식이 열린다. 토큰 발행은 비록 각각의 요소를 가지고 있지만 부채도 자본도 아닌 자금을 제공한다. 화폐 및 기타 자산. 화폐의 파생상품(이자율, 환율), 거래의 상승으로 인해 자산 시장의 새로운 유동성은 화폐와 다른 자산의 차이를 구분하는 유동성(확실성)을 창출한다. 화폐로 전환. 그 다음에, 거래자들에게, 화폐는 필수적이지만 비용이 많이 드는 전환점으로 보인다. 즉, 그들이 한 자산에서 다른 자산으로 옮겨갈 때 '통과’해야 하는 것이다. 토큰은 거래를 통해 화폐 측정을 '통과’할 수 있게 한다. 자산의 본질. 세계 최대 기업의 주요 자산인 자산 유형으로서의 '무형’의 부상은 기업 회계에 문제를 야기한다. 이러한 자산은 쉽게 가치를 측정할 수 없기 때문이다. 블록체인 기반 자산은 이런 의미에서 전통적인 ‘무형 자산’과 다르지 않다. 기업 조직. '네트워크’가 기업조직의 한 종류로서 부상하는 것은 한 기업을 다른 기업과 차별화하는 기존의 수단을 무너뜨리고 '경쟁’의 원칙을 기업 논리의 원동력으로 삼는 것이다. 이것들은 분산형 어플리케이션에서 두드러지게 나타나는 이슈들이다. 생산의 이론적 근거. 기업의 사회적 책임, 특히 환경 및 인권 문제에 대한 우려가 모니터링의 새로운 방식에 의해 충족되고 있으며, 기업의 결정을 완화하고 있지만 기업의 목표로서 이윤창출이라는 과학적 우선성에 결코 도전하지 않는다. 프로그램 가능한 조직은 사회적 기준을 제약이 아니라 생산의 근거로 만드는 방식으로 생산을 구성할 수 있다. 위험의 분포. 노동의 성격 변화(정비화, 상해, 하청, 게임 경제의 상승)는 노동자들이 더 큰 위험을 안고 있는 것을 보고 고용에 대한 일과 생활 수준의 애착을 끊는다. 일을 조직하는 대체 방법에 대한 관심이 커지고 있다. 전통적인 금융상품의 신용. 2007-2008년 세계 금융 위기는 전통적인 은행업무에 불신의 경제 환경을 조성했다. 또한, 양적 완화는 국고채 가치의 안정성에 대한 지속적인 불확실성을 남긴다. 이러한 사태의 여파로 새로운 형태의 금융 신뢰가 더욱 매력적인 요소로 보인다. ¶새로운 크립토 이코노미의 주요 특징은 무엇인가? ¶국가에 의존하지 않는 새로운 지배방식 개발 필요 잠재적으로 국가의 경제역할을 변화시켰다. 일부는 국가의 필요 없이 프로토콜로 운영되는 경제에 대한 블록체인 토론에 관여했다. 즉, 블록체인 및 코인 발행의 경우 계약과 재산소유 및 거시경제적 관리의 시행은 물론 현재 암호화폐으로 복제될 수 없는 많은 주 캐패시턴스에 의존한다. 그러나 돈과 국가는 분명히 곤경에 처해있다. 또한 국가가 사회신뢰를 감독한다는 생각 또한 도전적이다. 거래를 위한 기록 보관소 및 집결소는 더 이상 국가의 손을 필요로 하지 않는다. 비밀경제는 국가에 의해 직접적으로 조정되지 않는 경제관계를 제공하며, 국가의 경제질서에 따르지 않는 경제조직의 가능성을 열어준다. 국가가 눈에 띄지 않는 한, 암호 경제는 자체의 통치 방식에 초점을 맞출 필요가 있다. 비밀경제가 본질적으로 조화롭고 균형을 이루고 있다는 개념이 없어야 한다. ¶돈의 성격 변화 암호화폐는 국가만이 돈으로 상징적 교환에 대한 신뢰의 기초를 제공할 수 있다는 역사적 명제에 이의를 제기해왔다. 비트코인은 역사적으로 돈과 국가를 분리할 수 없는 것에 도전하면서 신뢰의 다른 기반을 제공하였다. 국가(및 화폐발행과 관련된 은행)에 의한 공급으로부터의 자금 분리의 문제를 넘어, 화폐의 변화는 더 큰 의미를 가진다. 최근 특히 비트코인과 관련하여 암호화에 대한 논의에서 교환의 수단으로서의 역할에 초점을 맞추고 있다. 비판자들은 그 가치의 변동성이 극심하다고 지적한다. 그들은 또한 비트코인이 교환의 수단으로 널리 사용되지 않는다고 지적한다. 어떤 이들은 이 시점에서만 그것을 불운한 통화로 이야기 하곤 한다. 그러나 화폐는 단순한 교환의 수단이 아니다. 화폐의 다른 중요한 기능은 가치의 저장, 그리고 계좌의 단위이다. But money is not simply means of exchange: its other critical functions are store of value and unit of account. 암호 토큰은는 부분적으로 변동성 때문에 아직 강력한 가치의 저장 역할을 하고 있지 못하지만, 이는 또한 다른 저장가치 방법과 연결하는 법이 개발되지 않았기 때문이다. 예를 들어, 암호화폐 회사가 나스닥에 상장되어 있거나 또는 어떤 종류의 '자산’의 비전의 확대 및 '법적 제약’으로 투자 은행과 연금 기금에 의해 접근할 수 있다면, 어떤 것이 '무형의 가치’가 될 것이다. 하지만 실질적인 잠재력은 계산의 단위로서 암호화폐에 있다: 내재적인 자금과 다른 방식으로 인식되는 경제 활동을 측정하는 방식이다. 명목 화폐는 전통적인 수익과 손실, 소득과 지출, 그리고 시장 중심적인 계산과 연관되어 있다. 비농업용 자산은 경제적 활동을 계산하는 새로운 방법을 개발할 수 있는 잠재력을 가지고 있다. 즉, 상이한 사회적, 경제적 가치를 나타내며 이익 이외의 기준으로 성과를 측정하는 방법이다. 계좌 잠재력 단위는 각 토큰이 지원하는 활동을 계산하고 측정하는 방법(단일 방법이 아니라 동전 고유 방법)을 개발하는 암호화 경제의 중요성을 나타낸다. 이것이 단지 그것들을 투기적인 가치의 저장고로 남겨두는 것이 아니라 크립토 이코노미에서 중요한 기반을 제공하는 중심이라고 본다. ¶경제 협회 유형 거래: 암호화 방식으로 활성화된 분산 정보 시스템을 통해, 경제적으로는 볼 수 없었던 사람/제도 간의 빠른, 저렴한 비용으로 보이는 P2P(peer-to-peer) 무역을 가능하게 한다. 일부, 특히 자유주의 경제의 추종자들에게는 교류 능력(무역)이 본질적인 미덕이다. 즉, 상호 이익을 위해 자유롭게 연관시킬 수 있는 인간/조직의 능력이다. Blockchain은 확실히 이 정치적 비전을 따른다. 그러나 거래는 종종 불평등한 힘을 가진 당사자들 사이에 있기 때문에 상호 이익을 추정할 수 없다. 크립토 이코노미에서 중요한 문제는 블록체인이 어떻게 무역의 비대칭적 권력을 강제할 수 있는가 하는 것이다. 우리는 블록체인이 마찰을 일으키지 않고 오히려 마찰을 일으키지 않는 자본, 즉 분산자본이라고 본다. 네트워크: 네트워크 연결 관계에 대한 조직 연구, 서로 다른 조직 사이의 점점 더 유동적인 경계, 그리고 노동자와 기업의 변화하는 관계에 대한 많은 내용이 기록되어 있다. 네트워크가 조직 및 소유권에 대한 전통적인 생각(예: 지적 재산)과 '고용’을 파괴하고 있음이 분명하다. 어떤 사람들에게는, 이러한 도전은 개별 계약의 비효율성을 극복하는, 우리의 알려진 조직들이 합성 혼합이라는 개념으로 귀결된다. 그들은 네트워크를 통해 개별 계약의 효율성이 부활하고 있다고 주장한다. 우리는 네트워킹이 협력의 새로운 가능성과 함께 위험과 추측의 가능성을 열어준다고 본다. 생산: 암호화의 잠재성으로부터 주의 화폐와 다른 회계 단위로서 사회적 기여도를 측정하는 것, 그리고 사회적 생산 방식을 재도입하는 것, 즉 우리가 사회적 기여도를 어떻게 이해하고 있는가 하는 것입니다.nd 출력이 분배/액세스/소유되는 방식. 생산을 재정립하고 재측정은 암호경제학의 물질적 기초를 제공한다. 암호 해독제는 대체 경제 논리의 통화로서 장기적인 미래를 가능하게 하는 기초이다. 경제를 하는 다른 방법이 될 수도 있다. 크립토 이코노미에 관련하여 우리가 논의해야 할 경제적 공간은 전통적인 경제 체제와 병행하는 자본주의 이후의 조직 및 계산 방식을 이미징 및 엔지니어링하는 데 그치지 않는다. 이는 거대한 요구다. 그것은 완전히 새로운 것은 아니지만, 그들의 범위와 조직 방식에 대한 개념에서 완전히 새로운 경제적 가능성을 보여준다. 1840년대에 주식회사와 주식시장의 동반 상승은 자본주의를 변화시켰다. 완전히 새로운 형태의 생산, 캡처, 유통이 탄생되었다. 우리가 지금 비슷한 의미의 전환점에 있다고 생각한다. 새로운 네트워크 기술은 근본적으로 다른 경제를 만들어 낼 것이다. 가치가 어떻게 창출되고, 수집되고, 분배되고, 돈이 무엇이고, 사람들이 생산과 어떻게 관련되어 있는가 하는 것은 1세대 인터넷이 정보 수준에 있는 다른 사람들의 존재와 의사소통하는 방식을 변화시켰을 때만큼 급진적으로 변하고 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인이 안전한 투표를 위한 답이 아닐 수도 있다.","slug":"are-blockchains-the-answer-for-secure-elections-probably-not","date":"2018-11-10T15:00:00.000Z","updated":"2018-11-11T01:52:41.000Z","comments":true,"path":"2018/11/11/are-blockchains-the-answer-for-secure-elections-probably-not/","link":"","permalink":"https://www.yceffort.kr/2018/11/11/are-blockchains-the-answer-for-secure-elections-probably-not/","excerpt":"Are Blockchains the Answer for Secure Elections? Probably Not 원문 미국의 투표 시스템의 완전성 보장에 대한 진전이 거의 없는 상태다. 수많은 신생기업들이 혁신적인 해결책으로, 비트코인과 같은 암호 화폐를 위한 디지털 거래 주도자로 가장 잘 알려진 블록체인을 활용하고 자 하고 있다. 지지자들은 이러한 인터넷 기반 시스템이 유권자들의 선거 접근을 증가시키는 동시에 부정 조작 방지와 공적인 감사 가능성을 향상시킬 것이라고 말한다. 그러나 사이버 보안과 투표의 전문가들은 블록체인이 불","text":"Are Blockchains the Answer for Secure Elections? Probably Not 원문 미국의 투표 시스템의 완전성 보장에 대한 진전이 거의 없는 상태다. 수많은 신생기업들이 혁신적인 해결책으로, 비트코인과 같은 암호 화폐를 위한 디지털 거래 주도자로 가장 잘 알려진 블록체인을 활용하고 자 하고 있다. 지지자들은 이러한 인터넷 기반 시스템이 유권자들의 선거 접근을 증가시키는 동시에 부정 조작 방지와 공적인 감사 가능성을 향상시킬 것이라고 말한다. 그러나 사이버 보안과 투표의 전문가들은 블록체인이 불필요하게 복잡하며 다른 온라인 투표보다 더 안전하지 않다고 본다. 기존의 투표 시스템은 많은 의혹을 남긴다. 이론적으로 유권자 가장이 가능하다. 최근의 조사에서 반복적으로 미국에서 이것에 대해 무시할 수 없는 비율임을 인지하고 있다. 우편 투표는 변경되거나 도용될 수 있다. 모든 선거 관리자들은 부정확하게 생각한다. 2016년 선거 전에 발표된 갤럽 여론조사에서 미국인의 3분의 1이 투표가 제대로 집계될지 의심하는 것으로 나타났다. ¶블록체인 투표 블록체인 옹호자들은 이 기술이 투표 시스템의 불안의 근본 원인, 즉 투표가 단일 개인, 그룹 또는 기계에 의해 통제될 수 있다는 사실을 다루고 있다고 말한다. 아르헨티나의 &quot;Net Party&quot;는 무엇이 잘못될 수 있는지에 대한 예를 제공한다. 이 작은 정당들은 온라인 투표 플랫폼에 표현된 것처럼 시민들의 요구를 엄격하게 따르겠다고 약속하는 후보들을 선거로 내보내고 있었다. 2014년 초 당 지도부가 정당간 연대를 고려하는 와중에, 당원들 사이에서 표결에 부쳤다. 놀랍게도, 그들은 데이터베이스 관리자가 투표가 끝날 때까지 새로운 유권자 등록을 선택적으로 지연시키고 있다는 것을 발견했고, 이것은 참가자들의 풀을 관리자가 선호하는 방향으로 왜곡시키는 결과를 낳았다. 이와 같은 일은 오직 공무원이 어떤 표와 유권자들이 투표를 할 것인지 일방적으로 결정할 수 있을 때만 가능하다. 이러한 깨달음에 고무되어, Net Party 창당자인 Santiago Siri는 블록체인 투표 시작인 Democracy Earth를 만들었다. Democracy Earth와 그 동료들은 투표 과정을 분산시켜 부패를 예방하는 것을 목표로 하고 있으며, 각 결정과 투표는 블록체인에 대한 대중의 검토에 따른다. 기능적으로, 블록체인은 단순히 복잡한 데이터베이스이다. 예를 들어 비트코인 데이터베이스의 각 항목은 디지털 원장의 트랜잭션이다. 원장은 현재까지의 모든 거래를 공개적으로 나열하고, 누가 얼마의 금액을 보유하고 있는지를 명시한다. 블록체인을 기존 데이터베이스와 구별하는 것은 중앙 집중식 제어 없이 여러 당사자가 데이터베이스를 공유할 수 있다는 점이다. 대부분의 기존 데이터베이스에는 데이터 추가 프로세스를 제어하는 하나의 권한 있는 컴퓨터가 있었다. 블록체인에서, 그 신뢰할 수 있는 게이트키퍼는 인터넷상의 컴퓨터로 대체되고, 각각은 데이터베이스 복사본을 유지한다. 이러한 컴퓨터는 새로운 데이터의 검증자 역할을 하ㄴ다. Alice가 Bob에게 돈을 보내고 싶을 때, 검증자에게 이 거래를 브로드캐스트합니다. 이 트랜잭션은 Blockchain의 규칙을 포함해야 한다. 일단 대부분의 네트워크가 그 거래를 받아들인 후에는, 그들은 사실상 합의의 역사가 된다. 블록체인의 가장 두드러진 용도는 통화지만 다른 유형의 데이터를 저장하지 못할 이유는 없으며, 투표가 가장 적합한 것으로 보인다. 이상적인 투표 시스템은 당국이나 해커들의 부패에 저항하고 시민들과 감사들이 선거 결과에 합의할 수 있게 한다. 서로 완전히 신뢰하지 않는 당사자들 간의 편리하고 감사할 수 있는 합의가 정확히 블록체인이 제공하는 것이다. 이 비전을 추구하는 각 회사들은 자신만의 고유한 특징을 가지고 있다. Votem이라고 불리는 한 신생기업은 유권자들이 개별 투표가 집계되었음을 확인하도록 하는 학문적 연구를 중심으로 시스템을 구축했다. 또 다른 스타트업인 Voatz는 스마트폰과 태블릿의 내장된 지문 인식과 유권자 확인을 위해 얼굴 인식 기능을 사용하여 블록체인을 생체 인식의 신원 확인으로 보완한다. Democracy Earth 대중이 신뢰하는 다른 유권자에게 투표권을 위임할 수 있는 능력을 제공한다. 저명한 투표 기술 회사인 Smartmatic은 블록체인을 더 넓은 투표 서비스 제품군에 통합한다. 미국 정당, 미군과 브라질, 스위스 등 정부로부터 관심을 끌고 있다. ¶세부사항에 감춰진 위험들 그러나, 암호학자나 선거 전문가들은 선거의 청렴도를 향상시킬 수 있는 블록체인의 잠재력에 감명을 받지 않는다. 저명한 암호학자인 Ron Rivest는 학자들 사이의 암울한 의견을 요약한: “나는 그것이 좋은 생각이라고 생각하는 사람을 알지 못한다. 그리고 1~2년 안에 이 모든 회사들이 죽을 것이라고 생각한.” 블록체인 투표는 단순히 비트코인 거래를 투표로 대체하는 것 이상의 것을 필요로 할 것이다. 런던 대학의 블록체인 연구원인 Arthur Gervais는 &quot;비트코인은 대중이 (중앙으로 발행된) 신분을 필요로 하지 않기 때문에 효과가 있다.&quot;라고 말한다. 대신 사용자는 예금 전용 계좌 번호처럼 해당 계좌에서 돈을 이체하는 데 필요한 비밀 디지털 키 같은 주소를 생성한다. 누구나 쉽게 키 주소 쌍을 만들 수 있다. 요점은 비밀 키를 잃어버리거나 도둑에게 갈취당하면, 해당 계좌가 쓸모없어 질 수 도 있다. 이 상황은 주와 지방 당국이 유권자 명단을 관리하는 정부 선거에서는 일어나지 않을 것이다. 대부분의 정부도 디지털 투표 키가 손상된 하드 드라이브에 의해 저장되거나, 도둑이 사기 투표를 하기 위해 훔치는 등 유권자의 선거권을 박탈당할 가능성을 용납하지 않을 것이다. 이것이 대부분의 선거 제공자들이 유권자 정체성의 관리를 부분적으로 중앙 집중화하는 이유이다. 이들의 시스템은 등록 과정에서 수집한 ID와 지문과 같은 여러 가지 ID 데이터베이스의 컨소시엄을 쿼리하여 유권자를 정부 유권자 명단의 이름과 일치시키도록 설계되었다. 이러한 신원관리 기관의 정족수는 분실 또는 도난 투표 키를 취소할 수도 있다. 마찬가지로, 기업들은 악의적 영향으로부터 보호하기 위해 검증 과정을 부분적으로 중앙집중화한다. 즉, 누구든 검증자가 되는 것을 허용하는 대신, 선거를 조직하는 것은 컨소시엄을 지정하고, 비정부 기구와 그들로 하여금 어떤 합의를 결정하게 한다. 비트코인 스타일의 오픈 모델과 달리, 이 컨소시엄이 관리하는 블록체인 모델은 적어도 선거과정을 손상시키지 않고 구현할 수 있다고 선거 보안 회사인 Free &amp; Fair의 대표이자 소프트웨어 책임자인 Joe Kiniry는 말한다. 그러나 컨소시엄으로 전환하면 블록체인의 보안상의 이점도 사라지게 된다. 중앙당국이 유권자의 신분을 박탈하고 철회하는 것은 유권자들을 어떤 표를 얻을지 결정할 수 있는 소수의 행정가들에게 다시 맡겨야 한다. 한편, 검증자의 역할은 부정 투표에 대한 감사로 줄어들어 훨씬 더 단순하게 이루어질 수 있다. &quot;블록체인은 중앙당국이 없는 분산된 합의점에 있어 매우 흥미롭고 유용한 기술입니다. 하지만 선거는 그 모델에 맞지 않습니다.&quot;라고 마이크로소프트 수석 암호학자 Josh Benalo는 말합니다. 중앙 기관이 선거를 조정하면, “그 기업이 웹사이트에 투표 데이터를 게시하고 디지털 방식으로 서명하여 실행하는 것이 좋습니다.” 사실, Kiniry와 Gervais 둘 다 Blockchain 기술이 온라인 선거 무결성의 핵심 문제들조차 해결하지 못한다고 주장한다. &quot;필요한 모든 기술 구성 요소를 살펴보면, 블록체인은 100개의 요구사항중 4개만 충족한다고 Kinry는 말합니다. 투표용지를 기록하는 데는 효과적이지만, 블록체인 창업자들조차 유권자 검증, 투표용지 비밀 유지, 각 유권자들이 투표용지가 집계되었음을 입증하는 것과 같은 더 어려운 도전을 위해 추가적인 기술 계층이 필요하다. 암호학 기술자들은 수십 년 동안 이런 도전에 대한 한가지 해결책을 주장해왔다. 이를 ‘끝에서 끝까지 검증 가능한 투표(end-to-end verifiable voting)’라고 하는 기법으로 설명한다. 이러한 기법은 블록체인을 사용하지 않는다. 하지만 아이러니하게도 종단 간 검증 가능성을 주류로 만드는 것은 블록체인의 선거 보안에 가장 큰 기여를 하게 될 수도 있다. 결국 ‘블록체인’이라는 단어는 기술과의 연결이 관대하고 약한 기업들에게도 투자자의 현금을 끌어당긴다. 그리고 회의론자들조차도 블록체인의 투표 관련성을 인정한다. 보안에 대한 의문의 여지가 있음에도 불구하고 유사한 절차가 투표 시스템의 효율성이나 신뢰성을 향상시킬 수 있다. 그래서 누군가는 암호학자가 승인한 시스템을 만들고 그것을 블록체인이라고 부르는 방법을 찾을 수 있을 것이다. 엔드 투 엔드 검증이 트랙션을 얻는 데 필요한 것이라면? &quot;그것이 여러분이 그것을 채택하도록 만든 것이라면, 좋아요, 그렇게 합시다,&quot;라고 베날로는 말한다. “하지만 저는 좋은 프로토콜의 모든 진정한 이점에 대해서도 말하고 싶습니다.”","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smartcontract","slug":"smartcontract","permalink":"https://www.yceffort.kr/tags/smartcontract/"}]},{"title":"블록체인을 활용한 디지털 투표","slug":"digital-voting-with-the-use-of-blockchain-technology","date":"2018-11-09T15:00:00.000Z","updated":"2018-11-09T19:44:01.000Z","comments":true,"path":"2018/11/10/digital-voting-with-the-use-of-blockchain-technology/","link":"","permalink":"https://www.yceffort.kr/2018/11/10/digital-voting-with-the-use-of-blockchain-technology/","excerpt":"Digital Voting with the use of Blockchain Technology 원문 ¶1. Summary 이 보고서의 목적은 블록체인 기술을 사용하여 디지털 투표 문제를 해결하자는 우리의 제안을 요약하는 것이다. 현재 투표 관행과 관련된 문제들을 소개함으로써 시작하고, 그 후 블록체인 기술이 무엇이고 어떻게 사용되고 있는지에 대한 간단한 설명을 시작한다. 다음 섹션에서는 디지털 투표의 현재 배치와 이들이 직면하고 있는 문제에 대해 살펴본다. 보고서의 주요 부분은 제안된 설계에 대한 상세 내역, 잠재적인 결함과 위","text":"Digital Voting with the use of Blockchain Technology 원문 ¶1. Summary 이 보고서의 목적은 블록체인 기술을 사용하여 디지털 투표 문제를 해결하자는 우리의 제안을 요약하는 것이다. 현재 투표 관행과 관련된 문제들을 소개함으로써 시작하고, 그 후 블록체인 기술이 무엇이고 어떻게 사용되고 있는지에 대한 간단한 설명을 시작한다. 다음 섹션에서는 디지털 투표의 현재 배치와 이들이 직면하고 있는 문제에 대해 살펴본다. 보고서의 주요 부분은 제안된 설계에 대한 상세 내역, 잠재적인 결함과 위협의 분석이다. 마지막 섹션은 우리의 설계가 당면한 문제를 해결하는 방법에 대한 결론이다. ¶2. Introduction 투표는 어느 나라에서나 중대하고 심각한 사건이다. 한 국가가 투표를 하는 가장 흔한 방법은 종이 기반 시스템을 통해서이지만, 현대 기술의 21세기에 투표를 가져올 때가 아닌가? 디지털 투표는 투표 기계나 인터넷 브라우저와 같은 전자 장치를 사용하여 투표를 하는 것이다. 투표소에서 기계를 사용하여 투표할 때 전자 투표라고 하고 웹 브라우저를 사용할 때는 i-투표라고 한다. 디지털 투표의 보안은 디지털 투표 시스템의 실행을 고려할 때 항상 가장 큰 관심사다. 이러한 기념비적인 결정이 달린 상황에서, 잠재적인 공격으로부터 데이터를 보호하고 보호하는 시스템의 능력에 대해서는 의심의 여지가 없이 중요한 문제다. 보안 문제를 잠재적으로 해결할 수 있는 한 가지 방법은 블록체인 기술을 이용하는 것이다. Blockchain 기술은 암호화폐 비트코인의 기본 아키텍처 설계에서 비롯된다. 이것은 레코드가 트랜잭션의 형태를 취하는 분산 데이터베이스의 한 형태이며, 블록은 이러한 트랜잭션의 모음이다. 블록체인 사용으로 디지털 투표를 위한 안전하고 강력한 시스템이 만들어질 수 있다. 이 보고서는 어떻게 Blockchain 기술을 사용하여 안전한 디지털 투표 시스템을 구현할 수 있는지에 대해 개략적으로 설명한다. ¶3. 블록체인이 무엇이고 보통 어떻게 사용 되는가? (생략) ¶4. 현재 디지털 투표 시스템 많은 디지털 투표 시스템이 현재 전 세계 국가에서 사용되고 있다. 우리는 이러한 시스템들 중 일부를 조사하여 현재의 구현, 특히 에스토니아에서 익숙해졌다. 에스토니아는 2005년부터 전자투표를 해왔고 2007년에는 세계 최초로 온라인 투표를 허용했다. 2015년 총선에서 i-투표제를 통해 전체 투표의 30.5% 투표율을 기록했다. (Vabariigi Valimiskomisjon, 2016). 이 제도의 기초는 모든 에스토니아 시민들이 받는 국가 신분증이다. 이러한 카드에는 소유자를 식별하는 암호화된 파일이 들어 있으며 소유자는 온라인 뱅킹 서비스, 디지털 서명 문서, 정부 데이터베이스에 대한 정보 액세스 및 i-voting 등 여러 온라인 및 전자 활동을 수행할 수 있다. 투표하려면 카드 판독기에 카드를 입력한 다음 연결된 컴퓨터의 투표 웹 사이트에 액세스해야 한다. 그런 다음 PIN 번호를 입력하고 투표할 수 있는지 확인한다. 일단 확인이 되면, 그들은 선거일 4일 전까지 투표권을 행사/변경할 수 있다. 또한 유권자는 컴퓨터에 대한 카드 판독기가 없는 경우 휴대 전화를 사용하여 i-투표에 참여할 수 있다. 그러나 이 프로세스를 수행하려면 휴대폰 특수 SIM 카드가 필요합니다. (2015년 에스토니아 외무성) 투표자가 투표용지를 제출하면, 투표용지는 온라인 투표 기간이 끝날 때까지 암호화되고 저장되는 투표용지 서버에 공개적으로 접근 가능한 투표용 포워딩 서버를 통해 통과된다. 그런 다음 투표는 모든 식별 정보를 정리하고 DVD로 모든 네트워크와의 연결이 끊어진 투표 집계 서버로 전송된다. 이 서버는 암호를 해독하고 표를 계산한 다음 결과를 출력합한다. 이 프로세스의 각 단계가 기록되고 감사됩니다. 연구원들은 2013년 지방선거에서 아이 투표 과정을 관찰하고 연구했으며, 이 시스템을 통해 여러 잠재적인 보안 위험을 강조했다. 이러한 위험 중 하나는 사용자가 투표하는 것을 모니터링하고 나중에 다른 후보자에게 투표권을 변경하는 클라이언트측 시스템의 악성 프로그램의 가능성이다. 서버를 설정하고 표를 전송하는 데 사용되는 기기에 맬웨어가 저장되더라도 공격자가 서버를 직접 감염시킬 수 있는 위험도 있다. (Springall et al., 2014) 그러나, 이 보고서는 또한 Estonian Information Systems Authority로부터 비난을 받고 있다. (Veldre, 2014) ¶5.제안 우리의 디자인을 위해 우리는 현재의 투표를 완전히 대체하지 않고 오히려 현재의 시스템 내에 통합되는 시스템을 만들려고 노력했다. 우리는 가능한 한 많은 다양한 투표 방법을 허용하기 위해 이것을 (이 제안) 하기로 결정했는데, 이것은 대다수의 사람들이 투표에 접근할 수 있는 것이다. ¶5.1 등록 디자인의 첫 번째는 등록 과정이다. 유권자를 확인하는 것은 시스템 내에서 보안을 수립하는 데 필수적이다. 부정직한 목적으로 누군가의 신원이 오용되지 않도록 하는 것은, 특히 모든 투표가 중요한 곳에서 투표를 고려할 때 중요하다. 등록 프로세스 설계는 그림 4 (하단) 에서 확인할 수 있다. 사용자가 투표 등록을 할 수 있도록 웹과 우편양식을 모두 이용한다. 이 모든 정보는 투표를 요청하는 정부에 동의하는 사용자를위한 트랜잭션을 형성한다. 이 트랜잭션 투표 블록 체인과는 분명히 다른 유권자 블록 체인에 만들어집니다. 트랜잭션을 분석하고 투표를 받지 않았거나, 거부 당하면 마이너는 사용자를 확인할지 여부를 결정한다. 사용자가 확인되면 제공된 경우 주소와 이메일 주소에 정보가 있는 투표 용지를 보낸다. 또한 투표소에서 사용할 무작위로 생성된 암호를 보낸다. 이 서신이 보내지면 마이너부는 유권자 블록 체인에 대한 무한한 정부 투표에서 투표권을 사용자에게 제공하는 트랜잭션을 만듭니다. 이 과정에서 유권자 블록체인은 각 유권자에 대해 이 프로세스의 각 단계에서 발생하는 두 트랜잭션의 기록을 보관하는 데 사용된다. 첫번째, 사용자가 등록하면 트랜잭션이 생성된다. 다음 트랜잭션은 정부 마이너가 그 사용자의 투표권을 허가할 때 발생한다. 사용자가 서신을 수신한 후, 그들은 투표에 그들의 자격 증명을 사용하여 투표할 수 있는 투표권을 기다릴 수 있다. 이 유권자 블록체인에는 사용자가 투표한 세부 사항이 포함되지 않는다. ¶5.2 투표 메커니즘과 구조 아키텍처를 결정할 때 우리는 비트코인 네트워크의 분산과 가용성과 기존 투표의 통합 과정 모두에서 강한 영감을 얻었다. 네트워크는 서로 다른 두 개의 블록 체인을 수용하는 다중 계층 분산형 인프라로서, 네트워크는 세 개의 추상 계층, 즉 국가, 선거구 및 지역으로 나뉜다. 로컬 계층에는 전국의 모든 디지털 폴링 스테이션이 포함되어 있으며, 각 각은 선거구 노드에 연결된다. 로컬 노드는 연결된 지역구 노드와 해당 지역구 노드 자체에서만 다른 로컬 노드와 통신하도록 설정된다. 선거구 계층에는 선거구 수준에 있는 것으로 간주되는 모든 노드가 포함된다. 이 노드는 위치에 따라 서로 및 폴링 스테이션의 하위 집합에 직접 연결된다. 국가 계층은 위치에 묶여 있지 않은 노드 모음이며, 순수한 목적은 거래를 채굴하고 투표 블록 체인에 블록을 추가하는 것이며, 모든 선거구 노드는 국가 노드와 통신하고 국가 노드는 서로 통신할 수 있다. 독립 기관은 투표 과정을 모니터링하고 감사한다. 이 본문은 국가 노드를 호스트하거나 액세스할 수 있으며 암호화되지 않은 결과가 암호화된 투표와 일치하는지 확인할 수 있다. 개인과 조직은 국가 노드가 되기 위해 자발적으로 참여 할 수 있다. 이러한 신청서는 정부가 정한 최소 요구 사항을 충족하도록 정부가 처리한다. 이 개인들은 또한 계산 과정에서 마이너 역할을 할 것이다. 설계의 일환으로 공용 및 개인 키를 기반으로하는 암호화 방법을 가지고 있으며 블록 체인 내에서 데이터가 분리되는 구조를 구현했다. 이 분리는 선거구 수준의 노드가 키 쌍을 생성하도록함으로써 달성되었다. 공개 키는 연결된 폴링 스테이션 노드에 배포된 다음 공개 키를 사용하여 해당 폴링 스테이션에 대한 투표를 암호화한다. 그런 다음 데이터는 블록 체인 내의 암호화된 형식으로 저장되어 전체 네트워크로 전파된다. 각 선거구마다 공용 키가 다르기 때문에 블록 체인 내의 데이터 청크가 블록 체인 옆에 있는 데이터 청크와는 다르게 암호화된다. 우리는 이 방법을 투표 마감일 전에 어떤 한 사람이라도 투표 데이터를 해독할 수 없도록 막기로 결정했다. 만약 해커가 선거구 개인 키를 간신히 손에 쥐게 된다면, 그들은 블록체인의 특정 부분만 해독할 수 있을 것이고, 그래서 투표의 완전한 결과를 결코 알지 못할 것이다. 투표 마감일이 지나면, 선거구 노드 내의 소프트웨어는 블록체인 네트워크가 데이터를 해독할 수 있도록 개인 키를 발행하며, 이는 다시 표를 계산할 수 있음을 의미한다. ¶5.3 투표 절차 투표할 때가 되면, 사용자의 인증은 세 가지 뚜렷한 증거를 요구한다. 즉, 등록 시 제공된 비밀번호와 QR 코드가 포함된 투표 카드이다. 투표에는 두 가지 방법(웹 브라우저, 물리적 투표소)이 있으므로 인증 세부 정보를 입력하는 방법이 달라야 한다. 그러나 투표하려면 세 가지 정보를 모두 제공해야 한다. 또한 각 사용자는 특정 선거구에 등록되므로 선거구 내의 지역 투표소 또는 투표 카드에 제공된 URL로 인터넷을 통해서만 투표할 수 있다는 점을 유념해야 한다. (각 선거구는 투표가 올바른 네트워크 내에서 통합될 수 있도록 자체 웹 서버와 URL을 갖추어야 한다.) 막후에서 투표소는 유권자들이 이미 투표용지를 다 써버리지 않았는지 확인하기 위해 유권자들을 확인할 것이다. 사용자가 투표권을 가지고 있다면, 방송국은 사용자가 계속해서 투표 화면을 볼 수 있게 할 것이다. 그렇지 않으면 시스템이 사용자에게 적절하게 응답한다. (기권 등 선택권에서) 투표권을 선택하고 제출을 확정하면, 해당 투표는 트랜잭션이 되고, 해당 선거구의 공개 키로 암호화된다. 그런 다음 이 트랜잭션이 블록으로 추가되고 업데이트가 해당 특정 지역구 노드에 연결된 다른 모든 노드에 푸시된다. 그런 다음 전체 네트워크가 업데이트될 때까지 연결된 노드가 해당 피어에 데이터를 전달한다. 투표가 확인되면 투표소는 유권자 블록체인 내에서 사용자의 투표권을 제거하는 트랜잭션을 생성할 것이다. 두 개의 블록체인 즉, 등록한 사용자와 여전히 투표권이 있는 사용자와 관련된 거래를 포함하는 블록체인, 두 번째 블록체인(예: 의결된 당사자)이 있다는 점을 유념해야 한다. 이 두 개의 뚜렷한 블록체인을 사용함으로써 우리는 투표자들의 투표를 선택할 때 유권자들의 익명성을 보장한다. ¶6. 설계 분석 제안서 내에서 잠재적인 악의적 공격을 방지하기 위해 공격 벡터의 크기를 최소화하는 서비스와 시스템을 설계하려고 했다. 우리는 투표 과정의 각 단계에 대해 생각했는지 확인하기 위해 다양한 관점에서 설계를 평가하고 분석하려고 노력해 왔다. 보고서의 이 섹션에서는 우리의 제안과 관련된 잠재적인 위험에 대해 논의하고, 그러한 위험을 완화하기 위해 취할 수 있는 조치를 제안한다. 한 가지 위험은 투표일에 유권자가 신분증, 비밀번호 또는 투표 카드를 잊어버리는 것이다. 이 경우 유권자들은 입후보할 투표를 할 수 없을 것이다. 가능한 위험 완화에는 정확한 정보를 가지고 그날 늦게 돌아오는 유권자나 전화기와 같은 백업 인증 서비스의 구현이 가능할 수 있다. 또는, 잊어버린 암호 시스템을 유권자 등록 웹 사이트에 추가할 수 있다. 이것은 다른 웹 사이트에서 작동하는 암호를 복구하는 것과 동일한 방식으로 작동한다. 그러나 이것은 해커가 유권자들의 비밀번호를 모르는 사이에 바꾸려고 시도하는 위험을 증가시킨다. 51%의 공격은 제안된 설계에 대한 잠재적 위협이다. 그 공격의 근거는 이론적으로 누군가가 디지털 투표용 해시 비율의 대부분을 통제할 수 있고, 그 결과 공공 원장을 조종할 수 있다는 것이다. 이러한 규모의 처리 능력을 갖춘 하드웨어를 구입하는 데 필요한 막대한 비용 때문에 이러한 유형의 공격이 발생할 가능성은 희박하다. 우리 시스템 내 투표의 온라인 측면은 해커들이 자신의 장치를 통해 잠재적으로 유권자들을 다양한 방법으로 이용할 수 있기 때문에 해커들에게 가장 큰 공격 요소다. 이 소프트웨어와 싸우기 위해 클라이언트 장치에 다운로드되어 투표소에 안전한 연결을 설정할 수 있다. ¶7. 결론 결론적으로, 우리의 서비스 제안은 정부와 공공 기반 시설 양쪽의 기계들로 구성된 지리적으로 분산된 네트워크들로 구성되어 있다. 이 인프라에는 분명하게 분리된 두 개의 블록체인, 누가 투표를 했는지와 같은 투표 정보에 대한 다른 하나의 블록체인이 있다. 이러한 블록체인들은 특정 정당에 대한 표를 개인 유권자에게 다시 연결시키는 어떠한 위협도 완전히 제거하기 위해 완전히 별개로 행해지며, 누가 투표를 했는지 그리고 실제로 얼마나 많은 표가 존재하는지를 추적하는 능력을 유지한다. 투표에 등록한 사람에 대한 정보가 포함된 블록 체인은 또한 서비스가 각 유권자를 고유하고 5.1 절에 설명된대로 보장할 수 있게 한다. 등록한 후 세부 정보를 확인한 후 투표를 할당합니다. 이 등록된 유권자가 투표가 시작될 때 자신의 신원을 증명하기 위해 5.3 절에 설명된 3 가지 요소 인증 방법이 있다. 또한 우리는 특정 방식으로 투표를 강요하지 않도록해야하므로 사용자가 투표를 보내기 전에 제출을 확인하도록 두 번째 요청을받는 이중 검사 서비스를 통합했다. 이것은 또한 우발적인 투표를 거의 근절할 수 있게 할 것이다. 또한, 우리가 사용하고 있는 암호화 메커니즘 때문에 (제 5.3절에서 설명한 바와 같이) 어떤 사람도 전체 서비스 네트워크를 먼저 통제하지 않고 모든 투표에 접근하기가 거의 불가능할 것이다. 여기서부터 개인 키 게시 방법을 사용하면 누구든 투표의 블록체인을 읽고 새롭게 사용 가능한 선거구 개인 키로 암호를 해독하여 선거 결과를 확인할 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smartcontract","slug":"smartcontract","permalink":"https://www.yceffort.kr/tags/smartcontract/"}]},{"title":"블록체인과 합의 기반 암호화폐는 어떻게 규제할 수 있는가?","slug":"how-can-blockchain-and-other-consensus-driven-cryptographic-technology-be-regulated","date":"2018-11-08T15:00:00.000Z","updated":"2018-11-08T19:44:01.000Z","comments":true,"path":"2018/11/09/how-can-blockchain-and-other-consensus-driven-cryptographic-technology-be-regulated/","link":"","permalink":"https://www.yceffort.kr/2018/11/09/how-can-blockchain-and-other-consensus-driven-cryptographic-technology-be-regulated/","excerpt":"How Can Blockchain and Other Consensus Driven Cryptographic Technology be Regulated? 원문 ¶기술은 시작점에 있다. 1988년 Tim May는 다음과 같이 언급한 적이 있다. “컴퓨터 기술은 개인과 그룹이 완전히 익명의 방식으로 서로 의사 소통하고 상호 작용할 수 있는 능력을 제공하기 직전입니다. 두 사람은 메시지를 교환하고 사업을 수행하며 다른 사람의 실제 이름 또는 법적 신원을 몰라도 전자 계약을 협상할 수 있습니다.” 오늘날 블록체인과 분산 원장 기술 애","text":"How Can Blockchain and Other Consensus Driven Cryptographic Technology be Regulated? 원문 ¶기술은 시작점에 있다. 1988년 Tim May는 다음과 같이 언급한 적이 있다. “컴퓨터 기술은 개인과 그룹이 완전히 익명의 방식으로 서로 의사 소통하고 상호 작용할 수 있는 능력을 제공하기 직전입니다. 두 사람은 메시지를 교환하고 사업을 수행하며 다른 사람의 실제 이름 또는 법적 신원을 몰라도 전자 계약을 협상할 수 있습니다.” 오늘날 블록체인과 분산 원장 기술 애플리케이션의 기초를 형성하는 암호화 적으로 안전한 컨센서스 기술(CCTech)을 기반으로 구축되고 있는 디지털 생태계의 현실이 되었다. CCTech (합의 알고리즘을 의미하고 있습니다.) 는 이전에 가능했던 것 보다 질적으로 다른 상업적 활동 영역을 가능하게 한다. 그것은 효율성 이득을 제공하는 새로운 형태의 상업 활동뿐만 아니라 새로운 유형의 상업 활동을 창출하는 기존의 상거래를 수행할 수 있는 새로운 방법을 가능하게 한다는 약속을 가지고 있다. 2009년 1월 3일(Bitcoin)에 만들어진 최초의 P2P형 전자화폐(Peer-to-Peer) 버전에 이어, 일부 서비스 또는 유틸리티에 대한 액세스를 제공하거나 보안으로 운영되는 &quot;디지털 토큰&quot;이 나타났다. (암호화폐) 이러한 산업 성장에는 개발업자들이 규제 수준이 높은 공공 자본 시장을 더욱 확대하는 것도 포함되었다. 암호 화폐 거래에 의해 촉진된 2차 시장이 나타났다. 이는 규제 기관에게 기존의 법과 규정을 어떻게 적용할 수 있는지를 정의하는 중요한 과제를 만들어내고 있다. 지속 가능한 규제 접근방식을 확립하는 것은 규제 정책 수립에 새로운 도전을 제기하고, 규제 감독의 형태와 그것이 무엇을 이뤄내야 하는지에 대한 근본적인 의문을 제기하는 CCTech의 특징으로 인해 복잡하다. ¶규제의 관점 규제 기관들의 감독에 대한 전망에 대해, 암호 화폐 산업은 계속해서 당파적인 방식으로 목소리를 내고 있다. 감독으로부터의 독립을, 정치적 자유의 필요한 표현으로 보거나, 업계가 암호화폐에 참여하는 공동체 이외의 어떤 감독도 받아서는 안된다고 주장하는 사람들도 있다. 업계의 다른 참가자들은 상업적으로 실행 가능한 가장 낮은 법률 표준 또는 관할권으로 이동하여 현재 상황을 이용하기를 원하고 있다. 또한 주류 상업 활동에 받아들여지고 합법적인 활동으로 검증되고 사회에 도움이 되는 응용 프로그램에 이 산업을 육성하기 위한 수단으로 적극적으로 규제받기를 원하는 사람들도 있다. 일부에서는 규제 감독에 대한 예상되는 부담을 해결하기 위해, 규정이 제대로 갖추어지지 않았거나 불충분한 자금지원을 받는 다른 사람들에 비해 경쟁적 우위로 본다. 그러나 정책 고려사항과 법률 및 규제 개발의 일반적인 패턴은 규제하기를 원하는 것이 규제될 수 있는 것과 항상 동일하지는 않음을 의미할 수 있다. 규제 기관은 현재까지 기존 규제 기준을 가능한 산업에 주로 적용해야 한다. 이것이 사기 및 소비자 위험을 다루는 동시에 산업 발전을 촉진하기에 충분하지 않을 것이라는 일반적인 시선도 있다. CCTech가 제공하는 익명 성이 나쁜 행위자가 범죄 목적을 위해 사용할 수 있다는 우려도 있다. 규제 투명성을 위한 주요 장애물은 종종 CTTech 이전 시대에 확립된 법률, 규정 및 금융 및 상업 관행의 레거시 시스템이라고 본다. 업계에서는 CCTech가 제시한 새로운 맥락을 지나치게 단순화하고 관련 정책 고려사항을 과소평가하면서, 암호화폐가 어떤 규제 사일로에 속하는지(돈, 보안, 선물 계약, 상품 또는 기타) 결정하는 기능을 규제당국에 명시해야 한다. 그러므로 1차 시장 활동은 여전히 단 하나의 질문으로 지배된다: 암호화폐가 안전한가? 이에 따라 CCTech 개발자들은 변호사와 규제기관이 현재 명확히 정의할 수 없는 질문들을 넓은 기능적 개념이나 좁은 범주에서 해결함으로써 사후 규제의 위험이 커지게 된다. 규제 투명성을 지원하기 위한 수단으로서 기존의 증권법에 암호문화폐를 매핑하려는 분류법의 개발이 미니 산업(mini-industry)이 되었다. 그러나, 이것들은 종종 현행 법 증권법의 적용에 대한 근본적인 가정을 바꾸지 않고 문제를 &quot;해결&quot;한다. 따라서 그것들은 본질적으로 재귀적이고 문제 해결을 거의 성취할 수 없다. 물론 뭔가 새로운 것을 오래된 것처럼 다루면서 말하는 것은 다소 역설적이다. 1차 증권 시장 상황과 달리, 영국과 미국의 규제 당국은 선물 시장이 암호 화폐(Bitcoin, 그리고 최근 Ethereum) 주변에서 진화하는 것을 허용했다. CFTC v. McDonnell 등 18-CV-361, 2018)년 법원은 이에 대해 미국 상품 거래 위원회의 감독 권한을 확인했다. 비록 업계의 많은 사람들이 규제 감독을 CCTech의 본질에 대해 혐오스럽다고 생각하지만, 선물 시장의 규제 감독으로 인해 자산 분류의 유효 노출을 촉진하는 확립된 규제 기반 구조 내에서 금융상품의 개발이 가능하게 되었다. 중요한 것은 투자자가 규제 대상 중개자에게 부과되는 보호의 대상이 된다는 것을 의미한다. ¶블록 만들기 현대 금융 서비스 산업의 규제는 상품, 장소, 행동에 관한 세 가지 주요 걸림돌에 기초한다. 이것들은 시장, 중개인, 어드바이저를 통한 일종의 중재라고 가정한다. 규제는 이미 알고리즘 거래 및 로보 자문과 같은 인간의 개입을 대체하는 기술에 대응하여 적응해야했으며, 오히려 행위를 가능하게 하는 코딩이 포함된 알고리즘 거래와 자동 판매와 같은 인간의 참여를 대체하는 기술에 적응해야 했다. 그러므로 코드로 인한 활동도 규제의 대상이 된다. CCTech는 추가적인 어려움을 제시한다. 어떤 행위가 있지만, 그것은 창조자가 더 이상 역할을 하지 않는 네트워크를 통해 운용되는 코드의 무의식적인 운용 이외의 개입 없이 발생할 수 있다. 제품이 있지만, 규제 사일로(contracto)의 목적을 위해 암호화폐 기술을 특성화하는 방법에 대해서는 명확한 설명이 없다. 따라서, CCTech는 장소, 행위 및 제품을 분산 네트워크, 분산형 및 분리형 배치, 스마트 계약을 통해 코드 운영에 통합할 수 있다. 분산형, P2P 기준으로 상업적 활동을 수행할 가능성은 규제 기관에게 질적으로 다른 종류의 이슈를 나타낸다. 어떤 시점에서는 중앙 집중화된 중간 기반 시스템을 중심으로 개발된 기존 규제 도구가 어느 정도 쓸모 없게 될 수 있기 때문에 적응성에 어려움이 있을 수 있으며, 이로 인해 기존 법적 사일로와 기존 걸림돌의 지속적 실행 가능성에 대한 의문이 제기될 수 있다. 비록 어떤 법이 암호화폐에 적용되는지 혹은 어떤 점에서 그것을 적용하는지에 대한 기본적인 문제가 해결되더라도, 여전히 문제가 있는 부분이 남아있다. CCTech는 현재 규제 목표를 의미 있게 이행할 수 있는 일반적인 구성 요소를 제공하지 않는다. 여기에는 소유의 무결성 및 거래의 무결성, 회계 관리 관련 문제(공공 감사 표준에 대한 소유권 증명, 보관 및 분리, 기록 보존의 작업 방식, 교환 방법) 등 다양한 투자자 보호 및 시장 무결성 고려 사항이 포함된다. 시장 투명성과 시장 남용 방지를 주장할 수 있는 능력, 돈세탁 리스크 해결 방법 등도 포함된다. 이를 위해 업계가 적극적으로 해결하려 고하는 기술적 문제가 추가 될 수 있으며 그 중 많은 부분이 잠재적으로 법적 문제를 야기하고 투자자 보호 및 시장 무결성에 영향을 미친다. 이들은 종종 과학과 기술이 어떻게 작동하는지, 그리고 나쁜 당사자가 어떻게 게임에 참여 할 수 있는지와 같은 약점을 인식해야 한다. 여기에는 (개인)키 및 지갑 관리, 합의 알고리즘 위험, 서비스 거부 공격 (DDoS), 이중 지출, 확장 성, 코드 거버넌스 제어 및 사이버 보안 문제가 포함된다. 공개는 또한 문제다. 주요 공시는 다음과 같은 문제를 다룰 수 있다: 기존 코드가 예상되거나 약속된 것을 수행하는가? 적절한 코드 거버넌스(예: 롤백에 동의)가 적절히 구현되어 있고, 다른 문제를 용이하게 하는 확장 가능한 코드 또는 버그가 없는지 여부, 네트워크 효과의 이점 등. 이 점에서 모든 코드가 동일하지는 않으며 코드 오류 때문에 과거에 심각한 문제가 발생했지만, 코드를 작성하는 것에 대해 확립된 표준은 없다. 모든 문제가 단순히 정보를 공개함으로써 적절하게 관리되는 것은 아니다. 때로는 긍정적인 행동이 필요하다. 이것은 표준과 모범 사례를 통해 스스로를 규제하는 업계의 형태를 취할 수 있지만, 이러한 점에서 산업은 초기 단계에 있다. 주시해야 할 개발 영역은 국제 표준화 기구가 ISO/TC 307 프로그램에서 개발하고 있는 표준이다. 블록체인 및 DLT와 관련된 9개의 새로운 프로젝트가 현재 제안 또는 준비 단계에 있다. 따라서 위의 구성 요소 중 일부를 해결하는 것은 효과적이고 세분화된 규제를 개발하기 위한 선행 조건이다. 솔루션은 규제 기대치에 대응하여 개발됨에 따라 기술 자체에서 나올 가능성이 높다. 이는 규제 기술의 개발을 촉진하는 데 도움이 될 수 있으며, 이는 기반 CCTech 코드 내에 암호화폐 생성 또는 교환, 암호화폐 서비스 구매자 및 규제 기관 간의 상호작용을 위한 길을 만들 수 있는 기회를 제공한다. ¶기술은 또한 종점에 있다. 규제 불확실성의 현재 상태는 산업 자체에 위험을 야기한다. 불확실한 법률 환경에서 자본을 조달하면 책임 위험이 증가하기 때문에 산업 개발 비용이 증가한다. 여기에 사기, 돈 세탁, 도난, 잘못된 노출, 기타 자산 조작, 내부 통제 실패, 오용 등 전통적인 자본 시장(보조 산업 비용 포함)에서 이미 관찰된 위험(참석 산업 비용 포함)이 나타날 수 있다. 규제 가 어떤 형태로 이루어 지든 CCTech의 본질은 거래를 중개하는 규제 금융 기관의 개입을 필요로하지 않는 인터넷 기반 네트워크에서 상거래를 수행하는 대안의 가능성과 결과 때문에 감독 통제에 근본적인 장애물이 된다는 것이다. CCTech에 의해 초래된 다루기 힘든 문제 중 하나는 특정 기술적 기능이 파괴되었다는 것을 감안할 때, 적절한 감시 메커니즘 내에서 암호화폐를 가져 오는 방법이다. 미국 재무부의 해외 자산 관리국 (OFAC)이 제안한 디지털 지갑 주소를 SDN 목록에 추가 할 수 있다는 제안은 바로 그 점에 대해서 많은 비판을 받았다. 이것은 규제가 성공적으로 개발되면 규제 당국이 완전히 파악하는 데 중요한 CCTech의 무정부적 잠재력을 반영한다. 규제 기관은 이전에 사용된 전략과 다른 전략을 사용하여 업계에 감독을 제공하는 방법을 찾아야 할 수도 있다. 규제를 원하는 업계의 행위자는 검증 및 합법성, 규제 감독, 산업 위험 감소 및 더 큰 자본 풀에 대한 접근을 통해 시장에 제공되는 일반적인 보증을 포함하여 여러 가지 상업적 이유로 그렇게 (규제가 원하는 방향으로) 하고 있습니다. 이러한 이유는 규제를 바람직한 옵션으로 만들기 위해 관여할 수 있다고 제안된다. 간단히 말해서, 규제를 확립하는 가장 좋은 방법은 그것을 매력적으로 만드는 것일 수도 있다. 그것은 규제 종점이 아니라 규제 당국이 업계와 더 잘 일하기 시작할 수 있는 지점일 수 있다. 그러한 역동성이 작용하기 위해서는, 감독 통제장치가 상업 활동에 참여하는 새로운 방법에 제공하는 기회를 훼손하지 않는 것이 필수적이다. 규정은 공정한 공개, 업계 표준 및 부정 행위에 대한 책임과 같은 특정 기술과 활동과 독립적인 결과에 기초해야 한다. 감독 통제장치가 반경쟁적 도구로서 작동하지 않도록 주의해야 한다. In short, the best way to establish regulation may be to make it attractive. That may not be a regulatory end-point but a point from which regulators can begin to better work with the industry. For that dynamic to work, it is essential that oversight controls do not undermine the opportunities that cryptos offer to new ways of engaging in commercial activity. Regulations must be based on outcomes that are independent of specific technologies and activities, such as fair disclosure, industry standards, and accountability for wrongdoing. Care must be taken that oversight controls do not to operate as anti-competitive tools. CCTech이 만들 수있는 관계의 범위와 일단 만들어지면, 시장에서 특정한 행동이 일단 만들어 질 것이고, 이는 즉 사람들간 상거래의 모습이 될 것이며 잠재적으로 발전 가능성도 존재 할 것이다. 현재 규제적 사고와 조치의 궤도가 위험과 산업 발전의 효율적인 배분을 지원하기 위해 노력하고 있는지 여부는 두고 봐야 한다. 자본에서 위험과 산업 발전의 효율적인 배분을 지원하고 있으며 경제적, 사회적 개선의 합리적인 전망을 가지고 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smartcontract","slug":"smartcontract","permalink":"https://www.yceffort.kr/tags/smartcontract/"}]},{"title":"Step by Step machine laerning - 01","slug":"step-by-step-machine-learnig-01","date":"2018-11-07T15:00:00.000Z","updated":"2018-11-08T10:44:01.000Z","comments":true,"path":"2018/11/08/step-by-step-machine-learnig-01/","link":"","permalink":"https://www.yceffort.kr/2018/11/08/step-by-step-machine-learnig-01/","excerpt":"California Housing 데이터를 바탕으로 scikt-learn을 활용한 머신러닝 예제. ¶1. 기본적인 데이터 로딩 프록시 환경이라, 프록시를 핸들러에 추가하였습니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import os import tarfile from six.moves import urllib import numpy as np import pandas as pd # 데이터 로딩 HOUSIN","text":"California Housing 데이터를 바탕으로 scikt-learn을 활용한 머신러닝 예제. ¶1. 기본적인 데이터 로딩 프록시 환경이라, 프록시를 핸들러에 추가하였습니다. 1234567891011121314151617181920212223242526272829303132import osimport tarfilefrom six.moves import urllibimport numpy as npimport pandas as pd# 데이터 로딩HOUSING_PATH = os.path.join(\"datasets\", \"housing\")HOUSING_URL = \"http://www.dcc.fc.up.pt/~ltorgo/Regression/cal_housing.tgz\"def fetching_housing_data(housing_url=HOUSING_URL, housing_path=HOUSING_PATH): if not os.path.isdir(housing_path): os.makedirs(housing_path) proxy = urllib.request.ProxyHandler(&#123;'http': 'http://proxy.url', 'https':'http://proxy.url'&#125;) opener = urllib.request.build_opener(proxy) urllib.request.install_opener(opener) tgz_path = os.path.join(housing_path, \"housing.tgz\") urllib.request.urlretrieve(housing_url, tgz_path) housing_tgz = tarfile.open(tgz_path) housing_tgz.extractall(path=housing_path) housing_tgz.close()fetching_housing_data()def load_housing_data(housing_path=HOUSING_PATH): csv_path = os.path.join(housing_path, \"housing.csv\") return pd.read_csv(csv_path)housing = load_housing_data()housing.head() longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value ocean_proximity 0 -122.23 37.88 41.0 880.0 129.0 322.0 126.0 8.3252 452600.0 NEAR BAY 1 -122.22 37.86 21.0 7099.0 1106.0 2401.0 1138.0 8.3014 358500.0 NEAR BAY 2 -122.24 37.85 52.0 1467.0 190.0 496.0 177.0 7.2574 352100.0 NEAR BAY 3 -122.25 37.85 52.0 1274.0 235.0 558.0 219.0 5.6431 341300.0 NEAR BAY 4 -122.25 37.85 52.0 1627.0 280.0 565.0 259.0 3.8462 342200.0 NEAR BAY 1housing.info() 123456789101112131415&lt;class &apos;pandas.core.frame.DataFrame&apos;&gt;RangeIndex: 20640 entries, 0 to 20639Data columns (total 10 columns):longitude 20640 non-null float64latitude 20640 non-null float64housing_median_age 20640 non-null float64total_rooms 20640 non-null float64total_bedrooms 20433 non-null float64population 20640 non-null float64households 20640 non-null float64median_income 20640 non-null float64median_house_value 20640 non-null float64ocean_proximity 20640 non-null objectdtypes: float64(9), object(1)memory usage: 1.6+ MB ocean_proximity는 텍스트로 정보가 들어가 있는 것 같다. 1housing['ocean_proximity'].value_counts() 123456&lt;1H OCEAN 9136INLAND 6551NEAR OCEAN 2658NEAR BAY 2290ISLAND 5Name: ocean_proximity, dtype: int64 1housing.describe() longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value count 20640.000000 20640.000000 20640.000000 20640.000000 20433.000000 20640.000000 20640.000000 20640.000000 20640.000000 mean -119.569704 35.631861 28.639486 2635.763081 537.870553 1425.476744 499.539680 3.870671 206855.816909 std 2.003532 2.135952 12.585558 2181.615252 421.385070 1132.462122 382.329753 1.899822 115395.615874 min -124.350000 32.540000 1.000000 2.000000 1.000000 3.000000 1.000000 0.499900 14999.000000 25% -121.800000 33.930000 18.000000 1447.750000 296.000000 787.000000 280.000000 2.563400 119600.000000 50% -118.490000 34.260000 29.000000 2127.000000 435.000000 1166.000000 409.000000 3.534800 179700.000000 75% -118.010000 37.710000 37.000000 3148.000000 647.000000 1725.000000 605.000000 4.743250 264725.000000 max -114.310000 41.950000 52.000000 39320.000000 6445.000000 35682.000000 6082.000000 15.000100 500001.000000 그래프로 보자 12345%matplotlib inlineimport matplotlib.pyplot as plt# bins는 막대의 두께, figsize는 그래프의 크기다.housing.hist(bins=100, figsize=(20, 15))plt.show() ¶2. 데이터 분석 이제 데이터를 test set과 train set으로 나눠 보자. test_size 는 말그대로 테스트의 크기이고, random_states는 random값 생성을 위한 seed 값이다. 12from sklearn.model_selection import train_test_splittrain_set, test_set = train_test_split(housing, test_size=0.2, random_state=42) 이렇게 랜덤하게 나누는 것은 데이터가 클때, 그리고 속성이 많을 때는 괜찮다. 그러나 그렇게 데이터가 많지 않으면, 샘플링을 하는 과정에서도 bias가 생길 수 있다. 만약 한국의 인구비가 6:4라면, 테스트 split을 할 때에도 6:4 로 성비가 뽑혀야 괜찮다고 할 수 있을 것이다. 이를 stratified sampling이라고 한다. 랜덤으로 뽑을 경우, 6:4를 보장할 수는 없을 것이다. 다시 예제로 돌아와서, 만약 median_income이 median_housing_prices를 예측하는데 큰 요소라고 가정을 해보자. 그러기 위해선, 위에서의 예제 처럼 다양한 median_income을 카테고리화 해서 테스트 셋을 만드는 것이 중요할 것이다. 위 그림에서 볼 수 있듯이, median_income은 값이 너무나도 다양하므로, stratum처리를 해주지 않으면 테스트 셋을 랜덤하게 뽑아 낼 때마다 값이 널뛰기를 할 것이다. 그래서, 1.5로 나눈다음 5보다 큰 값은 다 5로 replace 해버렸다. 123housing[\"income_cat\"] = np.ceil(housing[\"median_income\"] / 1.5)housing[\"income_cat\"].where(housing[\"income_cat\"] &lt; 5, 5.0, inplace=True)housing['income_cat'].hist(bins=10, figsize=(10, 5)) 이제 카테고리화 했으니, 카테고리에 다라서 균등하게 나눠보도록 합시다. 123456789# 불균형한 데이터에 대해서 고르게 test, train set을 나눠준다.from sklearn.model_selection import StratifiedShuffleSplitsplit = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)for train_index, test_index in split.split(housing, housing['income_cat']): strat_train_set = housing.loc[train_index] strat_test_set = housing.loc[test_index]strat_test_set[\"income_cat\"].value_counts() / len(strat_test_set) 1234563.0 0.3505332.0 0.3187984.0 0.1763575.0 0.1145831.0 0.039729Name: income_cat, dtype: float64 얼추 그래프의 분포와 비슷한 양상을 보이고 있다. 최초의 목적은 달성헀으니, 컬럼을 드랍하자. 12345for set_ in (strat_train_set, strat_test_set): set_.drop(\"income_cat\", axis=1, inplace=True)housing = strat_train_set.copy()housing.plot(kind=\"scatter\", x=\"longitude\", y=\"latitude\") 투명도를 넣어서 조금더 선명하게 보자. 1housing.plot(kind=\"scatter\", x=\"longitude\", y=\"latitude\", alpha=0.1) 조금더 이쁘장하게 만들어보자 123456789101112housing.plot(kind=\"scatter\", #산점도 x=\"longitude\", y=\"latitude\", alpha=0.4, #투명도 s=housing['population'] / 100, #나타낼 데이터 label=\"population\", #라벨 figsize=(10, 7), #그래프 크기 c=\"median_house_value\", #색 부여할 데이터 cmap=plt.get_cmap(\"jet\"), #색 colorbar = True)plt.legend() correlation 매트릭스를 그려보자 12corr_matrix = housing.corr()corr_matrix longitude latitude housing_median_age total_rooms total_bedrooms population households median_income median_house_value longitude 1.000000 -0.924478 -0.105848 0.048871 0.076598 0.108030 0.063070 -0.019583 -0.047432 latitude -0.924478 1.000000 0.005766 -0.039184 -0.072419 -0.115222 -0.077647 -0.075205 -0.142724 housing_median_age -0.105848 0.005766 1.000000 -0.364509 -0.325047 -0.298710 -0.306428 -0.111360 0.114110 total_rooms 0.048871 -0.039184 -0.364509 1.000000 0.929379 0.855109 0.918392 0.200087 0.135097 total_bedrooms 0.076598 -0.072419 -0.325047 0.929379 1.000000 0.876320 0.980170 -0.009740 0.047689 population 0.108030 -0.115222 -0.298710 0.855109 0.876320 1.000000 0.904637 0.002380 -0.026920 households 0.063070 -0.077647 -0.306428 0.918392 0.980170 0.904637 1.000000 0.010781 0.064506 median_income -0.019583 -0.075205 -0.111360 0.200087 -0.009740 0.002380 0.010781 1.000000 0.687160 median_house_value -0.047432 -0.142724 0.114110 0.135097 0.047689 -0.026920 0.064506 0.687160 1.000000 123# 1에 가까울 수록 긍정적으로 강한 관계가 있음.# -1에 가까울 수록 부정적으로 관계가 있음.corr_matrix[\"median_house_value\"].sort_values(ascending=False) 값은 ~1 부터 1 사이의 값을 가지며, 1에 가까울 수록 강한 positive 상관관계를, -1에 가까울 수록 강한 negative 상관관계를 갖는다. 12345678910median_house_value 1.000000median_income 0.687160total_rooms 0.135097housing_median_age 0.114110households 0.064506total_bedrooms 0.047689population -0.026920longitude -0.047432latitude -0.142724Name: median_house_value, dtype: float64 0에 가까울 수록 아무런 관계가 없다는 것이다. 상관관계가 있을 수록, plot이 우/좌상향 분포를 나타낸다. 과연 그런지 봅시다. 1234from pandas.plotting import scatter_matrixattributes = ['median_house_value', 'median_income', 'total_rooms', 'housing_median_age']scatter_matrix(housing[attributes], figsize=(12, 8)) 1housing.plot(kind=\"scatter\", x=\"median_income\", y=\"median_house_value\", alpha=0.1) median_income 과 median_house_value와 상관관계 확실히 우상향 하는 분포를 띄고 있다. $500,000에 가로 선이 확실하게 보이는데, 이는 $450,000 과 $350,000에서도 뚜렷하게 보이고 있다. 추가적으로, 몇가지 속성 값을 만들어보자. 123456housing[\"rooms_per_household\"] = housing[\"total_rooms\"] / housing[\"households\"]housing[\"bedrooms_per_room\"] = housing[\"total_bedrooms\"] / housing[\"total_rooms\"]housing[\"population_per_household\"] = housing[\"population\"] / housing[\"households\"]corr_matrix = housing.corr()corr_matrix['median_house_value'].sort_values(ascending=False) 1234567891011121314median_house_value 1.000000median_income 0.687160rooms_per_household 0.146285total_rooms 0.135097housing_median_age 0.114110households 0.064506total_bedrooms 0.047689population_per_household -0.021985population -0.026920longitude -0.047432latitude -0.142724bedrooms_per_room -0.259984Name: median_house_value, dtype: float64 ¶3. 머신러닝 알고리즘 활용을 위한 데이터 준비 ¶1) 데이터 클리닝 일단, total_bedrooms 컬럼에 빈값들이 있는 것을 확인했다. 이 컬럼을 드랍하던지, 아니면 빈값을 적절하게 채우는 방법 이 있다. 빈값을 적절히 채우기 위해서는, 중간값(median)을 활용하는 것이 좋겠다. 12from sklearn.preprocessing import Imputerimputer = Imputer(strategy=\"median\") median은 오로지 숫자 값만 처리할 수 있으므로, 숫자가 아닌 컬럼은 제거할 필요가 있다. 1housing_num = housing.drop(\"ocean_proximity\", axis=1) 그리고 imputer를 적용해보자. 12345imputer.fit(housing_num)# 밑에 두개는 같은 결과를 보여준다.imputer.statistics_housing_num.median().values 12array([-118.51 , 34.26 , 29. , 2119.5 , 433. , 1164. , 408. , 3.5409]) imputer한 값을 다시 dataframe으로 가져오자. 123X = imputer.transform(housing_num)housing_str = pd.DataFrame(x, columns=housing_num.columns)housing_str.head() longitude latitude housing_median_age total_rooms total_bedrooms population households median_income 0 -121.89 37.29 38.0 1568.0 351.0 710.0 339.0 2.7042 1 -121.93 37.05 14.0 679.0 108.0 306.0 113.0 6.4214 2 -117.20 32.77 31.0 1952.0 471.0 936.0 462.0 2.8621 3 -119.61 36.31 25.0 1847.0 371.0 1460.0 353.0 1.8839 4 -118.59 34.23 17.0 6592.0 1525.0 4459.0 1463.0 3.0347 ¶2) 텍스트와 카테고리 데이터 다루기 ocean_proximity는 우리가 문자여서 못썼다. 12housing_cat = housing['ocean_proximity']housing_cat.head(10) 123456789101117606 &lt;1H OCEAN18632 &lt;1H OCEAN14650 NEAR OCEAN3230 INLAND3555 &lt;1H OCEAN19480 INLAND8879 &lt;1H OCEAN13685 INLAND4937 &lt;1H OCEAN4861 &lt;1H OCEANName: ocean_proximity, dtype: object 이렇게 하면 카테고리로 만들어 버릴 수 있다. 123housing_cat_encoded, housing_categories = housing_cat.factorize()housing_cat_encoded[:10]housing_categories 12array([0, 0, 1, 2, 0, 2, 0, 2, 0, 0])Index([&apos;&lt;1H OCEAN&apos;, &apos;NEAR OCEAN&apos;, &apos;INLAND&apos;, &apos;NEAR BAY&apos;, &apos;ISLAND&apos;], dtype=&apos;object&apos;) 너의 text 적당한 number로 카테고리 되었다. Korean 불만있어요? 근데 이렇게 한다면, 0과 1을 비슷한 값으로, 0과 4를 안비슷한 값으로 판단해버릴 것이다. 사실 숫자에는 별의미가 없기 때문에 저런일이 발생해서는 안된다. 그래서 사용하는 것이 one-hot encoding이다. one hot endoing은 이런 카테고리 데이터를 벡터화 하는 것이다. 여기에 잘 정리 되어 있다. 12345678from sklearn.preprocessing import OneHotEncoderencoder = OneHotEncoder()# housing_cat_encoded는 횡방향으로 데이터를 길게 늘어뜨려 놓았다.# 데이터 프레임과 마찬가지 형식으로 종방향으로 데이터를 바꾸기 위해 reshape를 하였다.housing_cat_1hot = encoder.fit_transform(housing_cat_encoded.reshape(-1, 1))housing_cat_1hot.toarray() 1234567array([[1., 0., 0., 0., 0.], [1., 0., 0., 0., 0.], [0., 1., 0., 0., 0.], ..., [0., 0., 1., 0., 0.], [1., 0., 0., 0., 0.], [0., 0., 0., 1., 0.]]) ¶3) 커스텀 트랜스포머 만들기 이제 이 과정을 데이터가 들어올 때 마다 일일히 할 수 없는 노릇이므로, 이를 자동화하는 과정을 만들어 보려고 한다. scikit-learn에서는 이러한 데이터 클린업 과정을 자동화 할 수 있는 Class를 만들 수 있다. 이를 위한 클래스에서 필요한 것은 fit(), (무조건 return self), transform(), fit_transform()이 세가지 메소드를 구현해야 한다. 그리고 이를 위해서는 TransformerMixin클래스를 더해야 한다. 추가로 BaseEstimator를 더하면,get_params()와 set_params()메소드도 구현할 수 있는데, 이는 hyperparameter를 튜닝할 때 유용하게 사용할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from sklearn.base import BaseEstimator, TransformerMixinrooms_ix, bedrooms_ix, population_ix, household_ix = 3, 4, 5, 6# TransformerMixin Custom Cleanup Operation을 하기 위한 필수요소# 필수로 구현해야 하는 것# fit (return self)# transform () # fit_transform ()# BaseEstimator 는 (*args, **kargs)룰 피할 수 있으며# 두가지 method를 추가로 구현 가능, get_params(), set_params()# automatic hyperparameter tuning을 하는데 유용하다고함..# 아래예제에서는 add_bedrooms_per_room가 hyperparameter이며, 이 속성을 추가할지 여부를 결정할 수 있음.# 가변적으로 추가해야할 파라미터들이 있을 때 유용할 것으로 보임.class CombinedAttributesAdder(BaseEstimator, TransformerMixin): def __init__(self, add_bedrooms_per_room = True): # no *args or **kargs self.add_bedrooms_per_room = add_bedrooms_per_room def fit(self, X, y=None): return self # nothing else to do def transform(self, X, y=None): # 가정당 방의 갯수를 구한다. rooms_per_household = X[:, rooms_ix] / X[:, household_ix] # 가정당 인구 수를 구한다. population_per_household = X[:, population_ix] / X[:, household_ix] # add_bedroooms_per_room (이것이 hyperparameter다!!) 이 true면 if self.add_bedrooms_per_room: # 방당 침실 수도 구한다. bedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix] # 다 하나의 array로 합혀 준다. return np.c_[X, rooms_per_household, population_per_household, bedrooms_per_room] else: return np.c_[X, rooms_per_household, population_per_household]# 위에서 만든걸 선언한다.attr_adder = CombinedAttributesAdder(add_bedrooms_per_room=False)# 이를 바탕으로 housing의 값을 변경한다.housing_extra_attribs = attr_adder.transform(housing.values)# 새로 생긴 값을 추가해서 housing을 만든다.housing_extra_attribs = pd.DataFrame(housing_extra_attribs, columns=list(housing.columns)+[\"rooms_per_household\", \"population_per_household\"])housing_extra_attribs.head() longitude latitude housing_median_age total_rooms total_bedrooms population households median_income ocean_proximity rooms_per_household population_per_household 0 -121.89 37.29 38 1568 351 710 339 2.7042 &lt;1H OCEAN 4.62537 2.0944 1 -121.93 37.05 14 679 108 306 113 6.4214 &lt;1H OCEAN 6.00885 2.70796 2 -117.2 32.77 31 1952 471 936 462 2.8621 NEAR OCEAN 4.22511 2.02597 3 -119.61 36.31 25 1847 371 1460 353 1.8839 INLAND 5.23229 4.13598 4 -118.59 34.23 17 6592 1525 4459 1463 3.0347 &lt;1H OCEAN 4.50581 3.04785 ¶4. 모델 적용하기 머신러닝을 할 때 중요한 것은 데이터 보정이다. 이 데이터에서 방의 갯수는 최소 6개에서 최대 39,320개 까지 있고 (우리집 방 한개…ㅠㅠ) median_income은 손을 댄 관계로 1~15까지 밖에 없다. 이러한 숫자들을 조정하는 방법에는 크게 두가지가 있다. ¶(1) Min Max Scaling - Normalization (정규화) 정규화 = (값 - 최소값) / (최대값 - 최소값) 값을 다 0 ~ 1 사이로 바꿔 버리는 것이다. 여기에서는 MinMaxScaler()를 쓴다. ¶(2) Standardization (표준화) 표준화 = (값 - 평균) / 표준편차 정규화랑은 다르게, 정해진 값의 범위가 없다. 이는 outlier에게 덜 영향을 받는 다는 장점이 있다. 여기에서는 StandardScaler를 쓴다. 암튼 이런 transforamation 스텝을 순서에 맞게 거쳐서 이쁜 값을 만드는 것이 중요할 것이다. 이를 위해서 PipeLine 클래스를 사용할 것이다. Pipeline의 fit을 부르면, 안에 tuple로 있는 모든 메소드들의 fit_transform()을 순차저긍로 호출하게 된다. 마지막까지 다 하게 되면, 마지막에는 fit()을 호출하고 끝낸다. 123456789101112131415from sklearn.pipeline import Pipelinefrom sklearn.preprocessing import StandardScaler# Pipeline, 여러가지 transforamation을 엮는 데 효과적.# 이름 / estimator 로 구성되어 있음.# 마지막 estimator를 제외 하고 모두 transformers여야 함. (즉, fit_transform() 메소드가 필요함)# 순서대로 fit_transform()을 실행하다가, 마지막에는 fit()을 실행함.num_pipeline = Pipeline([ ('imputer', Imputer(strategy=\"median\")), # 빈 값을 중간 값으로 채워주고 ('attribs_adder', CombinedAttributesAdder()), # 위에서 만든 속성 추가 클래스를 활용하고 ('std_scaler', StandardScaler()), # 값을 모두 표준화 시킨다. ])num_pipeline.fit_transform(housing_num) 12345678910111213array([[-1.15604281, 0.77194962, 0.74333089, ..., -0.31205452, -0.08649871, 0.15531753], [-1.17602483, 0.6596948 , -1.1653172 , ..., 0.21768338, -0.03353391, -0.83628902], [ 1.18684903, -1.34218285, 0.18664186, ..., -0.46531516, -0.09240499, 0.4222004 ], ..., [ 1.58648943, -0.72478134, -1.56295222, ..., 0.3469342 , -0.03055414, -0.52177644], [ 0.78221312, -0.85106801, 0.18664186, ..., 0.02499488, 0.06150916, -0.30340741], [-1.43579109, 0.99645926, 1.85670895, ..., -0.22852947, -0.09586294, 0.10180567]]) 이제 숫자 컬럼만 뽑아는 class 도 만들어보자. 12345678# attributes로 주어진 컬럼만 dataframe으로 추출해서 만들어냄class DataFrameSelector(BaseEstimator, TransformerMixin): def __init__(self, attribute_names): self.attribute_names = attribute_names def fit(self, X, y=None): return self def transform(self, X): return X[self.attribute_names].values 123456789101112from sklearn.pipeline import Pipelinefrom sklearn.preprocessing import StandardScalernum_attribs = list(housing_num)cat_Attribs = [\"ocean_proximity\"]num_pipeline = Pipeline([ ('selector', DataFrameSelector(num_attribs)), # 숫자있는 컬럼만 추출 ('imputer', Imputer(strategy='median')), # 빈 값에 대해 중간값으로 채움 ('attribs_adder', CombinedAttributesAdder()), # 여러가지 속성을 더 추가 ('std_scaler', StandardScaler()) # 값들에 대해서 최종적으로 표준화]) 텍스트를 카테고리로 처리하기 위한 pipeline 123456from sklearn.preprocessing import OneHotEncodercat_pipeline = Pipeline([ ('selector', DataFrameSelector(cat_Attribs)), ('cat_pipeline', OneHotEncoder())]) 그리고 이것들을 다 합치자. 123from sklearn.pipeline import FeatureUnionfull_pipeline = FeatureUnion(transformer_list=[(\"num_pipeline\", num_pipeline), (\"cat_pipeline\", cat_pipeline)]) 적용 123housing_prepared = full_pipeline.fit_transform(housing)housing_prepared.shapehousing_prepared.data 123(16512, 16)array([-1.15604281, 0.77194962, 0.74333089, ..., -0.09586294, 0.10180567, 1. ]) ¶4. 모델 선택하고 훈련 시키기 1234from sklearn.linear_model import LinearRegressionlin_reg = LinearRegression()lin_reg.fit(housing_prepared, housing_labels) 일단 빠르게 비교하기 위해 일부 데이터만 가지고 해보자. 1234567# let's try the full pipeline on a few training instancessome_data = housing.iloc[:5]some_labels = housing_labels.iloc[:5]some_data_prepared = full_pipeline.transform(some_data)print(\"Predictions:\", lin_reg.predict(some_data_prepared))print(\"Labels:\", list(some_labels)) 123Predictions: [210644.6046718 317768.80715244 210956.43323562 59218.98852743 189747.55850878]Labels: [286600.0, 340600.0, 196900.0, 46300.0, 254500.0] Mean Squared Error (MSE)를 구해봅시다. 123456from sklearn.metrics import mean_squared_errorhousing_predictions = lin_reg.predict(housing_prepared)lin_mse = mean_squared_error(housing_labels, housing_predictions)lin_rmse = np.sqrt(lin_mse)lin_rmse 168628.19819848923 median_housing_values가 120,000~265,000 인걸 감안했을때, 68628은 너무나 큰 값이다. 굉장히 underfit한 상태임을 알 수 있다. 이번엔 DecsionTreeRegressor를 활용해보자. 이 모델은 linear하지 않은 데이터 들 사이에 상관관계를 찾을 때 유용하다. 여기 에서 자세하게 공부해 볼 수 있다. 12345678910# 디시전 트리를 사용해보자. from sklearn.tree import DecisionTreeRegressortree_reg = DecisionTreeRegressor()tree_reg.fit(housing_prepared, housing_labels)housing_predictions = tree_reg.predict(housing_prepared)tree_mse = mean_squared_error(housing_labels, housing_predictions)tree_rmse = np.sqrt(tree_mse)tree_rmse 10 에러가 전혀 없다고 나온다. 이건 좀 아니지 않나요? ¶5. Cross-Validation으로 evlautaion을 향상 시키기 training set을 training set과 validation set으로 일정비율로 나누어, 테스트해보자. 이방식 중 하나 가 K-fold cross-validation이라고 하는데, 일정한 비율로 랜덤하게 n회 누어서, 반복해서 테스트 하는 방법이다. 12345678# 트레이닝셋을 벨리데이션 셋으로 또 나눠서 10번 cross-validation을 해보자.# K-fold cross validation# 트레이닝셋을 10개로 나눠서, 디시젼 트리 모델을 각각 10번 테스트 해보는 것이다. from sklearn.model_selection import cross_val_scorescores = cross_val_score(tree_reg, housing_prepared, housing_labels, scoring=\"neg_mean_squared_error\", cv=10)tree_rmse_scores = np.sqrt(-scores)tree_rmse_scores 10번 돌린 결과가 나왔다. 123array([68226.82910941, 67439.68375039, 70350.36780248, 68827.53048332, 69029.59842291, 75828.55054539, 70465.73078927, 71469.01269653, 76190.79186194, 69329.49606677]) 123456def display_scores(scores): print(\"Scores:\", scores) print(\"Mean:\", scores.mean()) print(\"Standard derivation:\", scores.std())display_scores(tree_rmse_scores) 12345Scores: [68226.82910941 67439.68375039 70350.36780248 68827.53048332 69029.59842291 75828.55054539 70465.73078927 71469.01269653 76190.79186194 69329.49606677]Mean: 70715.75915284026Standard derivation: 2865.9683978538446 디시전 트리를 활용한결과, 그다지 좋아보이지 않는다. Linear Model보다 구려보이기까지 하다. Cross-Validation은 단순히 모델을 평가하는 것 뿐만 예측치가 얼마나 정확한지 제공 (정규분표) 한다. 1234lin_scores = cross_val_score(lin_reg, housing_prepared, housing_labels, scoring='neg_mean_squared_error', cv=10)lin_rmse_scores = np.sqrt(-lin_scores)display_scores(lin_rmse_scores) 12345Scores: [66782.73844323 66960.1179304 70347.95241464 74739.57053231 68031.13387784 71193.84183403 64969.63055912 68281.61137905 71552.91570804 67665.10081912]Mean: 69052.46134977776Standard derivation: 2731.6740174446295 Leaner Model이 조금더 나은 걸 확인할 수 있다. 이번에는 RandomForestRegressor를 활용해보려고 한다. 랜덤 포레스트라고 불리우는 이방식은, 일종의 앙상블 학습 방법으로, 훈련 과정에서 구성한 다수의 의사결정 트리로 부터 분류 또는 평균를 출력함으로서 작동한다. 정확성도 높고, 간편하고 빠르게 학습을 하는 등 다양한 장점이 있지만 너무 느리다 ㅠ.ㅠ 12345678910# 마지막으로 해볼 것은 RandomForestRegressor# 디시젼 트리를 랜덤하게 여러개 피처를 만들어서 테스트 하는 방식from sklearn.ensemble import RandomForestRegressorforest_reg = RandomForestRegressor()forest_reg.fit(housing_prepared, housing_labels)scores = cross_val_score(forest_reg, housing_prepared, housing_labels, scoring=\"neg_mean_squared_error\", cv=10)forest_rmse_scores = np.sqrt(-scores)display_scores(forest_rmse_scores) 12345Scores: [52997.4173118 50186.47321364 53029.31828865 54414.07187827 52394.46338811 56393.90724324 51383.83051346 50054.41972395 55828.51540902 51771.1262269 ]Mean: 52845.35431970437Standard derivation: 2058.1934731131732 표준 편차가 조금더 줄어들었지만, 아직도 만족스러운 결과라 할 수는 없다. ¶참고: 모델을 파일로 떨구는 방법 123from sklearn.externals import joblibjoblib.dump(forest_reg, \"forest_reg_model.pkl\")saved_model = joblib.load(\"forest_reg_model.pkl\") ¶6. 모델 튜닝하기 ¶Grid Search 좋은 결과를 만들어내는 하이퍼파리미터의 조합을 찾을 때 까지 찾는 것을 의미한다. 12345678910111213141516171819202122## 모델 튜닝하기# hyperparameter를 만져서 좋은 모델 만들어보기from sklearn.model_selection import GridSearchCV# 첫번째: n_estimator 3개 * max_features 4개 로 총 12가지 의 조합으로 하이퍼 파라미터로 평가함# 두번째: 2 *3 개 총 6가지 조합으로 테스트 해봄.# 총 18가지 조합으로 RandomForestRegressor를 실행. # 그리고 cv=5, 즉 Five-fold test를 하므로 총 90가지의 경우의 트레이닝을 고려하게됨.param_grid = [ &#123;'n_estimators': [3, 10, 30], 'max_features': [2, 4, 6, 8]&#125;, &#123;'bootstrap': [False], 'n_estimators': [3, 10], 'max_features': [2, 3, 4]&#125;]forest_reg = RandomForestRegressor()grid_search = GridSearchCV(forest_reg, param_grid, cv=5, scoring='neg_mean_squared_error')grid_search.fit(housing_prepared, housing_labels)grid_search.best_params_grid_search.best_estimator_ param_grid를 통해 Scikit-learn은 첫번째로 12가지 의 조합(3 * 4)을, 두번째에는 6가지의 조합(2*3)을 활용하여 총 18가지의 방법으로 Grid Search를 진행했다. 그리고 이 모델을 cv(Cross-validation)을 5번씩 해서 총 90번의 연산이 돌아가게 된다. 1234567&#123;&apos;max_features&apos;: 8, &apos;n_estimators&apos;: 30&#125;RandomForestRegressor(bootstrap=True, criterion=&apos;mse&apos;, max_depth=None, max_features=8, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=30, n_jobs=None, oob_score=False, random_state=None, verbose=0, warm_start=False) 123cvres = grid_search.cv_results_for mean_score, params in zip(cvres['mean_test_score'], cvres['params']): print(np.sqrt(-mean_score), params) 12345678910111213141516171863620.795837027006 &#123;&apos;max_features&apos;: 2, &apos;n_estimators&apos;: 3&#125;55548.92569283444 &#123;&apos;max_features&apos;: 2, &apos;n_estimators&apos;: 10&#125;53050.85861795343 &#123;&apos;max_features&apos;: 2, &apos;n_estimators&apos;: 30&#125;59815.23943111992 &#123;&apos;max_features&apos;: 4, &apos;n_estimators&apos;: 3&#125;52773.64511880433 &#123;&apos;max_features&apos;: 4, &apos;n_estimators&apos;: 10&#125;50671.92650291877 &#123;&apos;max_features&apos;: 4, &apos;n_estimators&apos;: 30&#125;59985.840862213074 &#123;&apos;max_features&apos;: 6, &apos;n_estimators&apos;: 3&#125;52228.35440259691 &#123;&apos;max_features&apos;: 6, &apos;n_estimators&apos;: 10&#125;50217.90441108211 &#123;&apos;max_features&apos;: 6, &apos;n_estimators&apos;: 30&#125;59089.278039491895 &#123;&apos;max_features&apos;: 8, &apos;n_estimators&apos;: 3&#125;51630.326121947954 &#123;&apos;max_features&apos;: 8, &apos;n_estimators&apos;: 10&#125;50199.124440913874 &#123;&apos;max_features&apos;: 8, &apos;n_estimators&apos;: 30&#125;62217.97955428267 &#123;&apos;bootstrap&apos;: False, &apos;max_features&apos;: 2, &apos;n_estimators&apos;: 3&#125;53866.30814960368 &#123;&apos;bootstrap&apos;: False, &apos;max_features&apos;: 2, &apos;n_estimators&apos;: 10&#125;60700.922958303796 &#123;&apos;bootstrap&apos;: False, &apos;max_features&apos;: 3, &apos;n_estimators&apos;: 3&#125;52858.54368577 &#123;&apos;bootstrap&apos;: False, &apos;max_features&apos;: 3, &apos;n_estimators&apos;: 10&#125;58618.59314938758 &#123;&apos;bootstrap&apos;: False, &apos;max_features&apos;: 4, &apos;n_estimators&apos;: 3&#125;51672.291663087286 &#123;&apos;bootstrap&apos;: False, &apos;max_features&apos;: 4, &apos;n_estimators&apos;: 10&#125; RMSE가 제일 작은 50199.124440913874 {‘max_features’: 8, ‘n_estimators’: 30} 가 최적의 모델인 것으로 나타났다. ¶Randomize Search 앞선 그리드 서치의 경우, 조합의 수가 적을 경우에는 유용한 방법이다. 하지만 조합이 너무 많아 지는 경우, 검색이 엄청나게 오래 걸리게 될 것이다. 이 경우에는 RandomizedSearchCV를 대신 활용한다. 이는 GirdSearchCV와 굉장히 유사한 방법이지만, 모든 조합을 다 때려 박아보는 대신 랜덤하게 하이퍼파라미터에 값을 설정하여 탐색하는 방법이다. 이 방법은 일단 컴퓨팅 자원을 상대적으로 아낄 수 있다는게 가장 큰 장점이다. 그리고 만약 1000회 시도 한다고 가정했을 때, 매 회차마다 1000개의 서로 다른 하이퍼 파라미터를 사용할 수 있다는 장점도 있다. (그리드 서치였다면, 단 몇개의 제한적인 값만 사용했을 것이다) ¶Esemble Method 다른 방법으로는 좋은 결과를 내고 있는 모델들을 짬뽕시키는 것이다. ¶7. 최적의 모델과 에러를 분석하기 12feature_importances = grid_search.best_estimator_.feature_importances_feature_importances 1234array([7.25174043e-02, 6.40038155e-02, 4.30423521e-02, 1.50651260e-02, 1.41694078e-02, 1.55005328e-02, 1.36335231e-02, 3.85814812e-01, 4.51628522e-02, 1.08855596e-01, 4.37230361e-02, 5.91899634e-03, 1.65641423e-01, 1.29954352e-04, 2.35727395e-03, 4.46389467e-03]) 각 속성별 중요도를 알아봅시다, 12345extra_attribs = ['rooms_per_hhold', 'pop_per_hhold', 'bedrooms_per_room']cat_encoder = cat_pipeline.named_steps['cat_pipeline']cat_hone_hot_attribs = list(cat_encoder.categories_[0])attributes = num_attribs + extra_attribs + cat_hone_hot_attribssorted(zip(feature_importances, attributes), reverse=True) 12345678910111213141516[(0.3858148117438145, &apos;median_income&apos;), (0.16564142348730257, &apos;INLAND&apos;), (0.10885559563684136, &apos;pop_per_hhold&apos;), (0.07251740425030011, &apos;longitude&apos;), (0.06400381547849927, &apos;latitude&apos;), (0.045162852166503266, &apos;rooms_per_hhold&apos;), (0.04372303606477461, &apos;bedrooms_per_room&apos;), (0.043042352127968635, &apos;housing_median_age&apos;), (0.015500532784205033, &apos;population&apos;), (0.015065126043213665, &apos;total_rooms&apos;), (0.014169407785424392, &apos;total_bedrooms&apos;), (0.01363352312072851, &apos;households&apos;), (0.005918996335933865, &apos;&lt;1H OCEAN&apos;), (0.004463894670505644, &apos;NEAR OCEAN&apos;), (0.0023572739519965376, &apos;NEAR BAY&apos;), (0.00012995435198802713, &apos;ISLAND&apos;)] 중요도를 나열해보고, 여기애서 별 영향이 없는 변수 (ocean_proximity에서는 INLAND가 아니면 다 별 의미가 없어보인다.) 를 제거하는 방법도 사용할 수 있겠다. ¶8. 최종적으로 예측하기 123456789101112final_model = grid_search.best_estimator_X_test = strat_test_set.drop(\"median_house_value\", axis=1)y_test = strat_test_set['median_house_value'].copy()X_test_prepared = full_pipeline.transform(X_test)final_prediction = final_model.predict(X_test_prepared)final_mse = mean_squared_error(y_test, final_prediction)final_rmse = np.sqrt(final_mse)final_rmse 168139.43891327262","categories":[],"tags":[{"name":"machine-learning","slug":"machine-learning","permalink":"https://www.yceffort.kr/tags/machine-learning/"},{"name":"scikit-learn","slug":"scikit-learn","permalink":"https://www.yceffort.kr/tags/scikit-learn/"}]},{"title":"왜 대부분의 스마트 컨트랙트 사례가 실현 불가능한가?","slug":"three-smart-contract-misconceptions","date":"2018-11-07T15:00:00.000Z","updated":"2018-11-08T10:44:01.000Z","comments":true,"path":"2018/11/08/three-smart-contract-misconceptions/","link":"","permalink":"https://www.yceffort.kr/2018/11/08/three-smart-contract-misconceptions/","excerpt":"인기 있는 블록체인 플랫폼을 개발하면서, 나는 때때로 Ethereum과 같은 스마트 컨트랙트가 MultiChain 로드맵에 있는지 질문을 받는다. 내가 항상 하는 대답은 항상 '아니오, 아니면 아직 아니다’이다. 그러나 과대 광고로 가득 찬 블록체인 세계에서는 스마트 컨트랙트가 대유행이다. 문제는, 현재 허가된 비트코인 스타일의 블록체인(증명서, 회사 기록 보관 및 경량의 금융)에 대한 세 가지 강력한 사용 사례를 알고 있지만, 이더리움의 스마트 컨트랙트에 상응하는 것을 아직 찾지 못했다는 것이다. 사람들이 스마트 컨트랙트가 무","text":"인기 있는 블록체인 플랫폼을 개발하면서, 나는 때때로 Ethereum과 같은 스마트 컨트랙트가 MultiChain 로드맵에 있는지 질문을 받는다. 내가 항상 하는 대답은 항상 '아니오, 아니면 아직 아니다’이다. 그러나 과대 광고로 가득 찬 블록체인 세계에서는 스마트 컨트랙트가 대유행이다. 문제는, 현재 허가된 비트코인 스타일의 블록체인(증명서, 회사 기록 보관 및 경량의 금융)에 대한 세 가지 강력한 사용 사례를 알고 있지만, 이더리움의 스마트 컨트랙트에 상응하는 것을 아직 찾지 못했다는 것이다. 사람들이 스마트 컨트랙트가 무엇을 하길 원하는지 이해하지 못하는 것은 아니다. 오히려, 이런 생각들 중 그렇게 많은 것들이 단순히 불가능하다는 것이 사실이다. 똑똑한 사람들이 &quot;스마트 컨트랙트&quot;라는 말을 들으면, 그들의 상상력은 폭발하는 경향이 있다. 그들은 자율적인 지능형 소프트웨어의 꿈을 만들어내고, 세계로 뻗어나가고, 데이터를 가고 나아가려한다. 불행히도, 스마트 컨트랙트의 현실은 더 평범하다. 스마트 컨트랙트는 블록체인에 저장된 코드로, 블록체인 트랜잭션에 의해 트리거되고 블록체인의 데이터베이스에서 데이터를 읽고 쓴다. 바로 그게 전부다. 스마트 컨트랙트는 블록체인에서 실행되고 그 블록체인 상태와 상호작용하는 코드의 멋진 이름일 뿐이다. 코드는 어떻게 구성되어 있는가? 파스칼, 파이썬, PHP 자바, 포트란, C++ 다. 만약 우리가 데이터베이스에 대해서 이야기 한다면, 그것은 단순히 SQL 확장으로 작성된 저장 프로시저다. 이 모든 언어는 근본적으로 동등하며, 같은 종류의 문제를 같은 방법으로 해결한다. 물론 각기 강점과 약점이 있다. C로 웹 사이트를 만들거나 루비에서 HD 비디오를 압축하는 것은 미친 짓이다. 하지만 원칙적으로는 원한다면 할 수 있다. 당신은 단지 편리함과 성과, 그리고 아마도 당신의 일자리에 대해 큰 대가를 치르게 될 것이다. 스마트한 컨트랙트와 관련된 문제는 사람들의 기대가 부풀려진 것뿐만이 아니라, 많은 사람들이 실행 불가능한 아이디어에 시간과 돈을 쓰도록 유도하고 있다는 것이다. 대기업은 고위 경영진이 새로운 기술을 접하는 순간부터 기술의 장점과 한계가 진정으로 이해되는 시점까지 오랜 경로를 여행할 수 있는 충분한 자원을 보유하고 있는 것으로 보인다. 어쩌면 우리 자신의 경험이 이번에는 단축하는 데 도움이 될지도 모른다. 지난 9개월 동안 우리는 많은 스마트 컨트랙트 활용 사례를 제시받았고, 이러한 사례들이 간단하게 이루어질 수 없다는 것에 대해 몇번이고 반응을 해줬다. 결과적으로, 우리는 가장 일반적으로 행해지는 세 가지 스마트 컨트랙트의 오해들을 확인했다. 기술이 미숙하거나 도구를 아직 사용할 수 없기 때문에 이러한 생각은 틀리지 않다. 오히려, 그들은 데이터베이스에 존재하는 분산되어 있는 코드의 근본적인 특성을 오해한다. ¶1. 외부 서비스와 결합되는 스마트 컨트랙트 종종 제안된 첫 번째 사용 사례는 일부 외부 이벤트에 대한 응답으로 동작을 변경하는 스마트 컨트랙트다. 예를 들어, 주어진 달의 강우량에 따라 조건부로 지불하는 농업 보험 정책같은 것을 예로 들 수 있다. 상상 속의 과정은 이렇다: 스마트 컨트랙트는 미리 정해진 시간까지 기다리고, 외부 서비스에서 기상 보고서를 검색하며, 수신된 데이터에 따라 적절하게 행동한다. 이 모든 것이 충분히 간단해 보이지만, 또한 불가능하다. 왜일까? 블록체인은 합의 기반 시스템이기 때문에 모든 거래와 블록을 처리한 후 모든 노드가 동일한 상태에 도달할 경우에만 작동한다. 블록체인에서 일어나는 모든 일은 완전히 결정론적이어야 하며, 차이가 생겨날 수 있는 방법은 없다. 두 개의 정직한 노드가 체인의 상태에 대해 동의하지 않는 순간, 전체 시스템은 쓸모 없게 된다. 이제 스마트 컨트랙트가 체인의 모든 노드에 의해 독립적으로 실행된다는 점을 기억하라. 따라서 스마트 계약이 외부 소스에서 일부 정보를 검색할 경우 이 검색은 각 노드에 의해 반복적으로 별도로 수행된다. 그러나 이 소스는 블록체인 외부에 있기 때문에 모든 노드가 동일한 답변을 받을 것이라는 보장은 없다. 소스가 다른 노드의 요청 사이에 응답을 변경하거나 일시적으로 사용할 수 없게 될 수 있다. 어느 쪽이든, 합의는 깨지고 전체 블록체인 전체가 죽어 버린다. 그렇다면 해결 방법이 무엇일까? 사실, 이는 간단하다. 외부 데이터의 검색을 실행하는 스마트 컨트랙트 대신, 하나 이상의 신뢰할 수 있는 당사자(“요약”)가 해당 데이터를 체인에 내장하는 트랜잭션을 생성한다. 모든 노드에는 동일한 데이터 복사본이 있으므로 스마트 컨트랙트 계산에 안전하게 사용할 수 있다. 다시 말해, 신탁은 데이터를 끌어오기 보다는 블록체인에 데이터를 밀어넣는 것이다. In other words, an oracle pushes the data onto the blockchain rather than a smart contract pulling it in. 외부 세계에서 사건을 일으키는 스마트 컨트랙트에서도 비슷한 문제가 나타난다. 예를 들어, 많은 사람들은 돈을 이체하기 위해 은행의 API를 호출하는 스마트 컨트랙트 아이디어를 좋아한다. 하지만 모든 노드가 체인에서 코드를 독립적으로 실행하고 있다면, 이 API를 호출하는 책임은 누구에게 있는가? 정답이 하나의 노드일 경우, 의도적으로 오작동을 일으키거나 그렇지 않을 경우 어떻게 되는건가? 모든 노드가 정답이라면 해당 API의 암호를 사용하여 모든 노드를 신뢰할 수 있는가? 그리고 우리는 정말로 수백번이나 API를 호출하기를 원하는가? 더욱이, 스마트 컨트랙트에서 API 호출의 성공 여부를 알아야 한다면, 우리는 바로 외부 데이터에 의존하는 문제로 되돌아가게 된다. 이전과 마찬가지로 간단한 해결 방법이 있다. 외부 API를 호출하는 스마트 컨트랙트 대신 블록체인의 상태를 모니터링하고 특정 작업을 수행하는 신뢰할 수 있는 서비스를 사용한다. 예를 들어, 은행은 미리 블록체인을 감시하고 온체인 거래를 반영하는 자금 이전을 수행할 수 있다. 이것은 이 체인이 완전히 소극적인 역할을 하기 때문에 블록체인의 합의에 위험을 주지 않는다. 이 두 가지 해결 방법을 보면 우리는 몇 가지 관찰을 할 수 있다. 첫째, 둘 다 블록체인과 외부 세계 사이의 상호작용을 관리하기 위해 신뢰할 수 있는 실체가 필요하다. 이것은 기술적으로 가능하지만 분산형 시스템의 목표를 약화시킨다. 둘째, 이러한 해결 방안에 사용되는 메커니즘은 데이터베이스를 읽고 쓰는 간단한 예다. 외부 정보를 제공하는 신탁은 단순히 그 정보를 체인에 쓰는 것이다. 그리고 실제 세계의 블록체인 상태를 반영하는 서비스는 그 사슬에서 읽는 것 이외에는 아무것도 하지 않는다. 즉, 블록체인과 외부 세계 간의 상호 작용은 정기적인 데이터베이스 작업으로 제한된다. ¶2. 온체인 지불 실행 우리가 자주 듣는 또 다른 제안서는 다음과 같다. 스마트 컨트랙트를 통해 이른바 &quot;스마트 채권(Smart bond)&quot;에 대한 쿠폰 지급을 자동화하는 것다. 이 아이디어는 스마트 컨트랙트 코드가 수동 프로세스를 피하고 발행자가 채무불이행을 할 수 없다는 것을 보장하면서 적절한 시기에 지급을 자동으로 개시하는 것이다. 물론, 이것이 효과를 거두기 위해서는 지급에 사용되는 자금 또한 블록체인 내에 있어야 한다. 그렇지 않으면 스마트 컨트랙트가 지급을 보장할 수 없다. 블록체인은 단지 데이터베이스일 뿐이며, 이 경우에는 발행된 채권과 현금이 들어있는 재무원장일 뿐이다. 그래서 우리가 쿠폰 지급에 대해 이야기할 때, 우리가 말하고자 하는 것은 합의된 시간에 자동으로 일어나는 데이터베이스 운영이다. 이 자동화는 기술적으로 실현 가능하지만 재정적 어려움으로 고통 받고 있다. 쿠폰 지불에 사용된 자금이 채권의 스마트 계약에 의해 통제된다면, 그 지불금은 실제로 보장 될 수 있다. 그러나 이는 또한 채권 발행자가 다른 어떤 것에도 사용할 수 없다는 것을 의미한다. 그리고 만약 그 자금들이 스마트 컨트랙트의 통제하에 있지 않다면, 지불을 보장할 방법이 없다. 다시 말하면, 스마트 채권은 발행자나 투자자에게 의미가 없다. 그리고 생각해보면, 이것은 완전히 명백한 결과다. 투자자의 관점에서 채권의 전체 포인트는 채무불이행 위험의 비용으로 매력적인 수익률이다. 그리고 발행자의 경우, 채권의 목적은 새로운 공장 건설과 같은 다소 불확실한 활동을 위한 자금을 조달하는 것이다. 채권 발행자가 조성된 자금을 활용하는 동시에 투자자가 상환될 것임을 보장할 방법은 없다. 위험과 수익 사이의 연관성이 블록체인이 해결할 수 있는 문제가 아니라는 것은 놀라운 일이 아니다. ¶3. 민감한 정보 숨기기 앞서 말씀드린 바와 같이, 블록체인 구축의 가장 큰 도전은 그들이 제공하는 근본적인 투명성이다. 예를 들어, 만약 10개의 은행이 함께 블록체인을 설정하고, 두 개의 은행이 쌍방 거래를 한다면, 이것은 다른 8개의 은행이 즉시 볼 수 있을 것이다. 이 문제를 완화하기 위한 다양한 전략은 있지만, 신뢰할 수 있는 관리자가 누가 무엇을 볼 수 있는지를 완벽하게 제어할 수 있는 중앙 집중식 데이터베이스의 단순성과 효율성을 능가하는 것은 없다. 어떤 사람들은 스마트 컨트랙트가 이 문제를 해결할 수 있다고 생각한다. 그들은 각각의 스마트 컨트랙트들이 완전한 통제력을 가지고 있는 자체적인 미니어처 데이터베이스를 포함하고 있다는 사실에서 출발한다. 이 데이터베이스에 대한 모든 읽기 및 쓰기 작업은 컨트랙트 코드에 의해 조정되므로 한 계약에서 다른 사람의 데이터를 직접 읽을 수 없다. (데이터와 코드 간의 이러한 긴밀한 결합을 캡슐화라고 하며, 널리 사용되는 객체 지향 프로그래밍 패러다임의 기반이다) 그렇다면, 한 스마트 컨트랙트가 다른 사람의 데이터에 액세스할 수 없다면, 블록체인 기밀성의 문제를 해결했을까요? 스마트한 컨트랙트에서 정보를 숨기는 것에 대해 말하는 것이 이치에 맞는가? 불행히도 대답은 '아니오’이다. 왜냐하면 한 스마트 컨트랙트에서 다른 사람의 데이터를 읽을 수 없더라도 해당 데이터는 체인의 모든 노드에 저장되어 있기 때문이다. 각 블록체인 참가자의 경우, 참가자가 완전히 제어하는 시스템의 메모리 또는 디스크에 있다. 그리고 만약 그들이 그렇게 하기를 선택한다면, 만약 그들이 그들의 시스템에서 정보를 읽는 것을 막을 수 있는 것은 아무것도 없다. 스마트 컨트랙트에서 데이터를 숨기는 것은 웹 페이지의 HTML 코드에서 데이터를 숨기는 것만 안전하다. 물론, 일반적인 웹 사용자들은 브라우저 창에 표시되지 않기 때문에 이 정보를 볼 수 없다. 그러나 웹 브라우저가 ‘소스 보기’ 기능(모두가 가지고 있는 것처럼)을 추가하면 정보가 보편적으로 표시되게 된다. 마찬가지로 스마트 계약에 숨겨진 데이터의 경우 누군가가 블록 체인 소프트웨어를 수정하여 계약의 전체 상태를 표시하는 것이 필요하며 모든 비밀 유지가 손실된다. ¶스마트 컨트랙트는 무엇을 위한 것인가? 스마트 컨트랙트 자체만으로는 할 수 없는 것들이 너무 많기 때문에, 사람들은 그들이 실제로 무엇을 위한 것인지 물어볼 수도 있다. 하지만 이 질문에 답하기 위해서는, 블록체인 자체의 기본 원칙으로 돌아가야 한다. 블록체인을 통해서 중앙 관리자 없이도 서로 신뢰하지 않는 엔티티가 데이터베이스를 직접 안전하게 공유할 수 있다. 블록체인은 데이터 분리를 가능하게 하며, 이로 인해 복잡성과 비용이 크게 절감될 수 있다. 모든 데이터베이스는 '트랜잭션’을 통해 수정된다. 이 트랜잭션에는 전체 데이터베이스의 성공 또는 실패가 필요한 데이터베이스에 대한 일련의 변경 사항이 포함되어 있다. 예를 들어, 재무 책임자의 경우, 앨리스에서 밥으로의 지급은 (a) 앨리스가 충분한 자금을 가지고 있는지 확인하고, (b) 앨리스의 계좌에서 수량을 차감하고, 밥의 수량을 동일한 수량을 더하는 거래로 나타난다. 일반 중앙 관리 데이터베이스에서 이러한 트랜잭션은 신뢰할 수 있는 단일 권한에 의해 생성된다. 반대로 블록체인 기반 공유 데이터베이스에서 블록체인의 사용자가 트랜잭션을 생성할 수 있다. 그리고 이러한 사용자들은 서로를 완전히 신뢰하지 않기 때문에, 데이터베이스는 수행되는 트랜잭션을 제한하는 규칙을 포함해야 한다. 예를 들어, P2P(Peer-to-Peer) 재무 책임자의 경우, 각 거래는 총 자금의 양을 보존해야 하며, 그렇지 않으면 참여자들은 원하는 만큼 자유롭게 자신에게 돈을 줄 수 있게 되어 버린다. 사람들은 이러한 규칙들을 표현하는 다양한 방법을 상상할 수 있지만, 현재는 각각 비트코인과 이더리움에 의해 영감을 받은 두 개의 지배적인 패러다임이 있다. &quot;트랜잭션 제약조건&quot;이라고 부를 수 있는 비트코인 방식은 (a) 해당 거래에서 삭제된 데이터베이스 항목과 (b) 생성된 항목의 측면에서 각 거래를 평가한다. 금융 원장의 경우, 삭제된 항목의 총 기금 양이 생성된 총 기금 수와 일치해야 한다고 명시한다. (기존 항목의 수정은 해당 항목을 삭제하고 해당 항목에 새 항목을 생성하는 것과 같다고 생각한다) 두 번째 패러다임은 스마트 컨트랙트다. 이것은 계약 데이터에 대한 모든 수정은 계약 규정에 의해 수행되어야 한다고 명시한다. (기존 데이터베이스의 경우, 이를 강제 저장 절차라고 생각할 수 있다.) 계약 데이터를 수정하기 위해 블록체인 사용자는 해당 요청의 이행 여부 및 방법을 결정하는 코드로 요청을 보내게 된다. 이 예와 같이, 금융 책임자의 스마트 컨트랙트는 중앙집중형 데이터베이스의 관리자와 동일한 세 가지 작업을 수행한다. 즉, 충분한 자금 확인, 한 계정에서 차감, 다른 계정에 추가. 이 두 패러다임 모두 효과적이며 각각 장단점이 있다. 요약하자면, 비트코인 방식의 거래 제약조건은 우수한 동시성과 성능을 제공하는 반면, Ethereum 스타일의 스마트 계약은 더 큰 유연성을 제공한다. 다시 스마트 컨트랙트가 무엇에 대한 것인지 질문으로 돌아가 보자. 스마트 컨트랙트는 트랜잭션 제약으로 구현할 수 없는 블록체인 사용 사례를 위한 것이다. what smart contracts are for: Smart contracts are for blockchain use cases which can’t be implemented with transaction constraints. 스마트 컨트랙트 사용에 대한 이 기준을 고려할 때, 나는 아직 자격이 되는 허가된 블록체인에 대한 강력한 사용 사례를 볼 수 없다. 내가 알고 있는 모든 강력한 블록체인 애플리케이션은 자산 생성, 전송, 에스크로, 교환 및 파괴뿐만 아니라 허가 및 일반 데이터 스토리지를 처리할 수 있는 비트코인형 트랜잭션으로 구현될 수 있다. 그럼에도 불구하고 새로운 사용 사례는 여전히 나타나고 있으며, 스마트 컨트랙트의 힘을 필요로 하는 사례가 있다고 해도 놀라지 않을 것입니다. 최소한 비트코인 패러다임의 확장도 있다. 답이 무엇이든 간에 기억해야 할 핵심은 스마트 컨트랙트는 단지 데이터베이스에서 수행되는 트랜잭션을 제한하는 한 가지 방법이라는 것입니다. Whatever the answer turns out to be, the key to remember is that smart contracts are simply one method for restricting the transactions performed in a database. 이는 분명 유용한 것이며 데이터베이스를 공유하기 위해 안전하게 만드는 데 필수적이다 그러나 스마트 컨트랙트에서는 다른 작업을 수행할 수 없으며, 해당 컨트랙트에서 상주하는 데이터베이스의 경계를 벗어날 수는 없다. Why Many Smart Contract Use Cases Are Simply Impossible 원문","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smartcontract","slug":"smartcontract","permalink":"https://www.yceffort.kr/tags/smartcontract/"}]},{"title":"비트코인과 다른 암호화폐는 쓸모가 없다.","slug":"bitcoin-and-other-cryptocurrencies-are-useless","date":"2018-11-06T15:00:00.000Z","updated":"2018-11-07T10:44:01.000Z","comments":true,"path":"2018/11/07/bitcoin-and-other-cryptocurrencies-are-useless/","link":"","permalink":"https://www.yceffort.kr/2018/11/07/bitcoin-and-other-cryptocurrencies-are-useless/","excerpt":"Bitcoin and other cryptocurrencies are useless 원문 옛말에 시장이 탐욕이나 두려움에 의해 지배된다고 이야기 한바 있었다. 한때는 욕망이 암호화폐를 지배한적잉 있었다. 가장 잘 알려진 비트코인의 가격은 2016년 12월 약 900달러에서 1년 후 1만9천달러로 올랐다. 최근 공포가 그 원인이 되었다. 비트코인의 가격은 약 7,000 달러로 다시 떨어졌다. 그것을 따라 올라간 다른 암호 화폐의 가격들 또한 붕괴되었습니다. 암호화폐의 가격이 어디로 갈 지 아무도 모른다. 소위 말하는 암호화폐 팬들","text":"Bitcoin and other cryptocurrencies are useless 원문 옛말에 시장이 탐욕이나 두려움에 의해 지배된다고 이야기 한바 있었다. 한때는 욕망이 암호화폐를 지배한적잉 있었다. 가장 잘 알려진 비트코인의 가격은 2016년 12월 약 900달러에서 1년 후 1만9천달러로 올랐다. 최근 공포가 그 원인이 되었다. 비트코인의 가격은 약 7,000 달러로 다시 떨어졌다. 그것을 따라 올라간 다른 암호 화폐의 가격들 또한 붕괴되었습니다. 암호화폐의 가격이 어디로 갈 지 아무도 모른다. 소위 말하는 암호화폐 팬들이 현재가 바닥을 부르는 것은 지금이 최고가라고 하는 것만큼 어리석다. Technology Quarterly가 지적했듯이 특정 평가에 도달할 수 있는 합리적인 방법이 없기 때문에 암호 화폐의 적정가격을 알아내는 것은 특히 어렵다. 이런 식으로는 안 되는 일이었다. 가장 인기 있는 암호화폐인 비트코인은 악의적인 정부나 은행의 간섭 없이도 사람들이 거래할 수 있는, 온라인 버전의 현금을 만들기 위한 기술적 무정부주의 프로젝트로 시작했다. 10 년이 지난 지금, 그것은 의도 된 목적으로 거의 사용되지 않는다. 사용자는 복잡한 소프트웨어와 씨름하고, 시장에서 익숙한 모든 소비자 보호를 포기해야 한다. 시장에서 (비트코인을) 거의 받아들이지 않는다. 보안은 좋지 않다. 다른 암호 통화는 비트코인 보다 더 적게 사용된다. 그들의 가치를 확고히 하기 위한 용도가 거의 없고, 규제도 거의 없는 가운데, 암호 화폐는 대신 투기의 대상이 되었다. 암호화폐가 급등하고 하락하면서 일부 사람들은 큰 돈을 벌었다. 다른 사람들은 돈을 잃었다. 최근의 호황 주기가 마지막이 될 것 같지 않다. 경제학자들은 통화를 하나의 교환 수단, 가치의 저장 그리고 계좌의 단위로 정의할 수 있는 것으로 정의한다. 채택의 부족과 변동성의 부하는 암호화폐가 그러한 기준을 충족하지 않음을 의미한다. 그러나 이러한 사실이 암호화폐가 사라질 것이라는 것을 의미하지는 않는다. 그러나 현재 상황으로는 암호화폐가 지나치게 복잡하며 신뢰할 수 없는, 카지노 이상일 것이라고 생각할 이유가 거의 없다. 암호화폐에 도움이 되는 기반 기술인 블록체인이 더 효과적일 수 있을까? 이러한 데이터는 중앙 기관이 유지관리하지 않고 모든 시스템 사용자 간에 레코드를 복사하고 한 번 기록하면 항목을 변경할 수 없는 특이한 형태의 데이터베이스다. 지지자들은 이러한 특징들이 은행 지불의 합리화, 약의 입증 보증에서부터 재산권 확보와 난민들에게 신원확인 서류를 제공하는 것까지 모든 종류의 문제를 해결하는 데 도움이 될 수 있다고 믿는다. ¶블록체인 말곤 잃을게 없어 많은 사람들이 불러 일으키는 블록체인 주변의 열광은, 그들의 관련 암호 화폐 보유의 가치를 증대시키기를 바라는 암호 화폐 투기꾼들에 의해 만들어진다. 그러나 블록체인을 배치하는 회사들은 종종 자신들을 독특하게 만드는 많은 특징들을 버리게 된다. 또한 사용자 간에 데이터를 지속적으로 차단하면 기존 데이터베이스보다 속도가 느려지게 된다. 이러한 한계들이 더욱 널리 알려지면서, 그 과장된 열기는 식기 시작하고 있다. 은행결제 네트워크인 SWIFT와 온라인 결제 회사인 Stripe와 같은 몇몇 조직은 블록체인 프로젝트를 포기하고 비용이 이익을 능가한다고 결론지었다. 대부분의 다른 프로젝트들은 여전히 실험적인데, 그렇다고 해서 터무니 없는 주장이 나오는 것은 아니다. 예를 들어 시에라리온은 올해 초 “블록체인” 선거를 실시했다고 널리 알려졌다. 하지만 그렇지 않았다. 단지 블록체인이 과대평가 되었다는 것이 그것들이 쓸모없다는 것을 의미하지는 않는다. 사용자들을 합의된 업무 방식에 묶는 그들의 능력은 국제 무역과 같은 중앙 권위가 없는 지역에서 도움이 될 수 있다. 그러나 그것들은 큰 기술 프로젝트의 일반적인 위험성에 대한 만병통치약은 아니다: 비용, 복잡성, 그리고 지나친 기대. 기록보존방법은 그들의 야심찬 목표에 훨씬 못 미친다. 블록체인 옹호자들은 아직 기초 기술이 그것을 위한 엄청난 주장에 부응할 수 있다는 것을 증명하지 못했다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"'블록체인' 이라는 단어는 아직 의미가 없다.","slug":"blockchain-is-meaningless","date":"2018-11-05T15:00:00.000Z","updated":"2018-11-06T10:44:01.000Z","comments":true,"path":"2018/11/06/blockchain-is-meaningless/","link":"","permalink":"https://www.yceffort.kr/2018/11/06/blockchain-is-meaningless/","excerpt":"‘BLOCKCHAIN’ IS MEANINGLESS 원문 비트코인, 이더리움 등 많은 암호화폐가 주류에 들어서기 시작되고 널리 유포되고 있지만, 이들은 널리 사용되고 있지만 제대로 이해되고 있지 않는 개념, 즉 \"블록체인\"과 결합되어 있다. 비트코인 및 대부분의 암호 화폐를 뒷받침 하는, 암호화적으로 향상된 디지털 원장인 블록체인의 아이디어는, 이제 은행간 거래 시스템에서 부터 월마트의 새로운 공급망 데이터베이스에 이르기 까지 모든 것을 설명한는데 사용하고 있다. 이 용어는 너무나 빠르게 퍼져나가서 빠르게 그 의미를 잃어 가고 있","text":"‘BLOCKCHAIN’ IS MEANINGLESS 원문 비트코인, 이더리움 등 많은 암호화폐가 주류에 들어서기 시작되고 널리 유포되고 있지만, 이들은 널리 사용되고 있지만 제대로 이해되고 있지 않는 개념, 즉 &quot;블록체인&quot;과 결합되어 있다. 비트코인 및 대부분의 암호 화폐를 뒷받침 하는, 암호화적으로 향상된 디지털 원장인 블록체인의 아이디어는, 이제 은행간 거래 시스템에서 부터 월마트의 새로운 공급망 데이터베이스에 이르기 까지 모든 것을 설명한는데 사용하고 있다. 이 용어는 너무나 빠르게 퍼져나가서 빠르게 그 의미를 잃어 가고 있다. &quot;‘블록체인 이란 무엇인가?’ 이 단어는 점점더 명확하지 않은 유행어가 되어가고 있다’ 라고 Attack of the 50 Foot Blockchain: Bitcoin, Blockchain, Ethereum &amp; Smart Contracts의 저자는 이야기 했다. 웹에는 블록체인을 설명하는 수많은 텍스트, 오디오, 비디오 등이 있다. 이들 거의 모든 것들이 틀린 이유는 그들이 잘못된 전제에서 시작되었기 때문이다. 블록체인에 대한 보편적인 정의는 없으며, 블록체인이라고 부르기 위해 어떤 특성이 필수적인지에 대한 의견차이가 존재한다. 비트코인 시스템은 첫 번째 블록체인으로 구현된 시스템으로 간주된다. 블록체인 산업을 시작한 셈인데, 지지자들은 돈과 정부, 그리고 그 너머에 혁명을 일으킬 것이라고 말한다. 비트코인은 공개적으로 설계되어 누구든 가입할 수 있도록 설계되었으며, 블록체인은 중앙 감시가 없는 상황에서 정직하게 사람들을 유지해야 할 필요성에서 탄생했다. 이 설계는 도난에 대한 비용을 지불하지 않도록 효율성을 희생시켰다. 왜냐하면 원장을 다시 작성하는 데는 계산력이 너무 많이 필요하기 때문에 잠재적인 거꾸로 거래를 작성하는 비용이 많이 들기 때문이다. 이 효과를 얻기 위해 비트코인 블록 체인은 모든 트랜잭션을 처음부터 현재까지 기록하는 디지털 원장으로 구성한다. 원장의 복사본은 중앙에 저장되지 않고 대신 ‘노드’라고 불리는 슈퍼유저에 의해 보관된다. 이 노드들 중 일부는 ‘마이너’라고 불리우며 일괄 처리를 하고, 각 블록을 이전 블록과 암호화적으로 연결하는 ‘블록’의 원장에 추가한다. 놀랍게도, 이 시스템은 핵심 비트코인 개발팀의 관리 책임과 결합되어 거의 10년 동안 기능해왔다. 2009년 야생에서 데뷔한 비트코인은 “블록체인 기술의 첫번째 구현”이라고 IBM은 말했다. 하지만 오늘날 ‘블록체인’이라는 라벨이 붙은 기술 디자인은 비트코인의 블록체인과 거의 유사하지 않다. ¶서로 다른 정의 구글의 &quot;블록체인&quot;에 대한 정의는 &quot;비트코인이나 다른 암호통화로 이루어진 거래를 연대순으로 그리고 공개적으로 기록하는 디지털 원장&quot;이다. 대부분의 사람들은 블록체인이 디지털 원장이라는 것에 동의하지만, 많은 블록체인들은 관련 암호통화를 가지고 있지 않고 공개적으로 기록되지 않는다. 어떤 사람들은 블록체인이 디지털일 필요는 없다고 주장하기도 한다. Investopedia는 “블록체인은 디지털화 되고, 분산화되어 있으며, 모든 암호 화폐 거래의 공개 원장” 이라고 정의하지만, 다시, 많은 블록체인들은 퍼블릭이지 않고, 다른 많은 것들은 심지어 분산되어 있지도 않다. IBM의 정의에 따르면, “블록체인 기술은 모든 당사자가 특정 거래에 참여하는 P2P 네트워크에서 사용된다” 라고 되어 있다. 하지만 세계식량계획이 구축한 블록체인에는 참여 당사자가 한명 뿐이다. IBM은 계속해서 이렇게 설명한다. “원장이 배포되기 때문에 모든 참여자들은 언제든지 전체적인 상태를 볼 수 있으며, 거래 진행 상태를 모니터링 할 수 있다.” 라고 하지만, 마스터카드의 블록체인은 누구에게도 공개되어 있지 않다. 에스토니아에서 고도로 기울이고 있는 마케팅적 노력은 블록체인이라는 용어가 어떻게 확장되고 희석되어있는지 좋은 예를 보여준다. “2007년 부터 에스토니아는 블록체인을 이용해 보편적인 국가 디지털 신원 제도를 운영하고 있다.” 라고 HBR에서 글을 올렸다. The Newyorker는 2017년 12월 “에스토니아 디지털 보안의 근간이 바로 블록체인 기술” 이라고 썼다. 에스토니아의 시스템은 실제로 비트코인 블록체인보다 앞서 있으며, 이를 블록체인 기술이라고 불릴지 여부에 대해서는 약간의 의견 차이가 있다. 핀테크 컨설턴트이자 《Before Babylon, Beyond Bitcoin》의 저자인 데이비드 버치는 에스토니아의 CIO인 Siim Sikkut와 블록체인 이벤트에 행사에 참여했는데, 그는 에스토니아의 시스템이 블록체인이 아닌듯한 발언을 했다. 나는 이 에스토니아 블록체인 ID 신화가 어디에서 유래되었는지 물었는데, 그 이유는 이런 도시전설이 견인력을 얻었다는 사실이 정말 당황스러웠기 때문이다. 그리고 그는 에스토니아 시스템의 데이터 무결성을 보호하기 위해 해시를 사용하는 데서 비롯된 오해가 있을 수 있다고 밝혔다. 에스토니아의 기술 공급업체 가드타임은 ‘해시 링크 타임스탬핑’에서 ‘블록체인 기술’로 브랜드를 변경했다. 이는 ‘블록체인’에 합의된 정의가 없기 때문에 반드시 사실이 아닐 수는 없다. “비트코인을 생각하기 훨씬 전부터 우리는 이 주제에 대해 오랫동안 연구해오고 있습니다.” 가드타임의 CEO 마이크 골트가 이메일을 통해 말했다. “비트코인에는 새로운 암호화폐 없습니다. 그 뒤에 있는 천재성은 다른 암호 화폐 블록을 가져와서, 암호 프로토콜을 만들어 사람들에게 이용하도록 유도하는 것이었습니다.” 블록체인은 “암호적으로 연결된 데이터 레코드를 포함하는 부속 데이터 전용 구조”라고 그는 말했다. “다수 분산 당사자들이 사전 합의된 규칙에 따라 합의를 도출할 때 데이터 기록이 데이터 구조에 추가됩니다.” ¶프라이빗 블록체인 금융 산업을 위해 제안된 것과 같이 새로운 블로체인 제안의 상당 부분은 소위 “프라이빗” 블록체인들이다. 비평가들은 이 프로젝트들이 새로운 것으로 가장한 오래된 기술이라고 말한다. &quot;'프라이빗 블록체인’은 공유된 데이터베이스의 혼란스러운 이름일 뿐입니다,&quot;라고 Coursera에서 인기 있는 블록체인 수업을 담당하는 프린스턴 대학의 컴퓨터 과학 조교수 Arvind Narayananan은 말했다. 그는 비트코인 블록체인 이면의 핵심적인 혁신은 소위 말하는 작업 증명 합의 메커니즘이라고 주장한다. 그것은 중앙정부의 필요성을 구성원들을 정직하게 유지하는 규칙과 인센티브로 대체하기 위한 것이었다. 이는 작업증명이 비효율적이고 비트코인의 네트워크가 많은 에너지를 소비하는 이유이다. 그래서 그것을 버리는 것이 반드시 나쁜 것은 아니다. 하지만 작업증명이 없다면, 블록체인에 정말 새로운 것이 있을까? ¶법에서의 정의 이러한 불확실성은 “블록체인” 프로젝트의 수를 부풀리고 기술의 능력을 과장함으로써 업계의 전반적인 활기에 기여했다. 이것은 또한 국가가 블록체인 관련 법안을 통과시키기 때문에 미래에 예측할 수 없는 문제를 일으킬 수도 있다. 세인트 메리 법대 교수이자 런던 대학의 블록체인 테크놀로지 센터의 연구원인 안젤라 월치는 블록체인 관련 용어와 법에 대한 논문을 썼다. &quot;많은 주들은 그들이 얼마나 비밀스럽고 기술에 정통한지를 보여주기 위해 어떤 종류의 법안을 통과시키기 위해 정말 서두르고 있습니다,&quot;라고 그녀는 말했다. “그들 중 많은 것들이 블록체인 기술에 대한 정의를 이러한 법령에 적용하고 있으며, 제 관점에서는 그것들은 매우 문제가 많은 정의입니다.” 그녀가 언급한 걱정되는 정의는 애리조나주에 의해 개발된 것이다. 애리조나의 전자거래법은 블록체인에 대한 거래를 포함한다는 것을 명확히 하기 위해 2017년에 개정되었다. 이를 통해, 입법부는 '블록체인 기술’이란 정의를 작성했는데, “분산형, 공유 및 복제된 원장을 사용하는 것으로, 퍼블릭 또는 프라이빗, 허가된(Permission) 또는 허가되지 않은(Permissionless) 토큰에 의해 구동될 수 있다. 원장의 데이터는 암호화로 보호되며, 영구적이고 감사할 수 없으며, 검열받지 않은 진실(uncensored truth)을 제공한다” The definition that concerns Walch the most is the one developed by the state of Arizona. Arizona’s Electronic Transactions Act was amended in 2017 to clarify that it covers transactions done on a blockchain. In doing so, the legislature wrote a definition: “‘Blockchain technology’ means distributed ledger technology that uses a distributed, decentralized, shared and replicated ledger, which may be public or private, permissioned or permissionless, or driven by tokenized crypto economics or tokenless. The data on the ledger is protected with cryptography, is immutable and auditable and provides an uncensored truth.” 특히 그는 'immutable’과 'uncensored truth’라는 표현에 대해 우려를 표하고 있다. 이말인 즉, 마이너, 개발자, 그리고 독재자를 포함할 수 있는 네트워크를 유지하는 사람들이 원하는한 검열 받지 않을 수 있는, 그리고 변경이 어려울 수 있다는 것을 내포하기 때문이다. 코인 사이언스의 설립자인 기디언 그린스펀은 비트코인 블록체인 재작성 비용이 국가 의욕에 상당한 영향을 미친다고 썼다. 블록체인 변경으로 널리 알려진 많은 사례가 있다. 비트코인은 소프트웨어의 “integer overflow” 오류로 인해 920억 비트코인이 생성되었고 전체 네트워크에 920억 비트코인이 다시 생성되었다. 2016년 대규모 해킹으로 이더리움이 터졌다. 게다가, 5월에 발효되고 사용자들이 자신의 데이터를 통제해야 한다고 주장하는 유럽의 일반 데이터 보호 규정(GDPR) 때문에 개발자들은 이제 블록체인에서 데이터를 삭제하는 방법을 모색하고 있다. &quot;비응축적 진실&quot;이라는 문구는 데이터가 블록체인에 있다고 해서 데이터가 정확하다는 것을 의미하지는 않는다는 사실도 무시합니다. 의료 기록의 오류와 같은 부정확한 데이터는 블록체인에서 여전히 검증될 수 있다. 설상가상으로, 애리조나 주의 정의는 현재 캘리포니아를 포함한 다른 주에서 제안된 법률에 사용되고 있다. 블록체인을 활용하여 200개 이상의 정부가 투표, 부동산 기록, 디지털 신원 등 다양한 용도에 사용하도록 제안했다. ¶표준을 향해 브리티시 컬럼비아 대학의 보관 과학 부교수이자 블록 체인 연구 클러스터의 책임자인 Victoria Lemieux는 국제 표준기구의 블록 체인 용어 표준을 개발하기 위한 노력을 주도하고 있다. “일반적으로 거래가 블록으로 모이고 암호 기법를 사용하여 체인에 블록을 고정하며, 변조 방지 기능을 갖추고 불변의 레코드를 생성하도록 설계된 경우 시스템은 블록 체인으로 보기에 적합하다. “그러나 일반적인 사용에서, 블록체인은 트랜잭션이 블록으로 구성되지 않더라도 광범위한 범위에서 분산원장도 블록체인으로 볼 수 있다.” 그녀의 팀은 “다른 공동체가 블록체인에 대한 자신만의 아이디어를 형성했고, 일부는 오픈소스, 공유, 자율성을 둘러싼 매우 강력한 정치적, 사회적 견해를 가지고 있다”는 사실을 포함하여 몇 가지 도전 과제에 부딪혔다. 또 다른 과제는 &quot;이러한 관할권이 조치를 취하지 않고 있으며 법적 절차나 기술의 적용을 복잡하게 만들 수 있다&quot;는 법적 정의의 확산이다&quot;라고 그녀는 말했다. 명확한 정의를 수립하는 것은 이러한 오해들을 해결하는 데 도움이 될 것이다. &quot;블록체인 기술이 무엇인지에 대한 보다 정확한 이해를 개발하는 것은 우리가 그것의 단점을 해결하는 데 도움이 될 것이고, 이를 개선해서 지지자들이 상상하는 변형적인 방법으로 더 잘 사용될 수 있을 것입니다,&quot;라고 그녀는 말했다. “우리가 그것에 대해 말할 때, 모두 다른 의미를 가질 때 기술을 발전시키거나 사용하는 것에 대해 대화를 나누는 것은 어렵습니다.” 안타깝게도, 그녀는 용어 표준이 마무리되는 데 약 18개월이 걸릴 것으로 추정한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인은 얼마나 안전한가?","slug":"how-safe-are-blockchains-it-depends","date":"2018-11-04T15:00:00.000Z","updated":"2018-11-05T10:44:01.000Z","comments":true,"path":"2018/11/05/how-safe-are-blockchains-it-depends/","link":"","permalink":"https://www.yceffort.kr/2018/11/05/how-safe-are-blockchains-it-depends/","excerpt":"How Safe Are Blockchains? It Depends. 원문 비트코인의 근간이 되는 분산형 선두 기술인 블록체인은, 블록체인이 뒷받침하는 통화보다 훨씬 더 가치 있는 것으로 판명 될 수 있다. 하지만 블록체인은 그것이 안전한 만큼만 가치가 있다. 분산형 원장 기술을 실행하기 시작할 때, 우리가 설정하는 초기 조건이 나중에 보안 문제에 문제가 되지 않도록 하지 않는 것이 중요하다. 블록체인 기술에 내재된 보안 위험을 이해하기 위해서는 퍼블릭 및 프라이빗 블록체인의 차이를 이해하는 것이 중요하다. 비트코인은 누구나","text":"How Safe Are Blockchains? It Depends. 원문 비트코인의 근간이 되는 분산형 선두 기술인 블록체인은, 블록체인이 뒷받침하는 통화보다 훨씬 더 가치 있는 것으로 판명 될 수 있다. 하지만 블록체인은 그것이 안전한 만큼만 가치가 있다. 분산형 원장 기술을 실행하기 시작할 때, 우리가 설정하는 초기 조건이 나중에 보안 문제에 문제가 되지 않도록 하지 않는 것이 중요하다. 블록체인 기술에 내재된 보안 위험을 이해하기 위해서는 퍼블릭 및 프라이빗 블록체인의 차이를 이해하는 것이 중요하다. 비트코인은 누구나 거래를 읽고 쓸 수 있게 해주는 기록 시스템인 공개 블록체인에 의존한다. 이러한 거래를 집계하고 게시할 수 있는 사람은 누구나 충분한 노력을 기울여 어려운 암호화 퍼즐을 해결함으로써 이를 증명할 수 있습다. 노드 네트워크가 이전에 확인된 트랜잭션의 기록을 확인하고 새로운 트랜잭션을 확인하는 프로세스를 합의 프로토콜이라고 합니다. 비트코인 시스템에서는 트랜잭션을 확인하는 데 절대적으로 신뢰되는 사용자가 없으므로 모든 사용자는 강력한 힘으로(즉, 암호 퍼즐을 해결) 문제를 해결하기 위해 소프트웨어 및 하드웨어 리소스를 커밋하여 트랜잭션을 확인하는 알고리즘을 따릅른다. 솔루션에 먼저 도달한 사용자는 보상을 받게 되며, 이를 검증하기 위해 사용된 트랜잭션과 함께 각 새로운 솔루션이 다음 문제 해결의 기반이 된다. 이러한 분권화와 접근의 상대적 자유는 예상치 못한 결과를 가져왔다. 그 이유는 누구든지 거래를 읽고 쓸 수 있기 때문이다. 비트코인 거래는 암시장의 거래를 부채질했다. 합의 프로토콜은 에너지를 소비하기 때문에, 대다수의 사용자는 값싼 전기를 사용하는 국가에서 운영하며, 네트워크 중앙 집중화와 결합의 가능성을 초래하며, 네트워크를 전기세에 대한 정책 변화에 취약하게 만든다. 이러한 두 가지 추세는 모두 프라이빗 블록체인에 대한 관심을 증가시켰고, 이는 궁극적으로 기업에 더 큰 통제력을 줄 수 있다. 주로 금융 환경에서 사용되는 프라이빗 블록체인은 누가 검증된 거래의 원장을 읽을 수 있는지, 누가 거래를 제출할 수 있는지, 누가 그것들을 검증할 수 있는지를 운영자에게 제어한다. 프라이빗 블록체인에서는 복수의 당사자가 동시에 참여하기를 원하지만 서로를 완전히 신뢰하지 않는 다양한 시장이 포함된다. 예를 들어, 토지 및 물리적 자산 등록, 상품 거래 및 사모 주식 분배를 지원하는 민간 블록체인 시스템이 모두 시험되고 있다. 이러한 시스템이 개발되고 진화함에 따라 이들 시스템 역시 예상치 못한 결과를 겪을 수 있으며, 그 중 일부는 시스템 및 관리하거나 저장하는 자산의 보안에 영향을 미칠 수 있다. 소프트웨어 및 제품 개발과 마찬가지로, 초기 단계의 보안을 고려했을 때 나중에 보안 결함을 해결하기 위해 제품을 근본적으로 변경하기가 어렵다. ¶네트워크 아키텍쳐와 함께 보안이 시작된다. 프라이빗 블록체인을 설정할 때 내려야 할 첫 번째 결정 중 하나는 시스템의 네트워크 아키텍처다. 블록체인은 신규거래 작성 및 승인에 필요한 신규거래 목록, 검증된 거래목록에 대한 합의를 도출한다. 이러한 통신은 노드 간에 이루어지며, 각 노드들은 원장의 복사본을 유지하고 다른 노드들에게 새로 제출되거나 새로 확인된 트랜잭션의 새로운 정보를 알준다. 프라이빗 블록체인 운영자는 누가 노드를 조작할 수 있는지, 그리고 이러한 노드가 어떻게 연결되었는지 제어할 수 있다. 더 많은 연결이 있는 노드는 정보를 더 빨리 수신한다. 마찬가지로 노드는 활성 상태로 간주되는 연결 수를 유지하기 위해 필요할 수 있다. 정보의 전송을 제한하거나 잘못된 정보를 전송하는 노드는 시스템의 무결성을 유지하기 위해 식별 가능하고 피할 수 있어야 한다. 프라이빗 블록체인 기반 상품 거래는 기존 거래 파트너에게 네트워크의 중심 위치를 더 많이 부여할 수 있으며, 예상대로 작동하도록 보장하기 위해 이러한 중앙 노드 중 하나에 대한 연결을 유지하기 위해 새로운 노드가 필요할 수 있다. 네트워크 아키텍처 구축에 있어서 또 다른 보안 문제는 비일관적 또는 간헐적으로 활성 노드를 처리하는 방법이다. 노드는 피해를 끼치지 않기 위해서 오프라인 상태가 될 수 있지만, 네트워크는 오프라인 노드 없이 기능(이전에 확인된 트랜잭션에 대한 합의를 얻고 새로운 트랜잭션을 올바르게 확인하려면)을 구성해야 하며, 이러한 노드를 신속하게 복구할 수 있어야 한다. ¶퍼블릭 및 프라이빗 블록체인의 합의 프로토콜과 접근 권한 합의 도출에 사용된 프로세스(문제 해결을 통한 트랜잭션 확인)는 현재 약 10분 정도 걸리는 시간을 갖도록 의도적으로 설계되었다. 트랜잭션은 약 1~2시간 동안 완전히 검증되지 않은 것으로 간주되며, 그 후 원장은 포크(fork)라고 알려진 경쟁 버전의 원장을 도입하는 것이 계산적으로 비용이 많이 들 수 있다. 이러한 지연은 둘 다 시스템의 취약성으로 작용한다. 초기에 확인되는 트랜잭션이 나중에 그러한 상태를 상실할 수 있고 금융 거래와 같이 빠른 속도로 진행되는 트랜잭션에 비트코인 기반 시스템을 사용하는 데 상당한 장애물이 될 수 있다. 반면에 프라이빗 블록체인에서는 운영자가 특정 노드만 검증 프로세스를 수행하도록 허용할 수 있으며, 이러한 신뢰할 수 있는 당사자들은 새로 확인된 트랜잭션을 네트워크의 나머지 부분과 통신할 책임이 있다. 이러한 노드에 대한 액세스 보안을 확보하고 신뢰할 수 있는 당사자 집합을 확장할 시기와 대상을 결정하는 책임은 블록체인 시스템 운영자가 내릴 수 있다. ¶퍼블릭 및 프라이빗 블록체인의 거래 전환성과 자산에 대한 보안 블록체인 거래는 데이터를 저장하는 데 사용될 수 있지만 비트코인 거래의 주된 동기는 비트코인 자체의 거래다. 통화의 환율은 짧은 기간 동안 변동이 잇었으며, 지난 2배 이상의 가치가 상승했다. 각 비트코인 트랜잭션에는 교환되는 비트코인과 관련된 고유한 텍스트 문자열이 포함된다. 마찬가지로, 다른 블록체인 시스템은 거래와 관련된 자산이나 주식의 소유를 기록한다. 비트코인 시스템에서는 개인 키(고유한 출력을 제공하도록 설계된 알고리즘으로 생성된 긴 수)를 사용하여 소유권이 인정된다. 따라서, 도난이라 함은 비트코인의 보안 오류가 아니라 개인 보안문제다. 개인 키를 안전하지 않게 보관한 결과다. 일부 추산에 따르면 잃어버린 비트코인의 가치는 9억 5천만 달러에 달한다. 따라서 프라이빗 블록체인 운영자는 특히 물리적 자산을 관리하는 시스템의 경우 손실된 식별 자격 증명 문제를 해결하는 방법을 결정해야 한다. 비록 아무도 석유 한 배럴의 소유권을 증명할 수 없을지라도, 그 배럴은 어딘가에 존재 할 필요가 있을 것이다. 비트코인은 현재 개인 키를 잃어버린 사람들에게 상환 할 수 있는 기능을 제공하지 않고 있다. 마찬가지로 도난 당한 비트코인은 합법적인 거래와 구별이 안 되는 확인 노드에 나타나기 때문에 회수하기가 거의 불가능하다. 프라이빗 블록체인 소유주는 특히 그 거래가 절도 행위로 보일 수 있는 경우, 확인된 거래를 되돌릴 것인지 여부와 상황에 따라 결정해야 할 것이다. 거래 역전은 시스템의 공정성과 공정성에 대한 신뢰를 훼손할 수 있지만 버그 이용으로 인해 막대한 손실을 허용하는 시스템은 사용자들을 잃게 될 것이다. 이는 퍼블릭 블록체인 플랫폼인 Ethereum에서 운영되도록 설계된 코드 기반 벤처 자금인 DAO(Decentralizational Independent Organization)의 최근 사례를 통해 알 수 있다. DAO를 운영하는 코드의 보안 취약성은 Ethereum의 개발자가 Ethereum 프로토콜의 결함이 아니더라도 Ethereum 프로토콜 자체를 변경해야 하는 재정적 손실을 초래했다. 이러한 변화를 만들기로 한 결정은 논란의 여지가 있었고, 퍼블릭 및 민간 블록체인 개발업자들이 유사한 결정에 직면할 상황을 고려해야 한다는 생각을 분명히 했다. ¶보상의 무게 프라이빗 블록체인(트랜잭션 확인 및 네트워크 통신 속도 향상, 오류 및 역거래 수정 기능, 외부 공격 가능성 제한 및 감소 기능)이 제공하는 이점은 잠재적인 사용자들을 경계하게 할 수 있다. 모든 블록체인 시스템의 필요성은 어느 정도의 불신 또는 최소한 모든 사용자의 인센티브가 일치하지 않을 수 있다는 것을 전제로 한다. 비트코인과 같은 퍼블릭 블록체인 시스템을 유지하기 위해 노력하는 개발자들은 여전히 그들이 제안하는 변경사항들을 채택하기 위해 개인 사용자들에게 의존한다. 이것은 변화가 전체 시스템에 이익이 되는 경우에만 채택되도록 보장하는 데 도움이 된다. 반면에 민간 블록체인의 운영자들은 일부 사용자들이 동의하지 않는 변경을 일방적으로 적용하기로 선택할 수도 있다. 민간 블록체인 시스템의 보안과 유용성을 보장하기 위해, 운영자들은 시스템 규칙 변경에 동의하지 않거나 새로운 규칙을 채택하는 데 느린 사용자가 이용할 수 있는 상환을 고려해야 한다. 최신 패치 없이 현재 실행 중인 운영 체제의 수는 논란의 여지가 없는 변경도 신속하게 채택되지 않을 것임을 강력히 시사한다. 퍼블릭 블록체인에 금융시장이나 기타 기반시설을 건설하는 위험은 새로운 진입을 중단시킬 수 있지만, 민간 블록체인은 참여자의 행동과 거래 검증 과정에 대한 통제력을 어느 정도 제공한다. 블록체인 기반 시스템의 사용은 시스템 보안의 조기 고려에 의해 뒷받침되는 해당 시스템의 투명성과 사용성에 대한 신호이다. 기업이 안전한 프라이빗 인트라넷이나 인터넷에서 어떤 시스템을 더 잘 호스팅하는지를 결정하는 것과 마찬가지로 빠른 트랜잭션이 필요한 시스템, 트랜잭션 역전의 가능성, 그리고 거래 검증에 대한 중앙 집중식 제어가 더 적합할 것이다. 광범위한 참여로부터 투명성과 제3자 검증이 퍼블릭 블록체인에서 번창할 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"초보를 위한 웹크롤링: 네이버 영화 댓글 크롤링하기","slug":"web-crwaling-for-naver-movie","date":"2018-11-04T15:00:00.000Z","updated":"2018-11-05T10:44:01.000Z","comments":true,"path":"2018/11/05/web-crwaling-for-naver-movie/","link":"","permalink":"https://www.yceffort.kr/2018/11/05/web-crwaling-for-naver-movie/","excerpt":"파이썬과 파이썬 라이브러리 (beatifulSoup)를 활용하여 네이버 영화 댓글 크롤링 해보기 ¶1. 크롤링하려는 웹페이지의 구조를 살펴보기 인크레더블 평점 댓글 페이지를 먼저 살펴보겠습니다. 여기 우리가 할일은 저 페이징 (1, 2, 3, 4…)을 전부다 조회하면서, 댓글을 가져오는 일입니다. 한번 페이지를 눌러보면서 웹페이지 주소의 변화가 일어나는지 살펴봅니다. 별다른 변화가 일어나지 않습니다. 웹페이지 주소에 변화는 없지만 어디선가 다른 방식으로 데이터를 가져오고 있다는 것을 의미합니다. 어디에서 데이터를 가져오는","text":"파이썬과 파이썬 라이브러리 (beatifulSoup)를 활용하여 네이버 영화 댓글 크롤링 해보기 ¶1. 크롤링하려는 웹페이지의 구조를 살펴보기 인크레더블 평점 댓글 페이지를 먼저 살펴보겠습니다. 여기 우리가 할일은 저 페이징 (1, 2, 3, 4…)을 전부다 조회하면서, 댓글을 가져오는 일입니다. 한번 페이지를 눌러보면서 웹페이지 주소의 변화가 일어나는지 살펴봅니다. 별다른 변화가 일어나지 않습니다. 웹페이지 주소에 변화는 없지만 어디선가 다른 방식으로 데이터를 가져오고 있다는 것을 의미합니다. 어디에서 데이터를 가져오는지 살펴보기 위해, 페이지 아무곳에서 오른쪽단추를 누르고 검사를 누릅니다. 그리고 네트워크 탭을 누릅니다. 그다음, 페이지를 새로고침하고, 다시한번 페이지 버튼 (1, 2, 3)을 눌러봅니다. 간단하게 네트워크 탭을 설명해보면, 웹페이지를 로딩하면서 발생하는 모든 네트워크 이벤트 (이미지, 정보 등)가 기록되는 곳입니다. 위 이미지에서 주목해야 할 부분이 있습니다. 바로 페이지 번호에 따라서 변화가 있는 요소 인데요. 이미지 두번째 줄의 주소 URL을 보면, 마지막에 page=4 같은 형식으로 요청을 보내고 있다는 것을 알수 있습니다. 이링크를 들어가볼까요? 오른쪽 단추로 누르고, open in a new tab을 클릭합니다. 댓글 영역을 html로 불러오고 있었네요. 우리는 이제 저 page=1에 적절한 페이지 번호만 입력하면, 모든 댓글을 기계적으로 가져올 수 있다는 것을 깨닫게 되었습니다. ¶2. requests, beautifulSoup 라이브러리 활용하기 댓글 구조가 어떻게 되어 있는지는 확인했습니다. 이제 우리가 할일은 파이썬으로 정보를 가져오는 일만 남았습니다. 이를 위해서 우리는 두가지 라이브러리를 사용하고자 합니다. 12import requestsfrom bs4 import BeautifulSoup requests는 파이썬에서 http 요청을 보낼 때 쓸 라이브러리고, BeautifulSoup는 html에서 정보를 간단하게 빼오기 위해 사용할 라이브러리 입니다. 1234test_url = \"https://movie.naver.com/movie/bi/mi/pointWriteFormList.nhn?code=136990&amp;type=after&amp;page=1\"resp = requests.get(test_url)html = BeautifulSoup(resp.content, 'html.parser')html 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta content=&quot;IE=edge&quot; http-equiv=&quot;X-UA-Compatible&quot;/&gt;&lt;title&gt;네이버 영화&lt;/title&gt;&lt;link href=&quot;https://ssl.pstatic.net/static/m/movie/icons/naver_movie_favicon.ico&quot; rel=&quot;shortcut icon&quot; type=&quot;image/x-icon&quot;/&gt;&lt;link href=&quot;/css/common.css?20181031144347&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;&lt;link href=&quot;/css/movie_tablet.css?20181031144347&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;link href=&quot;/css/movie_end.css?20181031144347&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;script src=&quot;/js/deploy/movie.all.js?20181031144347&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/link&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- content --&gt;&lt;input id=&quot;movieCode&quot; name=&quot;movieCode&quot; type=&quot;hidden&quot; value=&quot;160487&quot;/&gt;&lt;input id=&quot;onlyActualPointYn&quot; name=&quot;onlyActualPointYn&quot; type=&quot;hidden&quot; value=&quot;N&quot;/&gt;&lt;input id=&quot;order&quot; name=&quot;order&quot; type=&quot;hidden&quot; value=&quot;sympathyScore&quot;/&gt;&lt;input id=&quot;page&quot; name=&quot;page&quot; type=&quot;hidden&quot; value=&quot;622&quot;/&gt;&lt;input id=&quot;point&quot; name=&quot;point&quot; type=&quot;hidden&quot; value=&quot;0&quot;/&gt;&lt;div class=&quot;ifr_area basic_ifr&quot;&gt;&lt;div class=&quot;input_netizen &quot;&gt;&lt;form id=&quot;pointWriteArea&quot;&gt;&lt;fieldset&gt;&lt;legend&gt;&lt;span class=&quot;blind&quot;&gt;네티즌 평점 입력란&lt;/span&gt;&lt;/legend&gt;&lt;!-- 모바일 기기로 접근 시 : 클래스 t_layer_view 추가 --&gt;&lt;ul class=&quot;t_layer_view&quot;&gt;&lt;li class=&quot;drag_star&quot;&gt;&lt;div class=&quot;lft&quot;&gt;&lt;div class=&quot;star_score&quot;&gt;&lt;strong class=&quot;blind&quot;&gt;평점선택&lt;/strong&gt;&lt;!-- [D] st_off 영역에 마우스 오버시 : 클래스 st_over 추가... 길어서 생략했지만, 암튼 가져왔습니다. 이제 저기에서 어디가 댓글 영역인지 찾아야 합니다. 바로 이 영역이요. 여기는 이제 우리가 눈에 불을 켜고 찾아야할 곳입니다. 찾아보니, 한가지 사실을 알 수 있었습니다. &lt;div class=&quot;score_result&gt; 라는 곳 아래에, ul, 그리고 그 아래에 li가 우리가 찾던 댓글 영역이었습니다. 그리고 그 li가 10개 반복되어 있네요. &lt;div class=&quot;score_result&gt; 이 구조에 대해 간단하게 설명드리면, div는 태그명입니다. class=&quot;score_result&quot;는 class라는 속성으로 score_result값을 가지고 있는 거지요. 123score_result = html.find('div', &#123;'class': 'score_result'&#125;)lis = score_result.findAll('li')lis[0] 결과 12345678910111213141516171819202122232425&lt;li&gt;&lt;div class=&quot;star_score&quot;&gt;&lt;span class=&quot;st_off&quot;&gt;&lt;span class=&quot;st_on&quot; style=&quot;width:100.0%&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;em&gt;10&lt;/em&gt;&lt;/div&gt;&lt;div class=&quot;score_reple&quot;&gt;&lt;p&gt;처음에 만두 같은게 나와서 상영관 잘못 들어온줄 &lt;/p&gt;&lt;dl&gt;&lt;dt&gt;&lt;em&gt;&lt;a href=&quot;#&quot; onclick=&quot;javascript:showPointListByNid(14315731, &apos;after&apos;);parent.clickcr(this, &apos;ara.uid&apos;, &apos;&apos;, &apos;&apos;, event); return false;&quot; target=&quot;_top&quot;&gt;&lt;span&gt;크리스탈(a8d5****)&lt;/span&gt;&lt;/a&gt;&lt;/em&gt;&lt;em&gt;2018.07.18 09:07&lt;/em&gt;&lt;/dt&gt;&lt;dd&gt;&lt;a class=&quot;go_report2&quot; href=&quot;#&quot; onclick=&quot;parent.clickcr(this, &apos;ara.report&apos;, &apos;&apos;, &apos;&apos;, event); common.report(&apos;false&apos;,&apos;a8d5****&apos;, &apos;mwNBVSIMqNRoWDHCxeN1YFkIC/JtxnOSpwYTkFE2Qos=&apos;, &apos;처음에 만두 같은게 나와서 상영관 잘못 들어온줄 &apos;, &apos;14315731&apos;, &apos;point_after&apos;, false);return false;&quot;&gt;&lt;em&gt;신고&lt;/em&gt;&lt;/a&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;&lt;div class=&quot;btn_area&quot;&gt;&lt;a class=&quot;_sympathyButton&quot; href=&quot;#&quot; onclick=&quot;parent.clickcr(this, &apos;ara.sym&apos;, &apos;&apos;, &apos;&apos;, event);&quot;&gt;&lt;span class=&quot;blind&quot;&gt;공감&lt;/span&gt;&lt;/a&gt;&lt;strong&gt;&lt;span class=&quot;sympathy_14315731 count&quot;&gt;2406&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;_notSympathyButton&quot; href=&quot;#&quot; onclick=&quot;parent.clickcr(this, &apos;ara.opp&apos;, &apos;&apos;, &apos;&apos;, event);&quot;&gt;&lt;span class=&quot;blind&quot;&gt;비공감&lt;/span&gt;&lt;/a&gt;&lt;strong&gt;&lt;span class=&quot;notSympathy_14315731 count v2&quot;&gt;141&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;&lt;/li&gt; 사용법은 간단합니다. 굳이 설명이 필요 없을 정도로요. 이제 찾고 싶은 요소를 하나씩 검색해봅시다. ¶댓글 내용 12review_text = lis[0].find('p').getText()review_text 1&apos;처음에 만두 같은게 나와서 상영관 잘못 들어온줄 &apos; ¶평점 12score = lis[0].find('em').getText()score 1&apos;1&apos; ¶댓글 좋아요, 싫어요 123like = lis[0].find('div', &#123;'class': 'btn_area'&#125;).findAll('span')[1].getText()dislike = lis[0].find('div', &#123;'class': 'btn_area'&#125;).findAll('span')[3].getText()like, dislike 1(&apos;7&apos;, &apos;12&apos;) ¶닉네임 12nickname = lis[0].findAll('a')[0].find('span').getText()nickname 1&apos;크리스탈(a8d5****)&apos; ¶작성일 123from datetime import datetimecreated_at = datetime.strptime(li.find('dt').findAll('em')[-1].getText(), \"%Y.%m.%d %H:%M\")created_at 1datetime.datetime(2018, 7, 18, 9, 7) 필요한 정보를 다 가져온 것 같습니다. 이제 이것을 method로 만들어봅시다. 12345678910111213141516171819def get_data(url): resp = requests.get(url) html = BeautifulSoup(resp.content, 'html.parser') score_result = html.find('div', &#123;'class': 'score_result'&#125;) lis = score_result.findAll('li') for li in lis: nickname = li.findAll('a')[0].find('span').getText() created_at = datetime.strptime(li.find('dt').findAll('em')[-1].getText(), \"%Y.%m.%d %H:%M\") review_text = li.find('p').getText() score = li.find('em').getText() btn_likes = li.find('div', &#123;'class': 'btn_area'&#125;).findAll('span') like = btn_likes[1].getText() dislike = btn_likes[3].getText() watch_movie = li.find('span', &#123;'class':'ico_viewer'&#125;) # 간단하게 프린트만 했습니다. print(nickname, review_text, score, like, dislike, created_at, watch_movie and True or False) 데이터를 가져오는 방법은, 보시면 아시겠지만 특별한 노하우가 없습니다. 이요소 저요소 찾아보면서, 다양한 방법을 시도하는 것이 좋습니다. 제가 쓴 코드가 결코 좋은 코드라고 말할 수는 없습니다만, 편하신 방법으로 찾으면 될 것 같습니다. ¶3. 전체 댓글 수 가져오기 한 가지 놓친게 있다면, 전체 댓글수를 가져오는 것입니다. 전체 댓글 수를 가져오고, 그 숫자 만큼 나누기 10을 하여 페이지 조회를 해야할 것입니다. 12result = html.find('div', &#123;'class':'score_total'&#125;).find('strong').findChildren('em')[1].getText()int(result.replace(',', '')) 19926 ¶4. 완성 12345678910test_url = 'https://movie.naver.com/movie/bi/mi/pointWriteFormList.nhn?code=136990&amp;type=after'resp = requests.get(test_url)html = BeautifulSoup(resp.content, 'html.parser')result = html.find('div', &#123;'class':'score_total'&#125;).find('strong').findChildren('em')[1].getText()total_count = int(result.replace(',', ''))for i in range(1, int(total_count / 10) + 1): url = test_url + '&amp;page=' + str(i) print('url: \"' + url + '\" is parsing....') get_data(url) 123456789101112131415161718192021222324252627282930313233343536373839일산빵셔틀(rnra****) 평론가 임수연씨의 마블보다 재밌다는 평을보고 코웃음치고 보러갔는데 마블빠인 내가봐도 마블보다 재밌었다 히어로물은 언제까지나 마블의 독주일꺼라는 착각을 씻어내준 가족액션 히어로물 진짜 너무재밌다 10 488 32 2018-07-18 23:49:00 Falseurl: &quot;https://movie.naver.com/movie/bi/mi/pointWriteFormList.nhn?code=136990&amp;type=after&amp;page=1&amp;page=4&quot; is parsing....크리스탈(a8d5****) 처음에 만두 같은게 나와서 상영관 잘못 들어온줄 10 2406 141 2018-07-18 09:07:00 Falsegksq**** 14년동안 기다린 보람이있다.인크레더블 3도 해주세요 ㅠㅠ 제발 ㅠㅠ 10 1539 66 2018-07-18 10:39:00 Falseyski**** 잭잭이랑 에드나 케미 미쳤닼ㅋㅋㅋ 10 1309 36 2018-07-18 10:07:00 False배센도(bbtj****) 어릴 때 1편을 보고 성인이 된 올해 2편을 봤다. 또 보고 싶다. 3편도 나오면 좋겠다. 10 1013 34 2018-07-18 12:28:00 Falsespace(tmd5****) 속편도 이리 완벽할 수 있구나..! 10 898 40 2018-07-18 09:27:00 False황진이의두번째팬티(sion****) 중심히어로와 빌런이 여성이라는 점, 그 둘의 대화 내용, 아내에게 열등감을 느끼던 남편이 육아를 도맡고 아내의 바깥일을 내조하며 그녀를 진짜 히어로로 인정하는 과정이 인상 깊었다. 꿈이 많은 내게 선물같은 영화였다. 또 보러 가겠다. 10 1230 382 2018-07-18 20:40:00 False불(catc****) 이런 게 최고의 애니매이션이 아니면 뭐란 말인가?? 미취학아동 때 1을 보고 대학생이 되어서 2를 보는 기분이란...ㅠㅠㅠ헬렌의 활약과 잭잭의 귀여움, 그리고 개인적으로는 에드나의 매력까지 올해 본 영화 중 최고!! 10 758 33 2018-07-18 12:39:00 False쿠앤크(zhfl****) 잭잭 납치하러 갈 파티원 구합니다(1/10000) 8 639 105 2018-07-18 09:21:00 False아머두어라두(dkqj****) 관람객내 어릴적 베스트 영화의 속편이 너무 잘만들어져서 울컥했습니다. 10 499 24 2018-07-18 18:05:00 True일산빵셔틀(rnra****) 평론가 임수연씨의 마블보다 재밌다는 평을보고 코웃음치고 보러갔는데 마블빠인 내가봐도 마블보다 재밌었다 히어로물은 언제까지나 마블의 독주일꺼라는 착각을 씻어내준 가족액션 히어로물 진짜 너무재밌다 10 488 32 2018-07-18 23:49:00 Falseurl: &quot;https://movie.naver.com/movie/bi/mi/pointWriteFormList.nhn?code=136990&amp;type=after&amp;page=1&amp;page=5&quot; is parsing....크리스탈(a8d5****) 처음에 만두 같은게 나와서 상영관 잘못 들어온줄 10 2406 141 2018-07-18 09:07:00 Falsegksq**** 14년동안 기다린 보람이있다.인크레더블 3도 해주세요 ㅠㅠ 제발 ㅠㅠ 10 1539 66 2018-07-18 10:39:00 Falseyski**** 잭잭이랑 에드나 케미 미쳤닼ㅋㅋㅋ 10 1309 36 2018-07-18 10:07:00 False배센도(bbtj****) 어릴 때 1편을 보고 성인이 된 올해 2편을 봤다. 또 보고 싶다. 3편도 나오면 좋겠다. 10 1013 34 2018-07-18 12:28:00 Falsespace(tmd5****) 속편도 이리 완벽할 수 있구나..! 10 898 40 2018-07-18 09:27:00 False황진이의두번째팬티(sion****) 중심히어로와 빌런이 여성이라는 점, 그 둘의 대화 내용, 아내에게 열등감을 느끼던 남편이 육아를 도맡고 아내의 바깥일을 내조하며 그녀를 진짜 히어로로 인정하는 과정이 인상 깊었다. 꿈이 많은 내게 선물같은 영화였다. 또 보러 가겠다. 10 1230 382 2018-07-18 20:40:00 False불(catc****) 이런 게 최고의 애니매이션이 아니면 뭐란 말인가?? 미취학아동 때 1을 보고 대학생이 되어서 2를 보는 기분이란...ㅠㅠㅠ헬렌의 활약과 잭잭의 귀여움, 그리고 개인적으로는 에드나의 매력까지 올해 본 영화 중 최고!! 10 758 33 2018-07-18 12:39:00 False쿠앤크(zhfl****) 잭잭 납치하러 갈 파티원 구합니다(1/10000) 8 639 105 2018-07-18 09:21:00 False아머두어라두(dkqj****) 관람객내 어릴적 베스트 영화의 속편이 너무 잘만들어져서 울컥했습니다. 10 499 24 2018-07-18 18:05:00 True일산빵셔틀(rnra****) 평론가 임수연씨의 마블보다 재밌다는 평을보고 코웃음치고 보러갔는데 마블빠인 내가봐도 마블보다 재밌었다 히어로물은 언제까지나 마블의 독주일꺼라는 착각을 씻어내준 가족액션 히어로물 진짜 너무재밌다 10 488 32 2018-07-18 23:49:00 Falseurl: &quot;https://movie.naver.com/movie/bi/mi/pointWriteFormList.nhn?code=136990&amp;type=after&amp;page=1&amp;page=6&quot; is parsing....크리스탈(a8d5****) 처음에 만두 같은게 나와서 상영관 잘못 들어온줄 10 2406 141 2018-07-18 09:07:00 Falsegksq**** 14년동안 기다린 보람이있다.인크레더블 3도 해주세요 ㅠㅠ 제발 ㅠㅠ 10 1539 66 2018-07-18 10:39:00 Falseyski**** 잭잭이랑 에드나 케미 미쳤닼ㅋㅋㅋ 10 1309 36 2018-07-18 10:07:00 False배센도(bbtj****) 어릴 때 1편을 보고 성인이 된 올해 2편을 봤다. 또 보고 싶다. 3편도 나오면 좋겠다. 10 1013 34 2018-07-18 12:28:00 Falsespace(tmd5****) 속편도 이리 완벽할 수 있구나..! 10 898 40 2018-07-18 09:27:00 False황진이의두번째팬티(sion****) 중심히어로와 빌런이 여성이라는 점, 그 둘의 대화 내용, 아내에게 열등감을 느끼던 남편이 육아를 도맡고 아내의 바깥일을 내조하며 그녀를 진짜 히어로로 인정하는 과정이 인상 깊었다. 꿈이 많은 내게 선물같은 영화였다. 또 보러 가겠다. 10 1230 382 2018-07-18 20:40:00 False불(catc****) 이런 게 최고의 애니매이션이 아니면 뭐란 말인가?? 미취학아동 때 1을 보고 대학생이 되어서 2를 보는 기분이란...ㅠㅠㅠ헬렌의 활약과 잭잭의 귀여움, 그리고 개인적으로는 에드나의 매력까지 올해 본 영화 중 최고!! 10 758 33 2018-07-18 12:39:00 False쿠앤크(zhfl****) 잭잭 납치하러 갈 파티원 구합니다(1/10000) 8 639 105 2018-07-18 09:21:00 False아머두어라두(dkqj****) 관람객내 어릴적 베스트 영화의 속편이 너무 잘만들어져서 울컥했습니다. 10 499 24 2018-07-18 18:05:00 True일산빵셔틀(rnra****) 평론가 임수연씨의 마블보다 재밌다는 평을보고 코웃음치고 보러갔는데 마블빠인 내가봐도 마블보다 재밌었다 히어로물은 언제까지나 마블의 독주일꺼라는 착각을 씻어내준 가족액션 히어로물 진짜 너무재밌다 10 488 32 2018-07-18 23:49:00 Falseurl: &quot;https://movie.naver.com/movie/bi/mi/pointWriteFormList.nhn?code=136990&amp;type=after&amp;page=1&amp;page=7&quot; is parsing....크리스탈(a8d5****) 처음에 만두 같은게 나와서 상영관 잘못 들어온줄 10 2406 141 2018-07-18 09:07:00 Falsegksq**** 14년동안 기다린 보람이있다.인크레더블 3도 해주세요 ㅠㅠ 제발 ㅠㅠ 10 1539 66 2018-07-18 10:39:00 Falseyski**** 잭잭이랑 에드나 케미 미쳤닼ㅋㅋㅋ 10 1309 36 2018-07-18 10:07:00 False배센도(bbtj****) 어릴 때 1편을 보고 성인이 된 올해 2편을 봤다. 또 보고 싶다. 3편도 나오면 좋겠다. 10 1013 34 2018-07-18 12:28:00 False 단순히 제 예제에서는 print만 헀지만, 이를 데이터 베이스로 저장한다던지, csv로 저장한다던지 하는 방법이 있습니다. csv작성을 위해서는 여기를, mysql같은 db에 저장하기 위해서는, 적절한 파이썬 라이브러리 (pymysql 등)를 찾으시면 되겠네요.","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://www.yceffort.kr/tags/development/"},{"name":"crawling","slug":"crawling","permalink":"https://www.yceffort.kr/tags/crawling/"}]},{"title":"분산된 데이터: 왜 블록체인은 의미가 없고, Trustless가 핵심인가?","slug":"decentralized-data-why-blockchain-is-meaningless-and-trustless-is-everything","date":"2018-11-03T15:00:00.000Z","updated":"2018-11-04T10:44:01.000Z","comments":true,"path":"2018/11/04/decentralized-data-why-blockchain-is-meaningless-and-trustless-is-everything/","link":"","permalink":"https://www.yceffort.kr/2018/11/04/decentralized-data-why-blockchain-is-meaningless-and-trustless-is-everything/","excerpt":"Decentralized Data: “Why Blockchain is meaningless and Trustless is everything” 원문 ¶왜 블록체인 기술은 의미가 없는가? 블록체인 기술과 분산화는 일반적인 대중들의 채택을 위한 준비가 되어 있지 않은 새로운 기술이지만, 동시에 다음 10년 동안 분명한 추세이기도 하다. 새로운 기술로서, 이 기술의 비전과 진정한 가치를 실용적인 방법으로 이해하는 사람은 다음 10년 안에 시장을 지배할 것이다. 불행하게도, 블록체인에서 일어나고 있는 일은 이 기술을 유용하고 안전하","text":"Decentralized Data: “Why Blockchain is meaningless and Trustless is everything” 원문 ¶왜 블록체인 기술은 의미가 없는가? 블록체인 기술과 분산화는 일반적인 대중들의 채택을 위한 준비가 되어 있지 않은 새로운 기술이지만, 동시에 다음 10년 동안 분명한 추세이기도 하다. 새로운 기술로서, 이 기술의 비전과 진정한 가치를 실용적인 방법으로 이해하는 사람은 다음 10년 안에 시장을 지배할 것이다. 불행하게도, 블록체인에서 일어나고 있는 일은 이 기술을 유용하고 안전하게 만드는 진정한 가치와 특징에 대한 큰 오해의 산물이다. 블록체인은 DB 구조일 뿐이며, 블록체인 내에서 제공하는 다른 기능들이 없이 비트코인과 이더리움 네트워크들을 믿는 것은 굉장히 위험한 일이다. 블록체인은 통화나 분산 데이터 측면에서 해킹방지와, 가치 측면에서 보안을 만드는 기능이 아니라, 삭제 기능 없이 분산 데이터베이스를 표현하고 트랜잭션 블록으로 구성되는 것이다. 블록체인 기술은 킬러 앱이 아닌 신뢰할 수 없는 기능을 강화하고 이 생태계에서 가치를 창출하는 계층으로 블록 안에 정보를 저장하도록 설계되었다. 예를 들어 비트코인이나 이더리움과 같은 네트워크에서 신뢰가 필요 없음(Trustless)이라는 기능은 보안과 가치를 창출하기 위한 것이며, 블록체인은 오로지 원장을 구성하는 디비 구조일 뿐이다. ¶Trustless (신뢰가 필요없음)이 전부인 이유 Trustless의 개념은 블록체인 네트워크에서 가치를 창출하는 것이며, 개체를 신뢰하지 않고 알고리즘에 의해 트랜잭션과 논리를 검증하는 방법이다. 블록체인 DB 구조가 아닌 블록체인 네트워크에서 이 목표를 달성하고 예술의 상태를 발전시키기 위해 다음과 같은 세 가지 기능이 있다. ¶익명의 검증자 검증자는 컴퓨팅 성능을 높이고, 분산된 원장을 유지하며, 블록의 보안을 검증하는 사람이다. 신뢰가 없는 네트워크에서, 검증자는 익명이고 네트워크를 소유하고 있으며, 더 많은 검증자가 있으며, 더 많은 계산 능력이 공유되고, 더 많은 네트워크가 있을 수록 좋다. 선택한 검증자 또는 하나의 검증자로 네트워크를 생성하는 경우 알고리즘이 아닌 실체를 신뢰하는 것이기 때문에 신뢰할 수 없는 네트워크가 아니다. ¶합의 과정 (Conesesus) 검증은 검증자(또는 마이너)가 블록을 검증하기 위해 사용하는 알고리즘이며, 이러한 알고리즘은 검증자가 단일의 경제 주체 또는 검증자를 조작하지 못하도록 할 수 있는, 많은 검증자의 분산적 힘을 보장하기 위해 고안되었다. ¶분산된 거버넌스 가치있는 블록체인 네트워크는 의사 결정 이벤트 및 업데이트에서 분산되어 있으며, 이는 신뢰할 수없는 검증에 도달하는 또 다른 숨겨진 가치다. 기술 업그레이드는 특히 블록체인 네트워크에서 매우 중요하며, 네트워크가 구축 방법과 업그레이드 방법에 집중되어 있으면 다른 기능을 쓸모 없게 만들 수 있다. 엔티티가 네트워크를 업데이트하는 방법을 결정할 수 있다면, 실제로 네트워크를 지배하고 분산된 응용 프로그램이 이러한 종류의 네트워크에 실행되면 신뢰가 아닌 엔티티를 신뢰하게 되어 버린다. 익명 유효성 검증, 컨센서스 알고리즘 및 분산 거버넌스는 블록체인 네트워크에서 신뢰도를 창출하는 기능으로,이 세 가지 측면 중 하나가 없으면 네트워크는 네트워크 비용, 개발자 비용 및 보안 측면에서 해킹 가능하고 값 비싼 아키텍처 일뿐이다. ¶신뢰할 수 있는 엔티티의 존재가 블록체인에서 위험한 이유 프라이빗, 또는 연합된 블록체인은 보안상 위험하다. 왜냐하면 네트워크의 다른 엔티티나 해커가 이를 손상시킬 수 있기 때문이다. 가치라는 범위에서 프라이빗이나 연합된 블록체인은 쓸모가 없다. 왜냐하면 당신이 검증한 모든 것은 신뢰하는 실체이기 때문이다. Ethereum이나 AION과 같은 블록체인 프로젝트는 하이브리드 프라이빗 블록체인이라는 개념을 사용하여 네트워크를 확장하기 위해 노력하고 있다. 예를 들어 Ethereum이 Plasma를 출시한다면, 일반 Smart Contract를 사용하여 프라이빗 블록체인을 만들 수 있다. AION은 프라이빗 블록 체인에서 퍼블릭 블록 체인으로 분산된 상호 운용성을 연구하고 있지만, Plasma뿐만 아니라 현재 작업 중인 프로젝트이므로 향후 프라이빗 블록 체인에서는 의미가 있을 수 있지만 현재는 아니다. EOS와 같은 다른 프로젝트들은 새로운 합의 알고리즘을 통해 퍼블릭 블록체인의 규모를 조정하고 있으며, 동시에 프라이빗 블록 체인을 만드는 것이 아니라 퍼블릭 네트워크를 확장하기 위해 노력하고 있다. 진짜 문제는 비재무적인 용도로 블록체인 기술을 사용하는 것이 엄청난 수요를 가지고 있지만, 기술은 채택할 준비가 되어 있지 않고, 동시에 모든 복잡한 세계를 다뤄야 하기 때문에 진정한 가치를 이해하기가 어렵다는 것이다. ¶기다려야 한다, 그러나 왜? 네트워크 또는 분산형 애플리케이션의 신뢰 없는 검증은 내일을 위한 기술을 개발하기 위한 기본 기능이다. 블록체인 기술의 숨겨진 진정한 가치는 분산된 데이터다. 즉, 기업을 신뢰하지 않고 데이터를 추적하기 위한 개념입니다. 이러한 개념뿐만 아니라, 오늘날 데이터가 얼마나 중요한지, 그리고 오늘날의 데이터가 어떻게 조작 가능하고 기업 검증을 기반으로 하는지를 생각해야 한다. 미래에 신뢰가 필요없는 분산형 데이터에서는 얼마나 많은 가치가 있을 수 있을까? ¶분산된 데이터의 개념 Dapp를 구축하고 분산 데이터를 만들기 시작하는 것은 간단하지만, 실제 문제는 분산형 데이터의 작동 방식에 있다. 많은 프로젝트가 비트코인이나 다른 블록체인 위에 분산형 로직을 구축하려고 시도했지만, 대부분의 프로젝트는 블록체인이 로직을 분산시키기 위해 개발된 것이 아니라 가치(코인) 만으로 개발되었기 때문에 실패했다. 이 근본적인 문제를 해결한 첫 번째 프로젝트는 Bitcoin 커뮤니티의 유명한 초기 활동 사용자인 Vitalik Buterin이 설립한 Ethereum이다. Ethereum은 스마트 컨트랙트, 응용 프로그램 및 분산 데이터를 위한 최초의 운영 체제가 될 미션과 논리를 처리하도록 설계된 새로운 블록 체인 네트워크로, 개발 당시 블록 체인 기술에 파괴적인 혼란을 불러왔다. Ethereum Technology의 핵심 개념은 오늘날 우리가 ‘블록체인 기술의 2세대’라고 부르는 표준을 정했다는 것에 있다. 블록체인의 블록 안에서 스마트 컨트랙트라는 개념으로 분산된 논리를 검증하는 아이디어를 도입했기 때문이다. 기본적으로 스마트 컨트랙트 기술이 도입됨에 따라, Ethereum 네트워크와의 상호작용을 위한 개발자는 자신의 기능을 분산시켜야 한다. 사용자가 분산 기능과 상호 작용할 때마다 Ethereum 트랜잭션을 만들어야 한다. Ethereum 트랜잭션 중에 네트워크는 블록 내부, 호출된 기능, 요청 및 결과를 검증한다. 이 세 가지 측면은 완전히 신뢰할 수 없는 방식으로 분산형 데이터를 제공하는 데 있어 매우 중요하다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인 10주년 기념: 비트코인의 역사","slug":"history-of-bitcoin","date":"2018-11-02T15:00:00.000Z","updated":"2018-11-03T10:44:01.000Z","comments":true,"path":"2018/11/03/history-of-bitcoin/","link":"","permalink":"https://www.yceffort.kr/2018/11/03/history-of-bitcoin/","excerpt":"Bitcoin turns 10: An annotated timeline 원문 지난 수요일 (2018년 10월 31일) 은 비트코인 백서의 \"Bitcoin: Peer-to-Peer Electronic Cash System\"이 cryptography 메일링 리스트에 올라온지 10주년이 되는 해다. 아직 알려지지 않은 나카모토 사토시가 쓴 이 논문은 최초의 암호 통화로 비트코인을 만들었다. 현재 2천 개 이상의 암호화가 유통되고 있으며 전체 산업은 2천억 달러 이상의 가치가 있다. ¶2008년 ~ 2010년: 점을 찍은 해 비","text":"Bitcoin turns 10: An annotated timeline 원문 지난 수요일 (2018년 10월 31일) 은 비트코인 백서의 &quot;Bitcoin: Peer-to-Peer Electronic Cash System&quot;이 cryptography 메일링 리스트에 올라온지 10주년이 되는 해다. 아직 알려지지 않은 나카모토 사토시가 쓴 이 논문은 최초의 암호 통화로 비트코인을 만들었다. 현재 2천 개 이상의 암호화가 유통되고 있으며 전체 산업은 2천억 달러 이상의 가치가 있다. ¶2008년 ~ 2010년: 점을 찍은 해 비록 비트코인에 대한 초기 아이디어는 2008년 말에 처음 제안되었지만, 비트코인 네트워크가 처음 만들어진 것은 2009년 1월이었다. 심지어 그 때에도, 첫 해에 비트코인 거래는 없었고, 이는 비트코인의 실제 가격이 없었다는 것을 의미한다. 2010년 3월에 첫 번째 거래가 이루어졌는데, 지금은 없어진 BitcoinMarkets.com이다. 첫 번째 실제 비트코인 거래는 몇 달 후 Laszlo Hanyecz가 플로리다에서 10,000 BTC로 대한 피자 두 판을 샀을 때 일어났다. 2010년 비트코인의 최고가는 0.39달러였다. ¶2011년 ~ 2012년: 초창기, 그리고 마약 거래 다음 몇 년 동안 비트코인은 서서히 메인 스트림으로 자리잡았지만, 불행하게도 잘못된 이유로 인해서 였다. 익명의 온라인 화폐의 급진적인 가능성을 처음으로 파악한 사람 중 하나는 2011년에 다크웹 시장인 실크로드의 설립자인 드레드 피라테 로버츠였다. 악명 높은 온라인 사이트는 마약 판매로 지배되었고 비트코인을 통화로 사용했다. 약 10억 달러 상당의 비트코인이 2013년 FBI에 의해 폐쇄되기 직전까지 거래되었다. ¶2013년: 비트코인의 해 비트코인에 대한 미디어 언급이 증가하고, 새로운 비트코인의 관련 회사가 증가하고, 바이두와 오버스톡과 같은 대기업들이 비트코인을 화폐로 받아들이는 것에 동의하면서 2013년에 주료로 자리잡게 되었다. 2013년 초 주요 거래소인 코인베이스는 1개월 만에 처음으로 비트코인을 1백만 달러 이상 판매해 시장이 성장하고 있음을 보여 주었다. 실제로 비트코인은 2013년에 처음으로 큰 폭의 가격 상승을 겪었고 연말까지 1,200달러를 넘어섰다. 12월 포브스 기사에서 2013년 &quot;비트코인의 해&quot;로 선언했다. 하지만 중국 정부는 그 해 말 비트코인을 금지해 가격이 급락했다. ¶2014년: 마운틴 Gox 비트코인은 2014년 비트코인 거래소의 붕괴로 큰 타격을 받았다. 도쿄에 본사를 두고 있는 마운틴 Gox는 2014년 2월 85만 비트코인 상당의 대규모 해킹으로 인해 파산 신청을 했다. 2013년에 비트코인 가격 거품에도 꺼지기 시작했다. 1천 달러 가까이에서 시작했지만, 비트코인은 2014년 300달러까지 떨어졌다. ¶2015년 ~ 2016년: 벤처 캐피탈이 블록체인과 암호화폐에 투자하다 투자자들이 마운틴 곡스 파산으로 인해 손해를 보고 있음에도 불구하고, 벤처캐피털 회사들은 가상 화폐를 뒷받침하는 암호 데이터베이스 기술인 비트코인, 암호화폐, 블록체인의 잠재력을 깨닫기 시작했다. CB Insights에 따르면 2015년과 2016년에 걸쳐 비트코인과 블록체인 창업에 10억 달러 이상이 투자되었다. 이는 지난 3년간 투자한 것의 두 배 이상이었다. 오랫동안 비트코인을 해치고 조롱했던 은행들도 블록체인을 보기 시작했다. 2015년 Santander 보고서는 은행들이 새로운 기술로 이전함으로써 연간 200억 달러의 백오피스 비용을 절감할 수 있을 것으로 추산했다. 그러나 비트코인의 가격은 2014년 최고가를 경신하는 데 실패했다. ¶2017년: 비상 비트코인은 마침내 2017년에 2014년 최고가를 돌파했으며, 그 후에도 일부 가격이 올랐다. 2017년 암호화폐에 대한 관심이 높아지면서 가격이 폭등했다. 그것은 수많은 새로운 암호 화폐가 시작되면서 동시에 엄청난 양의 소매 투자를 끌어들였다. 비트코인은 2017년 말까지 2만 달러를 넘어서는 최고가로 급부상했고, 하루에 이례적으로 10% 이상씩 가격이 폭등하기도 했다. 가격이 치솟으면서, 더 많은 주류 금융 회사들이 그 자산을 보기 시작했다. 거래 사업자인 CBOE와 CME 그룹은 둘 다 12월에 비트코인 선물 거래를 시작했다. 그러나 이러한 상승세는 단기 수익을 노리는 투자자들에 의해 촉발된 것으로 보인다. 올해 말까지 분석가들은 거품에 대해 경고했다. ¶2018년: Hangover 비트코인과 다른 암호 화폐는 사람들이 2017년 가치 상승이 기본이 아닌 단기적인 이득에 주로 기인한다는 것을 깨닫기 시작하면서 2018년에 다시 바닥으로 떨어졌다. 비트코인은 올해 첫 3개월 동안 급격히 하락했지만, 현재 지난 두 달 동안 6,200달러 선에 머물고 있다. 이는 암호화폐의 변동성이 비정상적으로 낮은 기간과 일치했다. 지난 10월 파리에 본부를 둔 세계 금융세탁 감시기구인 금융행동 태스크포스(FATF)는 정부가 암호화폐를 감독하기 위한 규정을 제정할 것이라고 발표했다. 또한 10월에 증권 거래 위원회는 암호화폐 시장의 특정 부분에 대한 단속을 확대했다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인 백서는 성경이 아니다.","slug":"bitcoins-white-paper-is-not-a-bible-stop-worshipping-it","date":"2018-11-01T15:00:00.000Z","updated":"2018-11-02T11:49:52.000Z","comments":true,"path":"2018/11/02/bitcoins-white-paper-is-not-a-bible-stop-worshipping-it/","link":"","permalink":"https://www.yceffort.kr/2018/11/02/bitcoins-white-paper-is-not-a-bible-stop-worshipping-it/","excerpt":"Bitcoin’s White Paper Is Not a Bible – Stop Worshipping It 원문 비트코인의 백서가 발표된 지 10년이 지났고, 세계는 비트코인의 깊은 영향을 이해하는데 10년이 걸렸다. 또한 가용성과 확장성을 개선하기 위해 10년 동안 개발해 왔다. 하지만 우리의 이해를 발전시키기 위한 많은 시간에도 불구하고, 우리는 어떻게든 비트코인 백서를 성경처럼 해석하려고 하는 광신자들이 나타났다. 비트코인 백서는 성경도 아니고, 정확한 것을 의미하지도 않는다. 예를 들어, 비트코인의 백서는 버전 0.1의","text":"Bitcoin’s White Paper Is Not a Bible – Stop Worshipping It 원문 비트코인의 백서가 발표된 지 10년이 지났고, 세계는 비트코인의 깊은 영향을 이해하는데 10년이 걸렸다. 또한 가용성과 확장성을 개선하기 위해 10년 동안 개발해 왔다. 하지만 우리의 이해를 발전시키기 위한 많은 시간에도 불구하고, 우리는 어떻게든 비트코인 백서를 성경처럼 해석하려고 하는 광신자들이 나타났다. 비트코인 백서는 성경도 아니고, 정확한 것을 의미하지도 않는다. 예를 들어, 비트코인의 백서는 버전 0.1의 소스 코드가 공개되기 몇 달 전인 2008년 10월에 공개되었다. 그러나 소프트웨어 자체는 이미 1년 반 동안 개발되어 왔으며 백서에서 언급되지 않은 특징과 중요한 일치 규칙을 포함하고 있었다. “기능적인 세부 사항은 백서에 나와 있지 않지만 곧 소스코드가 나올 것입니다.” 라고 2008년 11월, 사토시 나카모토가 전했다. 백서는 사이퍼펑크 공동체를 위한 입문 텍스트로 만들어졌다. 사토시는 심지어 백서가 발표된 직후 할 피니에게 보낸 이메일에서 &quot;말보다 코드로 더 낫다&quot;고까지 말했다. 이것은 코드를 아는 사람들에게 명백한 것으로 판명될 것이다. 왜냐하면 이 백서에 언급되지 않은 것이 꽤 많기 때문이다. 그리고 그것은 심지어 틀린 주장들도 포함되어 있었다. 2100만개의 코인 제한: 비록 '미리 결정된 사항’이라고 언급되긴 했지만, 사토시는 코드 공개를 발표할 때 일정과 코인 갯수의 상한선을 두었다. 가장 긴 사슬: 다수의 수용된 거래 내역을 나타내는 체인은 흔히 &quot;가장 긴 체인&quot;으로 언급되는데, 오늘날 우리는 이것이 사실이 아니라는 것을 알고 있다. 'Height’에서 'Chain work’로의 변화는 2010년 7월에 사토시가 만들었다. 백서 자체는 업데이트되지 않았다. ASIC 채광: CPU 마이닝은 논문 전반에 걸쳐 언급되고 있다. 사토시는 나중에 &quot;컴퓨팅 클러스터는 결국 생성된 모든 코인을 독차지할 것&quot;이라고 말했으며 &quot;그 날을 앞당기고 싶지 않다&quot;고 말했다. 돌이켜보면 비트코인의 성공으로 인해 CPU 마이닝이 무의미해지는 것은 불가피합니다. 비트코인 스크립트 또는 스마트 컨트랙트 시스템: 사토시는 나중에 비트코인 스크립트를 &quot;에스크로 거래, 채권 계약, 제3자 중재, 다중 서명&quot;에 사용할 수 있다고 제안했지만, 스크립트 기능은 전혀 백서에서 언급되지 않았다. ¶Text in wind 하지만 백서가 빠르게 시대에 뒤떨어진다면 사토시는 알아채지 못할 것 같았다. 그는 그가 발표한 코드를 보다 정확하게 반영하도록 백서를 수정하는 것조차 신경 쓰지 않았다. 그의 초점이 이미 무의미 해지는 백서가 아니라 라이브 네트워크의 코드에 매우 집중했다고 생각한다. 이것은 실제 작동중인 네트워크의 설계를 상당히 변화시켰음에도 불구하고, 백서는 코드 자체의 후속 공개 소스 진화를 신성 모독으로 보는 일부 사람들에게는 사이비종교 텍스트가 되었다. 물론, 사토시는 비트코인에 대한 언급과 코딩을 계속했다. 이 시기는 사토시가 마침내 시간이 흐르면서 시스템이 어떻게 발전할 것인가에 대해 다른 사람들과 토론할 수 있었던 시기였다. 그의 생각은 항상 완전히 사장된 것은 아니었고, 그는 자신이 완벽하다고 주장하지도 않았지만, 계속해서 독창성을 발휘했다. 결국 다른 사람들의 상상력을 사로잡은 한 가지 아이디어는 그가 부르는 &quot;high frequency trades&quot;였다. 이를 통해 사용자는 브로드캐스트되기 전에 확인되지 않은 트랜잭션의 상태를 반복적으로 업데이트할 수 있었으며, 백서에 언급되지 않은 비트코인 코드의 일부 기능을 활용했다. 이 특별한 &quot;사후 백서&quot;는 크리스천 데커 박사의 “Duplex Micropayment Channels” 논문과 함께 오늘날의 라이트닝 네트워크의 기초를 형성했다. 다른 개발자들이 이 개념을 채택하고, 보안 문제를 해결하며, 이를 확장함에 따라, 우리는 이제 빠른 P2P 비트코인 마이크로 페이먼트 네트워크를 만들었다. 백서의 누락과 구현 자체와의 차이점들의 예를 들어 말하고자 하는 요점은 소프트웨어가 진화하지만 읽기 전용 텍스트 문서는 그렇지 않다는 것이다. 백서는 이미 훨씬 더 많은 시간과 노력을 들여서 코드 자체를 작성하려 했던 누군가에 의해 높은 수준의 소개를 하려는 시도였다. 그것은 지금까지 비트코인의 성공에 중요한 많은 세부사항들을 생략했지만, 일부 사람들은 소수 디자인 결정을 강요하려는 잘못된 시도로 그것을 신성한 성경으로 높이려고 했다. ¶진화는 계속 되는 중 이 모든 것은 소프트웨어 자체가 비트코인이 무엇인지를 정의하고, 수년간 대다수의 사람들의 집단적 시각으로 형성되어 네트워크에서 어떤 규칙이 시행되기를 원하는지 프로그래밍 방식으로 표현했다는 것을 보여 준다. 백서는 개인적인 해석에 따라 개방되어 있다. 코드의 실행은 그렇지 않으며, 합의로 이루어진 중요한 시스템의 인코딩된 규칙의 경우, 그 코드만이 중요하다. 그가 비트코인의 소스 코드를 발표했을 때, 사토시가 그가 위대한 사회적 가치를 대중에게 전하고 있다는 것을 알고 있었다고 생각한다. 하지만 그가 단지 10년 후에 그것이 얼마나 멀리 올지 상상할 수 없었을 것이라고 생각한다. 비용과 다른 사소함은 제쳐두고, 오늘날 비트코인의 기반시설에 쏟아지는 노력의 양은 특히 자원 봉사자들에 의해 많은 일이 수행되기 때문에 고무되고 있다. 최신 주요 릴리스(0.17)에는 700건 이상의 풀 요청이 포함되어 있으며 135명의 개발자가 이 요청에 기여했다. 블록체인이 계속 커지더라도 동기화 시간이 개선되고 있다. 우리는 여전히 전체 비트코인 블록체인(Bitcoin) 블록에서 체인 팁까지 2시간 반 안에 동기화할 수 있다. 이더리움은, 아직 까지 그정도는 아니다. NAT은 기본 계층을 위한 G’Root, Bulletible Transactions, Secret Assets, PSBT 및 Signature Ag Aggregation(Signal Ag consensusation)과 같은 새로운 기술을 보유하고 있으며, 라이트닝 네트워크에서는 개발자가 기본 프로토콜에 대한 합의 변경없이 실험할 수 있게 한다. Liquid 네트워크의 출범과 함께, 우리는 상호 교환 결제 개선을 위한 최초의 진정한 해결책을 가진 사이드 체인의 가능성을 실현하기 시작하고 있다. 이러한 모든 개발로 비트코인 공간의 혁신이 전례 없는 속도로 가속화될 것이다. ¶새로운 길 그가 비트코인 소스 코드를 발표했을 때 사토시가 모든 사람들에게 훌륭한 서비스를 제공했다는 것은 의심의 여지가 없다. 그는 수년간 컴퓨터 과학자들이 연구해 온 문제를 해결하기 위해 경제적 사회적 인센티브를 사용했다. 자신이라는 단 하나의 실패 지점으로 제거하고 다른 모든 사람들에게 프로토콜에 대한 통제권을 확실히 넘겨줌으로써, 그는 세계가 그의 코드 인센티브를 받은 다수 합의 메커니즘을 통해 그것의 진화에서 발언권을 갖도록 했다. “제가 어떻게 할 것인지 묻지 마세요. 그냥 옳은 일을 하세요.” – 스티브 잡스 스티브 잡스가 지나가기 전에 그는 팀 쿡에게 이 조언을 남겼다. 애플 직원들이 잡스가 무엇을 원했는지 추측하는 데 시간을 할애하는 것은 생산적이거나 효과적이지 않기 때문에 , 이말은 합리적으로 느껴진다. 미래는 항상 변하고 있으며 과거의 지혜만으로는 앞으로 나아갈 올바른 결정을 내리는 데 있어 핵심 역할을 할 수 없다. 나는 사토시 또한 사람들이 그의 백서에서 미래를 성스럽게 하려고 하는 것을 원하지 않았을 것이라고 확신한다. 특히 비트코인 코드베이스가 자신과 다른 사람들에 의해 광범위하게 수정되었기 때문이다. 여러분은 확실히 10년 된 텍스트를 가지고 그것이 개인적 선택을 하는 개인들의 분산 네트워크에 대한 권한을 가질 것이라고 기대할 수 없다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"스웨덴 e-krona 프로젝트 리포트1","slug":"e-krona-project-report1","date":"2018-10-31T15:00:00.000Z","updated":"2018-11-01T11:49:52.000Z","comments":true,"path":"2018/11/01/e-krona-project-report1/","link":"","permalink":"https://www.yceffort.kr/2018/11/01/e-krona-project-report1/","excerpt":"E-krona project, report 1 원문 RiskBank는 이른바 e-krona가 현금에 대한 대체재가 될 수 있는지, 그리고 그러한 지불이 안전하고 효율적이도록 촉진하는 작업에서 Riksbank를 지원할 수 있는지 여부를 조사하고 있다. 이것은 특이한 상황이 아니다. 이전에는 정부가 결제 시장에서 상황이 바뀌었을 때 그 역할을 재고해야 했다. e-krona는 앞으로 현금 사용이 급격히 감소하고 있을 때 결제 시장에서 발생할 수 있는 몇 가지 문제에 대응할 수 있는 잠재력을 가질 것이다. e-krona는 국가가 보증","text":"E-krona project, report 1 원문 RiskBank는 이른바 e-krona가 현금에 대한 대체재가 될 수 있는지, 그리고 그러한 지불이 안전하고 효율적이도록 촉진하는 작업에서 Riksbank를 지원할 수 있는지 여부를 조사하고 있다. 이것은 특이한 상황이 아니다. 이전에는 정부가 결제 시장에서 상황이 바뀌었을 때 그 역할을 재고해야 했다. e-krona는 앞으로 현금 사용이 급격히 감소하고 있을 때 결제 시장에서 발생할 수 있는 몇 가지 문제에 대응할 수 있는 잠재력을 가질 것이다. e-krona는 국가가 보증하는 현금에 대한 디지털 대체재로서 일반 대중이 접근할 수 있게 하며, 여러 결제 서비스 공급업체가 e-krona 시스템에 연결할 수 있게 한다. 현재 Riksbank는 RIX1 디지털 결제만 제공한다. e-krona 시스템은 상업 은행 시스템에서 사용하는 인프라와 독립적으로 작동함으로써, 예를 들어 카드 결제 시스템이 중단될 경우 결제 시스템을 더욱 견고하게 만들 수 있다. ¶현금 사용량 감소 21세기 스웨덴에서 우리는 현금 사용이 카드 결제와 동시에 감소했다는 것을 알게 되었고, 최근 몇 년 동안 Swish payment(스웨덴의 모바일 결제 시스템)은 점점 보편화 되었다. 소매 부문의 현금 사용 비율은 2010년 40%에서 2016년 약 15%로 떨어졌다. 소비자의 3분의 2는 현금 없이 관리할 수 있으며, SEK 100에 따른 결제에는 대부분 카드를 사용한다고 밝혀졌다. 멀지 않은 미래에, 스웨덴은 더 이상 일반적으로 현금이 받아들여지지 않는 사회가 될 수도 있다. 스웨덴 결제 시장의 발전은 국제적 관점에서 독특하다. ¶이러한 디지털화 추세는 원치 않는 영향을 초래할 수 있다. 이러한 발전은 사회 디지털화 추세와, 전적으로 민간 행위자가 주도하며, 소수의 상업적 참여자 결제 서비스 및 인프라로 통합될 수 있는 스웨덴의 결제 환경 조정으로 향하는 더 큰 흐름의 일부이다. 장기적으로 이러한 집중은 시장의 경쟁력을 억제하고 사회를 취약하게 만들 수 있다. 거의 현금 없는 사회를 향한 발전은 또한 일반 가정은 위험 없는 중앙 은행에 저축하게 만들며, 결제할 기회를 거의 갖지 못하게 하고 이것은 궁극적으로 결제 시스템의 회복력을 떨어뜨릴 수 있다. 우리는 또한 현재 디지털 결제 솔루션을 사용할 기회가 없거나 단순히 다른 결제 수단보다 현금을 선호하는 특정 그룹이 있다는 것을 알고 있다. 이러한 그룹들에게 사회는 대안을 제시할 수 있는 것이 중요하다. 스웨덴 우정사업본부와 통신 당국 및 행정 위원회가 일반 대중의 기본 결제 서비스 요구를 충족시키도록 보장할 책임이 있다. 금융 위기나 재정 불안 상황에서, 현금 수요가 증가할 것으로 가정될 수 있을 때, RiskBank가 궁극적으로 이에 대한 준비와 준비를 했더라도, 다른 참가자들에게 현금을 분배하는 데는 상당한 시간이 걸릴 것이다. 시스템적인 충격이 발생할 경우, 현금과 같은 신속하게 이용할 수 있는 무료 대안이 현재 존재하지 않을 위험이 있다. ¶가치 기반 e-krona로 보안되는 등록 기반 e-krona (A register-based e-krona that is supplemented with a value-based e-krona) 등록 기반과 가치 기반 e-krona는 e-krona를 위한 두 가지 모델로 표시된다. 등록 기반 e-krona를 사용하면 잔액이 중앙 데이터베이스의 계정에 저장되는 반면, 가치 기반 솔루션은 현재 현금과 더 비슷할 것이다. 그 가치가 앱이나 카드에 로컬로 저장되기 때문이다. 현재의 평가는 단순한 가치 기반 솔루션은 등록 기반 솔루션보다 개발 가능성이 더 제한적이지만, 더 빨리 도입될 수 있다는 것이다. 등록 기반 솔루션은 더 복잡한 것으로 간주되지만, 동시에 단계별로 모델을 확장하고 향후 수요를 조정할 수 있는 더 큰 가능성을 제공합한다. 이 프로젝트는 등록 기반 솔루션을 주로 오프라인으로, 소액 결제에 적합한 가치 기반 e-krona로 보완하는 두 모델의 조합을 제안한다. 가치 기반 솔루션은 e-krona 계정을 가질 수 없거나 원하지 않는 그룹이 e-krona에 보다 쉽게 액세스할 수 있도록 하며, 기본 결제 서비스에 대한 특정 그룹의 요구를 충족하기 위해 솔루션을 추가로 개발할 수 있다. ¶기술 선택은 더 조사될 필요가 있다. 어떤 기술이 e-krona에 가장 효과적일 것인가가 프로젝트에 의한 추가적인 조사가 필요한 문제다. 새로운 기술과 시험된 기술을 모두 사용할 수 있고, 공공 당국과 민간 행위자들과의 협력이 있을 수 있다. ¶통화정책과 재정적인 안정성에 대한 제한적인 효과 e-krona가 통화 정책뿐만 아니라 지불 시장 및 금융 안정에 대해 가질 수 있는 예비 분석 결과에서 e-krona의 도입에 대한 주요 장애물은 식별되지 않았다. 우리는 통화 정책 체계가 새로운 현실에 적응할 것이라고 생각한다. Riskbank는 일반 대중과 시장이 요구하는 지폐와 화폐의 양을 공급한다. 그들은 그들이 현재 지폐와 동전의 공급을 결정하는 것과 같은 방법으로 e-krona의 공급을 결정하는 것으로 가정할 수 있다. ¶e-krona 컨셉 이 프로젝트는 Riksbank 이사회가 일반 대중이 사용할 수 있는 디지털 중앙 은행 자금을 도입할 필요성을 느낄 경우 e-krona를 위해 다음과 같은 설계를 제안합니다. e-krona는 주로 소비자, 기업 및 당국 간 소액결제를 위한 것이다. e-krona는 Riksbank에 대한 직접적인 청구를 구성하며, 스웨덴 krona에 명시되며 일반 공공, 금융 기관 및 회사가 보유할 수 있다. 실시간, 하루 24시간, 주 7일, 1년 365일 액세스가 가능하다. e-krona는 어떠한 이자도 일단은 발생시키지 않지만, 나중에 관심을 가질 수 있도록 내장된 기능이 있어야 한다. 등록 기반 e-krona는 작은 금액의 오프라인 결제를 가능하게 하고 e-krona 계좌를 원하지 않거나 가질 수 없는 그룹의 가용성을 높이는 가치 기반 솔루션과 결합된다. Riksbank는 e-krona를 위한 기본 기능을 제공하지만, 기존의 디지털 인프라 사용 가능성을 조사하고 외부 행위자를 초청하여 최종 사용자와의 상호작용을 할수있도록 설계 되어야 한다. ¶관계자와의 논의 결제 시장의 발전은 사회 전체에 영향을 미치고, Riksbank는 이 보고서가 다양한 질문과 문제들을 어떻게 관리할 수 있는지에 대해 다양한 그룹과의 폭넓은 대화를 위한 길을 열어주기를 희망한다. e-krona를 위한 조건을 조사하기 위한 프로젝트의 다음 단계는 관련자들의 견해와 질문을 모으는 것이다. RiskBank는 e-krona를 발행하는 것에 대해 아직 어떤 결정도 내리지 않았다. ¶결론 1: 현금 사용량 감소는 다양한 문제를 야기한다. 상업용 결제 시스템은 보통 잘 작동하고 일반 대중들은 현재 현금을 포함한 여러 가지 다른 지불 서비스를 이용할 수 있는 창구를 마련해준다. 그러나 현금 사용은 감소하고 있고 전자 결제 서비스의 사용은 증가하고 있다. 이것은 아마 돌이킬 수 없는 과정일 것이다. 가까운 미래에 스웨덴은 사실상 무 현금이 될 수 있다. Riksbank의 지불 시장 개발에 대한 분석은 미래 시장에서 두 가지 잠재적인 문제를 발견했다. 첫째, 특정 소비자 및 기업이 현금 서비스에 제한된 접근 권한을 얻는 문제. 둘째, 전자 결제 시스템이 조정되고 소수의 소유주가 있,는 소수의 시스템에 통합되는 금융 인프라 때문에 결제 시스템의 비효율적인 효율성과 탄력성이 관련된 장기적인 문제가 있을 수 있다. 이러한 통합은 현재 이미 높은 수준이며, 궁극적으로 더 커질 수 있는 영향력이 있다. 셋째, 중앙은행 자금의 형태로 무위험 자산에 대한 일반 대중의 접근은 아마도 완전히 중단될 것이다. 따라서 가계는 중앙 은행 돈을 저축하고 지불할 가능성이 거의 없을 것이며, 이것은 결제 시스템의 회복력을 감소시키는 데 영향을 미칠 것이다. 또한 실제로 우리는 지폐의 독점 이전, 즉 민간 행위자들이 국가가 제공하는 결제 수단과 경쟁하는 상황에 처할지도 모른다는 것을 주목할 필요가 있다. 오늘 문제는, 만약 RiskBank가 실제로 발행한 지폐가 사라지면, 일반 대중들이 상업적인 은행 자금에만 접근할 수 있는 상황이 될 것이고, 그 다음에는 법적 입찰의 개념이 수반될 것인가? e-krona는 신용위험 없이 정부가 보증하는 지불수단을 구성할 수 있으며, 현금보증을 위한 디지털 형태로 일반 대중이 이용할 수 있다. 이러한 유형의 e-krona는 대부분의 사회가 더 이상 물건에 대한 지불이나 돈을 절약하기 위해 지폐와 동전을 사용하고 싶어하지 않을 때 리크스뱅크의 지불 수단의 현대화로 간주될 수 있다. 가능한 e-krona는 또한 민간 부문에서 현재 제공되는 결제 양식을 보완하는 역할을 할 수 있다. 이것은 지불 시장의 경쟁과 옵션에 도움이 될 것이다. 더욱이, 비상 상황에서 e-krona는 민간 행위자들이 능동적인 위기 대비 책임을 지고 결제 시장을 전체적으로 보도록 요구하는 것이 어려울 수 있기 때문에, 위기 상황에서 대안의 결제 수단으로서 중요한 기능을 수행할 수 있다. 실제로 이것이 작동하는 방식은 이 프로젝트의 범위 내에서 더 자세히 조사해야 한다. ¶결론 2: 등록기반 e-krona가 더 가능성이 있다. 등록 기반이든 가치 기반 또는 이 둘의 조합에 상관없이, Riksbank는 규제 기관이 직접 다루어야 하는 여러 가지 기본적인 기능들이 있다. 시스템 개발, 고객 실사, 돈세탁 방지, 거래 승인 및 고객 지원과 같은 기타 기능 중 일부 또는 전부를 다양한 시장 참여자가 수행할 수 있다. Riksbank의 예비 평가는 가치 기반 솔루션은 등록 기반 시스템보다 개발 잠재력이 더 제한적이지만 중앙 은행이 발행한 지불 수단에 대한 액세스를 보장한다는 것이다. 가치 기반 e-krona의 이점은 등록 기반 솔루션보다 더 빠르게 도입할 수 있다는 것이다. 가치 기반 e-krona는 보다 현대적인 새로운 형태의 현금이라고 볼 수 있다. 등록 기반 e-krona는 더 복잡한 해결책으로 간주되지만, 더 많은 사용자 그룹을 대상으로 보다 광범위한 서비스를 제공할 수 있기 때문에 더 많은 잠재력을 가지고 있다. 또한 미래의 요구사항에 맞게 레지스터 기반 솔루션(확장성)을 확장하는 것이 더 쉽지만, 초기에 개발 및 실행하는 데 더 많은 비용이 드는 것으로 보인다. 또한 두 모델은 서로 다른 그룹에 대해 가능한 특성과 사용성에 관해서도 다르다. 즉, 등록 기반 솔루션과 가치 기반 솔루션의 조합이 적절할 수 있다. 이렇게 하면, 미래 결제 시장에서 확인된 문제를 더 잘 해결할 수 있는 보다 포괄적인 결제 솔루션을 만들 수 있다. 이 결론들은 잠정적이며 더 검토되어야 한다. 다른 당국과의 협력은 e-krona의 개발을 단순화하고 보다 비용 효율적인 해결책을 제공할 수 있다. ¶결론 3: 기술 선택은 좀더 조사가 필요하다 e-krona의 도입은 모델 선택에 관계없이 일반 대중을 겨냥한 Riskbank의 서비스 도입으로 이어질 수 있다. 이는 일반 대중, 소비자 및 기타 최종 고객과 직접적인 관계가 없는 현재의 영업 방식에 비해 상당한 변화이다. 이는 Riksbank가 솔루션 선택에 따라 달라지지만 더 많은 운영 작업을 수행할 것이라는 것을 의미한다. e-krona 솔루션 개발이 단계적으로 이뤄지는 것이 중요하다. Riksbank는 DLT를 포함한 새로운 기술을 지속적으로 평가하고 e-krona 시스템에 사용할 수 있는 기존의 시험 및 시험 기술을 검토해야 한다. 빠른 개발로 인해 현재 어떤 기술적 솔루션을 사용할지 선택하는 것은 부적절하다. e-krona가 개발될 경우 새로운 기술과 테스트된 기술을 결합하는 것이 적절할 수 있다. 그러나 e-krona는 모든 상황에서 우수한 기술 품질을 유지하고 사용되는 기술에 관계 없이 최고의 보안 성능을 가져야 한다. 현재 이 보고서에 제시된 e-krona 모델을 오늘날의 기술로 개발하는 것은 가능하다. 만약 Riksbank 자체가 기본적인 기술 솔루션, 인프라 및 사용자 솔루션의 대부분의 개발에 책임이 있다면, 상당한 양의 장기 개발 작업이 수반될 수 있다. 다른 사람과 협력하여 e-krona를 개발하려면 Riksbank 부분에서 덜 광범위한 작업이 필요하며, 또한 작업이 더 빨리 진행될 수도 있다. ¶결론 4: (도입에 따른) 결과는 조금 더 연구가 필요하다. e-krona의 특징과 디자인은 통화 정책의 틀과 실행에 어떤 영향을 미칠 수 있는지에 결정적이어서 이 단계에서 어떤 결론도 도출하기 어렵다. 이 장의 목적은 프로젝트의 프레임워크 내에서 조사해야 할 문제를 더 많이 식별하고 강조하는 것이다. 결제 시장과 금융 안정에 대한 결과를 살펴보면, e-krona의 도입에 큰 장애물이 없다는 것이 이 프로젝트의 현재 평가이다. 여기서조차 e-krona의 특성과 설계는 영향을 미칠 수 있으며, 이는 결과를 더 잘 이해하기 위해 더 깊은 분석이 필요하다는 것을 의미한다. e-krona는 지폐와 동전, 즉 양적 제한 없이 같은 방식으로 공급되어야 한다. Riksbank의 입장은 원칙적으로 e-krona가 자체 비용을 부담해야 한다는 것이다. e-krona 비용 책정 원칙은 추가로 조사되어야 한다, e-krona에 대한 수요는 아마도 제한적일 것인데, 이는 은행들이 예금 계좌의 이자율을 올릴 것이기 때문이고, e-krona가 소액 결제에만 가장 적합하기 때문이다. 이것은 Riksbank의 대차대조표, 통화정책 및 재무안정성에 미치는 영향이 미미하다고 가정된다는 것을 의미한다. 심지어 현재 결제 서비스 제공자들이 사용하고 있는 사업 모델에 미치는 영향도 작을 것으로 예상된다. ¶결론 5: Sveriges Riksbank Act를 검토해야 한다. 우리가 제기하는 문제들은 너무 크고 중요해서 우리는 그들이 국회의원의 철저한 심의를 필요로 한다고 평가한다. 사회가 현재의 법안이 통과되었을 때, 이와는 관련이 없는 디지털화의 과정을 겪고 있다는 관점에서 Sveriges Riksbank 법을 검토하는 것이 적절하다. Riksbank의 과제는 스웨덴에 지폐와 동전을 제공하고 안전하고 효율적인 지불 시스템을 보호하는 것을 포함한다. e-krona에 추가 법률이 필요한지 여부를 결정해야 하는 것은 궁극적으로 입법자이다. 보고서에 설명된 결제 시장의 추세가 계속된다면, 우리는 입법에 따른, 유일한 법정 화폐가 더 이상 이용 가능하지 않은 상황에 처하게 될 것이다. 이것은 또한 법정 화폐의 개념을 검토해야 한다는 것을 의미한다. ¶최종결론 스웨덴에서의 현금 사용은 꾸준히 감소하고 있으며, 한동안 그 추세가 계속될 것이다. 두 가지 주요 이유는 소비 패턴의 변화에 기여하는 전자 결제의 간편성, 접근성을 높이는 기술적 발전과 더 이상 시장이 이전과 같은 방식으로 현금을 공급하지 않는다는 점이다. 신속하고 간단한 전자 지불 방법에 대한 요구가 앞으로 높은 미래에도 지속될 것으로 예상됨에 따라, 결제에 대한 새로운 방법과 기술은 지속적으로 개발되고 있다. 현금 사용은 아마도 계속해서 감소할 것이다. 결제 시장은 규모의 경제와 시너지 효과의 달성을 위해 노력하며, 이는 시장을 높은 집중도로 몰아가고 있다. 따라서 머지 않은 장래에 스웨덴은 일반적으로 현금을 받지 않는 경제가 될 수 있으며, 결제 시장이 소수의 민간 참여자와 지불 서비스에 집중되어 있는 나라가 될 수 있다. 이러한 집중은 위험을 초래할 수 있고 경쟁을 방해할 수 있다. Riksbank는 안전하고 효율적인 지불 시스템을 촉진하고 스웨덴에 지폐와 동전을 제공하는 법적 업무를 가지고 있다. 이 보고서의 한 결론은 결제 시장 개발이 계속된다면 이러한 업무를 완료할 가능성이 저하될 수 있다는 것이다. e-krona는 Riksbank가 발행한 새로운 전자 지불 수단의 도입은 발생할 수 있는 문제들을 상쇄할 것이다. e-krona가 은행 소유의 상용 인프라와 독립적으로 작동할 수 있는 대체 플랫폼이나 인프라를 제공하는 경우, 결제 시스템이 기술적 중단과 재정적 불안 상황을 더 잘 견뎌낼 수 있도록 하는 데 기여할 수 있다. 또한 신규 참여자가 설립되기 보다 쉽고 e-krona를 기반으로 결제 서비스를 구축할 수 있는 기회를 제공함으로써 효율성 향상에 기여할 수 있다. 이것은 Riksbank가 안전한 결제 시스템을 장려하는 권한과 일치한다. Riksbank의 역할은 자연적 이유로 개별 시장 참여자들이 부족하다고 예상할 수 있는 결제 시장의 기능에 대한 전체적인 접근 방식을 취하는 것이다. 가능한 e-krona의 목적은 미래 결제 시장에서 발생할 수 있는 문제를 관리하고 일반 대중이 중앙 은행 자금에 접근할 수 있도록 하는 것이다. Riksbank는 e-krona를 일반적으로 시장에 내놓기 위해서는 시간이 걸릴 것이라고 평가한다. 그러므로 Riksbank가 e-krona에 투자할 수 있는 투자는 단기적인 비용-효익 분석이 아니라 장기적이고 전략적인 목표에 근거해야 한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"스웨덴 e-krona 프로젝트 리포트2","slug":"e-krona-project-report2","date":"2018-10-30T15:00:00.000Z","updated":"2018-10-31T11:49:52.000Z","comments":true,"path":"2018/10/31/e-krona-project-report2/","link":"","permalink":"https://www.yceffort.kr/2018/10/31/e-krona-project-report2/","excerpt":"E-krona project, report 2 원문 스웨덴에서는 현금 사용이 계속 감소하고 있다. 미래에는 현금 사용이 소외되어 지불 수단으로 사용하기가 어려워 질 수 있다. 350년 동안 Riksbank는 일반 대중에게 화폐를 제공했지만 앞으로 나아가면서 기술 개발 및 지불의 디지털화로 인해 주 정부의 역할 문제가 수면 위로 떠오를 것이다. 현금 사용의 소외가 계속된다면, 디지털 크로나인 ekrona는 일반 대중이 여전히 주정부가 보장하는 지불 수단에 액세스할 수 있다. 또한 현재의 개발 상황에 대처하지 않고 지불 시장을 민간","text":"E-krona project, report 2 원문 스웨덴에서는 현금 사용이 계속 감소하고 있다. 미래에는 현금 사용이 소외되어 지불 수단으로 사용하기가 어려워 질 수 있다. 350년 동안 Riksbank는 일반 대중에게 화폐를 제공했지만 앞으로 나아가면서 기술 개발 및 지불의 디지털화로 인해 주 정부의 역할 문제가 수면 위로 떠오를 것이다. 현금 사용의 소외가 계속된다면, 디지털 크로나인 ekrona는 일반 대중이 여전히 주정부가 보장하는 지불 수단에 액세스할 수 있다. 또한 현재의 개발 상황에 대처하지 않고 지불 시장을 민간 대리인에게 완전히 맡기는 것은 궁극적으로 일반 대중을 전적으로 민간 지불 솔루션에 의존하게 만들 게 될 것이며, 이로 인해 Riksbank가 안전하고 효율적으로 지불 시스템으로 남는 것을 어렵게 할 수 있다. 중앙은행 디지털 통화 (CBDC)는 현재 전 세계 여러 중앙은행에 의해 분석되고 있는, 비교적 미개척으로 남아있는 영역이다. 스웨덴이 e-krona를 도입해야 하는지에 대한 입장을 취하는 것은 시간이 걸릴 것이다. e‐krona의 결과 및 영향에 대한 지식을 높이려면 분석을 계속해야 한다. 동시에 e-krona를 개발하고 테스트할 수 있도록 기술 솔루션을 고안해야 한다. 이 보고서에서, 프로젝트는 Riksbank가 어떤 솔루션이 실용적이고 실현 가능한지 테스트하기 위해 e-krona를 위한 기술 솔루션을 설계하기 시작할 것을 제안한다. 추가로, 이 프로젝트는 Riksbank가 Riksbank의 권한과 e‐krona의 법적 지위를 명확히 하기 위해 필요한 법률 개정을 위한 제안서를 작성하는 것을 제안한다. ¶현금 사용이 줄고 있다. 2018년 조사에 따르면, 현금이 구매로 사용되는 것은 고작 13%였다. 2010년의 수치는 39%였다. 더 많은 소비자들이 전자 결제에 의존하게 됨에 따라, 소매상들이 더 이상 현금을 받는 것은 궁극적으로 수익성이 없을 것이다. 이러한 추세가 계속된다면 스웨덴은 몇 년 안에 더 이상 가계와 소매업자들이 일반적으로 현금을 받을 수 없는 위치에 있게 될 것이다. ¶국가가 결제 시장에서 역할을 해야 한다. 오랫동안, 국가는 일반 대중들에게 지불에 사용할 지폐와 동전을 제공해왔다. 현금은 대중의 신뢰를 얻었고 상품과 서비스의 무역을 촉진했다. 오늘날의 디지털 결제 시장은 우리가 일반 대중이 이용할 수 있는 모든 지불수단을 발급하고 사설 대리인에 의해 통제되는 새로운 상황에 직면하고 있다는 것을 의미한다. 만약 중앙 은행을 통해 국가가 강력한 민간 결제 시장의 대안으로 제공할 지불 서비스를 가지고 있지 않다면, 그것은 경쟁력 하락과 안정성이 떨어지는 결제 시스템을 야기시킬 수 있고 특정 그룹에게 결제를 어렵게 할 수도 있다. 궁극적으로는 스웨덴 통화 시스템의 기본 신뢰가 약화될 위험이 있다. 이러한 문제들 중 일부는 e-krona에 의해 중화되거나 완화될 수 있다. ¶e-krona는 무엇을 제공할 수 있는가? e-krona는 물리적 현금에 대한 대안으로 전자 형태의 크로나가 될 수 있다. 그러면 대중은 계속해서 중앙 은행 자금에 대한 일반 접근을 할 수 있을 것이다. e-krona는 또한 민간 시장이 위기 상황에서 지불이 제대로 기능하도록 모든 책임을 질 것으로 기대할 수 없기 때문에 대비 태세를 강화할 수 있다. 심각한 위기 상황에서, 민간 결제 시스템이 고장날 경우, e-krona는 대안적인 시스템으로서 작용하여 결제 시스템 전체의 안정성을 높일 수 있다. 따라서 e-krona는 안전하고 효율적인 결제 시스템을 촉진하는 데 도움이 될 수 있다. e‐krona는 가정과 기업에 서비스를 제공하고자 하는 경우 결제 서비스 제공 업체가 참여할 수 있는 경쟁력 있는 중립적인 인프라를 제공할 수 있다. 이것은 경쟁을 증가시키고 혁신을 이익을 줄 수 있으며 일반 대중에게 부과되는 수수료를 약간 줄일 수 있다. 현재 사회에는 여러 가지 이유로 디지털 결제 솔루션을 사용하기 어려워 현금 사용이 감소함에 따라 문제에 직면하고 있는 단체들이 있다. 이러한 집단에는 노년층, 장애인 또는 여러 가지 이유로 현금 외의 결제 상품에 접근할 수 없는 사람들이 포함된다. 민간 시장이 이들 그룹에 충분히 부응할 것으로 기대할 수는 없기 때문에 국가는 그들을 위해 더 큰 책임을 지는 쪽을 선택할 수 있다. 이것은 예를 들어 간단하고 사용하기 쉬운 e-krona를 설계하거나 민간 부문이 더 큰 책임을 질 수 있도록 입법 및 규제함으로써 이루어질 수 있다. ¶e-krona, 가치기반 또는 계좌기반? e-krona는 Riksbank의 계좌에 보관하거나 카드 또는 휴대 전화 앱 (가치 기반)과 같이 로컬로 저장할 수있는 스웨덴 크로나로 설명 할 수 있다. 두 가지 유형의 ekrona는 디지털 크로나의 정당한 소유자인 거래를 기록하고 보호할 수 있도록 기본 레지스터가 있다고 가정한다. 즉, e-krona와의 디지털 트랜잭션을 추적할 수 있다. 온라인 구매나 실제 상점에서 e-krona를 실제로 사용할 수 있으려면 e‐krona 플랫폼이 e‐krona의 기본 레지스터를 포함하는 다른 많은 시스템 및 시스템과 상호 작용해야 한다. 예를 들어, 은행과 다른 기업들은 가정과 회사에 결제 서비스를 개발하고 제공할 수 있도록 e-krona 플랫폼에 가입할 수 있어야 한다. 또한 e‐krona를 플랫폼 안팎으로 이동할 수 있도록 돈세탁 점검과, 문제 해결 시스템 링크를 지원하는 시스템도 필요하다. 법률적으로 말하면 가치 기반 e-krona는 전자화폐로 분류되는 반면 계좌 기반 e-krona는 예치금에 비유할 수 있다. e‐krona는 현금이 현재 있는 것과 같은 방식으로 제공될 수 있으며 (도메인과는 무관하게) 가정과 회사에서 광범위하게 사용할 수 있다. 그러나, e-krona 계좌를 열기 위한 신청서는 개인 은행에서 은행 계좌를 개설했을 때와 마찬가지로 정해진 규칙과 조건에 따라 평가되어야 할 수도 있다. 본 프로젝트의 결과는 e-krona의 도입이 안전하고 효율적인 지불 시스템을 촉진하는 Riksbank의 업무와 호환된다는 것이다. 그러나 그것의 디자인은 스웨덴 은행법의 개정 필요성에 영향을 미친다. 가치 기반 e‐krona는 Sveriges Riksbank Act와 호환된다고 간주되지만, Riksbank가 계좌 기반 e‐krona를 발행하기 위한 명확한 권한을 가지려면 이 Action이 필요하다. 그 프로젝트는 Riksbank가 그러한 명확한 권한을 제공하기 위해 필요한 개정안에 대한 구체적인 제안서를 작성하기 위한 조사를 시작할 것을 제안한다. ¶e-krona에 대한 수요는 통화정책과 금융 안정을 가져올 수 있다. e-krona의 통화 정책 및 금융 안정성은, e-krona에 얼마나 큰 수요가 있을지에 따라 달라진다. 차례로 수요는 e-krona가 어떻게 설계되는가에 따라 달라진다. 이 보고서의 결론은 만약 e-krona가 상당한 수요를 가지고 있고 널리 이용가능하다면, 그 수요를 통제하는 것이 유익할 것이라는 것이다. 이 경우 금리는 통화 정책과 금융 안정성에 미칠 수 있는 부정적인 영향을 제한할 수 있는 다른 가능한 수단들 중 하나가 될 수 있다. 수요가 적을 경우 금융 시스템에 미치는 영향은 미미할 것이다. 은행들은 예금을 조금 덜 받을 수도 있고 따라서 자금을 확보해야 할 것이다. 금융 위기가 있을 때, 국민들이 (상대적으로) 약한 은행에서 많은 돈을 인출하고 싶을 때, e-krona는 전통적인 은행 시스템에서 현금으로 운영되는 것보다 쉽고 신속하게 국가 보증 된 돈을 운영 할 수 있다. 그러나 Riskbank는 이미 금융 안정에 위험이 있다고 여겨지면 이러한 상황에 대처할 수 있는 수단을 가지고 있다. ¶이 프로젝트는 Riskbank가 가치기반 e-krona를 위한 기술 솔루션을 구축할 것을 제안한다. 이 프로젝트는 Riksbank가 e-krona를 발행할지 여부를 결정하기 전에, Riksbank에 운영 및 지식의 더 큰 공간을 제공하는 포괄적인 e-krona 개념에 대한 하나 이상의 가능한 기술 솔루션을 개발하기 위한 파일럿 프로그램을 시작할 것을 제안한다. 이 프로그램의 제안 된 초점은 이자없이 추적 가능한 거래로 선불 가치 (전자 화폐)를 구성하는 e-krona를 개발하는 데 있어야 한다. 계정 기반 ekrona는 다른 중앙 기관과의 조정이 필요하다. 따라서 계좌 기반 크로나에 대한 e-krona 시스템은 다른 기관과의 제휴로, 그리고 아마도 파트너십으로 구축 될 수 있다. 결제 시장에서의 디지털화에 대한 스웨덴의 입장도 초안을 작성해야 한다. 이 프로젝트는 Riksbank가 이 문제에서 기관 간 대화를 시작할 것을 제안한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"소셜 미디어에서 금지되고 있는 ICO 광고","slug":"big-tech-are-banning-crypto-and-ico-ads-is-there-a-reason-to-panic","date":"2018-10-29T15:00:00.000Z","updated":"2018-10-30T11:49:52.000Z","comments":true,"path":"2018/10/30/big-tech-are-banning-crypto-and-ico-ads-is-there-a-reason-to-panic/","link":"","permalink":"https://www.yceffort.kr/2018/10/30/big-tech-are-banning-crypto-and-ico-ads-is-there-a-reason-to-panic/","excerpt":"Big Tech Are Banning Crypto And ICO Ads - Is There A Reason to Panic? 원문 페이스북, 인스타그램, 트위터를 포함한 주요 소셜 미디어 플랫폼은 최근 암호화폐와 ICO 광고를 금지했고, 구글은 2018년 6월에 유사한 규정을 도입할 예정이다. 페이스북은 이러한 광고들이 '기만적인 홍보 관행’과 관련이 있으며, 암호폐와 ICO 관련 광고에 대해 비슷한 조치를 취한 다른 소셜 미디어 기업들에게 선례를 남기는 것과 관련이 있다고 처음 말했다. 전면 금지령은 분명히 시장에 약간의 손","text":"Big Tech Are Banning Crypto And ICO Ads - Is There A Reason to Panic? 원문 페이스북, 인스타그램, 트위터를 포함한 주요 소셜 미디어 플랫폼은 최근 암호화폐와 ICO 광고를 금지했고, 구글은 2018년 6월에 유사한 규정을 도입할 예정이다. 페이스북은 이러한 광고들이 '기만적인 홍보 관행’과 관련이 있으며, 암호폐와 ICO 관련 광고에 대해 비슷한 조치를 취한 다른 소셜 미디어 기업들에게 선례를 남기는 것과 관련이 있다고 처음 말했다. 전면 금지령은 분명히 시장에 약간의 손해를 끼쳤다. 그것은 산업 종사자들에게 어떤 홍보 수단을 빼앗았을 뿐만 아니라 전체적으로 암호 화폐의 오명화에 기여했다. 하지만, 항상 긍정적인 면이 있다. 일부 전문가들은 단속이 실제로 산업의 합법화로 이어질 수도 있다고 주장한다. ¶암호화폐 광고 금지 타임라인 1월 30일 페이스북은 ICO와 암호해독을 구체적으로 지칭하는 &quot;주도적 또는 기만적인 홍보 관행&quot;을 사용하는 광고를 금지할 것이라고 블로그 게시물을 통해 발표했다. Facebook의 제품 관리 이사인 Rob Leathern은 다음과 같이 설명했다. “우리는 사람들이 사기나 속임수에 대한 두려움 없이 페이스북 광고를 통해 계속해서 새로운 제품과 서비스에 대해 발견하고 배우기를 원합니다. 그렇긴 하지만 현재 선의로 운영되지 않는 ICO 및 암호 화폐를 광고하는 많은 회사들이 있습니다.” 이 금지령은 굉장히 광범위하게 적용될 의도였으며, 소셜 미디어 거인들이 플랫폼 (페이스북, 인스타그램 등)의 모든 암호 화폐 광고를 먼저 금지하고, 실제로 &quot;기만적&quot;으로 행동하는 광고에 대해 찾아보는 것으로 의도되었다. 업계의 일부 소식통은 페이스북이 미국의 규제 기관이 몇 달이 걸릴 수 있는 명확한 정책을 발표하기를 기다릴 것이라고 추측했다. 실제로 페이스북의 움직임은 2017년 12월 발행된 암호 관련 투자와 ICO에 관한 미국 증권거래위원회(SEC)의 공개 발표와 일치하는 것으로 보였다. 이 성명서에서 SEC의 제이 클레이튼 회장은 (암호화폐의) 인기 상승으로 인해 암호 통화 및 ICO 시장에서 &quot;사기 및 조작&quot;에 대한 추세가 증가하고 있다고 주장했다. 클레이튼은 또한 투자자들에게 SEC에 등록된 ICO가 없다고 경고했다. 기본적으로 페이스북은 구글 등이 따라야 할 다른 대기업들의 선례를 세웠다. 3월 14일, 당시 구글이 부인했던 애드센스 정지 및 계정 종료에 관한 암호 화폐 광고의 보도가 나온 직후, 구글은 2018년 모든 유형의 암호폐 관련 광고를 금지할 것이라고 발표했다. 이 정책은 구글 검색, 유튜브 등 구글 소유의 플랫폼, 제3자 사이트의 디스플레이 광고에 적용될 것이다. Google의 지속 가능한 광고 담당 이사인 Scott Spencer는 암호 통화 관련 광고를 금지하기로 한 결정을 설명하면서 CNBC에 다음과 같이 말했다. 우리는 미래에 암호 화폐가 어디로 갈지 알 수 있는 수정 구슬은 없지만, 우리는 소비자 피해나 소비자 피해에 대한 충분한 가능성을 보아왔다. 그것은 우리가 극도로 조심스럽게 접근하기를 원하는 분야이다. 3월 26일, 트위터는 암호화폐 관련 광고를 단속하는 페이스북과 구글을 따를 것이라는 소문이 옳다는 것을 확인해 주었다. 그 금지령은 ICO와 토큰 판매만을 대상으로 했다. 또한 이 정책은 주요 증권거래소에 상장되지 않는 주식 거래에 대해서도 포함되어 있었다. 블룸버그 통신은 &quot;우리는 이러한 콘텐츠가 속임수와 관련이 있다는 것을 알고 있으며, 이러한 유형의 계정이 다른 사람들과 기만적인 방식으로 관여하는 것을 막기 위해 몇 가지 신호를 적극적으로 구현하고 있다&quot;고 설명했다. 최근 보도에 따르면 Snapach를 이끄는 Snap Inc.는 2월부터 토큰 판매를 위한 광고를 자동으로 제한하고 있으며 나머지 암호폐 광고 유형에 대한 향후 계획은 여전히 불투명하다고 밝혔다. 이 시점에서 모든 주요 소셜 미디어 플랫폼은 암호 통화 및 ICO 광고에 대한 제한을 발표를 마쳤다. 페이스북과 트위터가 온라인 광고 시장의 약 60-70%를 장악하고 있다는 것을 주목할 필요가 있다. ¶암호화폐, ICO광고 금지로 인한 시장 통행 금지 페이스 북의 발표가 1월 30 일에 발표된 직후 비트 코인은 2월 5 일까지 약 10,166 달러에서 6,914 달러로 붕괴되었지만 2월 20 일까지 가격이 11,228 달러로 상승했다. 구글이 암호 화폐와 ICO 광고를 단속할 계획이라는 소식을 듣고 3월 14일 비트코인은 8,000달러 이하로 급감해 약 9퍼센트의 가치를 잃었다. 3월 26일 트위터 금지 발표 직후인 3월 말까지 Bitcoin은 또 다른 폭락을 기록했다. 3월 29 일에 7500 달러 이하로 떨어졌고, 그 결과 가파른 매각과 주주들에 대한 우울한 한 주가 되었다. ¶ICO가 실제로 영향을 받았다기보다는, 일종의 낙인이 찍혔다. 블록체인 기반의 소셜 네트워크인 Narraction의 CEO인 Rosemary O’Neill은 Cointelleg에게 토큰 판매 프로젝트가 실제로 주요 소셜 미디어 플랫폼에 크게 의존하지 않는다고 밝혔다. 대부분의 ICO 프로젝트는 이미 대규모 소셜 미디어보다는 ICO 관련 사이트, 니치 e-메일 뉴스레터, 텔레그램 채널, 디코드 룸에 훨씬 더 집중하고 있습니다. 우리는 항상 청중들이 어울리는 곳에 가길 원하며, (페이스북에게는 미안하지만) 암호화폐 지지자들은 거기에 집중하지 않습니다 하지만 그에 따르면, 비록 소폭이지만, 올바른 고객을 찾는 과정은 실제로 최근의 일련의 금지로 영향을 받았다고 언급했다. “암호화/블록체인 프로젝트 세계에서는 일반적으로 두 단계의 청중이 있습니다. 토큰 판매를 위해 암호화폐 투자자 (1단계) 또는 알트 코인 매니아를 대상 (2단계) 의 잠재적 고객이 있다. 최근의 광고 금지조치는 1단계에서는 좀 더 넓은 네트워크를 만드는 것을 어렵게 만들 뿐이다.” 오닐은 최근의 금지 조치가 암호 통화의 오명을 씌운 것 처럼 보이지만, 그의 회사가 토큰 판매 참가자 측면에서 큰 손실을 경험하지 못했다고 주장했다. 그러나 일반적인 사람들에게 암호화폐에 대해서 심리적인 영향을 미친 것은 분명하다. 구글이 광고를 금지한다고? 그건 분명 그럼 나쁜 거겠네. 하지만 이는 애석하게도 사실이 아니다. 마케팅 및 홍보회사인 마켓블록의 창립 파트너인 벤 노블은 구글의 금지 조치 이후에는 시장이 결코 예전같이 않을 것이라고 추측했다. 구글 광고 금지라는 단순한 발표가 시장을 크게 축소시켰다. 대부분의 피해는 이미 받았다. 그러나 이 금지 조치는 organic 마케팅 패러다임에 적합하지 않은 회사들 사이에서 시장 축소를 더욱 심화시킬 것이다. 좋은 기술은 일반적으로 그 자체로 의미가 있다. 그러나 (이러한 조치를 피하는) 영리한 마케팅은 일부 블록 체인 회사를 떠오르게 할것이다. 노블에 따르면 기업들은 유료 (소셜미디어) 광고에서 직접 마케팅, 홍보, 브랜드 저널리즘 및 검색 엔진 최적화(SEO)로 자원을 옮겼다. “유료 플랫폼이 줄어들면서 블록체인 기업들은 마케팅 예산으로 계산된 결정을 더 많이 내려야 합니다. 불행히도, 갑작스런 단속으로 시장이 균형을 잃게 되었습니다. 언론인들은 불협화음에 빠져들고 있으며, 소셜미디어 채널에 봇과 스팸 게시가 가속화되었습니다.&quot;. 퓨전의 임원인 노엄 코헨은 거대 IT 기업의 단속으로 인해 발생하는 오명이 증가하고 있음을 확인했다. “물론 ICO에서 부상하고 있는 사기의 증가와 새로운 벤처 사기의 정도를 확인하는 데 어려움이 커짐에 따라 대중의 인식이 이 암호 화폐 영역에 대해 더 부정적으로 변하고 있다고 생각합니다.”. “표면적으로 모든 ICO는 이제 웹 사이트 디자인, 카운트 다운 시계 (ICO가 언제 시작되는지 나타내는), KYC [고객을 알 수 있음] 등등이 비슷하게 보입니다. 유머러스한 밈이 성공적인 ICO의 템플릿을 조롱하는 것처럼 보였습니다. 이 '승리 템플릿’은 너무 널리 채택되어 백서를 읽을만큼 기술에 정통하지 않은 많은 사람들에게 좋은 프로젝트와 사기를 구별하는 것이 훨씬 어려워졌습니다. 새로운 프로젝트에 대한 기본 태도는 극단적인 회의론이다.” 그 결과, 소셜 미디어 플랫폼이 고객을 보호하기 위해 급급했다. &quot;이러한 분위기에서, 사람들은 그러한 새로운 프로젝트에 대한 광고가 언론/채널을 돕고 부추기는 것으로 인식되어 새로운 정책에 대한 책임을 야기한다고 생각할 수 있다.&quot;고 그는 말한다. 또한 나쁜 행위자로부터 소비자를 보호하는 것이 잘못된 것은 아니지만, 합법적인 사업에는 더 섬세한 행동이 필요하다고 덧붙였다. “우리는 이러한 금지 조치가 궁극적으로 세계가 변화하는 블록체인과 암호 통화 기술에 대한 열정을 약화시키는 일이라고 생각합니다. 좋은 소식은 광고 금지가 그 기술이 일어나는 것을 막을 수 없다는 것입니다. 그것은 양동이로 파도를 막으려고하는 것과 같습니다. &quot;. 많은 수의 사기가 합법적인 ICO와 비교하여 두드러지는 경향이 있다. 사기 범죄자들은 빠르게 가져갈 돈을 찾고 있고 종종 메시지의 질보다는 홍보량에 의존한다. 그들은 논리에 분명한 허점을 남기는 경향이 있다. 노블은 &quot;만약 당신이 회사가 하는 일을 이해하지 못한다면 투자하지 말라&quot;고 덧붙인다. ICO 팀의 온라인 존재 여부도 항상 조사해야 한다. &quot;Crypto Portfolio: Crypto Portfolio: Cryptocus Investing&quot;의 저자인 Jonathan Hobbs는 이렇게 말한다. &quot;만약 관련 정보를 구글이나 링크드인에서 찾지 못한다면, 이는 (그 실체가) 존재하지 않을 가능성이 크다) ICO의 소셜 미디어 마케팅 외에도 다른 요인들도 있다. 홉스는 ICO 프로젝트 팀의 강점과 소위 '토큰 경제’라는 두 가지 중요한 요인을 강조한다. “토큰 경제학은 ICO 투자가 어떻게 구조화되어 투자자에 대한 잠재적 가치를 결정하는지에 대한 다양한 측정 기준을 포함합니다. 예를 들어 여기서 고려해야 할 간단한 측정 기준은 ICO의 토큰 가격이며, 총 코인의 공급량과 비교하여 프로젝트 팀이 이미 로드맵에 제시한 목표를 달성하는데 있어서 얻은 견인력이 될 것입니다.” ¶이러한 금지 조치가 실제로 ICO 업계를 어떻게 합법화 시킬것인가 홉스는 규제완화가 장기적으로 ICO 시장에 반드시 해로울 필요는 없다고 믿는다. “구글, 페이스북, 트위터와 같은 회사들에 의한 ICO 광고의 금지는 일부 사람들에게는 최선의 것으로 보이지 않을 수도 있지만, 향후 몇 년 동안 ICO 산업을 더욱 합법화하는 데 도움이 될 수 있다. 광고하는 능력을 제한함으로써, 사기꾼들을 의심하지 않는 소매 투자자들을 찾아서 그들의 프로젝트를 팔아 벌이는 것이 더 어려워집니다.” 그는 또한 주류 주식 회사가 &quot;규제 악몽&quot;으로 인해 유료 광고를 통해 대중에게 서비스를 홍보하지 않는다고 지적한다. 홉스는 “암호 화폐와 ICO가 대형 기관 투자자들(큰 은행, 연금 펀드, 자산 관리자 등)에 의해 더 진지하게 받아들여지면, 이러한 주식회사와 똑같이 해야 한다”고 믿었다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"토큰화된 자산에서 어떻게 가치가 만들어지는가?","slug":"how-value-is-created-in-tokenized-assets","date":"2018-10-28T15:00:00.000Z","updated":"2018-10-29T11:49:52.000Z","comments":true,"path":"2018/10/29/how-value-is-created-in-tokenized-assets/","link":"","permalink":"https://www.yceffort.kr/2018/10/29/how-value-is-created-in-tokenized-assets/","excerpt":"How Value is Created in Tokenized Assets 원문 ¶1. Introduction 2010년 5월, 초기 비트코인 개발자인 Laszlo Hanyecz는 비트코인을 사용하여 처음으로 공개 구매를 했다. 그 당시, 그 비트코인은 약 40달러의 가치가 있었다. 오늘날 그것들은 1억달러의 가치가 있을 것이다. 이 이야기의 가장 일반적인 해석은 Hanyecz가 피자 값을 너무 많이 지불했다는 것이다. 우리는 Hanyecz가 새로운 기술에 대한 신뢰를 쌓음으로써 엄청난 가치를 창출했다는 다른 관점에서 바라본다.","text":"How Value is Created in Tokenized Assets 원문 ¶1. Introduction 2010년 5월, 초기 비트코인 개발자인 Laszlo Hanyecz는 비트코인을 사용하여 처음으로 공개 구매를 했다. 그 당시, 그 비트코인은 약 40달러의 가치가 있었다. 오늘날 그것들은 1억달러의 가치가 있을 것이다. 이 이야기의 가장 일반적인 해석은 Hanyecz가 피자 값을 너무 많이 지불했다는 것이다. 우리는 Hanyecz가 새로운 기술에 대한 신뢰를 쌓음으로써 엄청난 가치를 창출했다는 다른 관점에서 바라본다. 사실, 이 구매는 알렉산더 그래엄 벨이 전화로 말한 &quot;왓슨씨, 이리 오세요. 보고 싶어요.&quot;와 같은 역사적인 말로 기억될 수 있다. Hanyecz는 비트코인을 사용하여 실제 제품을 구입함으로써 비트코인이 실제 화폐 가치를 가질 수 있다는 것을 보여주었다. 그는 초기의 개발자들에게 비트코인이 새로운 종류의 디지털 화폐로 사용될 수 있다고 신뢰를 주었다. 그 신뢰은 전염성이 있었다. 그것은 비트코인을 그 역사적인 구매 이후 가치를 2,500,000%까지 증가시켰을 뿐만 아니라, 그것은 또한 완전히 새로운 &quot;토큰 자산&quot;의 디지털 자산 Class를 만들었다. 그런 의미에서 피자는 거래였다. 투자자들은 이러한 디지털 자산을 어떻게 평가하는가? 대부분의 경우, 자산, 수익 또는 보증이 적용되지 않다. 일부 경제학자들이 그랬던 것처럼 자산 전체를 투기적인 것으로 무시하는 것은 근시안적이다. 왜 어떤 토큰화된 자산은 만 달러 가치가 있고 다른 자산들은 사실상 아무 가치도 없는 것일까? 수백 개의 새로운 토큰 출시를 관찰하고 각각의 성공률을 측정함으로써 투자자의 행동에 대해 알 수 있는 것은 무엇일까? 이 지식을 사용하여 어떤 토큰의 가치가 증가할 수 있는지 예측할 수 있습을까? 비트코인의 다음을 예측할 수 있을까? 이 논문에서 우리는 투자자 신뢰라는 잘 이해된 개념을 사용하여 이러한 질문에 답한다. 우리는 투자자들이 토큰화된 자산을 어떻게 평가할지, 평가할 ‘어려운 숫자 (Hard Number)’가 없을 때 어떻게 평가할 것인지에 대한 새로운 이론적 틀을 제시한다. 마지막으로 토큰 제작자와 투자자 모두에게 이익이 되는 토큰 평가에 대한 분석 도구를 소개gks다. 이는 바로 토큰 신뢰 프레임 워크입니다. ¶2. 토큰화된 자산이란? 1997년, 록 뮤지션 데이비드 보위가 &quot;Bowie Bond&quot;라고 불리는 새로운 투자 펀드 선보였다. 투자 은행가 데이비드 풀먼의 아이디어로, 보위 본드는 평균 10년간 7.9%의 이자율을 제시했다. 이 채권은 데이빗 보위의 25개 앨범에 대한 예상 수익에 의해 지원되었는데, 이것은 시간이 지남에 따라 수익 잠재력을 가질 것으로 합리적으로 예상될 수 있다. 투자자들은 이 채권에 확신을 가질 수 있다. 왜냐하면 무디스로부터 투자 적격 등급을 받았고, 결국 미국의 프루덴셜 보험사에 의해 5,500만 달러에 매입되었다. 즉, 보위는 자신의 음악에 권리를 팔기 보다는 채권을 다시 사기 위해 사용했다. 보위 본드는 디지털 음악과 같은 무형 자산도 증권화할 수 있다는 것을 일찍이 증명했다. 디지털 음악이 가능했다면, 디지털 컴퓨터 코드라고 못할건 없지 않은가? 이것은 정비트코인과 Ethereum, Ripple 과 같은 소위 &quot;altcoin&quot;을 포함한 새로운 종류의 디지털 자산에서 일어난 일이다. 기존 채권과 마찬가지로 토큰도 기본 자산 또는 엔터프라이즈에서 가치의 일부분으로 이해할 수 있다. 다음 분류법을 제안합니다. 비트코인과 같은 통화 토큰을 사용하여 실제 상품을 구매하고 판매할 수 있다. Ethereum과 같은 플랫폼 토큰은 블록체인 플랫폼에서 트랜잭션을 실행하기 위해 &quot;지급&quot;으로 사용할 수 있다. 자산이 지원된 토큰은 부동산, 미술품 또는 수집품과 같은 기본 물리적 자산에 연결된다. 오늘날 블록체인 기술은 블록체인이 분산형 소유권 및 제어, 새로운 합의 메커니즘, 데이터의 불변성, 신뢰도 없는 프로토콜, 새로운 토큰 등의 기능을 제공하기 때문에 사용자가 이러한 토큰의 소유권을 저장하고 전송할 수 있는 일종의 “연료” 다. 실제로 우리는 새로운 ‘토큰화된 경제’에 진입할 가능성이 높다. 여기서 투자자들은 스포츠 팀부터 도시, 정부까지 가치 자산의 부분적 소유권을 살 수 있고, 블록체인 기술에 기록될 것이다. 이러한 변혁적인 추세를 감안할 때 투자자가 토큰화된 자산을 어떻게 평가하는지 이해하는 것이 중요하다. 보위 본드의 경우, 그것은 아티스트의 음악으로부터 예상되는 미래 수익으로 뒷받침되었다. 기업이나 예상되는 미래의 수익에 의해 뒷받침되지 않는 상품권을 투자자들은 어떻게 평가하는가? 그 가치는 어디에서 나온 것인가? ¶3. 토큰화된 자산 이러한 질문에 답하기 위해 먼저 알려진 가치의 자산, 불확실한 가치의 자산, 새로운 토큰화된 자산으로 뒷받침되는 디지털 토큰을 고려할 것이다. 우리는 투자자들이 상품권에서 화폐 가치를 매기기 위해 사용하는 정신적 지름길 (Mental Shortcut)을 더 잘 설명하기 위해 이 분류 체계를 제안한다. ¶3-1. 알려진 가치가 있는 자산으로 지원되는 토큰 대략적인 가격이 알려진 기초 물리적 자산(예: 금, 부동산, 미술 등)을 나타내는 토큰을 생각해보자. Bowie Bond와 마찬가지로 이러한 토큰은 실제 자산 또는 예측 가능한 수익 흐름을 통해 뒷받침된다. 블록체인 기술이 발전함에 따라, 우리는 토큰화된 “실제” 자산의 수가 엄청나게 증가할 가능성이 높다. 예를 들면 다음과 같다. 부동산: 뭄바이의 투자자들은 뉴욕 부동산 시장에 맞춰 맨해튼에 부동산을 소유할 수 있다. 수집품: 미술 애호가들이 반 고흐 그림이 후원하는 토큰을 소유할 수 있으며, 이 토큰은 반 고흐의 작품이 인기 있는 한 그 가치를 유지할 수 있다. 기업: 벤처 캐피털 회사는 자체적인 토큰을 발행할 것이며, 이는 투자자들이 회사의 포트폴리오 회사에 대한 신뢰도가 높아짐에 따라 가치가 평가될 것이다. 각 경우에, 토큰은 기초 자산 가치의 부분적 소유권을 나타내지만 자산 자체를 나타내지 않는다. (토큰의 정의는 “사실상실체의 가시적 또는 유형적 소유권의 역할을 하는 것”.) 토큰을 사용하면 인식된 값의 몫을 나타낸다고 말하는 것이 더 정확하다. 미국 달러가 여전히 금본위제일 때, 그것은 물리적인 금으로 뒷받침되었다. 미국이 금본위제를 벗어났을 때, 사회적 계약이 지지를 받았다. 달러 가치가 있다는 것에 널리 동의했기 때문입니다. 동일한 사회계약은 교환권과도 같은 것이다. 충분한 투자자들이 가치가 있다고 동의하는 한, 그들은 가치가 있다. 더 많은 투자자들이 시장에 진출하거나, 또는 투자자들이 미래의 교환 가치에서 더 신뢰을 갖게 되면, 그들은 가치가 상승하게 된다. 투자자들이 신뢰을 잃으면, 그들은 무너진다. 데이빗 보위의 작품이 &quot;Bowie 토큰&quot;으로 뒷받침될 미래를 상상해 보자. 그리고 나서 데이비드 보위의 재산은 데이비드 보위의 후편 카탈로그에 대한 투자자들의 신뢰를 높이기 위해 가능한 모든 것을 할 것이다. 인기 영화에 대한 라이센스 부여, 보위 테마 음악 페스티벌 개최 등. 이러한 방식으로, 그들은 투자자, 그리고 그들 자신을 위한 가치를 창출할 것이다. 따라서, 알려진 가치가 있는 자산의 지원을 받는 토큰값은 다음과 같이 간단히 계산할 수 있다. $${토큰의,가치} = \\frac{총,자산의,가치}{토큰의,수}$$ ¶3-2. 가치를 알수 없는 자산으로 뒷받침 되는 토큰 그러나 대부분의 알트코인에는 실제적인 자산이 없다. 그러나 사회계약은 가치가 있다고 판단한다. 매일 수십억 개의 알트코인이 디지털 교환으로 구매되고 판매된다. 이 값은 어디에서 발생하는가? 이 문제에 접근하는 한 가지 방법은 네트워크 효과를 통해서이다. Metcalfe의 법칙에 따르면 네트워크의 가치는 네트워크 사용자 수에 비례하여 증가한다. 네트워크의 n 명의 사용자의 경우 각 사용자의 값은 총 사용자 수에 비례한다. $$n(n-1) = n^2 - n$$ 100개의 토큰 풀에 의해 지원되는 간단한 블록체인 플랫폼을 상상해 보자. 각 토큰의 값이 네트워크의 모든 사용자에 대해 1달러인 경우 10명의 사용자가 총 $100 또는 토큰당 $1의 값을 형성한다. Metcalfe의 법칙은 10배 증가할 때마다 네트워크 효과가 100배 증가한다고 추정한다. 예를 들어 네트워크가 10명에서 100명으로 증가하면 네트워크의 총 가치는 100달러에서 약 10,000달러로 증가한다 그러나 토큰 수는 고정되어 있으므로 토큰 값이 1달러에서 100달러로 증가한다. 실제로, 모든 블록체인 자산의 총 시가총액화를 기준으로 블록체인 지갑의 성장을 분석할 때 정확히 알 수 있는 것은 다음과 같다. 이러한 발견은 Metcalfe의 규칙은 디지털 토큰의 가치에 적용된다는 것을 보여주지만, 고려해야 할 것이 있다 토큰 수가 일정하게 유지되기 때문에 토큰의 가격이 불균형적으로 증가하는 것을 볼 수 있다. 이는 명목통화와 토큰의 차이를 만든다. 달러화를 사용하는 사람이 많을수록 달러화 가치가 높아지지 않는다. 따라서 가치가 증가할 가능성이 있는 토큰은 미래에 성장할 가능성이 있는 크고 확립된 사용자 기반이 있는 토큰이다. 분산 원장은 일반적으로 ‘해싱’이라고 알려진 복잡한 수학 문제를 해결함으로써 네트워크에 컴퓨팅 능력을 빌려주는 분산된 컴퓨터의 연결에 의해 구동된다는 사실을 기억해야 한다. 비트코인, 총 컴퓨팅 능력, 또는 ‘해시 파워’와 같은 이른바 ‘작업 증명’ 블록체인의 경우, 컴퓨터의 가치를 측정하는 또 다른 방법이다 해싱은 실제 전기 비용을 포함하기 때문에 Metcalfe의 법칙에 따라 네트워크의 총 &quot;가치&quot;를 측정하는 또 다른 척도로 사용될 수 있다. ¶3-3. 새롭게 토큰화된 자산 기초 자산 없이 그리고 사용자 네트워크(예: ICO나 토큰 판매 등이) 없이 새로운 토큰이 생성되는 경우, 투자자들은 가능한 모든 참조 포인트를 사용하여 주관적으로 가격을 계산한다. 투자가들이 어떻게 이런 결정을 내리는지를 조사하기 위해, 우리는 몇 달 동안 약 250명의 토큰 투자자들과 함께 작업 회의를 가졌다. 우리는 보스턴과 매사추세츠 캠브리지에서 일련의 &quot;블록체인 투자자 미팅&quot;을 만들었다. 각 미팅에서 우리는 그룹으로서 분석하고 토론하기 위해 몇 가지 높은 등급의 ICO 상품을 선정했다. 그리고 나서 우리는 투자자들의 의사결정 과정을 관찰하면서 각 ICO에 대한 논의를 촉진했다. 마지막으로, 우리는 참가자들에게 ICO에 개인적으로 투자할 것인지 여부를 투표하라고 요구했다. 우리는 투자자들이 다음을 포함한 다양한 요인을 찾고 있다는 것을 알게 되었다. 팀: 창엄 멤버들이 입증된 성공 기록을 가지고 있는가? 아이디어: 토큰이 실제 문제를 신뢰할 수 있는 방식으로 해결하는가? 시장: 시장은 강하고 성장가능성이 있는가, 아니면 틈새 시장이 줄어들고 있는가? 사용자 채택: 어떻게 구매자와 판매자가 토큰을 실제로 사용하도록 할 것인가? 버즈: 다른 투자자들은 토큰에 대해 뭐라고 하는가? 홍보가 잘 되고 있는가? 우리는 두 가지 유형의 ICO 투자자를 식별했는데, 그것은 장기적으로는 매입하고 보유할 계획이었던 투자자와 가능한 한 빨리 매입하여 매도하려는 투자자들이다. 장기 투자에 대한 속어적인 “hodl” (존버하는 사람 정도의 뜻)은 단기 투자자들이 보통 “pump and dump” 라고 부르는 사람들 이었다.력한 팀이 주도하는 강력한 아이디어에 관심이 있는 곳에서는 첫 날 거래가 급증하면 수익성이 높아지기를 바라며 ‘하이프 사이클’에 더 관심을 보였다. 기업가정신의 팀몬스 모델을 토대로, 우리는 ICO 투자기회를 평가하고, 장기 사용자 채택을 유도할 가능성이 가장 높은 투자기회를 식별하여, 네트워크 평가를 즐기는 엄격한 방법을 개발했다. 이 모델,Token Confidence의 프레임워크는 아래에 설명되어 있다. 그 기초를 이해하기 위해서, 우선 투자자의 마음을 살펴보자. 미래의 불확실성과 앵커로서의 과거의 성과가 부족하다는 것을 고려해 볼 때, 무엇 때문에 애초에 투자자의 신뢰가 형성되는가? ¶4. 토큰에서 투자자들이 신뢰 만들기 신뢰는 모든 금융 거래의 필수적인 요소이다. 구매자와 판매자는 서로를 신뢰해야 하고, 그들이 참여하는 시장에 신뢰 가져야 하며, 시장은 그것을 지배하는 기관에 대한 신뢰를 가져야 한다. 예일 투자자 신뢰 지수, ZEW 투자자 신뢰 지수, State Street Confidence 지수 등 투자자의 신뢰를 측정하기 위한 여러 지표가 작성되었다. 위의 수치는 시장 움직임이 투자자 신뢰 지수에 의해 측정된 것과 매우 관련이 있음을 보여준다. 우리는 또한 이것을 상식적인 사실로 받아들인다. Fed는 &quot;시장 감정&quot;을 높게 유지하기 위해 신중하게 단어를 선택한다. 금융 언론은 시장 침체에 대해 &quot;격렬한&quot;또는 &quot;소름 끼치는&quot;투자자라고 말한다. 이것들은 모두 신뢰의 척도이다. 신뢰와 시장 성장이 상관관계가 있다면, 토큰이 공적 교류에 가치를 부여하기 전에 새로운 블록체인 토큰을 만드는 사람들이 어떻게 자신감을 창출할 수 있을까? 행동경제학의 최근 연구 결과, 특히 대니얼 카너먼과 아모스 트버스키의 기초 연구 결과는 투자자들의 마음에 대한 흥미로운 단서를 제공하고, 블록체인 신생기업들이 투자자의 신뢰를 쌓기 위해 얼마나 노력할 수 있는지를 보여준다. ¶친숙함 우리는 우리가 아는 것을 신뢰한다. 이것이 광고, 종교 육성, 정치, 왕조의 원칙이다. 래리 자코비가 《Becoming Famous Overnight》에서 보여준 것처럼, 우리는 그 정보에 대해 이미 잘 알고 있다면 새로운 정보를 더 유리하게 볼 수 있다. 실험 대상을 무작위로 노출하면, 기억하는 방법을 기억하지 못하더라도 나중에 그 이름을 ‘기억’할 가능성이 더 높다. 폭넓은 인식을 구축할 수 있는 토큰은 자신감을 쌓을 가능성이 높으며 따라서 더 많은 가치를 창출할 수 있다. 750개가 넘는 ICO에 대한 분석에서 우리는 창업자들이 광고 예산이나 홍보를 통해 인식을 높일 수 있다는 사실을 발견했지만, 종종 ‘풀뿌리’ 노력, 예를 들어 강력한 개발 공동체를 구축하거나 기존 블록체인 애호가 네트워크를 활용하는 등의 노력으로 인해 더욱더 많은 성과를 거두었다. 교훈은 더 큰 마케팅 예산이 필요하다는 것이 아니라 토큰 제작자가 강력한 사용자 네트워크를 구축하는 데 집중해야 한다는 것이다. ¶후광 효과 우리는 잘생긴 사람들이 더 똑똑하다고 가정하는 경향이 있다. 이를 ‘후광 효과’라고 하는데, 이는 쉽게 재확인된 속성이 식별하기 어려운 다른 속성과 결합된다. 투자자들이 긍정적인 관점에서 회사나 브랜드를 볼 때 리더십 팀에 대한 그들의 견해에 “뒤집어지는” 경향이 있다 새로운 토큰 제공에 참여할지 여부를 결정할 때 투자자는 잘 알려진 회사 또는 학술 기관에서 온 창립 팀에게 &quot;후광 효과&quot;를 돌리는 경향이 있다. 예를 들어, Dragonchain 블록 체인 기술은 원래 Disney에서 일하면서 팀에 의해 개발되었다. Dragonchain이 1,370만 달러의 ICO를 출시했을 때 Disney는 토큰과 공식적인 제휴가 없었지만 미디어 스토리의 일부가 되었다. 새로운 토큰에 대한 자신감을 측정하기 위해 투자자들은 다른 신뢰의 상징을 찾는다. 토큰이 잘 알려진 기술 브랜드(우버, 구글, 페이스 북), 금융 브랜드(비자, 페이팔, 애플 페이) 또는 교육 브랜드(하버드 비즈니스 스쿨, 스탠퍼드, MIT)와 연결되면 후광 효과가 작용한다는 좋은 신호가 된다. ¶직관 미국의 경제학자 허버트 사이먼은 인간이 어떻게 결정을 내리는지 연구했고, 그의 아이디어는 인공지능 분야에서의 선구적인 업적에 의해 깊이 형성되었다. 그를 매료시킨 주제 중 하나는 직관이었다. 직관은 분명한 인간의 특성이었을까, 아니면 기계도 직관을 배울 수 있었을까? 그는 직관이 무의식적인 패턴 인식에 지나지 않는다고 믿게 되었다. 우리는 “이 영화를 전에 본 적이 있다.” 다시 말해, 직관에 대해 마법이나 신비스러운 것은 없다: 직관은 친숙함에 기반을 두고 있다. 그래서 전문가들은 종종 “어떻게 알게 되었는 지” 와 관계 없이 “알고” 있다. 그러나 직관이 간단한 알고리즘으로 일대일로 맞서게되면 알고리즘이 승리한다… 다니엘 카너먼은 그의 획기적인 책 《Thinking, Fast and Slow》에서 &quot;Intuitions vs. Formulas&quot;에 대한 내용을 한 챕터에 할애 했다. 그의 결론은 &quot;전문가 예측&quot;대 &quot;단순한 공식&quot;을 측정하는 수십 가지 학술 연구를 검토한 후, 수식은 승리 결과를 예측할 가능성이 더 크다고 결론 내렸다. 토큰 제안을 평가할 때 직관을 신뢰할 수 없는 이유는 그 제안이 너무 새롭기 때문이다. 직관적인 판단을 내리기 위해 그것을 검토하는 데 필요한 ‘10,000시간’를 가진 사람은 아무도 없다. 카너먼의 연구는 투자자들이 ICO를 평가하기 위해 5~6가지의 간단한 공식을 만드는 것이 더 낫다는 것을 보여준다. 우리가 아래에 제시하는 것은 바로 이 틀이다. ¶5. 토큰 신뢰를 위한 프레임워크 Babson College 교수 Jeffrey Timmons는 기업가적 사상의 매력을 평가하기 위해 기업가정신의 Timmons 모델을 개발했다. 그것은 새로운 상품을 개발하려는 기업가들과 기업가 아이디어를 평가하려는 투자자들에 의해 사용될 수 있다. 여러 다른 범주에서 동일한 질문을 엄격하게 함으로써, 엔젤 투자자나 기업가는 다른 사업 아이디어에 대한 반응을 비교를 할 수 있다. 우리는 토큰 오퍼링과 더 관련이 있도록 Timmons 모델을 구축했다. 목록의 각 질문에 대해 1~5의 값을 지정한다… 각 질문의 점수는 각 섹션 끝에 평균을 내고 각 섹션의 점수는 마지막에 평균을 낸다. 실제로, 대부분의 토큰 (정의에 의한)이 평균이기 때문에, 약 3점의 점수가 일반적이다. 점수가 2에 가까워지는 토큰은 낮은 투자자의 신뢰를 보여 주며 피해야하며 약 4 점의 점수는 높은 투자자의 신뢰를 나타내며 더 자세히 볼 가치가 있다. 다른 투자와 마찬가지로, 이것은 프로세스의 끝이 아니라 강력한 시작을 의미한다. 투자자들의 경우, 토큰 신뢰도를 위한 프레임워크는 덜 매력적인 기회를 걸러내기 위한 도구로 보아야 한다. 높은 점수를 받는 토큰의 경우, 투자자는 설립 팀을 인터뷰하고, 토큰 사용자를 찾고, 더 깊은 경쟁적 분석을 할 것이다. 기업가 또는 창업 팀의 경우, Token Confidence 프레임워크를 아이디어를 강화하는 도구로 사용할 수 있다. 여전히 잘 아는 제3자가 가장 객관적으로 토큰 신뢰의 기본틀을 작성할 수 있는 가장 좋은 위치에 있다. 설립자들이 편견이 없는 외부 소스보다 더 낙관적으로 점수를 매길 가능성이 높기 때문이다. 이는 토큰 제작자와 토큰 투자자들 사이에 존재하는 정보의 비대칭성과 &quot;우리의 실명에도 눈이 멀 수 있다.&quot;는 인식적 편견 때문이다. ¶6. 결론 블록체인 기술의 형태로 우리 경제체제에 엄청난 변화가 일어나고 있다. 새로운 자산인 암호화폐인 알트코인 및 토큰은 빠르게 증가하고 있으며, 투자자들은 이러한 새로운 &quot;토큰&quot;을 가치 있게 평가할 프레임워크를 찾고 있다. 이 논문의 주요 공헌은 기존의 이론적 및 분석 도구를 기반으로 토큰 평가를위한 유용한 출발점을 제공하는 동시에 토큰 가치를 평가하기 위한 새로운 프레임 워크를 제공하는 것이다. 우리는 행동 경제학과 기업가 정신 연구에 대한 잘 발달된 문헌에 의존하며, 이러한 경험적 발견이 투자자의 마음 속에 어떻게 작용하는지 설명하고 투자 결정을 내릴 때 수정되어야 한다. 따라서 이 연구는 실무자뿐만 아니라 학계에서 처음으로 이루어졋다. 이 연구의 다음 단계는 시간이 지남에 따라 토큰의 성능에 대한, 실제 데이터를 바탕으로 실제 세계의 프레임 워크를 테스트하는 것이다. “실제” 자산(부동산, 로열티 스트림 또는 귀금속)의 지원을 받는 토큰은 매우 쉽게 가치를 창출할 수 있다. 실제 자산(예: Ethereum 또는 Ripple)의 지원을 받지 않는 토큰의 가치는 총 네트워크 사용자 수 또는 총 해시 파워(총 Method power)를 확인하여 추정할 수 있다. 일반적으로 ICO이라고 알려진 새로운 토큰 제공은 토큰 신뢰 프레임워크를 사용하여 평가할 수 있다. 이러한 오퍼링은 투자자의 신뢰를 처음 구축하는 경우에 더 높게 평가될 수 있다. 신뢰는 우리 경제 시스템의 성공적인 기능에 중요한 요소이다. 어떤 것이 가치 있다고 믿는 사람이 충분하다면, 그 믿음을 멈출 때까지는 그럴 것이다. 이것이 우리가 종교의 노래와 이야기, 정치의 화려 함과 상황, 월스트리트의 의식과 규칙과 같은 가장 큰 사회 기관을 중심으로 정교한 구조를 만드는 이유다. 은행가들이 은행 로고가 있는 옷깃 핀을 착용하고 의사들이 왜 흰 코트를 입는가에 대한 이유기도 하다. 이러한 구조는 이러한 기관에 대한 신뢰 창출하여 합법성을 부여한다… 새로운 토큰을 출시하고자 하는 야심 찬 기업가들은 a) 강력한 사용자 네트워크를 끌어들이는 것을 통해 투자자의 신뢰를 구축하고 b) 토큰을 잘 알려진 회사와 연관시키고 c) 블록체인 공간에서 투자자들 사이의 토큰에 친숙 함을 구축하는 것이 현명할 것이다. 토큰에서 장기적인 가치를 구축하려면 제도적 구조를 통해 장기적인 신뢰를 구축하는 것이 필요하다. 종교가 이야기, 경전, 그리고 노래를 가지고 있는 것처럼, 장기적인 가치를 창조하고자 하는 토큰은 이야기, 태그, 광고를 포함할 것이다. 그들은 잘 관리된 자문 팀의 형태로 &quot;엘더 (원로)&quot;의 도움을 받을 것이고, 그들은 끊임없이 말, 습관, 복장에 대한 그들의 가치를 전달할 것이다. 예를 들어, 리플 토큰의 설립자들은 정기적으로 블럭체인 회의에 리플 로고가 있는 라펠 핀을 꽂은 채 정치인들의 방식으로 등장한다. 투자자의 신뢰를 쌓는 데는 시간이 걸린다. 신뢰할 수 있는 프로젝트에 투자하는 것도 시간이 걸린다. 토큰 창안자와 토큰 투자가 모두 토큰 신뢰 프레임워크를 사용하여 블록체인 경제와 세계를 위한 장기적인 가치를 구축하는 데 집중할 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"암호화폐는 닷컴버블과 같은 운명을 맞이할 것인가?","slug":"is-crypto-space-fated-to-become-another-dotcom-bubble","date":"2018-10-27T15:00:00.000Z","updated":"2018-10-28T11:49:52.000Z","comments":true,"path":"2018/10/28/is-crypto-space-fated-to-become-another-dotcom-bubble/","link":"","permalink":"https://www.yceffort.kr/2018/10/28/is-crypto-space-fated-to-become-another-dotcom-bubble/","excerpt":"Is Crypto Space Fated to Become Another Dotcom Bubble? 원문 지난 한 해 동안의 암호화폐에 대한 열풍은 암호 화폐 가격이 원래 값의 수만 배까지 올랐다는 것을 보여주었다. 비트코인을 비롯하여 심지어 Ethereum, Cardano, Ripple, Stellar, NEO 와 같은 암호화폐의 가격도투자자들의 수요가 증가함에 따라 새로운 정점으로 상승했다. 암호화폐 시장 규모는 올해 1월 초 8,000억 달러 규모의 최고치를 기록했다. 시장의 이러한 수요 급상승을 \"거품\"이라고 불렀다.","text":"Is Crypto Space Fated to Become Another Dotcom Bubble? 원문 지난 한 해 동안의 암호화폐에 대한 열풍은 암호 화폐 가격이 원래 값의 수만 배까지 올랐다는 것을 보여주었다. 비트코인을 비롯하여 심지어 Ethereum, Cardano, Ripple, Stellar, NEO 와 같은 암호화폐의 가격도투자자들의 수요가 증가함에 따라 새로운 정점으로 상승했다. 암호화폐 시장 규모는 올해 1월 초 8,000억 달러 규모의 최고치를 기록했다. 시장의 이러한 수요 급상승을 &quot;거품&quot;이라고 불렀다. 사람들이 과거를 통해 새로운 사건들을 이해하려고 노력하기 때문에, 암호화폐의 이러한 모습은 1990년대 후반인 2000년대 초반에 '닷컴 붕괴’의 렌즈를 통해 흔히 보여져 왔다. 소위 &quot;닷컴 거품&quot;의 여파로 수백 개의 회사들이 그들의 종말을 맞이했다. 그렇다면, 암호화폐도 비슷한 운명을 향해 가는가? ¶여전히 개척중 암호화폐 영역은 여전히 개척지로 여겨질 수 있다. 블록체인은 기술로서 더 넓고 점진적인 채택을 보기 시작했다. 아직 벤처 회사와 투자자들이 들을 견제해야 할 몇 가지 규정이 있다. 시장은 투기로 크게 거래된다. 암호 화폐 뒤에 있는 대부분의 프로젝트는 실제적으로 명확한 실제 가치를 보여주거나 전달하지 못했다. 무엇이 암호 화폐의 성과를 이끌어내는가에 대한 기초를 다지는 것은 어려운 것처럼 보인다. 토큰의 갑작스러운 상승에 대한 근본적인 근거가 많지 않더라도, 암호화폐에 대한 지원은 한 프로젝트에서 다른 프로젝트로 쉽게 이동할 수 있다. 특정 사건이 시장에 어떤 영향을 미칠지 예측하는 것도 어렵다. 예를 들어, 많은 사람들은 중국에 기반을 둔 블록체인 프로젝트가 중국의 ICO 금지를 고려했을 때 어려움을 겪을 것이라고 예상했었다. 그러나 이 조치는 NEO와 같은 벤처기업에 상당히 유리하게 작용한 것으로 보인다. 플랫폼 출시가 이러한 금지되기 전에 시작되었기 때문에, 사기에 의해 이용되는 것을 근본적으로 피했다. 이 프로젝트에 대한 지원이 증가하고 있으며, 비트코인이 하락했을 때 NEO의 사회적 과대 광고와 가격 변동, 심지어 회복세를 보여주기도 했다. ¶이해할 수 있는 비교 금융 버블은 자산이 내재가치보다 유의적으로 높은 가격으로 거래될 때 형성된다. 암호 화폐 시장의 매우 투기적인 성향은 분명히 많은 암호 화폐를 과대평가하는 데 기여했다. 예를 들어, Dogecoin는 발행 당시 3억 3천 3백만 달러 이상의 시장 가치를 가지고 있었다. 그것은 정점에 달했을 때 심지어 10억 달러 이상까지 도달했었다. 닷컴 버블과 비교하는 것은 지극히 당연하고 상당히 공평하다. 왜냐하면 그것은 가장 최근의 파괴적인 기술이었기 때문이다. 둘 다 사건의 전개에서 유사점을 보였다. 파괴적인 기술의 도착. 개인용 컴퓨터의 보급, 상용 인터넷 서비스 제공업체, 그리고 더 나은 웹 브라우저 기술의 출현은 인터넷 회사들을 위한 소비자 시장을 형성했다. 90년대 인터넷 보급도 급증했다. 암호화폐 의 경우에는, 블록체인은 이 암호화폐 붐 이전에 오랫동안 존재해왔다. 분산된 원장 기술의 사용은 10여 년 전부터 제안되어 왔다. 비트코인을 둘러싼 소란과 더 많은 애플리케이션을 발견한 것은, 최근에서야 비로소 Ethereum과 같은 플랫폼이 등장하면서 시작됐다. 전통적인 기관들은 블록체인 프로젝트를 스스로 시작함으로써 이 기술을 합법화했다. 두 사건 모두 기술을 활용하고자 하는 프로젝트와 벤처의 갑작스런 폭발을 특징으로 한다. 수백 개의 회사들이 닷컴 열풍 중에 설립되었다. 1999년에는 457개의 초기 상장(IPO)가 있었는데, 이들 중 대부분이 기술 회사였다. 2000년 3월에는 시장이 최고조에 달했을 때 나스닥에서 4,715개의 회사가 거래되었다. 암호 화폐 산업은 ICO와 유사한 것을 경험하고 있다. ICO는 60억 달러 이상의 자금을 조달했다. 2018년에는 이미 70개 이상의 토큰 판매가 이루어졌다. 주가가 급등했다. 닷컴 산업이 발전하고 있는 동안 인터넷 회사 주가는 급등했다. 1999년 IPO 가운데 117개 기업이 거래 첫날 주가가 두 배로 올라 시장의 활황을 보였다. 나스닥은 2000년 3월에 최고치인 5,132를 기록했다. 암호화폐는 더 많은 이득을 나타낸다. 불과 몇 달 만에 교환권이 ICO 가격의 수백 배까지 치솟는 것을 보는 것은 암호화폐 시장에서 흔한 일이다. 이런 패턴들은 많은 사람들로 하여금 암호화폐와 닷컴버블의 궤적이 같다고 믿게 만든다. 닷컴 거품이 2002년쯤에 터졌다. 나스닥은 2002년 9월에 바닥을 쳤다. 최근의 사건들은 비슷한 양상을 보이는 것 같다. 올해 2월 비트코인 가격이 6,000달러로 폭락했다. 다른 코인들도 큰 성공을 거두었다. 시가총액은 최고치에서 약 2,650억 달러로 60% 이상 하락했다. 많은 사람들은 이것이 거품이 터지는 것이라고 생각했다. 분석가들은 비트코인이 1,000달러 아래로 떨어질 것이라고 경고하기도 했다. 거의 3월 한달 동안, 당분간 안정세를 찾지 못하고 불안한 상태다. ¶배워야할 것 Eden Block의 CEO는 아래와 같이 이야기 했다. 우리가 해야할 질문은 지금이 거품인가? 가 아니다. 하지만 오히려, 거품이 얼마나 클까? 라는 질문을 해야 한다. 만약 우리가 파괴적인 기술의 자연적 진화를 존중한다면, 우리는 모든 거대한 발전과 동시에, 거대한 충돌이 있다는 것을 알아야 한다. 1600년대 튤립 거품에서 인터넷 거품까지 15년 전만 해도 추락은 불가피하다. 따라서, 우리가 과거의 거품으로부터 무엇을 배울 수 있고, 그것들이 얼마나 우리의 행동을 암호화폐 시장 내에서 이끌 수 있는가?&quot;라는 질문을 해야 한다. 닷컴 시대에 잘못된 일은 암호화폐 이해당사자들에게 많은 교훈을 주었다. 인터넷의 출현은 기업들이 직접 소비자를 대상으로 한 전자 상거래가 등장할 수 있도록 만들었다. Pets.com은 아마존이 책을 파는 것과 유사한 방식으로 애완용품 물건 판매를 모색했다. 회사는 또한 자신의 밸류에이션을 높이는 많은 벤쳐자금 투자를 유치했다. 그러나 사업모델이 부실하고 수익성은 고사하고 지속가능성을 보장하기 위한 시장조사도 없었다. 그 회사는 수지 타산을 맞추지 못했다. 애완동물 사료나 고양이 배설물과 같은 무거운 애완동물 용품의 높은 운송비를 흡수하려고 하는 것은 분명히 실수 이상의 것이었다. 암호화폐 시장은 이미 잘 계획되지 않은 “me too” 벤처기업이 출현하고 있다. 기업들은 블록체인을 사용하여 기술이 특정 사용 사례를 처리할 수 있을 만큼 충분히 성숙했는지 또는 이들 기업의 목표가 분산형 기술에 실질적인 필요성을 가지고 있는지에 대해 신경 쓰지 않고 모든 것을 토큰화하려는 것 같다. 그러나 블록체인 벤처기업은 이러한 기업들과는 정확히 비교할 수는 없다. 다음은 작동 방식에 대한 몇 가지 주요 차이점이다. ¶물류 시스템이 필요없다. 최소화 많은 닷컴 회사들은 온라인 채널과 물리적 이행의 균형을 맞추어야 했다. 많은 이들이 Pets.com, eToys, Webvan 사례와 같은 물류 문제에 휘말렸다. 블록체인 프로젝트는 주로 디지털 거래와 토큰화된 자산을 다룬다. 물류 시스템에 대해 벤처가 추구하지 않는 한 물류 문제는 미미하다. ¶소규모 직원들. 많은 닷컴 회사들이 물리적인 성취를 처리해야 했기 때문에, 그들은 개발, 영업, 마케팅 인력 외에도 창고와 물류 업무를 처리할 모든 종류의 인력을 고용해야 했다. 대부분의 블록체인 팀들은 숫자가 매우 적다. 대부분은 원격 조작이 용이하여 물리적 사무실과 인프라 구축의 필요성이 줄어든다. ¶기술적 편리함. Dotcom 회사는 고객 교육 및 판매 후 지원을 위해 자원을 할당해야했다. (주요 고객들이 기술에 익숙하지 않았다). 그러나 암호 시장에 참여한 고객들은 디지털 채널을 사용하는 것에 불편함을 느끼고 있지 않다. ¶혁신과 지속 가능성 암호화폐에 대한 거래와 투자에서 주의를 기울이는 것은 신중하고 현명한 일이지만, 블록체인 기술이 가져온 것을 완전히 무시하는 것은 불공평한 일이다. 닷컴 버블과 암호화폐 버블과의 유사점은 이해관계자들에게 교훈으로 작용할 것이다. 닷컴 버블의 여파로 진정한 혁신적 조직과 기술이 폭풍을 이겨낼 수 있다는 점을 명심해야 한다. 아마존과 이베이와 같은 회사들은 기발한 아이디어와 훌륭한 비즈니스 통찰을 결합하는 것이 성공으로 이끌 수 있다는 것을 증명했다. 물론, 20년 전의 암호화폐와 닷컴 버블과는, 분명히 차이를 가질 것다. 벤처 기업은 최선의 결정을 내리기 위해 이러한 뉘앙스를 탐색할 수 있어야 한다. 암호 화폐 벤처가 닷컴과 비슷한 운명을 공유할지 여부는 여전히 우리가 관찰 할 수 있습니다. 적어도 지금은 암호 화폐 이해관계자들이 (닷컴버블과는) 다른 이야기를 쓸 기회가 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"2018년까지, 해커들이 51%공격으로 약 2천만달러의 수익을 챙겼다.","slug":"cryptocurrency-51-percent-attacks","date":"2018-10-26T15:00:00.000Z","updated":"2018-10-26T21:48:42.000Z","comments":true,"path":"2018/10/27/cryptocurrency-51-percent-attacks/","link":"","permalink":"https://www.yceffort.kr/2018/10/27/cryptocurrency-51-percent-attacks/","excerpt":"Report: Cryptocurrency hackers earned $20M with 51-percent attacks in 2018 원문 블록체인을 대상으로 한 강력한 공격이 증가하고 있다. 올해 들어 지금까지 해커들은 암호화폐 프로젝트에 대해 최소 5차례의 51%의 개별 공격을 감행했으며 2천만 달러 가까운 이익을 냈다. ¶51% 공격은 공짜 돈을 보장한다. 51%의 공격은 해쉬레이트라고 알려진 작업 증명 블록체인의 전체 마이닝 파워의 최소 51%를 공격자가 장악하는 것으로 구성된다. 이는 많은 수의 컴퓨터들을 통제하는","text":"Report: Cryptocurrency hackers earned $20M with 51-percent attacks in 2018 원문 블록체인을 대상으로 한 강력한 공격이 증가하고 있다. 올해 들어 지금까지 해커들은 암호화폐 프로젝트에 대해 최소 5차례의 51%의 개별 공격을 감행했으며 2천만 달러 가까운 이익을 냈다. ¶51% 공격은 공짜 돈을 보장한다. 51%의 공격은 해쉬레이트라고 알려진 작업 증명 블록체인의 전체 마이닝 파워의 최소 51%를 공격자가 장악하는 것으로 구성된다. 이는 많은 수의 컴퓨터들을 통제하는 한 마이너에 의해 수행될 수 있거나 마이너들이 마이닝 풀을 형성하면 공격을 가할 수 있다. 블록체인의 해쉬 레이트의 대다수를 통제하는 공격자는 시스템을 정지시키고, 트랜잭션 검증을 중단하며, 채광 작업을 중단하며, 다른 마이너들이 거래를 확인하지 못하게 하고, 궁극적으로는 이중 지출 공격 즉으로 이어질 수 있다. 이중 지출은 51%의 응답자가 자신의 (실제) 거래를 확인하는 데 사용할 수 있는 숨겨진 대체 블록체인을 만드는 것을 포함한다. 이것은 종종 해커들이 많은 양의 암호 화폐를 생성할 수 있게 한다. ¶공격자들은 작은 규모의 암호화폐를 공격해 약 2천만달러의 이익을 냈다. 올해, 해커들은 성공적으로 Verge를 두 번 공격했다. 4월에, 코드에 있는 버그가 해커들로 하여금 100만 달러 이상의 암호 화폐를 훔치게 했고, 5월에는 해커들이 거래를 인수하고 거절하기도 했다. 6월의 공격에서, 알려지지 않은 범죄자들은 Zen 블록체인을 통제함으로써 4시간 동안 55만 달러 가치의 ZEN 암호통화를 훔쳐갔다. 같은 달 Lite coin cash 라는 소규모 암호 화폐 프로젝트도 해커들이 침입한 후 원활한 운영을 위해 필요한 주요 인프라를 차단해야 했다. 그러나 올해 공격 중에서 가장 수익성이 높은 것은 비트코인 골드에 대한 무력한 공격이었다. 지난 5월, 한 악의적인 마이너가 BTG 해시레이트 대부분을 차지해 38만8000 BTG($18M)를 개인 지갑에 직접 보낼 수 있게 되었다. 그 여파는 수개월 후 지속되었고, 미국의 거래소 비트렉스는 공격자들이 돌아올 경우 투자 보안에 대한 우려로 비트코인 골드를 상장폐지시켰다. 사이버 범죄자들은 작고 알려지지 않은 암호 화폐를 공격함으로써 높은 보상을 받고 많은 돈을 훔칠 수 있다. 기술적으로는 상대적으로 알려지지 않은 암호 화폐를 쉽게 공격할 수 있는데, 이는 대개 공격자가 훔친 자금을 좀 더 안정된 통화로 전환하는 것을 막는 데 필요한 신속한 대응을 할 능력이 없게 된다. ¶51% 공격은 저렴하지 않다. 실제로 주요 암호 플랫폼에 대한 51%의 공격을 수행하는 데 광부들이 얼마나 들었는지 추적하는 웹사이트가 있다. 마이너들이 공격을 실행하기 위해서는, 그들은 먼저 네트워크가 그들에게 정상적으로 정당한 암호 화폐 거래 처리를 위해 보상하는 수익금을 희생해야 한다. 실제로, 암호화폐로 55만 달러를 벌어들인 Zen Cash 공격은 해커들에게 준비와 실행에 최소 3만 달러를 들였다고 보고했다. 결국, 암호화폐 채굴 산업의 전제는 성공적인 51퍼센트의 공격으로 발생할 수 있는 가능한 보상을 능가하는 네트워크를 유지한 것에 대해, 마니들에게 수여되는 인센티브에 달려 있다. 이를 염두에 둔 이 사이트에서는 현재 비트코인 네트워크를 한 시간 동안 관리하는데 52만 달러가 조금 넘고, 60분 동안 이더리움을 통제하는데 15만 달러가 밖에 들지 않는다고 주장한다. 51%의 공격에 의해 제어될 위험을 최소화하기 위한 소규모 암호화폐 프로젝트의 경우, 대형 시장 참여자들이 사용하는 것과 다른 암호화 알고리즘을 사용해야 한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"중앙은행 디지털화폐: 왜 정부는 디지털화폐를 발행하려고(하지 않으려고) 할까","slug":"central-bank-issued-digital-currencies-why-governments-may-or-may-not-need-them","date":"2018-10-25T15:00:00.000Z","updated":"2018-10-25T21:48:42.000Z","comments":true,"path":"2018/10/26/central-bank-issued-digital-currencies-why-governments-may-or-may-not-need-them/","link":"","permalink":"https://www.yceffort.kr/2018/10/26/central-bank-issued-digital-currencies-why-governments-may-or-may-not-need-them/","excerpt":"Central Bank-Issued Digital Currencies: Why Governments May (or May Not) Need Them 원문 일본은행 아마미야 마사요시 부총재는 20일 중앙은행에서 발행한 디지털 화폐(CBDC)가 기존 화폐를 개선하지 못할 가능성이 낮다고 거듭 주장했다. CBDC(중앙은행 발행 디지털 화폐, Central Bank-Issued Digital Currencies), 즉 국가 규모의 디지털 화폐에 대한 개념은 전 세계의 많은 정부들을 끌어들였다. 이들 중 일부는 이미 가상화폐를 출시했고","text":"Central Bank-Issued Digital Currencies: Why Governments May (or May Not) Need Them 원문 일본은행 아마미야 마사요시 부총재는 20일 중앙은행에서 발행한 디지털 화폐(CBDC)가 기존 화폐를 개선하지 못할 가능성이 낮다고 거듭 주장했다. CBDC(중앙은행 발행 디지털 화폐, Central Bank-Issued Digital Currencies), 즉 국가 규모의 디지털 화폐에 대한 개념은 전 세계의 많은 정부들을 끌어들였다. 이들 중 일부는 이미 가상화폐를 출시했고 일부는 계속해서 경제적 영향을 조사했으며, 반면 다른 일부는 일본처럼 이 아이디어를 완전히 폐기하기로 결정했다. ¶CBDC가 무엇인가? CBDC(국가 디지털 통화)는 연방 규제 기관이 발행하고 제어하는 가상 통화다. 따라서, 그들은 국가에 의해 완전히 통제된다. CBDC는 대부분의 암호화폐 체계와 같이 분권화되지 않고 대신, 디지털 형식으로만 화폐를 나타내게 된다. 따라서 CBDC를 발행하는 중앙은행은 규제당국뿐 아니라 고객의 계정 보유자가 된다. 각 CBDC 장치는 보안 디지털 장치로 작동하며, 일반적으로 DLT(분산 원장 기술)로 구동된다. CBDC는 중앙은행들이 점점 인기를 얻고 있는 암호 화폐에 대한 대응으로 볼 수 있는데, 이는 규제당국의 설계상 관점을 벗어난 것이다. CBDC는 암호화(편의성과 보안)를 최대한 활용하고, 이러한 특징들을 화폐 유통이 규제되고, 예비성이 있는 기존 은행 시스템의 시간 테스트를 거친 특징들과 결합하는 것을 목표로 한다. ¶스위스: 블록체인은 디지털 화폐로는 유용하지만, 굳이 CDBC를 발행할 이유가? 스위스는 유럽에서 가장 블록체인에 대해서 우호적인 국가임에도 불구하고 CBDC의 유용성에 대해 의문을 표시했다. 지난 6월, 스위스 국립은행(SNB)의 토마스 모서스 이사장은 국가 지원 디지털 화폐의 발행을 고려할 만큼 암호화와 블록체인은 혁신적이지 않다고 말했다. Zug에서 열린 Crypto Valley Blockchain 컨퍼런스에서 현재 조건에서 블록체인을, CD 처럼 쓸모없는 혁신이라고 비유했으며, 디지털 주식, 채권, 바우처와 같은 기존 제품을 모방한 것이라고 주장했다. “비트코인에서도 비슷한 일이 일어났었다. 더 잘 작동하거나 더 저렴할 때만 사람들은 새로운 것으로 바꿀 것이다.” 이튿날 그는 기업 관계자들에게 중앙은행들이 CBDC를 발행하는데 있어 초기 이해관계가 있었지만, &quot;재정 안정성에 미치는 영향 때문에 고려하는 것을 줄이고 있다&quot;고 말했다. 이전에 스위스는 잠재적으로 &quot;e-franc&quot;라고 명명된 CBDC를 발행하는 데 관심을 보였는데, 스위스 연방 의회는 5월에 정부 지원 디지털 화폐의 도입 위험과 기회에 대한 보고서를 요청했다. 스위스 증권 거래소 SIX의 로미오 라처 회장은 2 월에 &quot;중앙 은행의 통제하에 있는 전자 프랑 (e-fran)이 많은 시너지 효과를 창출할 것이므로 경제에 좋을 것&quot;이라고 주장하면서 국가 암호 통화를 개발하려는 아이디어가 제안되었다. ¶중국: CDB는 기술적으로 불가피한 것 중국 인민은행은 CBDC의 개념을 연구해 왔으며, 작년에 이 목적을 위해 디지털 통화 연구실이라는 특정 연구소가 설립되었다. 최근 9월 중국인민은행은 중국의 수도를 넘어 디지털 화폐연구소의 활동을 확대해 난징에 새로운 연구소를 열었으며, 이는 중국 국가 디지털 통화(에 대한 연구)가 작용하고 있다는 신호일 수 있다. 또한, 10월에 중국인민은행은 암호 관련 전문가가 보안 데이터 플랫폼과 암호 트랜잭션을 허용하는 칩 프로세서를 개발할 수 있는 4 개의 직책을 새로 만들었다. 이에 앞서 지난 3월 주샤오촨 중국은행 총재는 이 문제에 대해 신중한 입장을 보였다. “만약 [블록체인 기술]이 너무 빨리 확산된다면, 그것은 소비자에게 큰 부정적인 영향을 미칠 수 있다. 금융 안정과 통화 정책 전달에 예측할 수 없는 영향을 미칠 수도 있다.” 조이 총재는 또 디지털 통화가 궁극적으로 현금 순환을 감소시킬 것이라고 선언하고 중국인민은행은 국내 경제에 &quot;실질적이고 돌이킬 수 없는 피해&quot;를 방지해야 한다고 강조했다. 그럼에도 불구하고 차이나 데일리에 따르면 그는 디지털 화폐의 개발이 &quot;기술적으로 불가피하다&quot;고 주장했다. ¶홍콩: CDBC에 대한 연구후, '기존 인프라보다 우수하지 못하다’는 결론 홍콩은 중국 본토에 비해 CBDC에 대해 훨씬 분명한 입장을 갖고 있다. 지난 5월 정부는 이미 효율적인 지불인프라를 갖고 있다는 것을 언급하면서, 홍콩이 가까운 미래에 CDBC를 발행하지 않을 것이라는 보도자료를 발표했다. 이 성명서는 금융 서비스 담당 차관 및 입법위원회 재무부에 의해 서명되었다. 그는 중국 인민은행(PBoC)과 홍콩 통화당국(HKMA)의 회원국으로 구성된 국제 결제 및 시장 인프라 위원회(CPMI)가 공동연구기관이라고 설명했다. 결과론 적으로, 그들으 보고서는 &quot;현재 지불을 위해 제안된 CBDC 구현은 기존 인프라와 광범위하게 유사하며 확실히 우월하지 않다&quot;고 결론을 내렸다. 또한 본 논문은 CBDC의 혜택이 효율적인 개인 소매 결제의 존재로 인해 제한될 수 있다고 주장하며, 본질적으로 CBDC는 “지속적인 연구가 필요한 주제이며 결제 응용 프로그램의 타당성을 확인하기 위한 PoC 작업이 필요하다” 고 주장헀다. ¶베네수엘라: 국가 단위 암호화폐가 있지만, 굉장히 의심스러워 2018년 2월, 베네수엘라 정부는 Petro라고 불리는 국가 암호통화를 시작했다. 2017년 12월 니콜라스 마두로 베네수엘라 대통령이 석유, 금, 광물자원의 지원을 받는 암호통화를 발표할 계획이라고 선언하면서, TV를 통해 처음 발표되었다. 1월에 그는 석유의 가치와 같은 1억 개의 Petro가 발행될 것이라고 상세히 말했다. 마두로에 따르면, 러시아 루블, 중국 위안화, 터키 리라, 그리고 유로화를 포함한 많은 명목화폐들이 석유와 자유롭게 교환될 것이라고 합니다. 페트로는 중앙 은행에서 발행하지 않기 때문에 CBDC가 아니다. 최근 이더리움의 핵심 개발자인 조이 조우는 페트로가 대시의 GitHub 저장소에서 백서의 일부를 표절한 것으로 보인다고 지적했다. 베네수엘라 디지털화폐는 도널드 트럼프 미국 행정부가 세운 금융제재 봉쇄와 싸우기 위해 자국 경제에 부정적인 영향을 미친 미국의 제재를 피하기 위해 고안되었다. 이에 따라 트럼프는 지난 3월 20일부터 시작된 ICO 참여 제한 명령을 발효했다. 니콜라스 마두로는 판매 기간 동안 총 50억 달러가 모금되었다고 주장했는데, 이는 이 돈이 20억 달러의 텔레그램 ICO와 1억 달러의 토큰으로 지금까지 최대 규모의 ICO 중 하나가 될 것이다. 석유의 공매는 11월 5일에 시작될 예정이다. 타임지에 인용된 익명의 소식통에 따르면, 암호통화는 러시아에 부과된 서방의 제재를 우회하라는 호소 때문에 2017년부터 러시아의 지지를 받고 있다고 한다. 러시아 국영은행 관계자는 푸틴과 가까운 사람들은 이것이 제재 조치를 피하는 방법이라고 말했다고 한다. 그러한 주장은 나중에 콘스탄틴 비시콥스키 러시아 재무부 국채국장에 의해 부인되었다. 베네수엘라 정부는 공식적인 출범을 앞두고 자국민에게 석유 공급을 적극적으로 밀어부치고 있는 것으로 보인다. 예를 들어, Petro는 최근 베네수엘라인들이 여권 수수료를 지불할 수 있는 유일한 화폐로 만들어졌고, 10월 8일부터 새로운 여권 발급 비용은 2petro, 그리고 연장비용은 1petro로 책정되었다. 블룸버그통신이 보도한 바와 같이, 베네수엘라의 월 평균 최저임금은 여권 인상 비용의 4배이다. (4Petro) 게다가, 마두로는 최근 텔레비전 방송에서, 노동자들이 petro에 근거한 보너스를 받기 시작할 것이라고 선언했다. ¶일본: CDBC는 현금이 없으면 작동하겠지만, 지금은 현금이 필요해 비트코인이 공식적인 지불수단으로 인정받는 일본은 현재 두 번이나 CBDC에 대한 개념을 부정했다. 10월 20일, 일본은행 총재 아마미야 마사요시는 CBDC의 효과에 대해 의문을 표명하며, 가까운 시일 내에 디지털 통화를 발행하지 않을 것이라고 덧붙였다. 좀 더 구체적으로, 아마미야는 CBDC가 정부가 &quot;zero lower bound&quot;를 극복하도록 도울 수 있다는 이론에 대응했는데, 이는 금리가 0으로 떨어져서 경제를 자극하기 위한 도구들을 잃는 상황을 말한다. 이론에 따르면, CBDC는 중앙 은행들이 개인과 기업들로부터 예금에 더 많은 이자를 부과함으로써 경제를 자극할 수 있게 하고, 따라서 그들이 더 많은 돈을 쓰게 할 것이라는 것이 그 골자다. 부총리는 중앙은행이 발행한 통화에 대한 이자를 부과하는 것은 중앙은행이 금융시스템에서 물리적 돈을 완전히 제거할 경우에만 효과가 있을 것이라고 주장하며 이 이론에 의문을 제기했다. 그렇지 않으면 대중은 이자를 내지 않기 위해 계속해서 디지털 통화를 현금으로 바꿀 것이다. &quot;현금이 여전히 일본에서 인기 있는 지불수단이기 때문에 일본에서의 화폐 폐기는 중앙은행으로서 우리에게 선택사항이 아니다&quot;라고 아마미야는 설명했다. 올해 초, 4월, 아마미야가 그러한 통화가 기존 금융 시스템에 부정적인 영향을 미칠 수 있다고 선언하면서 CBDC에 대한 생각을 공식적으로 일축했다. 당시 아마미야는 CBDC가 중앙은행들이 사회에 어느 정도까지 결제와 결제 인프라를 제공해야 하는지에 대해 글로벌 논의를 하고 있다고 지적했다. “일반 용도로 중앙은행 디지털 통화를 발행하는 것은 가계와 기업이 중앙은행에 직접 계좌를 보유할 수 있도록 하는 것과 유사할 수 있다. 이는 앞서 언급한 2단계 통화 시스템 및 민간 은행의 금융 중개에도 큰 영향을 미칠 수 있다.” ¶EU: CDBC에 대한 준비가 안됐어 유럽 연합은 CBDC 측면에서 관망하는 접근법을 취한 것 같다. 지난 9월, 유럽중앙은행 총재 마리오 드라기는 유럽 의회에 디지털 화폐를 발행할 &quot;계획이 없다&quot;고 발표했다. ECB 임원은 &quot;분산된 원장들과 같은 중앙은행의 디지털 통화를 발행하는 데 잠재적으로 사용될 수 있는 기술은 중앙은행의 사용을 고려하기 전에, 아직 철저히 검증되지 않았고 이 기술은 상당한 발전을 필요로 한다&quot;고 주장했다. 그는 ECB와 유로체제는 현재 중앙은행 디지털화폐를 발행할 계획이 없다고 강조하면서도, 자신의 기관은 현금 보충과 같은 통화를 발행하는 데 있어서 잠재적 결과를 신중하게 분석하고 있다고 덧붙였다. 게다가, 드라기는 CBDC에 반대하는 또 다른 대중적인 주장을 이용했는데, 이는 중앙 은행이 소매 부문의 다른 은행들과 경쟁해야 할 것임을 암시하는 것이었다. “중앙은행이 가계와 기업을 위한 개인 계좌를 관리하는 것과 관련해, 이것은 중앙은행이 은행 부문과 소매 예금을 놓고 경쟁을 할 것이고 잠재적으로 상당한 운영 비용과 위험을 초래할 것이라는 것을 의미한다.” 마지막으로, 그는 유로존 내에서 현금 지폐에 대한 수요가 유럽 연합에서 계속 증가하기 때문에 현재 추가적인 통화를 발행할 &quot;구체적인 필요&quot;가 없다고 덧붙였다. 앞서 2017년 9월 드라히가 국가 암호화에 대해 질문을 받았을 때 그는 다음과 같이 강조했다. 그 이후, 에스토니아는 국가 암호 통화인 esCoin의 개발을 중단했다. 게다가 지난 여름 독일은 부정적인 입장을 표명했다: 올해 7월에 독일 연방 재무부는 녹색당 하원 의원인 Gerhard Schick에 대한 대응으로 CBDC를 발행하는 것은 너무 위험하다고 공표했다. &quot;지금까지 독일과 유로존의 광범위한 사용자들을 위해 디지털 중앙은행을 발행해야 할 타당한 이유는 없습니다,&quot;라고 경제 신문인 헨델스블랫이 당시 재경부의 말을 인용 보도했다. 재경부는 또 CBDC 즉 고속은행 이체도 다른 방법으로 얻을 수 있다고 주장했다. 간단히 말해서, 이 기관은 CBDC가 “잘 이해되지 않는 많은 위험 요소들&quot;을 수반한다고 주장했다.” ¶캐나다: CDBC의 이자를 부담할 수 있다면, 복지를 개선할 수 있다. 2017년 11월, 캐나다 은행은 &quot;Central Bank Digital Currency: Motivations and Implications&quot;라는 제목의 보고서를 발행했는데, 이 보고서는 통화부서 직원이 공동으로 제작했다. 비록 그러한 논문이 반드시 CBDC에 관해 캐나다 은행이 취한 공식적인 입장을 대변하는 것은 아니지만, 그것은 그 기관의 관심을 분명히 보여준다. 간단히 말해서, 이 문서는 사회가 현금이 없어짐에 따라 중앙은행의 필수적인 수입원, 즉 더 많은 돈을 인쇄함으로써 생기는 이윤이 위태로워진다고 주장했다. 다시, CBDC는 그것이 디지털 현금 창출을 통해 정착을 유지할 수 있게 한다. 게다가, 캐나다 은행 보고서는 거래 수수료와 금융 포함의 부족을 CBDC의 다른 잠재적 이익으로 언급했지만, 익명성은 &quot;중앙은행 디지털 통화에 적합하지 않다&quot;고 강조했다. 이 신문은 캐나다 은행이 CBDC를 시행할 것인지 여부를 결정하기 위해서는 더 많은 연구가 필요하다고 결론지었다. 캐나다: CBDC는 관심을 가질 수 있고, 복지혜택을 개선할 수 있다. 2017년 11월, 캐나다 은행은 중앙은행 디지털 통화: 동기 및 함의라는 제목의 보고서를 발행했는데, 이 보고서는 통화부서 직원이 공동으로 관리했다. 비록 그러한 논문이 반드시 CBDC에 관해 캐나다 은행이 취한 공식적인 입장을 대변하는 것은 아니지만, 그것은 그 기관의 관심을 분명히 보여준다. 간단히 말해서, 이 문서는 사회가 현금이 없어짐에 따라 중앙은행의 필수적인 수입원, 즉 더 많은 돈을 인쇄함으로써 생기는 이윤이 위태로워진다고 주장했다. 다시, CBDC는 그것이 디지털 현금 창출을 통해 정착을 유지할 수 있게 한다. 게다가, 캐나다 은행 보고서는 거래 수수료와 금융 포함의 부족을 CBDC의 다른 잠재적 이익으로 언급했지만, 익명성은 &quot;중앙은행 디지털 통화에 적합하지 않다&quot;고 강조했다. 이 신문은 캐나다 은행이 CBDC를 시행할 것인지 여부를 결정하기 위해서는 더 많은 연구가 필요하다고 결론지었다. 2018년 7월, 캐나다 은행은 또 다른 연구를 발표했다. 이 책에서 중앙은행의 자금 관리 및 은행 부서에서 일하는 담당자는 CBDC가 “이자를 부담할 수 있는 가능성을 포함해 잠재적인 이점을 확보하고 있다”며 “CBDC 도입의 복지 이득은 캐나다의 경우 최대 0.64퍼센트까지 추정된다”고 주장했다. ¶이란: CDBC 대신 Ban crypto 이란의 한 장관은 국내 은행들의 모든 암호 화폐 거래 금지 며칠 후인 올해 4월 국내 디지털 화폐의 실험 모델이 개발되었다고 확인했다. 모하마드 자바드 아자리-자흐로미 정보통신기술(ICT) 장관은 다음과 같이 말했다. “중앙은행의 Ban이 국내 개발에 디지털 화폐의 사용을 금지하거나 제한하는 것을 의미하는 것은 아닙니다.” 특히 아자리-자크롬은 국내에서 개발된 디지털 통화가 궁극적으로 대중들에게 제공될 것인지 여부, 그리고 우체국이 발행할 것인지 아니면 국가가 소유할 것인지 아니면 다른 국가가 소유할 것인지 밝히지 않았다. 실험적인 이란의 암호화폐에 대한 뉴스는 이란과 러시아가 서방의 제재를 피하기 위해 암호 화폐를 사용하기 시작할 수도 있다는 보고서와 관련이 있을 수 있다. 5월에 이란 의회 경제위원회 위원장인 모하마드 레자 푸레브라히미는 두 나라가 미국 달러화 거래를 피할 수 있는 유망한 방법으로 암호 화폐체제의 도입을 언급했다. 실제로 최근 미국의 금융범죄단속망은 이란에 대한 제재를 피하기 위한 암호화폐 거래를 요구했다. ¶싱가포르: CDBC는 이점이 있을 수 있지만, 대중적인 맥락에서는 아니다. 싱가포르가 CBDC와의 실험을 발전시켰다고 전해지는데, 공개되지는 않을 것 같다. 2017년 6월, 싱가포르 통화당국은 싱가포르 달러화(GD)의 &quot;토큰 형태&quot;를 도입하기 위한 블록체인 &quot;프로젝트 유빈&quot;에 관한 보고서를 발표했다. 이 프로젝트는 중앙은행과 블록체인 컨소시엄 R3 간의 협력으로 국경을 넘나드는 지급을 촉진하기 위한 블록체인 파일럿 개발에 초점을 맞추고 있다. 그러나 2018년 1월, MAS의 라비 메논 전무는 CBDC에 대한 아이디어를 비판했는데, 특히 대중적인 맥락에서 그러했다. 파이낸셜 타임즈와의 인터뷰에서 그는 다음과 같이 주장했다. &quot;중앙은행이 비은행 국민들에게 디지털 통화를 발행하려는 이유가 무엇인가? 은행에 대해 불안한 느낌이 있다면 은행을 운영하면 된다. 그러나 CDBC가 있다면 모든 사람들이 예금을 가지고 중앙 은행에 들어갈 것이고, 사람들이 중앙 은행에 예금을 두면, 누가 신용을 연장할 것인가? &quot; “Why would the central bank want to [issue digital currency to the non-bank public]? If there’s any sense of nervousness about the banks, you will have a bank run; everybody is going to go into the central bank [with their deposits] […] And, if people placed their deposits with central banks, who’s going to extend credit?” ¶스웨덴: 현금없는 사회를 위해 필요할지도 2017년 12월 스웨덴 중앙은행(Riksbank)은 e-Krona 프로젝트 2단계 실행 계획을 발표했다. &quot;e-Krona&quot;는 &quot;일반적인 전자 지불 수단&quot;과 &quot;현금에 대한 대체&quot;으로 정의됩니다. 이 신문은 스웨덴 중앙 은행이 e-크로나를 발행할지 여부를 아직 결정하지 않은 상태여서 e-크로나가 현금을 대체하는 것이 목표가 아니라고 지적했다. 실제로 중앙은행이 e-Krona를 출시한 주요 이유는 현금에 대한 수요가 급격히 하락하기 때문이다. 중앙은행은 2017년 9월 이와 관련된 연구를 진행했다.(어떤 이유에서인지 더이상 열람이 불가능하다) 구현될 경우 e-Krona는 가치 기반 시스템과 등록 기반 시스템이라는 두 가지 시스템 하에서 작동할 수 있다. 후자의 버전은 디지털 통화 잔액을 중앙 데이터베이스의 계정에 저장(잠재적으로 블록체인에 의해 백업될 수 있음)하는, 반면 가치 기반의 경우에는 &quot;비준 통화 계정&quot;에 별도로 저장됩니다. 세계 최초의 현금 없는 사회가 되기 위한 속도를 고려할 때, 중앙은행이 CBDC를 출시할 가능성은 상당히 높다. ¶영국: CDBC를 좋아하지만, 상업은행 분야에서 위험을 초래할 지도 5월에, 영국 은행은 CBDC에 대한 입장을 두 개의 연구 문서에서 밝혔다. 먼저, 중앙은행은 CBDC와 관련된 다양한 위험을 분석하는 연구를 발표했다. 이 논문은, CBDC를 도입하는 것이 민간 신용이나 경제에 대한 총 유동성 공급에 부정적인 영향을 미칠 것이라고 믿을 이유가 전혀 없다는 것을 특히 발견했다. 또 다른 실무자 논문에서는 CBDC가 시중은행들이 사용하는 현재의 수익성이 높은 사업 모델, 즉 개인과 기업의 현금 보유를 위험에 빠뜨릴 수 있다고 추측했다. 이 연구는 사람들에게 중앙은행 디지털 화폐의 형태로 중앙은행에 돈을 저장하고, 디지털 지갑을 사용하여 돈을 원활하게 송금할 수 있는 선택권을 줄 수 있다는 생각을 허용하면서, 그러한 시나리오에 대한 중요한 결과로 (상업은행의 붕괴를) 가져올 수 있다고 경고하고 있다. 지난 5월, 마크 카니 영국은행 총재는 CBDC를 도입할 가능성에 대해 개방적인 생각을 갖고 있다고 선언했지만, CBDC 채택은 조만간 이루어지지 않을 것이라고 강조했다. ¶인도: 돈을 만드는건 비싸다. 그러나 CDBC는 저렴해보여 인도는 CBDC를 적극적으로 연구하는 국가 중 하나다. 명백히, 비용에 대한 문제가 CBDC를 연구하는데 중요한 동기 요소가 되었다. Economic Times가 인용한 통계에 따르면 인도에서 종이 현금을 인쇄하는 비용은 63억 루피였다. RBI의 보고서는 인쇄 비용이 일부 다른 중앙 은행들도 디지털로 전환되도록 동기를 부여한다고 주장했다. “전 세계적으로 증가하는 화폐 관리 비용은 전 세계의 중앙 은행들로 하여금 명목 디지털 화폐의 도입 옵션을 연구하도록 이끌었다.” 인도 중앙은행이 언급한 다른 요인으로는 &quot;결제 산업의 급격한 변화&quot;와 개인 디지털 토큰의 “상승” 등이 있다고 덧붙였다. EY India의 Maesh Mahija는 &quot;디지털 위폐와 관련된 이슈들을 다룰 필요가 있음에도 불구하고 중앙 은행이 디지털 통화를 발행하는 아이디어는 매우 희망적입니다.&quot;라고 신문에 말했다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"블록체인 발명뒤 10년, 아무도 블록체인 사용 사례를 만들어내지 못했다.","slug":"ten-years-in-nobody-has-come-up-with-a-use-case-for-blockchain","date":"2018-10-24T15:00:00.000Z","updated":"2018-10-24T21:48:42.000Z","comments":true,"path":"2018/10/25/ten-years-in-nobody-has-come-up-with-a-use-case-for-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/10/25/ten-years-in-nobody-has-come-up-with-a-use-case-for-blockchain/","excerpt":"Ten years in, nobody has come up with a use for blockchain 원문 지불 수단에서, 법률 문서, 에스크로에서 투표 시스템에 이르기 까지, 다양한 사용사례는 그러한 분산의 성격이 필요하지 않은 곳 까지 분산시키고, 암호화된 익명의 원장을 추가하려는 일련의 분쟁을 초래하고 있다. 만약 분산형 원장이 전혀 사용되지 않는다면? 발명된 이후 10년 후, 아무도 분산원장을 채택하지 못했따면, 그것은 아무도 그것을 원하지 않기 때문이다. ¶지불과 뱅킹 블록체인의 원래 용도는 비트코인과 같은 통화를","text":"Ten years in, nobody has come up with a use for blockchain 원문 지불 수단에서, 법률 문서, 에스크로에서 투표 시스템에 이르기 까지, 다양한 사용사례는 그러한 분산의 성격이 필요하지 않은 곳 까지 분산시키고, 암호화된 익명의 원장을 추가하려는 일련의 분쟁을 초래하고 있다. 만약 분산형 원장이 전혀 사용되지 않는다면? 발명된 이후 10년 후, 아무도 분산원장을 채택하지 못했따면, 그것은 아무도 그것을 원하지 않기 때문이다. ¶지불과 뱅킹 블록체인의 원래 용도는 비트코인과 같은 통화를 위한 수단으로, 다른 통화와 마찬가지로 가치를 저장하고 교환하는 방법으로 사용되고 있다. 사람들은 모두 비자와 마스터카드는 모두 공룡이라고 선언했다. 왜냐하면 이제 중개인을 거치지 않아도 가치를 교환할 수 있으며, 비용이 들지 않기 때문이다. 은행에서의 혁명은 시작에 불과하다. 더 이상 통화를 발행할 수 없는 정부들은 개별 시민들이 국가 시스템 밖에서 자유롭게 거래함에 따라 뒷전으로 밀려날 것이다. 그 꿈이 깨지는데 오래 걸리지 않았다. 우선, 이미 중개인이 없이도 가치를 교환할 수 있는 비용 없는 즉각적인 방법이 있다. 바로 현금이다. 비트코인은 달러를 대신하지만, 비자와 마스터카드는 실제로 은행들이 사기와 분쟁을 추적하고 구매자와 판매자의 신원을 확인할 수 있게 하는 것과 같은 일련의 부가가치 서비스를 제공하는 달러 기반 은행 거래 시스템을 제공하고 있다. 어떤 물건을 사는 사람에게 있어서, 새로운 지불 시스템의 중요한 특징인 페이팔을 생각해보면, 만약 상품이 설명된 대로 당신의 돈을 돌려받을 수 없을 것이라는 확신이 있다. 그리고 지불을 받아들이는 사람들의 경우, 기본적으로 중요한 특징은, 고객이 그것을 가지고 있고 기꺼이 그것을 사용한다는 것이다. 유나이티드 항공의 포인트 등의 포인트를 추가하면 소비자가 선택하고 상인들이 받아들이는 것을 보실 수 있다. 아무도 실제로 비트코인으로 돈을 내려고 하지 않는 것이 바로 이 때문이다. 게다가, 그것은 실제로 그렇게 좋은 지불 시스템이 아니다. 비자는 초당 6만 건의 거래를 처리할 수 있는 반면, 비트코인은 7번의 확인이 필요하다. 그리고 주목할 만한 것은 비트코인은 이미 비자보다 35배나 많은 에너지를 사용하는 것으로 추정된다는 점이다. 비트코인의 거래량을 비자 수준으로 끌어올린다면 세계의 모든 국가들이 사용할 수 있는 만큼의 전기를 사용하게 될 것이다. ¶정부의 감시가 없는 자유로운 거래 많은 국가에서, 국가 당국으로부터 사적인 것을 숨기는 약간의 능력이 세상을 더 좋은 곳으로 만들 수도 있다. 쿠바나 베네수엘라 같은 곳에서 사람들이 달러로 거래하는것을 선호하며, 비트코인도 이론적으로는 비슷한 기능을 수행할 수 있다. 그러나 이것이 만병통치약이 아닌 두가지 이유가 있다. 그것은 개인에 대한 정부의 이익과, 사회에 대한 정부의 장점이다. 정부가 지원하는 은행 시스템은 FDIC의 보증, 신원확인, 감사기준, 그리고 문제가 발생했을 때 조사할 수 있는 시스템을 제공한다. 비트코인은 그 디자인적인 특성상 이런 것들을 해낼 수가 없다. 나는 이메일이 해킹당하고, 비밀번호를 도둑맞아서 비트코인 계정을 털린 사람의 스레드를 보았다. 그들은 (문제를 해결할) 의지가 전혀 없었다. 그리고 이는 공공연하게 널리 퍼져 있는 사실이다. 그 당시 최고의 비트코인 무역거래소였던 마운틴 Gox 도 보안 실패로 인해 400만 달러의 투자금을 잃었다. 이후 1위 비트코인 트레이더 Bitfinex도 고객 자금의 손실로 문을 닫았다. 만약 은행들이 고객의 자금을 빼앗긴다면 세상은 어떻게 될까? 둘째, 정부의 정책은 테러리스트들의 자금 조달과 조직화된 범죄를 방해하고 도난 신용카드 번호나 아동 포르노와 같은 불법 상품들의 교통을 막기 위해 고안되었다. 물론 대부분의 사람들은 거래가 비공개로 유지되어야 한다는 것에 동의할 것이다. “정부가 당신이 돈을 지불한 모든 사람의 명단을 갖고 있어야 한다” 라고 하면 모두 아니오라고 하겠지만, “정부가 아동 포르노 수집가가 돈을 지불한 사람의 명단을 갖고 있어야 한다” 라고 요구한다면, 대부분은 그렇다고 말할 것이다. 아무도 비트코인이 정부가 불법이라고 간주한 서비스와 상품을 거래하는데 트래픽이 100배이상 증가하길 원하지 않는다. ¶소액지불과 은행간 송금 사람들이 블록체인 기반의 통화에 특히 열광하는 두 가지 특별한 사용 사례인 소액지불과, 은행 간 송금에 주목해야 한다. 소액결제 측면에서, 사람들은 비트코인 거래가 무료이고 즉각적이라고 생각한다. 사실, 그들은 거래를 확인하는데 약 8분이 걸리고 처리하는 데 약 4센트의 수수료가 들었다. 사람들은 비트코인을 소액결제에 사용하자고 주장했다. 예를 들어, 음악가가 인터넷에서 노래를 듣는데 2센트, 신문 기사를 읽으려면 4센트를 내야 한다고 주장한다. 그러나 이를 위한 인프라(예: 자금 출처에 대한 사전 승인)는 클릭한 기사를 읽기 위해 8분 동안 기다리지 않아도 되므로 비트코인이 전혀 필요하지 않다. 만약 당신이 한 곡에 4센트나 2센트를 지불하는 것이 괜찮다면, 당신은 그것을 당신의 은행 계좌에서 한 달에 한 번 청구서로 설정하고 당신의 마음에 맞는 내용을 읽을 수 있다. 그리고 실제로 사람들은 소액결제보다 가입 서비스를 선호한다. 은행간 지불의 측면에서, 많은 사람들은 리플을 은행간 돈을 이체하는 좋은 방법이라고 언급한다. 지난 30일 동안 이 회사는 20억 달러 가치의 은행 간 거래와 대인 간 거래를 처리했다. 이는 SWIFT 인터뱅크 네트워크에서 약 40초 분량의 통화량이다. 이것은 이쑤시개 판매로 구성된 미국 GDP의 비율과 같다. 왜 은행들은 이 새로운 기술을 선호하지 않는가? 정답은 리플 게이트웨이를 설정하는 것이 기존 해당 계정 시스템을 사용하는 것과 크게 다르지 않다는 것이다. 단, 암호 또는 보안 토큰이 손실되면 비트 더 크고 즉각적인 실제 손실이 발생할 수 있다. 은행 시스템을 최종 사용자에게 매력적으로 만드는 동일한 기능들 또한 은행들에게 매력적이다. 그들은 이미 원장이 있고, 배포하고, 익명으로 하고, 암호화하고, 되돌릴 수 없게 만들 필요가 없습니다. ¶“스마트” 컨트랙트 “스마트” 컨트랙트는 법적 문서로 작성되지 않고 소프트웨어로 작성된 계약이다. 블록체인에서 직접 인코딩할 수 있으므로 관련 당사자의 암호화 동의에 따라 직접 가치를 이전 시킬 수도 있다. 즉, &quot;자체 실행&quot;입니다. 그리고 이론적으로, 소프트웨어로 작성된 계약서는 해석하는데 더 저렴하다. 왜냐하면 계약서의 운영은 문자 그대로 수학적이고 자동적이기 때문이다. 이것은 비싼 법적 공방이 필요 없다는 것을 의미한다. 하지만 실제 세계의 예들은 어떻게 이것이 문제가 되는지를 보여준다. 현재까지 가장 두드러지고 가장 큰 스마트 계약인 분산형 자율기구(DAO)는 회원들이 개인 암호 키를 사용하여 직접 투자할 수 있도록 했다. 변호사도, 관리비도, 불투명한 회의실도 없는 DAO는 “이사들과 펀드매니저들이 투자 자금을 오도하고 낭비하는 능력을 제거한다”고 말했다. 그러나 소프트웨어 버그로 인해 DAO는 회원의 자금의 3분의 1인 50만 달러를 의도치 않은 곳으로 투자해버렸다. 어떤 이들은 소프트웨어가 의도한 대로 작동하지 않았기 때문에 해킹이라고 말했고, 반면에 다른 사람들은 해킹 같은 것은 없다고 말했다. 만약 소프트웨어가 어떻게 결정을 내렸는지, 그리고 사람들이 소프트웨어를 어떻게 해석할 수 있는 두 가지 방법이 없다는 것이 결국 이문제의 요점이었습니다. 결국, 모든 사람들이 모여서 소프트웨어 계약을 소급하여 수정하고 그 돈을 원래의 소유주에게 돌려주기로 했다. 어떻게? 가장 완고한 블록체인 열성가들 조차도 실제로 많은 사람들이 소프트웨어 자가 실행을 허용하기 보다는 계약 이면의 근본적인 의도에 대해 논쟁하기를 원한다. 아마도 &quot;멍청한 방법’이 가장 영리한걸지도 모른다. DAO는 실례적인 실험이었지만 대기업에서의 일상적인 거래는 어떨까? 스마트 컨트랙트의 투자자들과 신생 기업들은 블록 체인이 초고속 실행과 지불을 가능하게 할 것이라고 약속한다. 예를 들어 의료 애플리케이션에서 “청구가 처리되기까지 90-180 일을 기다리거나, 청구서를 지불하려고 전화로 시간을 보내는 대신 이론적으로는 현장에서 처리할 수 있습니다.” 라고 주장한다. 그러나 그것은 어떤 프로그램을 사용하든지간에, 가능한 문제다. 우리 회사의 아마존 서버는 웹사이트 트래픽을 기반으로 자동으로 확장되며, 얼마나 많은 돈을 사용하는지 계산한다. 스마트 컨트랙트가 이것을 변화시킬 것이라는 생각은 오류다. 즉, 소프트웨어로서 코드화되는 법적 약정 자체를 소프트웨어와 통합하는 것이다. 아마존의 서비스 조건은 스마트 컨트랙트가 아니지만 아니지만, 이러한 조건을 구현하는 청구 시스템은 자동화되어 있다. 예를 들어 건강보험 청구서가 자동화되지 않은 한, 기존 소프트웨어가 청구서를 제출하고 전자적으로 지불할 정도로 ‘똑똑하지’ 않다는 것이 문제가 아니다. 보험회사가 실수로 또는 목적에 따라 인간 검토를 선호하기 때문에 느리게 움직이고 있다는 것이다. 결국 블록체인 열성가부터 건강 보험사에 이르기까지 모든 사람들은 실제로 인간 언어로 비즈니스 관계가 무엇인지를 논의하고 이를 지속적으로 해석한 다음 이행과 지급을 처리하는 소프트웨어를 작성하고자 한다. 그러나 이것은 이미 존재한다. ¶분산된 스토리지, 컴퓨팅, 그리고 메세징 또 다른 믿기 어려운 아이디어는 블록체인을 분산 스토리지 메커니즘으로 사용하는 것이다. 표면적으로는 문서를 &quot;블록&quot;으로 나누고, 암호화한 후 분산된 원장에 넣는다. 여러 장소에 걸쳐 백업되고, 안전하고, 모든 것을 쉽게 추적할 수 있다. 그러나 파일을 분해하고 암호화하며 여러 위치의 여러 저장 매체에서 복제하는 훌륭한 방법이 여러 가지 있다. 이미 더 싸고 분산된 '드롭박스’로 불리우는 회사가 있다. 블록 체인은 이것을 하는데 특히 비효율적이고 불안정한 방법이다. 블록체인 방식에는 네 가지 추가적인 문제가 있다. 첫째, 2단계 인증, 침입 탐지, 볼륨 제한, 방화벽, 원격 IP 추적 및 비상 연결 해제 기능이 포함될 수 있는 보다 정교한 시스템이 아닌 단일 지점 암호화(개인 키)에 의존한다. 둘째, 가격 trade off를 전적으로 믿을 수 없다. 비트코인 블록체인은 10억달러 상당의 전기를 소비하여, 한달에 10달러짜리 드롭박스 구독으로 얻을 수 있는 약 1/6에 상당하는 양의 데이터를 해싱했다. (셋째를 누락한듯) 넷째, 넷째, 데이터를 복제할 장소와 금액을 체계적으로 선택하는 것이 장기적으로는 이점이다. 그리고 마지막으로 Dropbox와 Box.com과 구글, 마이크로소프트, 애플, 아마존 그리고 다른 모든 사람들은 여러분이 스스로 개발하고 싶지 않은 일련의 가치 있는 기능들을 제공한다. Visa와 유사한 문제는 데이터 저장, 권한 관리, 이전에 공유했던 공유 해제, 보기 쉬운 문서 기록, 여러 장치에서 동기화 등이 있다. 동일한 주장이 제안된 분산 컴퓨팅 및 보안 메시징 애플리케이션에 대해서도 적용된다. 암호화하고, 영구적으로 저장하고, 전체 네트워크에 걸쳐 복제하는 것은 실제로 수행하려는 작업에 비해 엄청난 오버헤드에 불과하다. 블록체인 기반 솔루션보다 필요한 모든 암호화와 복제를 모두 갖추고 있으며, 그 외에도 수많은 훌륭한 기능을 갖춘 탁월한 컴퓨팅, 메시징 및 스토리지 솔루션이 존재한다. ¶주식발행 고객 대 제품과 같은 다른 거래 추적 문제와 마찬가지로, NASDAQ의 원장과 블록체인의 원장의 차이는 블록체인이 분산되어 있다는 점이다. 신뢰할 수 있는 중개자가 부족하다는 문제를 해결한다. 그러나 (법적 거래의 경우) 회사 자체, 이전 대리인, 청산소 또는 거래는 모두 신뢰할 수있는 중개자이며 일반적으로 부가가치 서비스를 제공한다. 나스닥이 블록체인 중심 올바른 본거지인 이유는 그들이 주식 거래의 준수와 보안 측면에 대해 전문가이기 때문이다. 중간자(여기, 나스닥 자체)와 정부를 제외하면, 결국 주류 시장에 공통적으로 적용되는 법률, 준수, 추적 시스템을 중심으로 최종 실행을 선택하는 회사로 제한될 것이다. 상장되지 않은 주식을 거래하는 사람들이 당신에게 말하듯이, 그것은 당신이 돈을 잃는 방법이 될 수도 있다. 그러나 (법적 거래의 경우) 회사 자체, 레코드, 창고 또는 거래의 대리인은 모두 신뢰할 수 있는 중개자이며 일반적으로 부가가치 서비스를 추가로 제공한다. 나스닥이 블록체인 거래소의 좋은 본거지인 이유는 그들이 거래소의 준수와 보안 측면에 전문가이기 때문이다. 중간자(나스닥)와 정부를 배제하면 궁극적으로 주류 시장에 공통적인 법률, 규정 준수 및 추적 시스템을 최종 운영하기로 선택한 기업들로 제한된다. 상장되지 않은 주식을 거래하는 사람들이 말하듯이, 이는 돈을 도둑맞기 위한 방법이다. 그리고 우리는 이미 그 사실을 알고 있다. 새로운 기업들은 블록체인 기반의 &quot;코인&quot;을 회사 주식으로 전환하여, 그것들을 ICO에서 기존의 주식보다 더 저렴하고 유연한 방법으로 대중에게 팔기 시작했다. 이런 열풍이 얼마나 오래 지속되는지 보는 것은 흥미로울 것이다. 무엇보다도 주식으로 전환할 수 있는 토큰을 증권으로 제공하는 것이기 때문에, SEC 규칙은 다른 어떤 증권과 마찬가지로 이러한 증권 제공에 적용될 수 있다. ‘코인’은 보안이 덜한 전자주식 증명서일 뿐 아니라, 증권거래소의 법과 보호가 아니라 비밀번호를 신중하게 저장하는 방식으로 보호받는다. ¶인증된 검증 블록체인의 또 다른 그럴듯한 용도는, 만약 여러분이 변경할 수 없고 삭제할 수 없는 서명을 만들고 싶다면, 여러분은 그것을 블록 체인에 그것을 &quot;게시&quot;할 수 있다. 이론적으로 당신은 이것을 투표용지 기록, 다이아몬드나 브랜드 이름의 기원, 사람들의 신원을 확인하고, 도메인 이름의 소유권을 확인하며, 항목을 에스크로 유지하고, 임시 특허를 봉인하지 않고 공개하는 데 사용할 수 있다. 각각의 세부 사항들을 너무 철저하게 조사하지 않는다면, 사용 사례는 매우 빠르게 무너지는 것 같다. 투표의 경우 현 상태는, 투표 용지의 총 수를 기록하고 유권자는 상자에 눈에 띄는 종이 투표 용지를 넣고, 양측의 언론인과 관찰자는 투표 상자를 내내보고 있다. 투표에서 어려운 문제는 누가 익명으로 투표했는지를 계속 유지하지면서 동시에 유권자와 투표가 1 대 1인지 확인하는 것이다. 종이는 블록체인보다 훨씬 더 잘한다. 공증인이나 이와 유사한 경우, 운전면허증 확인 또는 현재 증인이 있다는 것은 도난당한 암호 또는 개인 키로 서명되지 않았음을 의미하며, 암호 또는 개인 키가 적절한 경우 PGP 키를 사용하여 게시할 수 있다. 시계나 핸드백과 같은 브랜드 명품의 신뢰성을 확립하거나 다이아몬드가 윤리적으로 채굴되었다는 사실을 입증하기 위해, 배포되고 암호화되는 원장은 어떠한 가치도 추가하지 않는다. 즉, 원래 회사는 온라인으로 확인할 수 있는 인증서만 포함할 수 있다. 에스크로의 경우, 스마트 계약이 재화를 검증하고 보유할 필요 없이 자동으로 재화를 지불할 수 있지만, 여전히 재화가 배달되고 약속된 대로 이루어지는지 확인하기 위해 신뢰할 수 있는 당사자가 필요하다. 그리고 마지막으로, 만약 당신이 X를 공개적으로 알리지 않고 Y를 알고 있다는 것을 반박할 수 없게 하려면, 그것을 암호화하거나 전자 우편과 핫메일 주소를 모두 당신 자기 자신에게 보내거나, bickbucket에 올리거나, md5로 해쉬해서 트윗을 하거나, 아무튼 지간에 다양한 방법으로 해라. 그러나 다시 한번 말하지만, X를 알리지 않으면서 Y를 알리는 산업의 규모가 도대체 얼마나 큰가? 그것을 리딩하는 회사나 서비스가 있는가? ¶무엇이 남았는가? 이 모든 것들은 사소한 것 같다. 네, 모든 사람들은 가방에 이미 온라인 상에서 찾을 수 있는 ID 번호가 포함된 인증서를 가지고 있다는 것을 알고 있다. 단, 각각의 경우, 수천만 달러가 기업 전체에 사용되고 있다. 그리고 당신은 더 난해한 것 - 블록체인에서의 두번째 삶, 또는 블록체인이 가능한 가전제품들을 얻을 수 있어서 세탁기가 자체 세제를 위해 스마트한 컨트랙트이나 블록체인에서 코칭 결정을 내리는 스포츠 리그를 만들 수 있다. 결국, 거래와 관련된 기존 인간 및 소프트웨어 시스템의 장점 - 운전 면허증으로 신원을 확인하는 것에서부터 신용 분쟁 거래에서 작성된 진술을 명확히하고 신문 구독을 위해 신용 카드를 자동으로 청구하는 것 -은 취소할 수없는 자동 실행의 숨겨진 비용뿐만 아니라 그것이 주는 이점이 더 중요하다. 블록체인 애호가들은 종종 어려운 부분이 A에서 B로 돈을 받거나 일어난 일에 대한 기록을 유지하는 것처럼 말한다. 각각의 경우, 돈을 옮기고 거래를 기록하는 것은 실제로 훨씬 더 복잡한 시스템의 저렴하고 쉽고 고도로 자동화된 부분이다. 그래서 우리가 시작한 곳, 즉 통화 투기와 불법 거래가 교훈이 될 수 있다. 비트코인 기업가, 투자자, 컨설턴트와의 대화에서 오늘날의 업무 수행 방식이나 최종 사용자에게 어떤 가치가 있는지에 대한 지식이나 관심이 부족한 경우가 종종 있었다. 비트코인에 돈을 다 써버렸기 때문에 아무도 나가서 대부분의 신용카드 사용자가 거래에 대해 분쟁할 능력을 상실한 대가로 그들의 마일리지를 포기할 것인지에 대한 조사를 하지 않았다. 아마도 IPO가 너무 비싸거나 벤처 펀드 서류가 너무 까다로운 이유는 모든 변호사와 회계사가 종이를 밀고 다니면서 부자가되어 버렸기 때문이다. 업계 경험이없는 20 대 스마트 엔지니어가 분명히 할 수 있다. 몇 백만 달러의 벤처 캐피탈로 자동으로 일자리를 창출 할 수 있다. 아직까지는, 글쎼요.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"암호화폐와 시장남용의 위험성: 자체 규제를 해야할 때","slug":"cryptocurrencies-and-market-abuse-risks-self-regulation","date":"2018-10-22T15:00:00.000Z","updated":"2018-10-23T00:48:42.000Z","comments":true,"path":"2018/10/23/cryptocurrencies-and-market-abuse-risks-self-regulation/","link":"","permalink":"https://www.yceffort.kr/2018/10/23/cryptocurrencies-and-market-abuse-risks-self-regulation/","excerpt":"Cryptocurrencies and Market Abuse Risks: It’s Time for Self-Regulation 원문 2018년 초에는 비트코인, 리플, 이더리움과 같은 지배적인 시장 점유율 암호 화폐에 대해서 가격 변동성이 심한 것으로 나타났다. 암호 화폐 가치의 합리성 에 대해 상당한 논의가 있었고, 대중에게 이러한 ICO에 대한 규제 감독과 ICO의 시장에서의 위험성은 적절하게 논의 된 바가 적다. (암호 화폐의)시장 가격 조작은 여전히 투자자들에게 중요한 이슈이다. 영국 감독당국은 2016년 보고서에서 (","text":"Cryptocurrencies and Market Abuse Risks: It’s Time for Self-Regulation 원문 2018년 초에는 비트코인, 리플, 이더리움과 같은 지배적인 시장 점유율 암호 화폐에 대해서 가격 변동성이 심한 것으로 나타났다. 암호 화폐 가치의 합리성 에 대해 상당한 논의가 있었고, 대중에게 이러한 ICO에 대한 규제 감독과 ICO의 시장에서의 위험성은 적절하게 논의 된 바가 적다. (암호 화폐의)시장 가격 조작은 여전히 투자자들에게 중요한 이슈이다. 영국 감독당국은 2016년 보고서에서 (암호화폐) 내부자 거래로 영국에서 2009년 이전 4년 동안 최대 30%를, 2015년에는 최대 1/5 가까이를 차지할 수 있다는 것이 밝혀졌다. 게다가, 현대 금융에서는 인공지능, 디지털 기술, 소셜 미디어에 의해 주도되는 새로운 종류의 사이버 시장 조작은 암호 화폐 시장에만 국한되지 않으며, 정보와 가격의 크고 즉각적인 왜곡을 일으킬 수 있다. 일례로 들어, 미국 Securities Futures Trading Commission는 2010 년 5 월 6 일의 플래시 크래시 (Flash Crash)가 단 반시간 만의 시장 조작으로 인해 수십억달러의 피해를 가져온 주식시장의 붕괴를 이르켰다고 결론 지었다. 분산형 선도기업 기술(DLT)은 거래의 투명성을 개선하고, 시스템적 위험을 완화하며, 금융 안정성을 강화하기 위한 방법으로 간주되어 왔다. 규제 기술 산업의 전문가들은 블록체인 내부에 컴플라이언스 규칙을 직접 입력함으로써 규제 기관과 시장 참여자 간의 컴플라이언스 파트너십을 창출할 수 있는 잠재적 효과를 가지고 있다고 설명하기도 했다(즉, 블록체인 내부에 컴플라이언스 규칙을 직접 입력함으로써.) 따라서 데이터의 거의 실시간 액세스, 분석 및 처리를 용이하게 한다. 그럼에도 불구하고 실제로 시장 남용 위험은 DLT에 의해 제거되지 않았으며 규제되지 않은 ICO 또는 암호 화폐 투자의 성격을 감안할 때 이러한 위험은 여러면에서 훨씬 더 크다. 가격 형성 및 주문 실행, 중앙 거래소에서 주문 조작 또는 &quot;pump and dump&quot;및 “spoofing” 관행과 등은 암호 화폐에 대한 정보가 부족한 투자자의 잠재적인 문제 중 일부일 뿐이다. 현행 규정을 신속하게 조사한 결과, 대부분의 국가는 규제 당국이 시장 남용에 개입할 수 있도록 광범위한 법적 조치를 취했다. 그러나 이러한 지침 등은 금융 상품에만 적용되기 때문에, 암호화폐에 대한 적용은 제한적인 것으로 보인다. 몇 EU 회원국은, 현재 법으로는 기존 암호 화폐가 금융 상품의 특성을 충족시키지 않아 법의 적용을 받지 않는다. 오직 독일 금융 규제 기관 만이 금융상품으로 분류했다. 그러나 이러한 결정도 아직 완료된 것도 아니다. 규제 당국이 기존 법률에 대한 광범위한 견해를 채택하고 시장 조작에 기존 금지 조항을 적용하더라도 그러한 조작과 출처를 식별하는 데 상당한 장벽에 직면하게 된다. 암호 화폐를 처리할 때 두드러지는 한 가지는 익명의 성격이다. 암호 화폐는 암호화 (개인) 키를 유일한 식별으로 사용하여 실제 이름이나 ID없이 빠른 속도로 한 디지털 지갑에서 다른 지갑으로 이동한다. 블록체인 기술은 분산 원장을 통해 모든 단일 거래를 등록하지만 특정 위법 행위와 그 뒤에 있는 사람 사이의 연결을 만들고 증명하는 것은 매우 복잡한 문제로 바뀔 수 있다. 이에 대한 한 가지 설명은 규제당국과 시장 참여자들이 규제된 시장에 사용하는 것과 같이 특정 불법 행위를 발견하고 식별하는 데 사용할 수 있는 기술적 도구가 부족하기 때문이다. 또한 증권 거래소 거래를 통제하는 것과, 달리 암호 화폐에 관해서는 시장 조작을 공식적으로 담당하는 단일 공공 기관이 없다. 실제로 암호 화폐는 일반적으로 증권, 파생 상품 또는 금융 상품으로 등록되지 않으므로 전 세계에 퍼져있는 다양한 플랫폼을 통해 거래된다. 많은 규제 당국은 실제로 거래 플랫폼이 외국 관할권에 위치한 그러한 위법 행위를 시행 할 책임과 법적 권한을 주장하기가 어려울 것이며, 실제 위법 행위는 Slack, Telegram, Twitter 및 Facebook과 같은 소셜 플랫폼을 사용하여 일어났다. 암호 시장 조작 제재를 시행하는 명백한 어려움에도 불구하고 변화의 징조가 있었다. 한 예로 2014 년에 공개적으로 암호 화폐 (또는 암호 화폐와 관련된 기본 사항)로 표시된 옵션, 선물 및 스왑 도구가 파생 상품으로 간주되어 잠재적으로 금융 상품으로 간주 될 수 있다고 말한 폴란드 재무부 장관이 지적했다. 이스라엘에서는, 2017년 12 월에 이스라엘 증권 거래소 초안을 발표하여 주요 사업이 암호 화폐를 투자, 보유 또는 채굴하는 지수 회사를 금지하는 것을 제안했다. 이 발표는 이스라엘 회사 자본금의 비정상적인 거래에 대한 신속한 반응으로 나온 것이며, 회사의 암호 화폐 채광 사업에 참여하겠다는 발표의 직접적인 결과였다. 이스라엘 당국은 회사의 실제 경제적 가치와 주식 가격 사이에 거의 상관 관계가 없는 주식 시장에서 이스라엘 투자자들에 대한 깊은 우려를 표명했다. 그러나 대부분의 규제 기관은 특히 블록 체인과 같은 미지의 영역에서 천천히 움직이는 경향이 있다. 반면 거래 플랫폼과 투자는 더 빨리 움직일 수 있다. 전반적으로, 암호 화폐 시장이 '주류’로 빠르게 이동함에 따라 시장 조작을 방지하고 중단하기 위해 고안된 더 많은 제어 및 도구를 설치해야하는 압력을 받게 된다. 이러한 통제 중 하나는 공공, 컨소시엄 또는 완전 민간 분산 원장을 통해 회사가 통신하는 불변의 규제 데이터를 저장하기 위한 블록 체인 통합 기술을 사용하는 것이 될 수 있다. 공식 정보는 거래소 및 금융 시장 규제 기관의 감시하에 그러한 원장을 통해 확산 될 것이다. 시장 참여자가 자동화된 준수 및 모니터링을 의미하는 이러한 형태의 ‘자체 규제’ (self-regulation) 는 시장 남용 위험을 완화하기 위한 전략적인 행보로 보인다. 단기적으로는 Association of Crypto-Currency Enterprises and Start-ups, Singapore (ACCESS) or the Korean Blockchain Industry Association in South Korea 등 국가적 자율규제기구가 등장할 것으로 보인다. 이러한 국가 또는 지역 자치 단체는 각 규제 기관과 효과적인 협력 및 파트너십을 개발해야 한다. 이러한 자체 규제 조직의 회원 자격 조건으로 조직의 행동 강령을 채택하고 시행하고 내부 조치를 요청해야 한다다. 암호 통화 거래 플랫폼 Bittrex가 발표한 공개 성명서가 보여 주듯이 암호 통화 거래는 시장 남용 및 사이버 보안 문제를 모니터링하기 위한 엄격한 내부 조치를 채택하는 것이 현명할 것이다. 자율규제기관은 이러한 기업에 고객에게 일반적이고 일관된 진술을 제공하고, 내부 정책(예: 직원 윤리강령, 내부 고발 등)에 대한 법적 표현을 제공할 것을 제안할 수 있다. 정보 보안 프로세스 및 기술적인 경고 및 규칙(고객 예치 및 계정을 보호, 비정상적인 가격 이동 탐지, 주문-취소 비율, 펌프 및 덤프 등), 설정된 규칙 위반에 대한 정기적인 규정 준수 검토 및 엄격한 정책 등, 이러한 문제를 해결하기 위해 ICO 자금후원, 암호 거래소 및 지갑 제공 업체들도 시장 남용 위험과 규정 준수에 대해 적극적이고 정기적으로 인력을 교육해야 할 것이다. 국가 자체 규제기구가 창설된 후 다음 단계는 International Securities and Derivatives Association (ISDA) 및 Internet Corporation for Assigned Names and Numbers (ICANN)와 같은 기존 기관의 거버넌스 및 접근 방식을 모델로 사용하여 암호 통화 시장 참가자를 위한 글로벌 국제 자체 규제 기관을 구축하게 될 것이다. 의무적이지는 않지만 자체 규제 기관의 행동 강령과 결정은 제재된 회사에 평판이 영향을 미치고, 시장 표준을 개발하며 규제 기관의 암호 통화 시장의 정당성을 강화할 수 있는 잠재력을 가질 수 있다. 이러한 아이디어가 아직 초기 단계에 있을 수 있음을 알고 있지만, 역동적인 암호 화폐 시장에서는 공정한 무역을 보장하기 위한 강력한 조치를 신속하게 적용할 수 있는 기업이 결국 승리할 것이다. 그리고 규제자들이 그 뒤를 따라다닐 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"World Payments Report 2018: 분산 원장은 금융시장의 수요를 충족시키지 못하고 있다.","slug":"world-payments-report-2018-dlt-falls-short-of-meeting-financial-market-demands","date":"2018-10-21T15:00:00.000Z","updated":"2018-10-22T03:48:42.000Z","comments":true,"path":"2018/10/22/world-payments-report-2018-dlt-falls-short-of-meeting-financial-market-demands/","link":"","permalink":"https://www.yceffort.kr/2018/10/22/world-payments-report-2018-dlt-falls-short-of-meeting-financial-market-demands/","excerpt":"World Payments Report 2018: DLT Falls Short of Meeting Financial Market Demands 원문 보고서 2018년 10월 16일 발행된 World Payments Report 2018에 따르면 분산형 원장기술(DLT)은 현재 금융시장의 수요를 충족시키지 못하고 있다. 이 연례 보고서는 컨설팅 및 기술 서비스 회사인 Capgemini와 유럽 은행 BNP Paribas에 의해 공동으로 작성되었다. 보고서에서는 DLT 채택이 직면한 문제를 다루고 있다. 조사에 참여한 참가자","text":"World Payments Report 2018: DLT Falls Short of Meeting Financial Market Demands 원문 보고서 2018년 10월 16일 발행된 World Payments Report 2018에 따르면 분산형 원장기술(DLT)은 현재 금융시장의 수요를 충족시키지 못하고 있다. 이 연례 보고서는 컨설팅 및 기술 서비스 회사인 Capgemini와 유럽 은행 BNP Paribas에 의해 공동으로 작성되었다. 보고서에서는 DLT 채택이 직면한 문제를 다루고 있다. 조사에 참여한 참가자 중 85.9%는 상호운용성 결여, 83.1%의 규제 명확성 결여, 77.8%의 확장성 문제 등을 채택을 제한하는 요인으로 꼽았다. 응답자의 60% 이상이 보안, 구현 비용, 트랜잭션에 블록 추가에 필요한 시간 등의 문제를 강조했다. 이 보고서는 또한 DLT의 혁신과 프로젝트는 단순 실험이나 PoC(Proof-of-concept) 단계에 머물러 있다고 언급하였다. DLT와 은행 시스템 간의 상호 운용성 부족은 확장 가능한 솔루션의 구현을 방해한다고 알려져 있다. 이 보고서에서는 &quot;여러 DLT 시스템은, 솔루션 간의 연결성이 제한적인 파편화된 시장을 만들어 비효율성과 제한된 채택으로 이어진다.&quot;고 덧붙였다. 보고서에 따르면 DLT의 불확실한 규제 환경과 대부분의 국가에서 법적 프레임워크의 부족으로 인해 법적 위험성 또한 존재한다고 덧붙였다. 보고서는 네덜란드 은행(DNB)의 DLT 3년 실험을 인용하며 &quot;현재 상태로는 금융시장 인프라의 매우 높은 수요를 충족시키지 못한다&quot;고 말했다. 그러나 DNB는 더 나아가 DLT가 은행 간 정산 및 외환 거래를 포함한 일부 시장 인프라를 대체할 수 있다고 언급하고 있다. DNB에 따르면, 그러한 영역들은 DLT의 잠재력을 최대한 활용할 수 있으며, 비용보다 이점이 더 크다고 주장한다. 블록체인이 특정 시장의 요구를 충족시킬 수 있을 정도로 충분히 확장 가능한지의 문제는 많은 업계 종사자들의 고민거리중 하나였다. Depository Trust &amp; Clearing Corporation(DTCC)가 최근 19주간의 연구를 통해 블록체인이 미국 주식 시장의 일일 거래량을 지원할 수 있다는 사실이 밝혀졌다. DTCC는 이번 연구가 기본 기능만을 테스트했으며, DLT이 복원력, 보안 및 운영 요구사항을 충족할 수 있는지 여부를 판단해야 한다고 지적했다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"2017년 ICO 분석","slug":"ico-2017","date":"2018-10-20T15:00:00.000Z","updated":"2018-10-21T12:44:20.000Z","comments":true,"path":"2018/10/21/ico-2017/","link":"","permalink":"https://www.yceffort.kr/2018/10/21/ico-2017/","excerpt":"Ernst & Young Report: One Year on, ICOs’ Fate Is ‘Worse Than We Thought’ 원문 ¶요약 2017년 ICO는 눈에 띄는 성과를 거두지 못했다. 86%는 현재 원래 가격보다 떨어졌으며, 30%는 사실상 모든 가치를 잃었다. 2018년 1월 1일 2017년 ICO에 투자한 사람이 돈을 잃을 확률은 66%다. 2017년 ICO 신생기업 중 29%(25)만이 제품이나 시제품을 보유하고 있으며, 이는 지난해 말 대비 13% 증가에 그쳤다. 이 중 7개 업체는 기존의 명목 통화(달러","text":"Ernst &amp; Young Report: One Year on, ICOs’ Fate Is ‘Worse Than We Thought’ 원문 ¶요약 2017년 ICO는 눈에 띄는 성과를 거두지 못했다. 86%는 현재 원래 가격보다 떨어졌으며, 30%는 사실상 모든 가치를 잃었다. 2018년 1월 1일 2017년 ICO에 투자한 사람이 돈을 잃을 확률은 66%다. 2017년 ICO 신생기업 중 29%(25)만이 제품이나 시제품을 보유하고 있으며, 이는 지난해 말 대비 13% 증가에 그쳤다. 이 중 7개 업체는 기존의 명목 통화(달러화)와 ICO 토큰으로 결제하는 것을 허용한다. 2017년 10 개의 ICO 토큰에 이익이 집중되었으며 그 중 대부분은 블록 체인 인프라 카테고리에 있다. 그러나 이러한 새로운 프로젝트가 업계의 주요 플랫폼인 이더리움의 지배력을 줄이는 데 성공했다는 신호는 없다. (사실상 대부부느이 ICO 가 이더리움에 영향을 받고 있다.) ¶ICO 수요는 증가하고 있으며, 2018년 1/4분기 누적 ICO가 2017년 ICO 보다 150억달러 더 많다. ¶86%는 표기 가격보다 떨어졌고, 30%는 완전히 가치를 잃었다. ¶투자 유치후 1년이 지난뒤, 아주 적은 수의 ICO 스타트업만이 당초에 제안한 시제품을 가지고 있었다. ¶이러한 시제품을 갖고 있는 회사 대부분은, 다른 화폐를 수용하여 토큰의 가치를 떨어뜨렸다. ¶2017년 상위 10개 ICO가 전체 순수익의 99퍼센트를 차지했다. ¶2017년 가장 성공적인 투자는 블록체인 플랫폼이었으며, 대부분의 ICO 는 이더리움에 집중되었다. ¶이더리움 개발자 커뮤니티가 가장 활발하게 움직이고 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"블록체인 혁명은 지난 10년간 떠오르지 못했는가?","slug":"has-the-blockchain-revolution-failed-to-take-off-10-years-on","date":"2018-10-19T15:00:00.000Z","updated":"2018-10-20T03:44:20.000Z","comments":true,"path":"2018/10/20/has-the-blockchain-revolution-failed-to-take-off-10-years-on/","link":"","permalink":"https://www.yceffort.kr/2018/10/20/has-the-blockchain-revolution-failed-to-take-off-10-years-on/","excerpt":"Has the Blockchain Revolution Failed to Take Off 10 Years On? 원문 모든 사람들, 심지어 비트코인과 다른 암호 화폐에 대한 대한 큰 회의론자들조차 세상을 변화시킬 수 있는 잠재력을 가진 뒷받침하는 블록체인 기술에 대해 긍정적인 말을 했다. 하지만 블록체인 기술이 공개된 지 10년이 지났지만, 아직도 이 기술은 그다지 큰 쓸모가 없다. 일부는 비트코인이 블록체인으로 구축된 기술이기 때문에 블록체인의 주된 용도는 지불 시스템 또는 가치의 저장용이라고 주장할 것이다. 그러나 비트코인","text":"Has the Blockchain Revolution Failed to Take Off 10 Years On? 원문 모든 사람들, 심지어 비트코인과 다른 암호 화폐에 대한 대한 큰 회의론자들조차 세상을 변화시킬 수 있는 잠재력을 가진 뒷받침하는 블록체인 기술에 대해 긍정적인 말을 했다. 하지만 블록체인 기술이 공개된 지 10년이 지났지만, 아직도 이 기술은 그다지 큰 쓸모가 없다. 일부는 비트코인이 블록체인으로 구축된 기술이기 때문에 블록체인의 주된 용도는 지불 시스템 또는 가치의 저장용이라고 주장할 것이다. 그러나 비트코인 혁명은 세계적이지는 못했다. 블록체인(예: 분산형 거래 플랫폼)의 다른 용도는 새로운 통화, 스마트 계약, 분산형 스토리지, 신뢰성 검증 및 불변형 원장으로서 매력은 있었지만, 혁신적이지는 못했다. (have all been tasted, but not savoured.) ¶뱅킹 혁명 비트코인이 거리로 나가 중개자 필요 없이 즉시 가치를 교환할 수 있으며, 비용이 거의 없는, 즉각적인 방법이 될 수 있다는 비전을 제시했을 때, 사람들은 이러한 뱅킹 혁명에 열광했고, 중앙통화 통제권자들은 두려움에 떨었다. 이러한 자유의 최초목표가, 탐욕에 굴복하면서 계획은 제대로 진행되지 못헀다. 비트코인은 화폐로서의 기능을 제대로 하지 못했고, 단순 디지털 자산으로만 동작하게 되었다. 금융 혁명은 수수료가 오르면서 약간 주춤하게 되었고, 전 세계적으로 채택이 비트코인을 사용하게 되었음에도 불구하고 거래는 더 오래 걸렸다. 은행들조차도 이 디지털 통화에 뒤쳐지지 않을까 하는 우려를 한시름 놓게 되었다. 그렇다면, 블록체인이 돈의 모습을 바꾸는 데 사용되지 못한다면 - 비록 다른 코인들이 여전히 그들 자신의 블록체인, 포크 또는 다른 방법으로 이 이상을 향해 나아가고 있지만 - 그 외에 블록체인 혁명은 무엇을 목표로 하고 있는가? ¶정부 감독의 부재 블록체인(Blockchain)은 중개인을 없애는 기술로도 알려져 있다. 문제는 부패한 정부와 경제의 비도덕적인 규칙에도 불구하고, 그들은 최소한 안전의 수준을 가지고 협상 테이블에 올라간다는 것이다. 블록체인 자체는 안전할 수 있지만, 여러분이 블록체인 기술을 온전히 이해하지 못한다면 여전히 위험할 수 있다. 그러므로 블록체인 기술이 정부의 자금에 대한 통제에 혁명을 일으키기 위해서는 기술에 정통한 사람들뿐만 아니라 모두에게 안전하게 제공될 필요가 있다. 정부의 은행 시스템은 다양한 수준의 보안을 제공한다. 반면에, 비트코인은 자신의 자산을 자신의 손에 달려 있다. 마운틴 곡스, Bitfinex, 심지어 CoinCheck와 같은 해킹 사건들은 정부의 눈 밖에서 거래하는 데 여전히 많은 위험이 있다는 것을 보여준다. 만약 이것이 블록체인 혁명의 일부라면, 그것은 해킹과 사기공격을 받을 수 있는 높은 위험성에 사람들이 노출될 것이다. ¶스마트 컨트랙트 스마트 컨트랙트는 혁명의 관점에서 흥미로운 현상이다. 스마트 컨트랙트의 발명은 러시아의 버팀목 Vitalik Buterin의 뒤에서 중앙집중화된 제3자의 필요성을 완전히 제거할 수 있는 세계 광범위한 컴퓨팅 네트워크를 만들기 위한 것이었다. 이것은 확실히 오늘날의 현대 세계에서 멋지게 들린다. 그러나 이 아이디어가 첫 번째 장애물에 부딪혔기 때문에 스마트 컨트랙트는 아직 갈 길이 멀다. DAO의 실패가 스마트 컨트랙트가 사용자들을 속일 수 있다는 것을 증명했으며, 우리가 스마트 컨트랙트는 때로 '그들 자신의 이익을 위해 원하는 대로 영리하게 만들 수 있다’고 말할 수 있으며, 어쩌면 지도적인 인재가 필요할 수도 있다. 그러나 이런 점에서 ICO가 계속해서 부상하고 있는 가운데 스마트 컨트랙트를 국경과 같은 방식으로 운용의 토대로 삼는 블록체인(Blockchain)의 양상에는 약속이 있다. ICO는 블록체인 기술이 도움을 줄 수 있는 영역을 계속 넓혀가고 있으며, 이러한 분야에서 큰 차이를 만들 수 있는지 여부는 지켜봐야 한다/ ¶계속해서 새로운 블록체인 응용프로그램은 나올 것 블록체인은 현대 생활의 거의 모든 영역(위에서 언급한 것들을 포함해)에 적합하도록 이론화될 수 있으며, 이것은 불변의 원장, 진정성 검증, 불변의 데이터 기반 등등의 원래 의도된 용도를 바탕으로 활용되고 있다. 그러나 블록체인 기술이 진정으로 탄생한 지 거의 10년이 지난 지금, 이 분산된 원장이 경쟁자들을 쓸모 없게 만든 분야는 하나도 없다. 아이디어는 훌륭하지만, 이 게임 변화 기술의 실행은 여전히 너무 느리다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인이 지키지 못한 약속들","slug":"the-big-blockchain-lie","date":"2018-10-18T15:00:00.000Z","updated":"2018-10-18T22:44:04.000Z","comments":true,"path":"2018/10/19/the-big-blockchain-lie/","link":"","permalink":"https://www.yceffort.kr/2018/10/19/the-big-blockchain-lie/","excerpt":"Blockchain’s Broken Promises 원문 블록체인 기술의 지지자들은 그것의 초기 시절을 인터넷의 모습과 비교한다. 그러나 인터넷이 이메일, 월드 와이드 웹, 수백만 개의 상업적인 벤처기업을 빠르게 만들어냈지만, 블록체인의 유일한 응용 프로그램인 비트코인과 같은 암호 화폐는 그것의 정해진 목적조차 충족시키지 못하고 있다. 뉴욕 등 금융 서비스 산업은 혁명을 겪고 있다. 그러나 그 추진력은 비트코인과 같은 과대 포장된 블록체인 애플리케이션에서 오는 것이 아니다. 그것은 인공지능, 빅데이터, 사물인터넷을 기반으로 한","text":"Blockchain’s Broken Promises 원문 블록체인 기술의 지지자들은 그것의 초기 시절을 인터넷의 모습과 비교한다. 그러나 인터넷이 이메일, 월드 와이드 웹, 수백만 개의 상업적인 벤처기업을 빠르게 만들어냈지만, 블록체인의 유일한 응용 프로그램인 비트코인과 같은 암호 화폐는 그것의 정해진 목적조차 충족시키지 못하고 있다. 뉴욕 등 금융 서비스 산업은 혁명을 겪고 있다. 그러나 그 추진력은 비트코인과 같은 과대 포장된 블록체인 애플리케이션에서 오는 것이 아니다. 그것은 인공지능, 빅데이터, 사물인터넷을 기반으로 한 혁명이다. 이미, 수천 개의 실제 기업들은 금융 중재의 모든 측면을 파괴하기 위해 이러한 기술을 사용하고 있다. PayPal, Alipay, WeChat Pay, Venmo 등 수십 개의 온라인 결제 서비스에는 매일 수억 명의 사용자가 있다. 그리고 금융 기관들은 개인과 기업에 대한 풍부한 온라인 데이터 덕분에 몇 주가 아니라 몇 초 만에 정확한 대출 결정을 내리고 있다. 시간이 지남에 따라, 그러한 자료 중심 신용 평가 능력의 개선은 불황을 없앨 수도 있다. 마찬가지로 보험 심사, 보험 청구 평가 및 관리, 사기 감시는 모두 더 빠르고 더 정확해졌다. 또한 능동적으로 관리되는 포트폴리오가 점점 더 수동적인 로보 어드바이저(robo-adviser)로 대체되고 있다. 이들은 비싼 재정 자문가보다 더 잘할 수도 있다. 이제, 이 핀테크 혁명을 거의 10년 동안 존재해 온 블록체인의 기록과 비교해 보자. 그리고 여전히 단 하나의 응용 프로그램, 암호화폐만 있을 뿐이다. 블록체인의 지지자들은 그것의 초창기 시절은 그것이 상업적인 응용을 갖기 전, 인터넷의 초기 시절과 유사하다고 주장해 왔다. 그러나 그 비교는 단순히 잘못된 것이다. 인터넷이 재빨리 이메일, 월드 와이드 웹, 그리고 수십억 명의 사람들이 사용하는 수백만 개의 실행 가능한 상업 벤처들을 만들어냈지만, 비트코인과 같은 암호 화폐는 그들 자신의 정해진 목적조차 충족시키지 못한다. 비트코인은 통화로서 서비스 가능한 단위, 결제 수단 및 안정적인 가치 저장소여야 한다. 하지만 그런 것은 아니다. 비트코인에서는 아무도 값을 매기지 않는다. 그것을 받아들이는 소매업자는 거의 없다. 그리고 그것은 가치가 별로 없다. 왜냐하면 그것의 가격은 하루에 20-30%씩 변동할 수 있기 때문이다. 더 나쁜 것은, 일반적으로 암호 화폐는 잘못된 전제를 기반으로 한다. 비트코인 지지자들은 비트코인은 2천1백만대의 안정적인 공급망을 가지고 있어 화폐처럼 평가절하될 수 없다고 한다. 그러나 그 주장은 비트코인 현금, 라이트코인, 비트코인 골드 등 세 개의 서로 다른 코인으로 나눠 진 것을 고려할 때 분명히 사기성이 있다. 게다가, &quot;ICO&quot;를 기반으로 매일 수백 개의 다른 암호화가 발명되고 있는데, 이러한 방법은 증권법 (securities law)을 어기고 있다. 그래서 “안정적인” 암호 통화는 자금 공급을 창출함과 동시에, 주요 중앙은행보다 훨씬 빠른 속도로 그것을 약화시키고 있다. 금융 거품이 전형적으로 그렇듯이, 투자자들은 거래에서 사용하기 위해서가 아니라, 그들이 가치가 증가시킨다는 기대하를 때문에 암호 화폐를 구입하고 있다. 실제로, 누군가가 실제로 비트코인을 사용하고자 한다면, 그들은 사용에 어려움을 겪을 것이다. 비트코인 컨퍼런스도 이를 유효한 지불 형태로 받아들이지 않을 정도로 에너지 집약적이고 환경적으로 좋지 못하다. 지금까지 비트코인의 유일한 용도는 마약 거래, 탈세, 자본 통제의 회피, 돈 세탁과 같은 불법 행위를 용이하게 하는 것이었다. 놀랄 것도 없이 G20 회원국들은 현재 모든 소득 또는 자본금 발생 거래를 보고하도록 요구함으로써 암호해제를 규제하고 그들이 감당할 수 있는 익명성을 제거하기 위해 협력하고 있다. 이달 (2018년 1월) 들어 아시아 규제당국의 단속 이후 12월 최고치였던 암호화폐의 가치가 50% 하락했다. 그러나 서브프라임 버블의 경우와 마찬가지로 대부분의 미국 규제당국은 여전히 운전대만 잡고 있다. 수천년전 돈을 발명했을 당시에는, 수백개의 서로 다른 통화들이 서로 함께 움직이는 화폐시스템이 없었다. 돈의 핵심은 그것이 거래당사자들에게 물물교환을 하지 않고 거래할 수 있게 해준다는 것이다. 그러나 화폐가치가 있고 규모의 경제를 창출하기 위해서는 통화량이 많은 통화만이 동시에 작동할 수 있어야 한다. 미국에서는 달러 외에 유로화나 엔화를 사용하지 않는 이유가 분명하다. 그렇게 하는 것은 무의미하며 경제적으로도 비효율적이기 때문이다. 수백 개의 암호 화폐가 함께 잘 작동될 수 있다는 생각은 돈의 개념과 모순될 뿐만 아니라 완전히 바보 같은 생각이다. 그러나, 또한 단 하나의 암호 화폐가 화폐 대신 사용될 수 있다는 생각이다. 암호 화폐는 고유 가치가 없지만 명목화폐는 세금을 납부하는 데 사용할 수 있기 때문에 분명 가치가 있다. 명목화폐는 또한 가격 안정에 전념하는 중앙 은행에 의한 가치 하락으로부터 보호된다. 인플레이션이 높은 통화 시스템에서와 마찬가지로 명목화폐가 신뢰성을 잃으면보다 안정된 외국의 명목 화폐 또는 실질 자산으로 교환 될 것이다. 실제로, 비트코인의 비교우위는 아킬레스의 발뒤꿈치이기도 하다. 왜냐하면 비트코인은 실제로 2천1백만 단위의 안정적인 공급망을 가지고 있다고 해도, 그것을 실행 가능한 통화로 인정받지 못할 것이기 때문이다. 통화의 공급이 잠재적 명목 GDP를 추적하지 않는 한, 가격은 디플레이션을 겪을 것이다. 이것은 비트코인의 정상적인 공급이 실제로 점차 화폐를 대체한다면 모든 상품과 서비스의 가격 지수는 계속해서 하락할 것이라는 것을 의미한다. Bitcoin에서 명명된 명목상의 단기 부채는 시간이 지남에 따라 실질 가치가 상승하여 경제학자 Irving Fisher가 대공황을 촉발 시켰다고 믿는 부채 디플레이션으로 이어질 것이기 때문이다. 그와 동시에 비트코인의 명목 임금은 생산성 증가와 상관없이 실질적으로는 영원히 증가하여 경제 재앙의 가능성을 더욱 높일 것이다. 근본적인 블록체인 기술의 경우, 암호해독보다 더 많은 잠재력을 지녔음에도 불구하고 여전히 그것의 길을 가로막고 있는 거대한 장애물이 있다. 그 중 가장 중요한 것은 인터넷이 보편적으로 접근 가능하도록 만든 기본적인 공통 및 보편적 프로토콜이 없다는 것이다(TCP-IP, HTML 등). 보다 근본적으로 중간권력이 없는 분산형 거래를 약속하는 것은 검증되지 않은 유토피아적인 망상에 불과하다. 따라서 블록체인이 기대감을 부풀린 기술의 과대광고 주기의 정점에 근접한 것은 당연하다. 그러므로 블록체인, 비트코인, 기타 암호화에 대해서는 잊어버리고, 금융 서비스 산업을 혁신하기 위해 고군분투하고 있는 실제 비즈니스 모델로 핀테크 기업에 투자를 시작하라. 너는 하룻밤 사이에 부자가 되지는 못할 것이다. 하지만 너는 더 현명한 투자를 할 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인은 민주화와 탈중앙화를 위한 것이 아니다.","slug":"blockchain-democracy-decentralisation-bitcoin-price-cryptocurrencies","date":"2018-10-16T15:00:00.000Z","updated":"2018-10-16T22:44:04.000Z","comments":true,"path":"2018/10/17/blockchain-democracy-decentralisation-bitcoin-price-cryptocurrencies/","link":"","permalink":"https://www.yceffort.kr/2018/10/17/blockchain-democracy-decentralisation-bitcoin-price-cryptocurrencies/","excerpt":"Blockchain isn’t about democracy and decentralisation – it’s about greed 원문 지난해 말 최고치를 기록한 이후 비트코인의 가치가 70%가량 떨어지면서 모든 거품의 어머니는 이제 파산했다. 더 보편적으로 보자면, 암호 화폐는 그다지 의심스럽지 않은 않은 대참사에 들어갔다. Ether, EOS, Litecoin 및 XRP와 같은 주요 화폐의 가치는 모두 80% 이상 하락했으며, 수천 개의 다른 디지털 통화가 90%~99% 폭락했으며, 나머지는 완전히 사기 행위로 드러났다. 아","text":"Blockchain isn’t about democracy and decentralisation – it’s about greed 원문 지난해 말 최고치를 기록한 이후 비트코인의 가치가 70%가량 떨어지면서 모든 거품의 어머니는 이제 파산했다. 더 보편적으로 보자면, 암호 화폐는 그다지 의심스럽지 않은 않은 대참사에 들어갔다. Ether, EOS, Litecoin 및 XRP와 같은 주요 화폐의 가치는 모두 80% 이상 하락했으며, 수천 개의 다른 디지털 통화가 90%~99% 폭락했으며, 나머지는 완전히 사기 행위로 드러났다. 아무도 이 사실에 놀라지 말아야 한다: ICO 5개의 중 4개는 처음부터 사기였다. 시장의 이러한 유혈사태가 공공연히 드러남에 따라, 블록체인 옹호론자들은 모든 암호 화폐를 뒷받침하는 분산형 소프트웨어인 &quot;블록체인&quot;의 마지막 피난처로 달아났다. 블록체인은 가난과 기근에서부터 암까지 모든 것에 대한 잠재적인 만병통치약으로 알려지고 있다. 사실, 이 기술은 인류 역사상 가장 과장된 기술이며 가장 유용하지는 않다. 실제로 블록체인은 미화된 스프레드시트에 지나지 않는다. 그러나 그것은 또한 모든 정부, 중앙 은행, 전통적인 금융 기관 및 실제 통화를 파괴되어야하는 악의적인 권력 집중으로 취급하는 자유 주의적 이데올로기의 단어가 되었다. 블록체인 근본주의자들의 이상적인 세계는 모든 경제 활동과 인간의 상호작용이 무정부주의자나 자유주의자의 분권화의 영향을 받는 세계다. 그들은 사회 및 정치 생활 전반이 아마도 “영원히” 그리고 “신뢰할 수 있는 은행 같은 중재자에 의존하지 않는” 대중 지도자들에게 끝나기를 바란다. 아직 유토피아를 만드는 것과는 거리가 멀지만 블록체인은 친숙한 형태의 경제 지옥을 만들어냈다. 몇몇 백인 남성들은 세계의 가난하고 소외되고 은행가 없는 대중들이 수십억 달러의 부를 창출했다고 주장하면서 메시아인 척 한다. 그러나 우리는 단지 그 블록체인이 분배와 민주주의가 아니라 탐욕에 관한 것이라는 것을 알기 위해 암호통화 마이닝, 거래, 개발자와 재산권자들 사이의 대규모 권력 집중을 고려할 필요가 있다. 예를 들어, 주로 러시아, 그루지야, 중국과 같은 민주주의의 보루에 위치한 소규모 기업 집단은 모든 암호 화폐 마이닝 활동의 2/3~ 3/4를 통제하고 거래 비용을 늘려서 일상적으로 이윤을 늘린다. 명백히, 블록체인 광신도들은 우리를 중앙은행과 규제대상 금융 중개업자들을 신뢰하기 보다는 법의 지배를 받지 않는 익명의 카르텔에 믿음을 두도록 했을 것이다. 암호 화폐 거래에서도 비슷한 패턴이 나타났다. 모든 거래의 99%는 정기적으로 해킹되는 중앙 집중화된 거래소에서 발생한다. 그리고, 실제 돈과 달리, 일단 당신의 비밀의 재산이 해킹 당하면, 그것은 영원히 찾을 수 없게 된다. 게다가, 암호 화폐 개발의 중앙집중화는, 예를 들어, 근본주의자들은 이더리움의 창시자 Vitalik Buterin을 &quot;자비로운 종신 독재자 (benevolent dictator for life)&quot;라고 불렀다. 그리고 마치 블록체인 응용프로그램을 뒷받침하는 소프트웨어가 불변의 존재인 것처럼, ‘코드는 법’이라는 거짓 주장을 했다. 하지만 ㅏ그 사실은 개발자들이 판사와 배심원 역할을 할 절대적인 힘을 가지고 있다는 것이다. 스마트한 불법 도용 컨트랙트와 대규모 해킹이 발생하면 이들은 단순히 코드를 바꿔서 가짜 코인을 만들어 “신뢰할 수 없는” 기업 전체를 드러내게 된다. benevolent dictator for life (자비로운 종신 독재자)는 대게 소수의 오픈소스 개발자 리더에게 붙여지는 명칭으로, 보통 프로젝트의 창시자이자, 커뮤니티의 논쟁이나 토론에서 결정적인 말을 할 수 있는 사람을 의미합니다. 유명한 사람으로는 파이썬 개발자 귀도 반 루썸이 있습니다. 마지막으로, 지하세계의 부는 북한보다 훨씬 더 집중되어 있다. 지니계수가 1.0이라는 것은 한 개인이 한 나라의 소득/연방의 100%를 통제한다는 것을 의미하는 반면, 북한은 0.86을 기록했고, 오히려 불평등한 미국은 0.41, 비트코인은 놀랍게도 0.88 이다. 비트코인 지니계수에 대한 논의는 여기인 것 같은데 논문이 유료네 분명한 것은, ‘분권화’라는 주장은 이 사이비 산업을 통제하는 수십억 명의 가짜가 전파한 신화이다. 이제 암호 시장에 빨려 들어간 소매 투자자들이 모두 셔츠를 잃어 버렸기 때문에 남아있는 약장수 (snake-oil salesmen, 말그대로 약치는 사람들) 가짜 부의 더미에 앉아 있으며 &quot;자산&quot;을 청산하려고하면 이는 즉시 사라질 것이다. 분명한 것은, &quot;분권화&quot;라는 주장은 이 사이비 산업을 지배하는 사이비 억만장자들에 의해 유포된 신화이다. 이제 암호 시장에 속아 넘어간 소매 투자자들은 그들의 부를 모두 잃어버렸기 때문에, 남아있는 뱀장수들은 그들의 &quot;자산&quot;을, 청산하려고 하면 즉시 사라질 가짜 재산더미 위에 앉혀 놓았다. 블록체인 자체의 경우, 하늘 아래에 있는 모든 은행, 기업, 비정부 조직 또는 정부 기관(정부 기관)이 대차대조표 또는 거래 기록부, 거래자 없는 거래, 거래 및 거래 허가를 공공 분산을 통해 안내하고 있지 않다. 그러한 독점적이고 매우 귀중한 정보가 공개적으로 기록되어야 할 이유는 없다. 또한 분산형 기술(기업용 DLT라고도 함)이 실제로 사용되는 경우에는 블록체인과 아무런 관련이 없다. 그들은 사적이고 중앙 집중화 되어 있으며 단지 몇 개의 통제된 원장에 기록된다. 그들은 접근 허가를 필요로 하고, 그것은 자격을 갖춘 개인에게 부여된다. 그리고 아마도 가장 중요한 것은, 그들은 오랜 시간 동안 신뢰를 쌓아온 신뢰할 수 있는 당국에 근거하고 있다는 것이다. 이 모든 것은 이름만 “블록체인” 이다. 그것은 모든 “분할된” 블록체인이 실제로 사용되었을 때 중앙 집중화되고 허가된 데이터베이스라는 것을 말하고 있다. 이와 같이, 블록체인은 1979년에 발명된 표준 전자 스프레드시트에서도 개선되지 않았다. 어떤 심각한 기관도 세계 권위주의 독재 국가들의 그늘에서 운영되고 있는 익명의 카르텔에 의해 그것의 거래가 확인되는 것을 결코 허용하지 않을 것이다. 따라서 ‘블록체인’이 전통적인 환경에서 조종될 때마다 쓰레기통에 던져지거나, 엑셀 스프레드시트 같은 오도된 이름을 가진 데이터베이스에 불과한 개인 허가 데이터베이스로 변한 것은 놀라운 일이 아니다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인과 비트코인의 6가지 잘못된 믿음","slug":"blockchain-paradox-why-no-one-agrees","date":"2018-10-15T15:00:00.000Z","updated":"2018-10-15T22:44:04.000Z","comments":true,"path":"2018/10/16/blockchain-paradox-why-no-one-agrees/","link":"","permalink":"https://www.yceffort.kr/2018/10/16/blockchain-paradox-why-no-one-agrees/","excerpt":"Six myths about blockchain and Bitcoin: Debunking the effectiveness of the technology 원문 ¶비트코인에 대한 일반적인 사항 나는 비트코인 기술 자체가 혁명적이라고 생각한다. 불행히도 비트코인은 범죄행위에 너무 자주 사용되어 왔고, 정보보안 전문가로서 나는 그러한 관행을 강하게 싫어한다. 그러나 기술적으로 말하면 비트코인은 명백한 돌파구이다. 비트코인 프로토콜 컴포넌트와 내장 아이디어는 새로운 것이 아니다. 일반적으로 2009년 이전에 모두 알려졌지만, 비트코인","text":"Six myths about blockchain and Bitcoin: Debunking the effectiveness of the technology 원문 ¶비트코인에 대한 일반적인 사항 나는 비트코인 기술 자체가 혁명적이라고 생각한다. 불행히도 비트코인은 범죄행위에 너무 자주 사용되어 왔고, 정보보안 전문가로서 나는 그러한 관행을 강하게 싫어한다. 그러나 기술적으로 말하면 비트코인은 명백한 돌파구이다. 비트코인 프로토콜 컴포넌트와 내장 아이디어는 새로운 것이 아니다. 일반적으로 2009년 이전에 모두 알려졌지만, 비트코인의 개발자들만이 2009년에 그것을 다시 작동시키기 위해개발했다. 그 이후로 거의 9년 동안, 한 명의 악성 프로그램이 920억 개의 비트코인을 잡아냈을 때, 그것의 실행에서 오직 하나의 치명적인 취약성만이 발견되었다. 전체 재무 기록을 쉴새 없이 기록해야 하는 문제에도 불구하고, 9년 동안 단 하나의 취약점은 칭찬할 만하다. 개발자들에게 경의를 표한다. 비트코인의 개발자들은 중앙 시스템도 없고 아무도 다른 사람을 신뢰하지 않으면서 모든 것을 작동시키는 도전에 직면했다. 개발자들은 도전에 응하여 전자화폐를 운용통화로 만들었다. 그 과정에서, 그들의 결정 중 일부는 그들의 비효과적인 면을 파괴했다. 나는 많은 주목할 만한 사용을 보여준 유용한 기술인 크레딧 블록체인을 비난하려고 여기 온 것이 아니다. 단점에도 불구하고, 그것은 독특한 장점도 가지고 있다. 그러나, 선정적이고 혁명적인 것을 추구하면서, 많은 사람들은 종종 사물을 냉정하게 보는 것을 잊어버리고, 따라서 그것의 모든 단점을 무시하게 된다. 다양성을 위해, 기술의 단점에 초점을 맞추는 것이 유용할 수 있다. ¶믿음 1: 블록체인은 거대한, 분산된 컴퓨터다. 블록체인 운영의 원리를 살펴보지 않은 상태에서 이 기술에 대한 의견만 들어보셨을 경우, 블록체인은 분산형 분산형 컴퓨터라는 인상을 받을 수 있다. 여러분은 아마도 전 세계의 노드가 더 큰 무언가를 조금씩 모은다고 생각했을 것이다. 그것은 완전히 틀렸다. 실제로 블록체인을 유지하는 모든 노드가 동일한 작업을 수행한다. 수백만 대의 컴퓨터가 수행하는 작업은 다음과 같다. 동일한 규칙에 따라 동일한 거래를 확인하고 동일한 작업을 수행한다. 같은 것을 블록체인에 기록한다. 모든 이력을 저장하는데, 이것은 모두에게 항상 같은 것이다. 병행할 수 없고, 시너지 효과도 없고, 상호 원조도 없다. 단순간 백만배 중복이 있을 뿐이다. 효율과는 정반대다. ¶믿음 2: 블록체인은 영구적이다. 모든 것은 블록체인에 영원히 기록되어 있을 것이다. 모든 비트코인 네트워크 클라이언트는 전체 트랜잭션 기록을 저장한다. 이 레코드는 이미 100GB에 달한다. 저렴한 노트북 또는 최첨단 스마트폰 스토리지의 전체 용량이다. 비트코인 네트워크에서 처리되는 트랜잭션이 많을수록 크기가 더욱 커진다. 비트코인의 블록체인 성장은 가장 빠르지 않다. 경쟁관계인 Ethereum 네트워크는 출시 2년 만에 블록체인에 200GB의 기록 데이터를 축적했다. 따라서 블록체인의 수명은 현재 상황에서 10년으로 제한된다. HDD 용량의 증가는 분명히 뒤쳐져 있다. 대량의 데이터를 저장할 필요 외에도 데이터도 다운로드해야 한다. 로컬에 저장된 지갑을 암호화에 사용하려고 시도한 적이 있는 사람이라면 누구나 다운로드와 검증 과정이 완전히 완료될 때까지 돈을 주고 받을 수 없다는 사실에 놀라움과 실망감을 느껴보았을 것이다. 이렇게 물을 수도 있다. 모든 네트워크 노드에 저장하지 않는 것이 좋을까? 그럼요, 그게 더 효율적일 거다. 하지만 먼저, 피어 투 피어 블록체인이 아니라 기존 클라이언트-서버 아키텍처가 될 것이다. 둘째, 클라이언트는 서버를 신뢰해야 한다. &quot;누구도 믿지 말라&quot;는 것이 블록체인의 기초 중 하나라는 것을 기억하라. 오랫동안 비트코인 사용자들은 매니아들로 나뉘어져 있었는데, 이들은 모든 것을 다운로드 받고 자신의 컴퓨터에 모든 블록체인 전체를 저장하고, 온라인 지갑을 사용하고, 서버를 신뢰하지 않는 일반인들이다. ¶믿음 3: 블록체인은 효과적이고 확장가능하다. 화폐는 곧 사라질 것이다. 각 네트워크 노드가 동일한 작업을 수행하는 경우, 전체 네트워크의 대역폭은 한 네트워크 노드의 대역폭과 동일하다. 비트코인 네트워크는 초당 최대 7개의 트랜잭션을 처리할 수 있다. 그러나, 전 세계 수백만 명의 사용자를 대상으로 한다. 그 외에도 비트코인 블록체인 거래는 10분마다 한 번만 기록된다. 결제 보안을 강화하기 위해 기록이 정기적으로 롤백되기 때문에 새 레코드가 나타날 때마다 50분을 더 기다리는 것이 일반적인 관례다. 이제 비트코인을 이용해서 스낵을 사는 것을 상상해보아라. 전 세계를 고려해 본다면, 비트코인이 지구상의 인구 수천 명당 한 명 꼴로 사용될 때 조차도 그것은 우스꽝스럽게 들린다. 트랜잭션 처리 속도를 고려할 때 활성 사용자 수를 크게 늘릴 수는 없다. 비교를 위해 비자는 초당 수천 건의 트랜잭션을 처리하고 필요한 경우 대역폭을 쉽게 늘릴 수 있다. 결국, 고전적인 은행 기술은 확장 가능하다. 만약 전통적인 돈이 사라지면, 그것은 블록체인 때문이 아닐 것이다. ¶믿음 4: 마이너들이 네트워크 보안을 제공한다. 여러분은 분명히 발전소 옆에 존재하는 마이너와 거대한 마이닝 풀에 대해 들어봤을 것이다. 그들은 실제로 무엇을 할까? 그들은 10분 동안 아무런 목적도 없이 많은 전기를 소비하고, 블럭체인에 블럭을 추가할 수 있습니다. 기본적으로, 트랜잭션 기록을 다시 작성하려면 원래 기록을 작성하는 데 소요되는 시간과 동일한 시간이 필요하다(전체 컴퓨팅 성능과 동일). 그것을 이루기 위해 소비된 전기는 인구 10만 명의 도시가 사용할 양과 같다. 그리고 비트코인을 채굴하는 것 외에는 어떤 용도로도 거의 쓸모가 없는 값비싼 마이닝 장비도 필요하다. 블록체인 낙관론자들은 마이너들이 쓸모없는 작업을 수행할 뿐만 아니라 비트코인 네트워크의 안정성과 보안을 유지하고 있다고 말하는 것을 좋아한다. 이것은 사실이지만 문제는 마이너들이 비트코인을 다른 마이너들로부터 보호하고 있다는 것이다. 만약 현재 마이너들의 1,000분의 1만이 존재하고, 따라서 전기의 1천분의 1이 소비된다면, 비트코인은 지금과 다를 바 없을 것이다. 여전히 10분당 1블록을 만들어 동일한 수의 트랜잭션을 처리하고 동일한 속도로 작동한다. 51%의 공격 위험은 블록체인 솔루션에도 적용된다. 만약 누군가가 현재 마이닝에 사용되고 있는 컴퓨팅 파워의 절반 이상을 통제한다면, 그 사람은 몰래 다른 금융 역사를 쓸 수 있다. 그 버전이 현실이 된다. 따라서, 같은 돈을 한 번 이상 쓰는 것이 가능해진다. (이중지불공격) 전통적인 지불 시스템은 그러한 공격에 영향을 받지 않는다. 밝혀진 대로, 비트코인은 그 자신의 이데올로기의 포로가 되었다. “과도한” 마이너들은 마이닝을 멈출 수 없다. 이는 한 사람이 나머지 컴퓨팅 능력의 절반 이상을 장악할 확률을 극적으로 높일 것이다. 마이닝은 여전히 수익성이 있고, 네트워크는 여전히 안정적이다. 그러나 상황이 변화하면(예: 전기 가격이 상승하는 경우), 네트워크는 수많은 “이중 소비” 사고를 경험할 수 있다. ¶믿음 5: 블록체인은 분산화되있고, 그래퍼 파괴불가능하다. 블록체인이 각 네트워크 노드에 저장되어 있는 경우, 중앙 집중화된 서버나 이와 유사한 서버가 없는 경우 특수 서비스나 당국이 비트코인을 종료할 수 없는 것처럼 보일 수 있다. 하지만 그것은 단지 환상일 뿐이다. 사실, 모든 “독립형” 마이너들은 마이닝풀로 합쳐진다. 그들은 아마 매 천년마다 엄청난 보너스보다는 작지만 안정적인 수입을 얻는 것이 더 낫다는 가정 하에 합쳐져 있다. 위의 파이 차트는 최대 광업 풀 중 약 20개를 보여 주지만, 상위 4개 풀이 모든 컴퓨팅 파워의 50% 이상을 제어하는 것을 볼 수 있다. 단지 네 대의 컨트롤 컴퓨터에 접근할 수 있게 되면 누군가가 비트코인을 두 배로 쓰는 능력을 갖게 될 것이다. 여러분이 상상할 수 있듯이, 이것은 비트코인을 다소 감가상각시킬 수 있고, 실제로 그것을 하는 것은 꽤 실현 가능하다. 그러나 이러한 위협은 상기에서 암시하는 것보다 훨씬 더 심각하다. 대부분의 풀은 컴퓨터 능력과 함께 한 국가 안에 위치하고 있기 때문에 비트코인을 훨씬 쉽게 포착하고 제어할 수 있다. ¶믿음 6: 익명성과 개방적인 성격은 블록체인을 좋은 것으로 만든다. 블록체인(Blockchain)이 개방되어 있고, 모든 사람이 모든 것을 볼 수 있다. 그러므로 블록체인은 진짜 익명성이 없다. 그것은 대신에 가명을 제공한다. 비뚤어진 사용자들이 가지고 있는 주요 이슈들은 제쳐두고, 여기 왜 익명성이 정직한 사용자들에게 나쁜가 하는 이유가 있다. 간단한 예를 들어보자. 나는 엄마에게 몇개의 비트코인을 보낸다. 그 과정에서 엄마는 아래와 같은 것을 알 수 있다. 내가 가진 돈이 얼마인지. 내가 얼마나 소비했는지, 더 중요한 것은, 내가 무엇에 소비했는지이다. 그녀는 또한 내가 무엇을 샀는지, 내가 무엇을 도박했는지, 그리고 내가 “익명하게” 어떤 정치인을 지지했는지 알아낼 수 있었다. 또는, 만약 내가 내 친구에게 레모네이드에 대한 돈을 갚는다면, 나는 그에게 내 재정에 대한 모든 것을 알려줄 것이다. 그것은 결코 사소한 문제가 아니다: 당신은 당신이 알고 있는 모든 사람들에게 당신의 신용카드의 재무 내역을 공개할 것인가? 이것은 과거뿐만 아니라 미래의 거래도 포함한다는 것을 명심하라. 일부 공개는 개인에게 용인될 수 있지만 기업들에게는 치명적이다. 그들의 계약 당사자, 판매자, 고객, 계좌 금액, 그리고 다른 모든 사소한 세부 사항들이 모두 공개될 것이다. 재정적인 투명성은 비트코인 사용의 가장 큰 단점 중 하나일 것이다. ¶결론 나는 비트코인과 그것이 사용하는 블록체인 버전의 6가지 주요 단점을 열거했다. 여러분은 이렇게 물을지도 모른다. 왜 아무도 이 문제에 대해 인지 하지 못하는가? 어떤 사람들은 눈이 멀고, 어떤 사람들은 기술이 어떻게 작동하는지 이해하지 못할 수도 있고, 어떤 사람들은 모든 것을 보고 실현할 수도 있지만, 시스템이 그들을 위해 작용하고 있다고 느낄 수도 있다. 비트코인을 구매한 많은 사람들이 피라미드 구조에서처럼 광고를 시작하고 이를 옹호하기 시작한다. 비트코인 가치 상승에 기대를 걸고 있는데 왜 기술에는 불이익이 있다고 하는가? 네, 비트코인에게는 이러한 문제들 중 일부를 해결하려는 경쟁자들이 있다. 그 아이디어들 중 일부는 꽤 훌륭하지만, 여전히 블록체인(blockchain)에 기반을 두고 있다. 네, 블록체인 기술을 위한 다른 비화폐성 응용 프로그램들이 있지만, 주요 단점도 이와 비슷한 맥락에서 발견된다. 그러므로 만약 누군가가 여러분에게 블록체인의 발명은 인터넷의 발명과 중요성의 측면에서 비교될 수 있다고 말한다면, 회의적으로 반응해라.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 패러독스: 왜 분산원장 기술이 경제를 바꾸는데 미칠 영향이 적을 수 있는가?","slug":"the-blockchain-paradox-why-distributed-ledger-technologies-may-do-little-to-transform-the-economy","date":"2018-10-14T15:00:00.000Z","updated":"2018-10-15T00:36:12.000Z","comments":true,"path":"2018/10/15/the-blockchain-paradox-why-distributed-ledger-technologies-may-do-little-to-transform-the-economy/","link":"","permalink":"https://www.yceffort.kr/2018/10/15/the-blockchain-paradox-why-distributed-ledger-technologies-may-do-little-to-transform-the-economy/","excerpt":"The blockchain paradox: Why distributed ledger technologies may do little to transform the economy 원문 비트코인의 기반 기술인 블록체인은 다순한 디지털 결제보다 훨씬 더 많은 응용 프로그램을 만들어 낼 수 있을 것으로 보인다. 그것은 \"경제 조직에 대한 개념의 패러다임 변화\"로 유명하다. 그러나 OII의 Vili Lehdonvirta 교수는, 그러한 혁명적 잠재력은 기술의 지배와 관련된 근본적인 역설에 의해 약화될 수 있다고 주장한다. 저 (Vili","text":"The blockchain paradox: Why distributed ledger technologies may do little to transform the economy 원문 비트코인의 기반 기술인 블록체인은 다순한 디지털 결제보다 훨씬 더 많은 응용 프로그램을 만들어 낼 수 있을 것으로 보인다. 그것은 &quot;경제 조직에 대한 개념의 패러다임 변화&quot;로 유명하다. 그러나 OII의 Vili Lehdonvirta 교수는, 그러한 혁명적 잠재력은 기술의 지배와 관련된 근본적인 역설에 의해 약화될 수 있다고 주장한다. 저 (Vili Lehdonvirta 교수 지칭) 는 최근에 &quot;분산 원장 기술의 지배구조 문제&quot;라는 제목으로 Alan Turing Institute (ATI)에서 강연을 했다. 제 강연의 시작점은 블록체인 기술이 금융 서비스나 정부와 같은 &quot;디지털 기록 유지에 의존하는 산업들을 혁명화시킬 것&quot;이라고 종종 주장했다. 이 강연에서 저는 기본적인 제도적 경제학을 적용하여 블록체인 기술이 실제로 경제 조직 측면에서 어떤 역할을 하는지, 그리고 이것이 어떤 문제를 야기하는지 조사했다. 이 에세이에서 나는 그 주장의 간략한 버전을 제시합니다. 또는 아래 비디오를 볼 수 있다. 첫째, 블록체인(blockchain)의 정확한 의미에 대해 상당한 혼란이 있다는 점을 유념할 필요가 있다. 사람들이 &quot;블록체인&quot;에 대해 이야기할 때, 그들은 종종 비트코인 블록체인, 2009년에 시작되어 비트코인 P2P 네트워크를 형성하는 약 5,000대의 컴퓨터에 의해 유지되고 있는 거래의 선두주자인 비트코인이라고 언급한다. blockchain이라는 용어는 동일한 기술의 다른 인스턴스나 포크를 가리키는 데 사용될 수도 있다. 최근 DLT(Distributed Ladger Technology)라는 명칭도 관련 기술에 대한 보다 일반적인 명칭으로 통용되고 있다. 각각의 경우에, 나는 오늘날 많은 사람들이 블록체인에 대해 그렇게 흥분하는 이유가 그런 기술적 특성이 아니라고 말하는 것이 옳다고 생각한다. 초당 트랜잭션과 같은 성능 지표 측면에서 기존 블록체인 기술은 여러 면에서 기존 기술에 비해 열악하다. 이는 비트코인 네트워크가 초당 최대 약 7개의 트랜잭션을 처리할 수 있도록 설계에 의해 제한되는 반면, 비자 지불 네트워크는 초당 최대 56,000개의 트랜잭션 용량을 가지고 있다는 점을 자주 보여준다. 다른 구현에서는 성능이 향상될 수 있으며, 일부 다른 메트릭스에서는 블록체인 기술이 기존 기술을 능가할 수도 있다. 그러나 기술적인 성과는 블록체인이 혁명적이고 패러다임을 바꾸는 것이라고 많은 사람들이 생각하는 이유가 아니다. 블록체인이 파도를 일으키는 이유는 중앙집권적 제3자를 제거하는 등 경제조직의 방식을 바꿀 것을 약속하기 때문이다. 이것이 이론적 용어로 무엇을 의미하는지 설명해보자. 장거리 무역과 같은 많은 경제적 거래는 죄수들의 딜레마 게임으로 모델링될 수 있다. 구매자와 판매자는 협력하거나 (선적/지불을 약속한 대로 발송) 협조하지 않을 (배송/지불 보내지 않음) 수 있다. 만약 구매자와 판매자가 서로를 신뢰하지 않는다면, 균형 해결책은 경쟁자가 협력하지 않고 무역이 이루어지지 않는다는 것이다. 이것은 협력의 근본적인 문제로 알려져 있다. 협력 문제에 대한 몇 가지 고전적인 해결책이 있다. 하나는 평판이다. 회원들이 반복적으로 교환에 참여하는 거래자 사회에서, (약속을 이행할 수 없는) 결함이 있는 거래자는 부정적인 평판을 얻게 되고, 다른 거래자들은 그들과의 거래를 거절하게 된다. 이 지역 사회로부터의 배제의 위협은 탈선에 대한 억제책의 역할을 하며, 특정 조건에서의 균형은 모든 사람들이 협력하는 것이 된다. 그러나 명성은 제한된 해결책일 뿐이다. 그것은 평판 정보가 효과적으로 퍼지는 공동체 내에서만 작동하며, 그렇게 함으로써 얻는 이익이 미래의 무역 손실보다 더 클 경우 거래자들은 여전히 탈선할 수 있다. 사람들이 일상적으로 낯선 사람들과 거래하는 현대의 큰 규모의 시장 경제는 제3자라는 다른 해결책 때문에만 가능하다. 특히, 이것은 정부가 시행하는 계약과 은행이 시행하는 환어음을 의미한다. 본질적으로 이러한 제3자들은 당사자들이 협력하고 그들의 약속을 이행하도록 강요한다. 무역 외에도, 협력의 문제의 또 다른 예는 통화(화폐)다. 화폐는 죄수들의 딜렘마의 멀티플레이어 게임으로 모델링될 수 있다. 무역업자들은 전반적으로 안정적인 통화 유지에 관심이 있다. 왜냐하면 그것은 교역에 있어 윤활유의 역할을 하기 때문이다. 그러나 각 거래자는 위조지폐(블록체인 말로 하는 것을 이중지출이라고 한다)의 관점에서, 개별적으로 화폐의 가치 하락에 관심을 가진다. 이 딜레마에 대한 고전적인 해결책은 제3자의 집행이다: 국가 정책, 위조지폐를 처벌하고, 은행은 은행장들을 통제하며 사람들이 그들이 가지지 않은 돈을 쓰지 못하게 한다. 그래서 제3자의 집행은 오늘날의 시장 경제에서 경제 조직의 지배적인 모델이다. 하지만 문제가 없는 것은 아닙니다. 그 제 3자라고 불리는 존재들은, 시행된 것과 관련하여 강력한 위치에 있다. 은행들이 과도한 수수료를 추출할 수 있고, 주 정부들은 통화를 절하하거나, 불법적으로 자산을 동결하거나, 부당하게 계약을 시행함으로써 권력을 남용할 수 있다. 제3자 시행 문제에 대한 전형적인 해결방안은 경쟁이다. 은행 수수료는 경쟁에 의해 억제된다. 그러나 경쟁은 항상 실행 가능한 해결책이 아니다. 만약 당신의 국가가 권력을 남용하기 시작하면 다른 국가(즉, 난민이 되는)로 전환하는 데 드는 비용이 매우 높다. 또 다른 고전적인 해결책은 책임이다: 집행자가 행동하는 것을 확실히 하기 위해 노력하는 것이 민주 기관이다. 예를 들어, 은행 간 결제 메시지 네트워크 SWIFT는 은행들이 소유한 협동 커뮤니티다. 회원은 조직의 최고 의사결정 기구인 이사회를 선택한다. 이런 식으로, 그들은 SWIFT가 회원 은행으로부터 과도한 수수료를 빼내거나 그들에게 그것의 힘을 남용하지 않도록 하려고 시도한다. 그럼에도 불구하고, 책임조차도 그것의 문제가 없는 것은 아니다. 왜냐하면 그것은 다른 멤버들의 서로 다른 이해관계를 가능한 한 잘 조화시키려는 정치와 함께 나오기 때문이다. 이러한 그림에 바로 블록체인(블록체인)이 들어간다. 제3자가 바로 분산 네트워크로 대체되는 기술이다. 계약을 시행하고, 이중 지출을 방지하고, 참가자가 권력을 남용할 수 있는 특정 제 3 자에게 권력을 양도하지 않고도 모든 풀의 크기를 제한할 수 있다. 어떠한 세금, 권력 남용도, 정치도 없다. 블록체인 기술은 국가나 은행의 불완전하고 변덕스러운 인간 관료주의가 아니라 기계의 공정성으로 시행되는 ‘수학 기반의 돈’과 ‘멈출 수 없는’ 계약을 만드는 데 사용될 수 있다. 이것이 바로 많은 사람들이 블록체인에 대해 흥분하는 이유다. 그 능력은 지배적인 권력 관계를 변화시키는 방식으로 경제 조직을 변화시킵니다. 불행하게도 이것은 블록체인에 대한 순진한 이해로 밝혀졌고, 현실은 불가피하다. 왜 그런지 보자. 경제 기구에서 우리는 규칙을 시행하는 것과 규칙을 만드는 것을 구별해야 한다. 법은 국가 관료주의에 의해 시행되고 입법부에 의해 만들어진 규칙이다. SWIFT 프로토콜은 SWIFTNet(중앙집중식 컴퓨터 시스템)에 의해 시행되고 궁극적으로 SWIFT 이사회에 의해 만들어진 일련의 규칙입니다. 비트코인 프로토콜은 정확히 누가 만든 비트코인 네트워크(컴퓨터의 분산 네트워크)에 의해 시행되는 일련의 규칙입니다. 누가 규칙을 만드는지는 누가 규칙을 강요하는 것만큼 중요하다. 블록체인 기술은 완전히 공정한 규칙 강화를 제공할 수도 있지만, 규칙 자체가 바뀌면 별로 위안이 되지 않는다. 이 규칙 제정은 우리가 통치라고 부르는 것이다. 비트코인을 예로 들면, 프로토콜의 초기 버전(즉, 규칙)은 나카모토 사토시라는 필명으로 작성되었으며, 이후 버전은 핵심 개발 팀에 의해 공개된다. 개발팀은 독재적이지 않다. 복잡한 사회적, 기술적 난맥을 가진 사람들은 비트코인의 규칙이 어떻게 정해지는지에 영향력을 행사하고 있다는 것을 의미한다. 여기서 요점은 비트코인의 정치적 질서를 가려내려는 것이 아니다; 요점은 비트코인이 어떤 의미에서든 인간 정치를 배제하지 않았다는 것이다; 사람들은 여전히 네트워크가 강요하는 규칙을 설정하는 것에 매우 큰 책임이 있다. 그러나 비트코인에서 거버넌스가 어떻게 작동하는지에 대한 공식적인 과정은 없다. 왜냐하면 오랫동안 이러한 정치체계는 분명히 인식되지 않았고 많은 사람들은 전적으로 비트코인이라는 생각을 선호하기 때문이다. 그러나 이 입장을 옹호하기 시작했고 비트코인의 정치가 가시화 된 것은 소위 &quot;블록 크기 논쟁&quot;인데 이것은 비트코인 사회의 파벌들 사이의 미래의 규칙 방향에 대한 큰 차이이다. 이해관계자마다 이해관계가 다르며, 이해관계가 조화될 수 있는 강력한 거버넌스 메커니즘이 없는 상황에서 소셜 미디어와 토론 포럼을 둘러싼 양 진영 간의 &quot;전쟁&quot;이 벌어졌다. 경쟁이 이 문제를 해결할까? 비트코인 프로토콜의 여러 &quot;forks&quot;가 등장했는데, 각각은 약간 다른 규칙을 가지고 있다. 그러나 네트워크 경제학은 우리에게 강력한 네트워크 효과 앞에서 경쟁이 전혀 잘 되지 않는다는 것을 가르쳐 준다. 모든 사람들은 다른 사람들이 있는 네트워크에 있는 것을 선호한다. 비록 그것의 규칙이 그들이 선호하는 것이 아니더라도 말이다. 네트워크 시장은 가장 큰 네트워크를 선호하는 경향이 있다. 모든 포크/스플릿은 시스템의 총 가치를 감소시키고, 포크의 소수에 있는 사람들은 결국 그들의 자산이 쓸모없게 될 수 있다. 경쟁이 안 되면 책임감을 갖게 된다. 비트코인이 어떻게 책임 있는 거버넌스 기구가 발전할 수 있는지는 명백하지 않다. 그러나 다른 블록체인 프로젝트들, 특히 어떤 종류의 상업적이거나 공공 부문 합법성을 얻고 있는 프로젝트들은, 책임 있는 관리 수준을 바탕으로 처음부터 고안되었다. 예를 들어, R3는 금융 서비스 산업에서 사용할 블록체인 기술을 개발하는 회사이다. 그것은 그 노력을 이끌기 위해 은행들의 컨소시엄을 등록했고, 그것의 문서들은 그것의 &quot;회원 은행들&quot;으로부터 얻은 &quot;명령 (규칙)&quot;에 대해 이야기한다. 지배구조 모델은 SWIFT 같은 것의 시작과 매우 흡사하게 들린다. 또 다른 예로는 RSCoin이 있다. RSCoin은 ATI 동료 George Danezis와 Sarah Meiklejohn에 의해 고안되었다. 이것은 중앙 은행이 관리하게 된다. 모델에 상관없이, 내 요점은 블록체인 기술이 지배구조의 문제를 피할 수 없다는 것이다. 그들이 그것을 인식하든 그렇지 않든, 그들은 기존의 제 3 자 집행자와 동일한 지배 구조 문제에 직면 해 있다. 기술을 사용하여 잠재적으로 거버넌스 프로세스를 향상시킬 수 있다 (예 : 투명성, 온라인 심의, 전자 투표). 하지만 거버넌스를 그렇게 조작할 수는 없다. 이 모든 것이 나를 놀라게 한다. 얼마나 혁신적인 블록체인 기술이 실제로 존재하는지 말이다. 만약 여러분이 여전히 그것을 작동시키기 위해 이사회나 유사한 기관에 의지한다면, 경제 조직은 실제로 얼마나 변화했는가? (이사회에 의존하나, 블록체인에 의존하나 무슨 차이가 있냐는 뜻) 그리고 이것이 저의 마지막 요점인 도발로 이어집니다. 일단 거버넌스 문제를 해결하면 더 이상 블록체인을 필요로하지 않는다. 신뢰할 수 있는 중앙 파티를 가정하는 기존 기술을 사용하여 규칙을 시행할 수 있다. 왜냐하면 당신은 이미 누군가 (또는 일부 조직 / 프로세스)를 신뢰하여 규칙을 만들 수 있기 때문이다. 나는 이 블록체인의 ‘거버넌스 패러독스’를 ‘거버넌스 패러독스’라고 부른다. 실제로 R3의 디자인에는 ‘독특한 서비스’라는 것이 있는 것으로 보인다. 이는 신뢰할 수 있는 제3자 집행자처럼 보인다 (백서에서는 분명하지 않지만). RSCoin은 마찬가지로 전적으로 신뢰할 수있는 제 3 자에 의존합니다. 기존 기술과의 (블록체인 간) 차이점은 더 이상 분명하지 않다. 블록체인 기술은 더 나은 가용성 및 데이터 무결성과 같은 더 나은 기술적 성능을 제공할 수 있다. 하지만 경제 조직과 권력 관계의 진정한 변화가 무엇인지는 분명하지 않다. 내가 잘못을 저질렀던 내 추론의 한 부분을 지적할 수 있다면, 나는 이 문제에 대해 도전을 받게 되어 매우 기쁘다. 이해는 토론을 통해 커진다. 하지만 당분간은 블록체인이 근본적으로 경제나 정부를 변화시킬 것이라는 주장에 회의적일 수밖에 없다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 및 브렉시트: 영국-EU 관계에서 블록체인 채택이 어떻게 도움이 될 수 있는가","slug":"blockchain-and-brexit-how-adoption-could-help-with-ukeu-relations","date":"2018-10-13T15:00:00.000Z","updated":"2018-10-14T10:34:11.000Z","comments":true,"path":"2018/10/14/blockchain-and-brexit-how-adoption-could-help-with-ukeu-relations/","link":"","permalink":"https://www.yceffort.kr/2018/10/14/blockchain-and-brexit-how-adoption-could-help-with-ukeu-relations/","excerpt":"Blockchain and Brexit: How Adoption Could Help With UK–EU Relations 원문 블록체인은 한 명의 새로운 지지자를 가지고 있다. 바로 영국의 재무장관 필립 해몬드이다. 그는 보수당 회의에서 영국 정부가 브렉시트의 영국-이슬람 국경 문제를 어떻게 해결할 수 있는지에 대해 질문을 받았다. 다양한 기술이 보급되고 있습니다. […] (내가) 전문가라고 주장하는 것은 아니지만 가장 분명한 기술은 블록체인입니다. 그는 더 이상 세부 사항을 밝히지 않았지만 북 아일랜드와 아일랜드 공화국 간","text":"Blockchain and Brexit: How Adoption Could Help With UK–EU Relations 원문 블록체인은 한 명의 새로운 지지자를 가지고 있다. 바로 영국의 재무장관 필립 해몬드이다. 그는 보수당 회의에서 영국 정부가 브렉시트의 영국-이슬람 국경 문제를 어떻게 해결할 수 있는지에 대해 질문을 받았다. 다양한 기술이 보급되고 있습니다. […] (내가) 전문가라고 주장하는 것은 아니지만 가장 분명한 기술은 블록체인입니다. 그는 더 이상 세부 사항을 밝히지 않았지만 북 아일랜드와 아일랜드 공화국 간의 ‘마찰없는’ 관계를 촉진하는 한 가지 방법으로 분산 원장 기술(DLT)을 육성하여, 블록 체인이 영국과 EU 간의 원활한 포스트 브렉시트 무역을 보장하는 데 도움이 될 수 있다는 희망을 촉발 시켰다. 그러나 DLT가 Brexit 이후 세계에서 사용될 가능성은 있지만 블록체인 기술을 포함하는 솔루션이 규모에 맞게 출시되기까지는 아직 갈 길이 멀다. 그리고 보다 근본적으로, 최고의 블록체인이 불변하는 거래를 만드는 선도자라 치더라도, 여기에 입력된 데이터의 초기 신뢰성에 대한 영원한 문제는 여전히 남아 있을 것이다. ¶블록체인과 국경 Vili Lehdonvirta는 Cointellegraph에게 &quot;블록체인 기술이 북아일랜드와 아일랜드 공화국 사이에 마찰이 없는 국경을 제공하는 데 도움이 될 가능성은 전혀 없다&quot;고 말합니다. Lhdonvirta의 옥스포드 대학의 부교수이자 수석 연구원인 Lhdonvirta의 최근 연구는 더 넓은 세계 경제에 블록체인의 적용에 초점을 맞추고 있다. 그리고 그는 DLT를 대신하여 이루어진 약속들에 대해 잘 알고 있지만, 그는 이 약속들의 대부분이 실현될지에 대해 회의적이다. &quot;블록체인은 사람들이 무슨 말을 하고 있는지 모르는 필립 해몬드와 같은 사람들에게 온갖 희망과 꿈을 좇는 마법의 용어가 되었습니다. 나는 블록체인 기술이 여기서 어떻게 도움을 줄 수 있는지 설명하는 것이 지지자들에게 달려있다고 생각한다. 우선, 우리는 여기서 “블록체인&quot;이 정확히 무엇을 의미하는지 알 필요가 있을 것이다. 비트코인 스타일의 피어 투 피어(Peer-to-Peer) 검증 시스템을 의미한다면 어떤 이점이 예상되느냐에 따라 처리량과 지연 시간이 큰 문제가 될 것이다.” 실제로, 스케일링은 여전히 ​​Bitcoin 및 기타 작업 증명 (PoW) 블록 체인 (예 :. Ethereum, Bitcoin Cash, Litecoin, Monero) 그리고 최근 몇 달 동안 개선이 이루어졌지만 아일랜드 (및 다른 모든 EU-UK) 국경 경험에 대한 엄청난 일일 교통량에 대처하는 Bitcoin 스타일의 블록 체인을 상상하는 것은 여전히 어렵다. 예를 들어, 평균 약 3 만 명이 매일 남북 국경을 넘어 일을하고 북 아일랜드 수출의 35 %가 공화국 (2016 년 약 40 억 파운드)으로 이동합니다. 이것은 엄청난 양의 트래픽이지만 P2P 작업 증명방식의 블록 체인은 기존 시스템에 비해 특히 확장 가능하지 않다. Bitcoin은 초당 최대 7 건의 거래 (Visa의 50,000+와 비교하여)를 처리할 수 있으며 Ethereum은 CryptoKitty로 인해 지난 12월 엄청나게 느려졌었다. 사설 또는 '허가기반’의 프라이빗블록체인 경우, Lehdonvirta는 그들이 많은 약속을 지키지 않는다고 생각한다. “IBM 스타일 프라이빗 블록체인(Blockchain)을 의미한다면, 이는 본질적으로 공유 데이터베이스일 뿐이며 특별히 획기적인 것은 아니다.” 이것은 특별히 획기적인 일이 아닐 뿐만 아니라, 현재 개인 블록체인이 공유 데이터베이스보다 눈에 띄게 더 효율적이거나 효과적이라는 징후는 없다. “허용된 블록체인에 대해 이야기한다면, 그들은 중앙집중식 데이터베이스에 비해 어떠한 이점이 있다는 것을 아직 입증하지 못했다” 라고 저는 EY의 전 리더인 Angus C. de Crespigny가 말한다. ¶좋은 국경은 없는 국경 블록체인의 국가간 무역에 대한 적용가능성에 대한 비관적인 평가는 다른 전문가들도 마찬가지다. GlobalData의 기술 연구 프로그램 수석 분석가인 Gary Barnett은 다음과 같이 말한다. 블록체인 기술은 국경 간 무역에 적합하지 않다. 그것은 비싸고, 복잡하고, 느리다. 블록체인은 네트워크에서 단일 참여자가 거래 조정자의 역할을 맡을 수 없는 영역에서만 유용하거나 흥미로워집니다. 국경간 무역에서 수입업자들이 좋든 싫든 간에 국경 당국은 어떤 시스템이든 무역업자에 사용하라는 역할과 명령을 취할 수 있다. 그리고 더 근본적으로는 아일랜드 국경 문제를 ‘해결’하는 블록체인의 가능성을 약화시키는 정치적 긴장이 심다. 얼마나 효율적이고 저렴하며 신뢰할 수 있는 DLT가 될 수 있든 상관없이, 아일랜드 사람들은 20년(1998년 성 금요일 협정 이후) 한 나라에서 다른 나라로 자유롭게 지나가는 데 익숙해진 후 어떤 종류의 세관 절차에도 매우 불만스러워할 것이다. Landmark Public Affairs (그리고 이전에는 유럽 국제 정치 경제 센터)의 무역 및 디지털 경제 전문가인 닉 보튼은 코인 텔레 그래프에 다음과 같이 말한다. 애석하게도 북아일랜드 문제는 기술을 통해 해결될 것 같지 않은 문제이며, 이 단계에서는 엄밀히 말하면 정치적인 문제이다. 비록 블록체인 세관 이 향후 5년 안에 개발될 수 있는 것으로 모든 세관 문제를 완벽하게 처리할 수 있다 하더라도, 아일랜드나 북아일랜드와 나머지 영국 사이 에서는 여전히 판매하기 불가능할 것이다. 국경은사기와 밀수를 막기 위해 치안유지를 필요로 하는 국경이다. 그런 협정은 어디에 있던 간에 거부 될 것이다. ¶기본적인 문제 이 문제가 영국의 미래 무역과 나머지 EU와의 관계를 포함시키기 위해 범위가 확대될 때, 약간 더 낫지만, 여전히 어떤 블록체인이 기존의 해결책을 제공할 수 있는지에 대한 심각한 의문점들이 남아 있다. 디지털 컨설팅 그룹인 Reply는 12월에 &quot;Brexit UK-EU 이후의 무역에 DLT가 도움이 될 수 있는 분야를 요약한 &quot;Blockchain for Brexit&quot;이라는 보고서를 발행했다. 보고서 저자들은 &quot;블록체인의 주된 기여는 상품에 대한 강력하고 빈틈없는 데이터 추적을 확립하는 것&quot;이라며 “국경 검사 필요성이 줄어들 것&quot;이라고 주장했다.” 그러나 보고서에서는 블록체인에 대한 역할을 실현하려면 여러 가지 조건과 과제를 충족해야 한다고 언급한다. 즉, 블록체인을 적절하게 사용하는 것은 항목의 원산지를 기록하는 것만으로는 충분하지 다. 검사를 포함하여 항목과 관련된 모든 트랜잭션에 대한 전체 기록이 있어야 한다. 이는 공급 체인의 모든 링크에 블록체인을 추가하는 것을 의미한다. 이와 같이 완전한 기록을 유지하는 것은 노동 집약적인 일이 될 수 있으며, 특히 제품 처리에 관한 경우에는 더욱 그러하다. 예를 들어, 큰 동물이나 생선을 조각으로 잘라 여러 소비자들에게 팔 수 있다. Blockchain을 사용하여 총 중량이 전체의 원래 무게와 일치하는지 확인할 수 있지만, 이는 다시 모든 조각들이 추적가능하다고 가정해야 하는 것이다. 훨씬 더 심각한 문제는 블록체인에 처음 입력된 데이터가 신뢰할 수 있다는 가정에 관한 것이다. 예를 들어, 블럭체인은 스페인에서 온 오렌지와 공급망을 가로지르는 것에 대해 누가 방해받았는지, 누가 스페인어를 가로질렀는지 그 사람이 먼저 알 수는 없지만, 그 진리는 보증할 수 없다고 말할 수 있다. 포르투갈에서 온 것일 수도 있다. 즉, 초기 기록과 분산형 원장의 출품작에 대한 신뢰도를 결정하기 위한 추가 시스템을 마련해야 한다. 퍼블릭 블록체인 경우 블록체인은 사용자가 입력한 데이터만큼만 유효하며, 어떤 데이터가 입력되는지 합의하려면 먼저 사람들을 조율해야 한다. 블록체인은 다양한 그룹의 사람들을 조정하는 방법으로 홍보되고 있지만, 이러한 조정은 기술적인 문제가 아니라 사람들의 문제이다. 일단 사람들을 조정할 수 있게 되면, 블록체인보다 더 나은 사용 기술이 거의 항상 존재한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"어떻게 블록체인이 우리가 아는 마케팅을 바꿀 것인가?","slug":"how-blockchain-will-change-marketing-as-we-know-it","date":"2018-10-12T15:00:00.000Z","updated":"2018-10-13T00:36:12.000Z","comments":true,"path":"2018/10/13/how-blockchain-will-change-marketing-as-we-know-it/","link":"","permalink":"https://www.yceffort.kr/2018/10/13/how-blockchain-will-change-marketing-as-we-know-it/","excerpt":"How Blockchain Will Change Marketing As We Know It 원문 ¶1. Introduction 블록체인은 마케팅과 광고에 중요한 영향을 미친다. 그러나 CMO 조사에 따르면, 회사의 8 %만이 마케팅에서 블록 체인 사용을 중요하다고 생각하고 있는 것으로 나타났다. 블록체인 기술은 제대로 이해되지 않고 많은 과대 광고의 대상이 된다. 이러한 요소는 진입에 대한 자연스러운 장벽을 만들어 마케터가 “기다리고 보는” 접근 방식을 취할 가능성이 크다. 그러나 현재 이 기술을 이해하고 해당 업계의 특정 마","text":"How Blockchain Will Change Marketing As We Know It 원문 ¶1. Introduction 블록체인은 마케팅과 광고에 중요한 영향을 미친다. 그러나 CMO 조사에 따르면, 회사의 8 %만이 마케팅에서 블록 체인 사용을 중요하다고 생각하고 있는 것으로 나타났다. 블록체인 기술은 제대로 이해되지 않고 많은 과대 광고의 대상이 된다. 이러한 요소는 진입에 대한 자연스러운 장벽을 만들어 마케터가 “기다리고 보는” 접근 방식을 취할 가능성이 크다. 그러나 현재 이 기술을 이해하고 해당 업계의 특정 마케팅 애플리케이션을 탐구하기 위해 시간을 투자해야 하는 많은 이유가 있다. 디지털 플랫폼, 소셜 미디어, 핀테크 등 수많은 혁신과 마찬가지로 블록체인의 전리품은 파괴적인 혁신을 추구하는 얼리 어답터들에게 돌아갈 수 있다. 블록체인의 속성은 투명성, 불변성, 보안 등 공급망 관리, 스마트 컨트랙트, 재무보고, 사물 인터넷, 개인(의료) 정보 관리, 심지어 스마트 전력 그리드 관리와 같은 다양한 응용 프로그램에 대해 신뢰를 제공할 수 있다. 또한, 데이터 전송 모델은 거래 비용을 줄이고 검증 및 효율적인 소유권 거래를 가능하게 하며 실시간 소액 지불의 가능성을 높인다. 지불 결제에 있어 마찰이 줄어들고, 중개인이 사라지고, 소비자가 개인 정보를 소유하고 통제할 수 있게 해준다. 여기서 우리는 마케팅에서 블록체인의 파괴적인 잠재력을 보려고 한다. ¶2. 거의 제로에 가까운 거래 비용이 마케팅에 주는 임팩트 오늘날 금융 거래는 상당한 거래 비용을 가지고 있다. 소매 업체는 신용 카드 회사에 3 %의 지불 처리 비용을 지불하고, 주유소는 더 많은 비용을 지불한다. eBay 및 Shopify 유료 상장 및 판매 수수료를 요구하는 업체가 있고, PayPal과 같은 지불 포털에 대한 거래 수수료를 요구하느 업체가 있다. 이 모든 수수료는 상품 비용을 증가시키고 일반적으로 소비자에게 전달된다. 신용 카드와 직불 카드가 널리 보급됨에 따라 많은 상인들은 수수료로 수익성이 파괴되는 것을 피하기 위해 최소 구매 갯수 설정하기 시작했다. 블록체인 기술은 마이크로 트랜잭션에서도 거의 수수료가 0이 되는 거래 비용을 허용한다. 마스터카드와 비자 같은 금융회사들은 이미 이 기술의 추가적인 보안과 투명성을 활용하여 블록체인을 통해 모든 현지 통화로 돈을 보낼 수 있는 능력을 제공하고 있다. 게다가 중개인을 줄이고 각 거래의 양 끝에 있는 은행을 직접 연결할 수 있다면 대부분의 국경 간 수수료를 피할 수 있다. 마케팅 담당자와 광고주에게도 시사점이 있다. 오늘날 마케터들은 정보를 공유하기 위해 제3자(페이스북처럼)에게 돈을 지불함으로써 고객 데이터에 접근하려고 노력한다. 그러나 블록체인은 상인들이 소액 결제를 통해 소비자가 중개자를 거치지 않고 직접 개인 정보를 공유하도록 동기를 부여할 수 있다. 예를 들어 모바일 앱이 있는 식료품 점 체인은 사용자에게 전화기에 앱을 설치하는 데 1 달러를 지불할 수 있으며 위치 추적을 가능하게하는 경우 추가 1 달러를 지불할 수 있다. 앱을 열고 적어도 1분 정도 시간을 할애할 때마다 소매업자는 하루에 최대까지 몇 센트나 포인트의 매장 크레딧을 지불할 수 있다. 그 기간 동안, 그들은 사용자에게 거래와 특별 제안을 추진한다. 실제로 사용자 맞춤형 거래는 소비자 프로필의 기능인 개인화된 가격을 제공하기 위한 합법적인 메커니즘을 만들 수 있다. 이 접근법은 사기를 줄이고 현재 이러한 프로그램을 괴롭히는 고객의 부정확하거나 불완전한 정보를 최소화할 수 있다. 마찬가지로 마케터는 이메일 뉴스레터에 가입하거나 보상 프로그램에 가입할 때 활성화할 수 있는 ‘스마트 컨트랙트’(중개인의 검증, 검토 또는 인증의 필요성을 제거하는 가상 계약)을 가능하게 할 수 있다. 사용자의 지갑에 광고와 상호작용할 때마다 소액 결제가 직접 보관된다. ¶3. 구글과 페이스북 독점의 종말 유사한 모델을 각 페이지 뷰에 대해 소비자에게 보상하여 웹사이트 광고에 사용할 수 있다. 2016년 HubSpot은 대다수의 인터넷 사용자들이 대부분의 팝업 광고와 모바일 광고를 싫어하고 온라인 광고를 방해하고 부정적인 혼란을 주는 것으로 본다는 연구결과를 발표했다. 이에 따른 점점 더 흔한 반응은 광고 차단기를 설치하는 것인데, 이것은 산업에 중대한 징벌적 영향을 미치고 있다. 2020년까지, 광고를 차단하는 것은 광고사에 350억 달러의 비용이 들 것으로 추산된다. Blockchain 지원 기술은 잠재적으로 마케팅 담당자들이 다른 종류의 모델로 수익의 일부를 회수할 수 있게 해준다. 마케팅 담당자들은 소비자에게 직접 비용을 지불하고 Google-Facebook 레이어를 삭제한다. 우리는 디지털 광고에서 Google-Facebook의 독점이 곧 블록체인 기술에 의해 위협받을 것이라고 믿는다. 키워드 기반 검색은 완전히 사라지지는 않지만 훨씬 덜 중요해질 것이다. 결국, 개인들은 그들 자신의 온라인 프로필과 소셜 그래프를 통제할 수 있었다. 블록체인 기술을 통해 기업들은 소비자와 직접 상호작용함으로써 오늘날의 소셜 미디어 기업을 우회하고 광고 노출의 보상을 직접 공유할 수 있다. 구글은 지난해 광고를 통해 1인당 평균 73달러를 창출한 것으로 알려졌다. 물론, 73달러는 약 10억 명의 활성 사용자들에 비해 평균에 불과하다. 구글이 특정 고평가 인구통계량에 대해 1,000달러 이상을 벌어들일 것으로 기대하는 것은 타당하다. 기업들이 블록체인 기술을 통해 활성화되는 광고를 통해 이러한 가치를 소비자에게 효율적으로 이전할 수 있는 마케팅 가능성을 상상해 보라. 블록체인 기술은 또한 광고 제공과 소비자 참여를 검증할 수 있으며, 소비자들을 화나게 하고, 소비자들을 더 이상 구매하지 못하게 하는 광고나 이메일 오버 서빙을 피하고, 경쟁사의 제품이 더 이상 관련 없는 후속 광고를 방지한다. ¶4. 마케팅 스팸과 사기의 종말 블록체인을 통한 사기 검증도 마케터들의 기원과 방법론을 확인하는 데 도움이 될 것이다. 소액지불은 또한 모든 사람들의 마케팅 효과를 희석시키는 현재의 대량 피싱 스팸 개념을 효과적으로 파괴할 것이다. 미래에는 이메일과 인터넷 둘 다 무료가 될 것 같지 않다. 매일 약 1350억 개의 스팸 메일이 발송되며, 현재 전송된 전체 이메일의 48%를 차지하고 있다. 스팸 발송자는 1250만 건의 전자 메일에 대해 1개의 응답만 받는다. 이메일 수신자에게 매우 적은 블록체인 사용료를 지불하면 이 활동의 비용을 증가시킴으로써 스팸 발송자의 활동을 단념하게 할 수 있다. 그것은 또한 기업들이 이 거래에 관심이 있는 소비자들을 식별하는 것을 도와야 한다. 마찬가지로, 인터넷의 경우 사용자가 링크를 클릭할 때마다 소액지불을 할 수 있다. 대부분의 경우 사용자는 소액지불을 하게 된다(예: 뉴스 기사를 읽으려면 1센트). 이것은 서비스 거부 공격 (DDoS)을 물리칠 수 있을 것이다. 블록체인은 또한 보츠가 가짜 소셜 미디어 계정을 구축하고, 기만적인 메시지로 사용자들을 넘치고, 대형 브랜드로부터 온라인 광고 달러를 훔치는 것을 어렵게 만들 것이다. 온라인의 진실성은 말 그대로 블록체인 기술에 녹아든다. 소셜 미디어 사기의 문제를 해결하고 있는 회사 Keybase.io는, 이것은 개인들로 하여금 블록체인을 사용하여 그들이 다양한 소셜 미디어 계정의 정당한 소유자임을 증명할 수 있게 한다. 이는 마케팅의 효과를 추적하기 더 쉽게 만들고 마케팅 지출을 정당화하기 쉽게 할 것이다. 두 가지 모두 직업상 큰 승리이다. 2016년 현재 7.6B달러(총 디스플레이 광고 비용의 56%)는 사기 또는 스팸으로 인해 손실되었으며, 이 수치는 내년에 10.9B달러로 증가할 것으로 예상된다. 마케팅 팀은 블록체인 기술을 사용하여 광고를 추적함으로써 모든 자동화 관행을 제어하고, 마케팅 비용이 ROI 창출 활동에 초점을 맞추고, 사용자별로 마케팅이 미치는 영향을 직접 측정할 수 있다. 블록체인은 사용자 행동과 마이크로 페이먼트를 함께 묶음으로써 수십 년 동안 마케터들을 괴롭혀 온 문제를 해결할 수 있었다. ¶5. 미디어 소비의 재정의 블록체인 방식의 편집 내용은 기업들이 품질 관리와 저작권 보호를 강화할 수 있게 해줄 것이다. 예를 들어 Kodak은 KODAKOne을 만들었다. KODAKOne은 개별 이미지에 대한 권한을 소유한 디지털 원장을 특징으로 하므로, 사진작가가 자신의 작업물을 제어할 수 있다. 현재 온라인 콘텐츠의 절도는 만연된 문제이며, 창작자들은 값비싼 소송 외에 손실된 돈을 회수할 수 있는 수단이 거의 없다. 앞으로는 콘텐츠 사용에 대한 대금을 자동적이고 쉽게 받을 것이다. 또한, 많은 시청자들이 보는 비디오나 소셜 게시물과 같은 콘텐츠를 만드는 사람들은 클릭 한 번으로 보상을 받을 수 있다. 이러한 모든 시나리오에서 콘텐츠 제작자는 성공에 비례하여 가치가 있는 관련 작업을 작성할 수 있다. Coupit과 같은 회사들은 향상된 콘텐츠의 영향을 최대화할 준비를 하고 있다. Marketers는 휴면 중인 고객과 충성 고객을 구분하는 가시성과 투명성을 확보하여 각 그룹에 타겟 솔루션을 제공하기 위한 전략을 확장한다. 데이터 통합업체나 분석 매개체가 필요한 경우에도 소액지불은 기업이 광고 차단을 우회할 수 있게 해 준다. 개인들은 그들이 공유하는 개인 정보의 양을 통제할 것이고, 광고 노출에 대한 직접적인 보상을 받을 것이고, 많은 사생활 우려들은 합법적으로 사라질 것이다. 이것의 한 예로 모질라 프로젝트의 공동 설립자이자 JavaScript 언어의 창시자인 Brendan Eich가 만든 새로운 웹 브라우저인 Brave가 있다. 새로운 수준의 개인 정보와 보안을 제공하는 것 외에도, Brave는 사용자, 광고주 및 콘텐츠 제작자 간의 관계를 변화시키는 것을 목표로 하는 블록체인 기반의 시스템을 가능하게 하고 있다. Basic Attention Tokens (BAT)을 통해 출판사는 부가가치 서비스를 자본화하고 광고와 관련된 성장 중 일부를 포착할 수 있다. 이러한 부가가치의 73%는 Facebook과 Google이 차지하고 있다. ¶6. 적응하거나 위험이 사라짐 블록체인이 주류를 이루면서 모든 중개인들은 그들의 사업모델을 조정할 필요가 있을 것이다. 의사결정 체인은 구조적으로 바뀔 것이다, 개인들은 개인 정보를 어떻게 공유하고 광고주들과 어떻게 시간을 보내는지에 대한 더 많은 통제권을 가질 것이다. 스팸 및 피싱 사기는 기업에게 있어 이는 모든 마케팅 활동에 대한 인바운드 트래픽의 품질에 대한 더 높은 수준의 통제와 고객의 행동에 대한 훨씬 더 필요한 이해를 의미한다. 반면에, 광고 노출은 영향을 받는 각 개인에 대한 거래 지불 없이는 부과되지 않을 것이다. 또한 소비자들은 정확한 소셜 프로필을 온라인에 올릴 수 있는 인센티브를 받게 됩니다(자신의 관심사가 무엇인지 자세히 설명). 마케터는 소셜 미디어 중간 계층이 아닌 직접 소비자에게 돈을 지불할 것이다. 고부가가치 고객을 목표로 할 때, 인센티브는 그에 따라 높아질 것이다. 블록체인 기술은 사회가 더욱 신뢰할 수 있고 권한을 부여하여, 가시성을 높이고, 파티를 연결하고, 거래에 기여한 개인에게 보상할 수 있는 잠재력을 가지고 있다. 마케팅과 광고는 근본적으로 이러한 변화의 영향을 받는다. CMO뿐만 아니라 모든 전략적, 재무적, 기술적 의사결정권자에게도 블록체인 관련 변화를 만들기 위한 방법을 설계하고 구현하는 것이 우선되어야 한다. 운영상, 기업은 개인과 새로운 수준의 신뢰를 쌓고 궁극적으로 블록체인 없이 달성할 수 없는 방식으로 제품과 서비스를 소비자와 연결할 수 있다. 마케팅 및 기술 선도업체는 블록체인을 활용하여 고객 관계를 혁신할 수 있다. 이 광범위한 기술에 대한 초기 대응은 기업들로 하여금 광범위한 채택으로 이익을 얻을 수 있는 선두적인 위치에 있게 될 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 어플리케이션 분류","slug":"a-taxonomy-of-blockchain-applications","date":"2018-10-11T15:00:00.000Z","updated":"2018-10-12T11:40:35.000Z","comments":true,"path":"2018/10/12/a-taxonomy-of-blockchain-applications/","link":"","permalink":"https://www.yceffort.kr/2018/10/12/a-taxonomy-of-blockchain-applications/","excerpt":"From Hype to Reality: A Taxonomy of Blockchain Applications 원문 ¶Introduction 블록체인은 분산형 디지털 원장이며, 신뢰라는 문제를 특정 기관에서 알고리즘으로 전환하기 위한 고유한 가치를 가지고 있다. 블록체인이 기존 사업 모델과 이론에 미치는 미래의 영향은 스마트폰이나 인터넷의 발명과 유사할 수 있다. 따라서, 연구원들과 실무자들은 확립된 신뢰기반 사업 모델을 블록체인으로 대체하려는 시도로 블록체인에 뛰어 든다. 블록체인 주변에서 나타나고 있는 가능성은 블록체인이 금융","text":"From Hype to Reality: A Taxonomy of Blockchain Applications 원문 ¶Introduction 블록체인은 분산형 디지털 원장이며, 신뢰라는 문제를 특정 기관에서 알고리즘으로 전환하기 위한 고유한 가치를 가지고 있다. 블록체인이 기존 사업 모델과 이론에 미치는 미래의 영향은 스마트폰이나 인터넷의 발명과 유사할 수 있다. 따라서, 연구원들과 실무자들은 확립된 신뢰기반 사업 모델을 블록체인으로 대체하려는 시도로 블록체인에 뛰어 든다. 블록체인 주변에서 나타나고 있는 가능성은 블록체인이 금융 부문의 은행을 대체할 수 있음을 시사한다. 스마트계약을 사용하는 개인 또는 인터넷 기관 간의 컨트랙트를 지원하고 있으며 필수적인 기록물들을 관리하고 있다. 그러나 블록체인 기반 시스템을 개발하는 데 있어 당면과제는 기존 이점보다 더 크다.현재 대부분의 블록체인 프로젝트는 아이디어 단계에서 실무 단계로 이동할 수 없었다. 예를 들어, 우주 탐사(예: SpaceBIT) 또는 인공지능의 토큰화를 지원하기 위해 블록체인을 채택하는 것을 목표로 하는 프로젝트는 PoC를 해내지 못했다.범위가 좁은 블록체인 프로토타입은 블록체인 프로토콜의 확장성, 합의 메커니즘에 필요한 계산 리소스의 낭비, 사용자 추적성 및 부정 행위에 대한 네트워크 보호 결여와 관련된 문제를 경험하게 된다.현재, 실무자들은 시행착오 접근법에 기초한 PoC 및 시스템 설계를 계속 실험하고 있다. 블록체인 영역의 광범위한 연구는 블록체인 기반 시스템의 개발과 기술적 요소(예: 합의 메커니즘, 허가)와 애플리케이션(예: 금융 거래, 인터넷)의 다양성에 초점을 맞추고 있다. 광범위한 연구를 자세히 살펴보면, 블록체인 적용 영역의 다양성을 알 수 있다.예를 들어, 비트코인 네트워크는 신뢰가 필요하지 않은, 안전한 작업 증명 합의 메커니즘이 필요한 반면, HyperLedger 비즈니스 네트워크는 신뢰를 보장하고 실용적인 비잔틴 장애허용과 같은 보다 가벼운 합의 메커니즘을 사용할 수 있다.그러나 관련 기술 블록체인 특성은 여러 애플리케이션에 걸쳐 추상화, 단편화 및 분산되어 있습니다. 성공적인 블록체인 기반 시스템 개발에 관한 지침을 제공하기 위해서는 기술 블록체인 특성과 블록체인 애플리케이션을 연결하는 더 많은 지식이 필수적이다.시행착오 개발은 블록체인 기반의 시스템에 대한 미충족된 기대와 투자 손실로 이어진다. 따라서, 우리는 연구 질문에 답한다.어떤 특징을 가진 블록체인이 어떤 분야에 잘 들어 맞는가? ¶블록체인 분류 첫 번째 열은 'Reading Access’로 블록 체인의 정보를 읽는 여러 모드를 나타낸다. Pr(Private Reading)은 통해 권한이 부여된 구성원만 블록체인에 액세스할 수 있다. Pb(Public Reading)은 누구나 액세스를 통해 블록체인의 데이터를 읽을 수 있다. 두 번째 열은 ‘Writing Access’ 이며 블록체인에 대한 다양한 쓰기 모드를 나타낸다. P(Permissioned)는 트랜잭션 작성을 위해 유저에게 권한을 요구한다. U(Unpermissioned)인 경우, 사용자는 트랜잭션을 추가하기 위한 별도의 권한이 필요하지 않다. 세 번째 열은 주요 합의 메커니즘이며, 블록체인을 갱신하기 위한 채택된 수단과 관련이 있다.우리는 네 가지 주요 합의 메커니즘에 초점을 맞춘다. W(Proof of Work) 작업 증명에는 요청자의 리소스(또는 작업)가 필요하다.대개 컴퓨터의 처리 시간을 계산적으로 어려운 퍼즐을 해결하기 위해 사용한다. S(Proof of stake) 지분증명은 사용자에게 특정 양의 디지털 데이터의 소유권을 입증하여 이 데이터에 대한 지분을 설정하도록 요청한다. B(Byzantine Fault Tolerance) 비잔티움 장애 허용은 시스템 수준 동의를 함께 결정하는 네트워크의 신뢰할 수 있는 노드에서 내린 개별 결정을 수집한다. SD(Self-developed Consensus)자체 개발한 합의 메커니즘은 일부 애플리케이션 사례에서 사용되며 일반적으로 시스템 수준 동의에 도달할 수 있는 몇 개의 신뢰도가 높은 노드를 포함한다. 네 번째 열은 익명성 수준이며 사용자가 신원과 일치할 수 있는지 여부를 평가한다. A(Anonymous) 익명인 경우 사용자는 블록 체인으로 작업할 데이터를 제공할 필요가 없습니다. P(Pseudonymous) 블록체인이 가명이면 사용자는 가명으로 작업해야 한다. I(Identifiable) 식별 가능한 특성을 가진 블록체인 경우 이메일 주소와 같은 개인 식별 가능 정보를 요청하거나 자동으로 수집하게 된다. 다섯번째 열은 이벤트 핸들링이며 블록체인이 애플리케이션 논리 또는 이벤트를 처리할 수 있는지 여부를 나타낸다. N(No Event)는 블록체인이 애플리케이션 로직을 처리할 수 없음을 보여 주지 않습니다. F(Fixed event)는 내장 이벤트를 지원합니다. C(Custom event) 사용자 정의 이벤트 처리란 블록체인이 사용자가 제공하는 모든 애플리케이션 로직 처리를 지원한다는 것을 의미한다. 여섯 번째 열은 블록체인에 대한 사용자 간의 정보 공유 유형에 초점을 맞추고 특성 거래와 내용을 포함하는 데이터 교환 유형이다. T(Transaction)트랜잭션은 실행된 작업의 로그 교환을 의미한다. C(Contents)콘텐츠는 문서, 메시지, 비디오 또는 음악 파일과 같은 디지털 자산이 교환되는 것을 의미한다. 일곱 번째 열은 암호화이며 블록 체인의 데이터가 암호화되는지 여부를 지정합니다. U(Unencrypted) 암호화되지 않음은 블록체인의 데이터가 암호화되지 않음을 의미한다. P(Partially-encrypted) 부분적으로 암호화된 블록체인을 나타냅니다. T(Totally-encrypted)완전 암호화는 블록체인의 모든 데이터가 암호화되고 모든 작업에 대해 해독되어야 함을 의미한다. 여덟 번째 열은 히스토리 보존이며 전체 블록체인 또는 최근 업데이트만 호스트 간에 유지 및 배포되었는지 확인한다. W(Whole retention)전체 보존은 유전자 블록으로 시작하는 전체 역사가 블록체인에 보관되어 노드 간에 분산된다는 것을 의미한다. R(Recent updates)최근 업데이트 보존은 최신 업데이트만 유지 및 배포되도록 지정한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"왜 블록체인을 신뢰하기 어려운가","slug":"why-is-it-so-hard-to-trust-a-blockchain","date":"2018-10-10T15:00:00.000Z","updated":"2018-10-11T11:40:35.000Z","comments":true,"path":"2018/10/11/why-is-it-so-hard-to-trust-a-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/10/11/why-is-it-so-hard-to-trust-a-blockchain/","excerpt":"Why Is It So Hard to Trust a Blockchain? 원문 신기술의 채택은 기술의 이해와 신뢰의 정도에 영향을 받는다. 잠재적 채택자들은 완전히 새로운 시스템을 채택하는 것에 대해 불안해하거나, 최소한 회의적일 수 있다. 특히 기업은 기존의 데이터 관리 및 공유 방법을 재고해야 한다. 이것은 아마도 신뢰의 격차를 메우는 것을 목적으로 하는 기술인 블록체인 특히 그럴 것이다. 이 역설을 해부해 봅자. 블록체인 기술은 데이터 거래의 불변 기록을 만들어 사용자들 사이에 신뢰를 심어준다. 그러나 PwC가 실시한 새","text":"Why Is It So Hard to Trust a Blockchain? 원문 신기술의 채택은 기술의 이해와 신뢰의 정도에 영향을 받는다. 잠재적 채택자들은 완전히 새로운 시스템을 채택하는 것에 대해 불안해하거나, 최소한 회의적일 수 있다. 특히 기업은 기존의 데이터 관리 및 공유 방법을 재고해야 한다. 이것은 아마도 신뢰의 격차를 메우는 것을 목적으로 하는 기술인 블록체인 특히 그럴 것이다. 이 역설을 해부해 봅자. 블록체인 기술은 데이터 거래의 불변 기록을 만들어 사용자들 사이에 신뢰를 심어준다. 그러나 PwC가 실시한 새로운 글로벌 연구 조사 결과에 따르면 신뢰 문제가 거의 매순간 기업의 블록체인 노력을 방해하고 있다고 한다. 이는 기업들이 실험하지 않는다는 것을 의미하는 것이 아니다. 전 세계 15개 지역의 기술 중심 리더에게 행해진 설문 조사에 따르면, 응답자 중 84%가 블록체인에 적어도 일부분 이상 시험해보았다고 응답했다. 이니셔티브를 최대한 활용하려면 신뢰 문제를 정면으로 해결해야 한다. 모든 신기술과 마찬가지로 블록체인의 신뢰성, 속도, 보안 및 확장성에 대한 도전과 의심이 존재한다. 그러한 의혹은 블록체인 시스템 간의 표준화 및 상호운용성 결여에 관한 우려에서 더욱 복잡해진다. 게다가, 많은 경영자들은 블록체인이 무엇이고 그것이 그들의 사업을 어떻게 변화시킬지에 대해 여전히 불확실하다. 블록체인의 새로운 인프라 형태와 암호 화폐를 포함한 토큰을 통해 자산을 디지털화하는 새로운 방법으로서의 역할은 설명하기 쉽지 않다. 또 다른 과제는 참가자들 간의 신뢰 구축이다. 합의를 이끌어내기 위한 기술은 규칙과 표준을 설계할 필요성에 대한 초기 장애물에 부딪힌다. 규제에 관해서도 비슷한 노력이 부족하다. 대다수의 규제당국이 여전히 블록체인을 수용하고 있다. 많은 지역들이 특히 금융 서비스와 관련하여 이 문제를 연구하고 토론하기 시작했지만, 전반적인 규제 환경은 여전히 불안정하다. 회사는 어떻게 해야 할까? 확실히 블록체인은 기술은 현실에 다가왔다. 그러나 우리의 보고서가 분명히 밝혔듯이, 리더들은 준비되지 않은 채 뛰어들어 정반대의 극단으로 넘어가서는 안 된다. 시범사업 단계에서 블록체인 프로젝트를 보고한 응답자 중 54%는 이 노력이 때때로 정당화 할 만한 결과를 낳지 않았다고 밝혔다. 좀 더 효과적인 조치를 취해야 한다. 이 보고서는 경영진들이 이 요청에 응할 수 있도록 신뢰 구축을 위해 사용할 수 있는 네 가지 전략을 제공한다. 블록체인 작업 초기에 이들 4개 분야에 집중함으로써 기업들은 성공적인 실행을 위한 길을 마련할 수 있다. ¶1. 비즈니스 사례를 만들어라 블록체인을 개발하고 구현하는 것은 전통적인 IT 구축 모델과는 다르다. 처음부터 이러한 패러다임의 변화를 인식하지 못할 경우 기업은 결국 기존 역할, 프로세스 및 비즈니스 모델을 재확보하게 된다. 그 대신, 그들은 자신들이 현재 있는 곳에서 적절하게 변형된 전략에 대한 노력이 필요하다. 이는 비즈니스 사례에서 시작됩니다. 몇 가지 질문으로 시작해 보자. 전략적으로 달성하고자 하는 목표는 무엇입니까? 어떤 문제점과 이를 공유하는 다른 이해당사자들이 있는가? 우리가 어떻게 그런 계획을 추진할 것인가? 그것은 어떻게 규제될 것인가? ¶2. 산업 생태계를 만들어라. 사업 모델을 정의하는 일련의 표준에 대해 단체로 합의하도록 하는 것은 아마도 블록체인에서 가장 큰 과제일 것이다. 참여자들은 참여 규칙, 비용 및 편익이 공정하게 배분되도록 하는 방법, 공유 아키텍처에 어떤 위험 및 통제 프레임워크를 사용할 수 있는지, 그리고 지속적인 감사와 검증을 포함하여, 어떤 거버넌스 메커니즘이 마련되어 있는지 결정해야 한다. ¶3. 참여 규칙을 결정하라. 블록체인 생태계의 참여자들은 운영 표준이 무엇이고 다양한 사용자들이 보고 할 수 있는가를 결정해야 한다. 블록체인의 사용 권한이 없어 모든 사람이 사용할 수 있는지 또는 사용 권한(다양한 수준의 사용 권한을 가진)을 결정하는 것을 포함하는 전략적 비즈니스 모델을 만드는 것으로 시작된다. 권한은 참가자의 역할과 블록체인에 대한 참여를 결정한다. 모델 선택은 자동이 아니다. 기업은 설계 및 사용 사례 고려 사항에 따라 결정한다. 또한 구축할 네트워크 유형을 고려해야 한다. 설문 응답자 중 40%는 허가된 블록체인(프라이빗)을 사용하고 있다고 답했으며, 34%는 허가받지 않은 체인(퍼블릭)을 사용하고 있으며 26%는 하이브리드 방식을 채택하고 있다고 답했다(프라이빗 + 퍼블릭). ¶4. 규제의 불확실성을 잘 탐색해라 잘 설계된 블록 체인은 데이터를 검증하고 은행, 청산소 또는 정부와 같은 중앙 당국이 거래를 승인하고 처리할 필요성을 제거한다. 중앙당국이 비용을 절감하고 지연을 줄일 수는 있으며, 시장 안정성을 확보하고 부정 행위를 방지하는 데 중요한 기관의 필요성도 없앨 수 있다. 블록체인에 관해서는 규제기관이 결국 개입할 것이라는 징후가 있지만, 그렇다고 해서 진전을 늦출 이유가 될 수는 없다. 하지만 조사 응답자들 중 27퍼센트는 규제 문제가 블록체인 채택에 가장 큰 장벽이라고 생각한다. 이러한 불확실성은 많은 지역에서 상당히 일관성이 있으며, 규제 문제를 중국에서 17 %, 독일에서 38 %에 이르는 가장 큰 장벽으로 평가하는 응답자가 많았다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"탈중앙화된 데이터 인프라에서의 신뢰","slug":"trust-in-decentralized-data-infrastructures","date":"2018-10-09T15:00:00.000Z","updated":"2018-10-10T04:41:35.000Z","comments":true,"path":"2018/10/10/trust-in-decentralized-data-infrastructures/","link":"","permalink":"https://www.yceffort.kr/2018/10/10/trust-in-decentralized-data-infrastructures/","excerpt":"Barlaeus Dinner on Trust in Decentralized Data Infrastructures 원문 암스테르담 대학은 2년에 한번씩 사회, 경제, 문화, 과학적으로 영향이 큰 문제에 논의 하기 위해 사회 각계 각층의 저명한 인사들을 모아 저녁 만찬을 주최합니다. 아래는 2018년 5월 24일에 있었던 블록체인 관련 담론을 요약한 내용입니다. ¶요약 * 블록체인 기술은 신뢰가 필요하지 않은 기술이 아니다. 사실, 신뢰는 기술과 관련된 해결되지 않은 도전이다. * Contrary to the dominant","text":"Barlaeus Dinner on Trust in Decentralized Data Infrastructures 원문 암스테르담 대학은 2년에 한번씩 사회, 경제, 문화, 과학적으로 영향이 큰 문제에 논의 하기 위해 사회 각계 각층의 저명한 인사들을 모아 저녁 만찬을 주최합니다. 아래는 2018년 5월 24일에 있었던 블록체인 관련 담론을 요약한 내용입니다. ¶요약 블록체인 기술은 신뢰가 필요하지 않은 기술이 아니다. 사실, 신뢰는 기술과 관련된 해결되지 않은 도전이다. Contrary to the dominant discourse blockchain technologies are not trustless. In fact trust is a major, unresolved challenge related to the technology. 분산 데이터의 가치를 증명할 수 있는 실용적인 응용 프로그램은 아직 출현하지 않았다. Practical applications that are able to prove the worth of decentralized datasets are yet to emerge. 다양한 사회 영역 간의 지식 전달을 촉진하고이 기술 혁신의 잠재력을 최대한 발휘하기 위해서는 광범위한 학제 간 교육 프로그램이 필요합니다. Extensive interdisciplinary education programs are necessary to facilitate the knowledge transfer among different societal domains, and to unlock the full potential of this technological innovation. 블록체인 정책은 기술이 정의와 민주주의를 방해하지 않도록 보장해야 하며 경제적 이익과 근본적인 권리의 균형을 적극적으로 유지해야 한다. Blockchain policies should ensure that the technology does not interfere with justice and democracy, and should actively balance economic interests with fundamental rights 블록체인 거버넌스 프레임워크의 개발은 단기에서 중기의 가장 중요한 과제일 것이다. The development of blockchain governance frameworks is probably the most important challenge in the short to mid-term. UvA(이 논문이 쓰여진 암스테르담 대학) 내부 및 암스테르담 지역의 다른 파트너와의 여러 분야의 협력이 잠재적으로 필요할 것이다. There is a potential of, and a need for multidisciplinary collaborations inside UvA, and with other partners in the Amsterdam region of these topics. ¶신뢰와 블록체인 기술 블록체인 기술에는 근본적인 역설이 있다. 블록체인은 신뢰받는 중개인과 신뢰할 수 있는 기관들의 신뢰의 필요성을 제거할 수 있는 기술로 수 많은 인간 활동에서 광고되고 있다. 반면에, 기술 주위에 엄청난 과장 광고가 있고, 암호 화폐의 가치의 급격한 증가는 블록체인 기술 영역에 사기 활동의 홍수를 초래했다. 이 기술은 “신뢰가 필요 없는” 것으로 간주되고 있지만, 그것의 주변의 사회적, 경제적, 정치적, 그리고 암호학적 도전들은 놀라울 정도로 복잡하다. 이 기술은 완전한 투명성을 보장하지만, 이해관계자 그룹, 블록체인 기반 프로젝트의 시장, 제품 및 서비스는 점점 더 불투명한 상태가 되고 있다. 따라서 기술, 사회적 영향, 법적 준수, 장기적인 위협, 위험 및 기회와 약속에 대한 검증되고 신뢰할 수 있는 정보는 거의 없다. 우리는 기술의 진정한 사회적 가치, 과대 광고를 넘어서고 노출시키는 정보, 숨겨진 의제로 편향되지 않은 정보에 대한 신뢰할 수 있는 정보를 생성할 때라고 믿는다. 또한 우리는 사회에서 장기적인 책임을 지고 있는 기관들 사이에서 신뢰의 고리를 만들어야 한다. 기술 분야의 변화 속도는 어지럽다. 몇 년 동안 새로운 개념이 등장하고 유행에 뒤떨어져 나간다. 2010년 과학 소설 작가 브루스 스털링(Bruce Sterling)이 대학과 사이버 공간에 관한 컨퍼런스에서 지적했듯이, 우리의 디지털 환경은 비둘기보다 수명이 짧은 개념, 제품 및 서비스를 중심으로 구성된다. ‘정보 초고속 고속도로’, ‘냅스터’, ‘아이팟’ 이라는 용어를 생각해보라. 반면에 여기에 참가한 사회각계 각층의 대표는 과거 세대와 미래의 세대를 연결하는 기관, 인간 및 사회 프로젝트를 대표한다. 대학, 은행, 도시, 주, 법률 회사, 신문 : 그들은 모두 여러 세대의 인간 세대를 포함하는 시간적인 규모로 운영된다. 그들은 수십 년과 수세기에 걸쳐 인간의 기억을 관리인이다. 그들은 모두 수세기에 걸쳐서 이루어지는 인간 활동을 조정한다. 만약 우리의 주요 목표가 신뢰할 수 있는 지식을 만들어내는 것이라면, 우리의 또 다른 목표는 짧은 시간과 중간 규모, 즉 기술과 제도, 즉 일시적인 것과 지속적인 것, 혁명적인 것과 보수적인 것 두 가지를 연결하는 것이다. 다가오는 블록체인 혁명은 그들이 조율한 인간의 관행을 분리함으로써 많은 신뢰가 필요한 기관들을 은퇴시키기 시작했다. 우리는 그 일이 일어나기 전에 파괴된 기술과 기관들의 역할, 관련성, 장점, 약점을 완전히 이해하고 있는지 확인하고 싶다. 이 목표를 달성하는 첫 번째 단계는 우리가 기술과 약속된 혼란을 다루는 방법을 바꾸는 것이다. 기업가와 블록체인 전도자들의 말을 들으면, 분산된 기술이 사회, 경제, 정치 조직의 근본적으로 새로운 형태로 이어질 수 있는 방법과 이유에 대한 웅장한 비전을 듣게 된다. 우리는 그러한 혁명의 기회를 배제할 수는 없지만 오히려 제도, 시장, 사회, 정치 협력 및 조정 방식의 진화 등 진화를 준비해야 한다. 따라서 여기서의 목표는 블록체인 기술의 진화적 잠재력에 초점을 맞추고, 우리가 대표하는 기관이 사회의 이익을 위해, 우리의 각 기관의 이익을 위해, 시민으로서의 우리 각자의 이익을 위해이 새로운 기술을 어떻게 사용할 수 있는지 생각하는 것이다. ‘블록체인’ 이라는 용어는 이미 거대하고 빠르게 성장하고 고도로 기술적인 분야를 다루고 있기 때문에 우리는 간단한 것을 제안한다. 블록체인은 핵심에서 분산된 데이터베이스에 지나지 않는다. 이 기술은 하나의 중앙 데이터 사일로에 데이터를 저장하는 대신 공유된 일련의 데이터를 함께 유지할 수 있게 해준다. 영국방송공사(BBC)는 몇 년 전 완전히 다른 영역에서 본보기를 보여주기 위해 그 핵심, 존재의 본질, 시청각 자료실을 분산시키는 실험을 했다. 그 아이디어는 BBC 미디어서버에 요금을 지불하는 사람들을 p2p 네트워크로 묶어서, 모두 각각 작은 BBC 아카이브의 작은 데이터를 담당하도록 하는 것이었다. 이것은 모든 영국 시민을 영국의 시청각 유산의 관리인으로 만들었을 것이다. 블록체인은 비슷한 일을 한다. 단일 기관의 유일한 관리인으로부터 데이터를 확보하고, 광범위한 집단이 그 데이터를 함께 보존할 수 있게 해준다. 우리는 이미 우리 주변의 세계에 대한 공유된 지식을 유지하기 위한 두 가지 잘 정립된 메커니즘을 가지고 있다. 시장은 가격의 형태로 지식을 수집하는 매우 좋은 분산 메커니즘이다. 관료사회는 특정 분야에서 권위 있는 지식의 원천을 유지하기 위해 오랜 세월 동안 발전해 왔다. 인터넷을 통해 특정 조건 하에서 탈중앙화가 시장이나 관료보다 자원의 생산과 사용을 조정하고 지식을 모으는 보다 효과적인 방법이 될 수 있음이 분명해졌다. 그래서, 첫번째 질문은 이 분권화의 기술적 기회로부터 흘러나온다. 분산된 방식으로 공유되는 데이터는 어떤 종류일까? 사회로서 우리가 분산된 방식으로 관리하고 보존하고자 하는 지식은 무엇인가? 데이터 세트를 다른 사람들과 함께 유지하는 부담과 책임을 편안하게 공유할 수 있는 상황을 상상할 수 있을까? 우리가 이미 알고 신뢰하는 과정이나 제도가 아니라, 미지의 행위자들의 분산된 네트워크에 의해 공유되고 유지되는 데이터에 의존하는 우리 자신과 기관을 상상할 수 있을까? 두 번째 질문은 데이터 자체를 넘어서서 해당 데이터가 어떻게 사용되는지 살펴 본다. 데이터의 가장 중요한 용도 중 하나는 그룹과 활동의 조정을 가능하게 한다는 것다. 이것은 최초의 세금 기록이 메소포타미아의 어느 곳에 있는 부드러운 진흙에 기록된 이후, 수천 년 전에 첫 국가가 탄생한 이후부터 사실로 드러났다. 결과적으로 블록 체인 기술은 이러한 분산 된 방식으로 어떤 종류의 인간 활동이 가장 잘 조정되는지에 대한 질문을 제기한다. 에반젤리스트들은 모든 인간 활동이 공유된 데이터 세트와, 인간이 배제된 스마트 컨트랙트를 통해 조정 될 수 있고, 그래야 한다고 우리에게 설득하려고 한다. 과학은 조직적인 회의론이므로, 우리는 대안의 상대적 비용과 장점에 대한 심각한 연구없이 이 주장을 받아들이기를 꺼립니다. 이 저녁 식사 때 우리와 같은 소그룹의 조정에 관해서는, 조정의 적절한 기술은 방, 의자, 테이블 및 일부 음식입니다. 시장과 관료주의는 또한 거대하고 복잡한 인간의 노력을 조정하는데 매우 효율적인 것으로 증명되었다.(시장은 지금까지 효율적으로 동작하고 있다. ) 하지만, 우리 주변의 것들은 점점 더 글로벌한 규모를 띄고 있다. 우리는 지구 규모의 정보 통신 인프라를 사용하고 있다. 우리는 수십억 명의 사용자들 사이에서 동시에 작동하는 네트워크와 서비스를 사용한다. 여기에는 국제 금융, 물류, 노동 시스템에 포함되어 있다. 우리는 지구 온난화, 이주, 오염 등과 같은 전지구적인 규모의 도전에 직면해 있다. 이 모든 것은 인적 자원, 활동, 그리고 지구적 규모의 과정들의 조정을 필요로 한다. 이러한 도전에 직면하여 블록체인이 약속하는 분산 데이터 기반 조정 인프라가 시장이나 관료적 형태의 조정이 충분한 결과를 산출하지 못하는 것처럼 보이는 곳에 발을 들여 놓을 수 있는지 여부를 알아야 한다. 우리는 이러한 기술적 기회를 이용해서 지배구조 메커니즘을 글로벌 규모로 확장할 수 있는지 여부를 탐구할 수 있고, 따라서 분산된 방식으로 그러한 자원을 관리할 수 있어야 한다. 이런 대규모 질문에 대한 답을 얻기 위해서는 배경에 있는 수많은 문제를 명확히 해야 한다. 우리는 이러한 분산된 데이터베이스에 있는 데이터가 상황의 상태를 정확하게 나타내도록 보장해야 한다. 우리는 세계의 각 체인이 떨어져 있는 상태가 동기화되어 있고, 공유된 데이터베이스에 대한 신뢰할 수 있는 원천이 있으며, 사슬에 대한 행동의 사슬이 벗어난 결과가 적절하게 시행되도록 보장해야 한다. 분산된 권력, 분산된 신뢰의 분산된 네트워크로 설계된 분산된 시스템에 왜곡된 인센티브가 숨겨져 있지 않도록해야 한다. 우리는 분산된 기술 시스템과 현상 유지가 p2p 파일 공유 기술과 저작권법과 같은 끝없는 적대적인 권력 투쟁에 갇혀 있지 않도록해야 한다. 그런 확신을 만들어낼 수 있을까? 우리는 그렇게 믿고 있다. 하지만 그런 일이 일어나려면 집단의 협력이 필요하다. 우리 중 누구도 이 질문에 혼자 대답할 입장이 아니다. 우리는 토론, 공유 프로젝트, 학제 간 교육 프로그램에 투자해야 한다. 그래야 답을 빠르게 줄 수 있다. 우리는 해결책을 시험할 수 있는 규제 샌드박스와 같은 공간과 도구를 개발해야 합니다. 이 시간이 그 과정의 첫 번째 단계가 되기를 바란다. ¶시장 이 그룹이 논의한 첫 번째 질문은 왜 오늘날 블록체인 기반의 솔루션만이 실제 구현 사례를 찾고 있지만, 대부분은 단순한 아이디어에 지나지 않는가에 관한 것 이다. 시장에는 블록체인 프로젝트를 제안하고 나타났지만 짧은 기간 후에 점차 활동이 사라지게 되었다. 마찬가지로, 많은 PoC들이 개발되었지만 아직 완전히 운영되지는 않았다. 가치 이전의 효율성과 기술이 제공하는 거래 비용을 낮출 수 있는 능력에도 불구하고, 블록체인 기반 프로젝트의 실제 실행을 방해하는 몇 가지 과제를 식별했다. 먼저, 더 큰 고객 기반을 확보하고 사람들에게 기술의 이점을 설득할 수 있는 보다 유용하고 효과적인 사용 사례를 제안해야 할 것이다. 보다 기술적인 수준에서 입력 데이터에 대한 보안 및 개인 정보 보호의 필요성과 관련 데이터가 디지털화되지 않으면 블록체인 구현을 시작하는 데 장애물이 된다. 게다가, 기술과 주변 생태계에 대한 신뢰 부족은 산업의 출현을 늦추는 역할을 한다. 일반적으로 말해서 블록체인 기반 프로젝트의 시작과 성공을 가로막는 법적 장벽과 기술적 장벽이 있다. 미래 산업의 발전에 있어서, 교육 부족과 이 기술에 대한 구체적인 기술은 더 많은 장애를 나타낼 수 있다. 학문 간 융합 수준에서 지식의 이전 부족은 협력적인 노력과 협력을 통해 극복해야 하는 장벽을 만들게 된다. 기술적 지식은 사실 시장 성공으로는 부족하고, 학제 간 기술은 미래의 블록체인 채택과 성장을 촉진하는데 중요한 역할을 할 것이다. (설문) 참가자들은 앞으로 몇 년 안에 블록체인을 성공적으로 이용할 수 있을지에 대해는 의구심을 남겼지만, 교육 분야의 구현에 관해 특별한 낙관론을 표명했다. 보다 구체적으로 말하면, 블록체인은 일반적으로 대학교와 교육 기관 간에 학위를 이동할 수 있도록 인증 포인트를 사용하여 평판 시스템을 구축할 수 있다. 좀 더 일반적으로, 분산형 원장 기술에 의해 가능해진 것처럼, 중앙 인증 행위자의 개입 없이 가치를 이전하는 것은 몇몇 사업 분야에서 유익할 수 있다. 데이터 공유는 블록체인 기술의 근본적인 측면이다. 조직이 기존 데이터 시장 내에서 데이터를 공유해야 하는 인센티브의 부족은 미래의 블록체인 기반 디지털 인프라 맥락에서 극복할 수 있다. 오늘날, 정보를 보유함으로써 얻을 수 있는 가치는 소위 데이터 경제의 주요 동인이다. 개인 또는 익명화된 데이터의 공유를 열기 위해 새로운 인센티브 시스템이 등장할 수 있다고 언급했고, 블록체인 애플리케이션은 이러한 변화의 주역이 될 수 있다. 요약하자면, 이 시장 그룹은 블록체인 기술을 열렬히 환영했지만 현재 그것의 실제 실행을 방해하는 여러 가지 장애물에 대해서는 인정하지 않았다. 특히, 이 유망한 산업의 올바른 개발을 촉진하기 위해 명확한 규제 프레임워크와 데이터 관리를 위한 전략이 제공되어야 한다. ¶정부 정부와 블록체인 간의 관계에 대한 논의는 두 가지이다. 한쪽은 분권화의 위협과 도전에 대처하기 위해 국가가 기술의 개발에 어떻게 대응해야 하는지에 대해 의문을 제기하는 것과 관련이 있다. 또 다른 한 가지는 공공 기관이 투명성과 효율성을 높이기 위해 블록체인을 사용하여 어떻게 이익을 얻을 수 있는지 조사하는 것이다. 첫 번째 질문에 관해서, 국가가 블록 체인 기술과 그에 기반한 응용 프로그램을 규제해야하는지 여부와 방법에 대해 논의했다. 참가자들은 기술 규제에 대한 적절한 전체론적 접근 방식을 확인하는 데 어려움을 겪었음에도 불구하고 국가가 중립적이어야 한다고 단언했다. 공공 기관은 정의와 민주주의를 방해하는 기술의 사용을 막고 경제적 이익과 근본적인 권리를 균형있게 유지하기 위한 윤리적이고 규범적인 틀을 지지해야 한다. 두 번째 질문은 정부 차원에서 블록 체인 기술을 기관에 대한 신뢰 증가와 같은 공익을 추구하는 수단으로 사용할 수 있다고 생각한다. 논의 된 사용 사례는 디지털 신원의 경우였다. 온라인 인식 및 인증 프로세스를 최적화하고 데이터 수집의 중복을 피하면서 시민들에게 개인 데이터를 독점적으로 제어할 수 있는 블록 체인 기반 프로젝트를 컨트롤하고 있다. 참가자들이 언급한 또 다른 응용 분야는 건강 부문이었다. 여러 국내 및 국제 연구에서 의료 기록 관리를 위해 블록 체인 사용을 모색하고 있다. 모든 참가자들은 이러한 사용 사례들이 만들어낼 수 있는 조직의 변화에 흥분했다. 그러나 그들은 또한 그러한 시스템의 잠재적인 몰락을 보았다. 무엇보다도, 사회의 데이터가 수반하는 감시의 위험이 증가합니다. 블록체인의 파괴적인 힘에 대한 열정이 확산되었지만 일부 참여자들은, 정부가 변화하기를 열망하지 않는다는 것을 보여주었다. 정부 인프라의 효과적인 설계는 도구와 목표에 대한 공통된 이해가 전제 조건인 적절한 거버넌스, 법률 및 기술의 조정된 개발을 필요로 한다. 따라서 명확한 정책 및 표준화 전략은 블록 체인을 다루는 기관이 수행해야하는 첫 번째 단계다. 한편으로는 이 기술이 시민들의 데이터에 대한 신뢰를 높이고, 적절하게 배치되면 공공 행위자에게 투명성과 효율성을 더 많이 부여할 수 있다. 다른 한편으로, 프로세스의 분권화와 자동화는 법 집행과 사회 평등에 어려움을 낳을 수 있다. 따라서 블록 체인 기술의 개발을 간과하고 관련 이해 관계자와 엄격한 대화를 유지하면서, 새로운 문제를 해결할뿐만 아니라 기회를 활용할 수 있는 역량을 개발하는 것이 기관의 역할이다. ¶법 요약하자면, 이는 규제 수준이 목표하는 개인 또는 회사의 규모를 반영해야 한다는 것을 의미한다. 이 비전을 실현하기 위한한 가지 접근법은 블록 체인 기술의 사용이 시장 또는 부문의 핵심 측면에 실질적으로 영향을 미치거나 소비자 권리 또는 기본 권리와 충돌할 위험이 있는 입법자와 함께 위험 규제를 정의 하는 것이다. 인터넷 서비스 제공자들이 저작권법에서 규제되는 방식과 유사한 가치 사슬 접근방식을 통해서도 이 기술을 다룰 수 있다. 다시 말하면, 법적 책임은 판매되는 제품이나 서비스와 관련하여 특정 블록체인 분야에서 운영되는 회사가 수행하는 활동의 가치에 근거해 귀속될 것이다. 어느 쪽이든 이 접근법은 마이너나 암호 화폐와 같은 특정 블록체인의 고부가가치 행위자에 대한 더 엄격한 규제를 수반할 것이다. EU 전체의 블록체인 기술에 대한 잠재적 규제를 논의할 때, 그러한 규제의 적용은 특히 집행 목적으로 EU 이외의 행위자들에게도 제기되었다. 유럽 규정의 광범위한 지리적 영역을 보장할 수 있는 한 가지 가능한 가능성은 일부 부문별 EU 법의 외부적 적용에 의존하는 것이다. GDPR(General Data Protection Regulations)의 광범위한 영역 범위로 인해 개인 데이터 보호와 관련된 경우가 이미 있을 수 있다는 점에 주목하였다. 실제로, 문제의 데이터가 익명이라는 이유로 블록체인 기술에 이 법적 수단을 적용한다고 가정하면, 특정 상황에서 EU의 관할권 참여자들이 물리적으로 접촉하지 않는 기업을 차단하기 위해 추가 법칙, 특히 국제 무역법, 특히 금융서비스와 같은 민감한 분야에서 을 적용할 수 있다. 프라이버시의 관점에서, 그리고 GDPR의 외부적 적용의 문제를 넘어, GDP의 제17조에 규정된 삭제권(‘잊혀질 권리’)의 적용을 어떻게 보장할 수 있는지에 대한 의문이 제기되었다. 또한, GDPR의 보호를 받는 익명의 데이터 사용의 장점과 단점에 대한 논의가 있었다. 대부분의 참여자들은 익명 데이터에 의존하는 블록체인 솔루션에 대한 선호도를 인정했는데, 이는 원칙적으로 GDPR의 적용을 허용하기 때문이다. 규제 관점에서 이것은 익명화 기법을 제한하는 조치를 취하는 것을 의미할 수 있다. 블록체인이 혁명을 나타내는지 아니면 진화를 나타내는지는 또 다른 서로 다른 논의 주제다. 그 대답은, 어느 정도까지는, 맥락에 따라 결정될 것이라고 주장되었다. 어떤 맥락에서 볼 때, 이 기술은 만약 확장될 수 있다면 혁명적인 것처럼 보인다. 언급되는 여러 가지 예: ID 관리, 기존 시스템이 신뢰할 수 없는 국가의 토지 등록, 국가 통화가 불안정한 지역의 암호 화폐 사용, (예: 베네수엘라에서) 국가적인 비용 절감의 경우, 일부 사례.전세계 선적품의 추적 등. 현재 상황을 검토할 때, 블록 체인에 대한 가장 유망한 사용 사례는 폐쇄된 허가된 응용 프로그램 (프라이빗 블록체인)에서 발견되며, 정의에 따라 가장 분산, 개방 및 허가 없는 응용 프로그램, 즉 블록체인의 개념에서 가장 멀리 떨어져 있는 곳에 있다는 주장이 제기 되었다. 한 참가자가 말했듯이, 가장 성공적인 블록체인은 신뢰 계층을 가지고 있는데, 이는 역설적으로 신뢰받는 중개자, 즉 이 기술이 제거해야하는 중간 계층에 의존합니다. 이것이 사실이라면 블록체인은 많은 경우에 새로운 자동화 방식을 나타낼 수 있다. ¶사회 토론에서 가장 중요한 반복적 개념은 '권력’이었다. 때때로 권력은 매우 문자 그대로 나타나게 되는데, 예를 들어, 블록체인 마이너들의 집합 (마이닝 풀)이 전기가 저렴한 독재적인 국가(중국 등)에서 나타난 다는 것이다. (power(권력)을 다루는 국가에서 mining power를 많이 갖게됨) 블록체인 기반시설의 유지비가 더 많이 들수록, 저비용 전력의 기반인 블록체인 생태계가 영향을 미칠 가능성이 더 높아진다. 하지만 권력은 다른 의미에서도 중요한 것으로 밝혀졌다. 단 하나의 법적 실체가 없는 분산형 기술은 개방된 소스 코드로 작업하는 개발자들의 느슨한 환경에서 변화하며, 익명화된 네트워크는 법 집행에 도전할 수 있는 자율 또는 주권적인 주체로 부상하는 경향이 있다. TOR 네트워크 또는 P2P 파일 공유 시스템과 같은 개인 정보 보호 기술은 bittorrent와 같이 중요한 합법적 용도를 가지고 있지만 다크 웹 (딥웹 등)을 작동할 수 있는, 이중 사용 기술의 두 가지 예다. 최근 몇 년 동안 이러한 기술이 가능한 부가 판매 영역 및 관행과 이에 대응하려는 다양한 민간 및 공공 에이전트 사이의 집중적인 권력 투쟁이 있었다. 특정 유형의 블록체인 기술도 이러한 이중 사용을 가능하게 한다. 한편, 일부 응용 프로그램에서는 완전한 법적 준수를 달성하기 위한 충분한 인센티브가 있을 것이다. 그러나 우리는 또한 기술의 합법적이지 않은 적용을 촉진하는 조건들을 이해해야 한다. 두 번째 이슈는 인센티브 체계와 기관 및 개인이 블록체인 기술과 애플리케이션의 거버넌스에 참여할 수 있는 기회였다. 기술이 이해관계자들에 의해 어떻게 관리되고 있으며, 어떻게 기술이 활동, 그룹, 자원을 통제하는데 사용될 수 있는지가 지속적이고 집중적인 관심을 필요로 하는 핵심 과제로 나타났다. 분산 기술은 시장 및 중앙 집중식 조정의 효과적인 대안인 것으로 입증되었다. 그러나 분산형 형태의 지배구조가 현재 상황보다 더 효과적인지 여부는 여전히 불확실하다. 특히, 이 논의는 중앙 집중화의 동인과 기술적 가능성을 주요 과제로 지목했다. 기술이 분산되도록 설계되었지만, 분산형 네트워크에서 힘의 재집중화를 위한 많은 기회와 충분한 경제적 또는 정치적인 동기가 있다는 것은 점점 더 명확해지고 있다. 해답이 없는 한 가지 흥미로운 질문은: 인간의 권력 및 계층적 관계 성향으로 볼 때, 왜 어떤 권력 집중을 효과적으로 방지하는 시스템에 참여하게 될까? 결국, 토론은 신뢰의 개념과 블록체인 상황에서 후자를 더 잘 탐구할 필요성으로 바뀌었다. 네트워크 내에서 프로세스, 활동 및 트랜잭션에 대한 권한을 정확히 누가 가지고 있는지가 불분명하기 때문에, 누가 신뢰해야 하는지, 신뢰의 정확한 범위, 그리고 어떻게 다른 유형의 신뢰, 즉 올바른 개인에 대한 인센티브 등이 불분명하다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"누리엘 루비니교수: 블록체인은 쓸모없고, 모든 ICO는 스캠","slug":"blockchain-is-useless-all-ICOs-are-scam","date":"2018-10-08T15:00:00.000Z","updated":"2018-10-09T11:40:35.000Z","comments":true,"path":"2018/10/09/blockchain-is-useless-all-ICOs-are-scam/","link":"","permalink":"https://www.yceffort.kr/2018/10/09/blockchain-is-useless-all-ICOs-are-scam/","excerpt":"Economist Nouriel Roubini Says ‘Blockchain Is Useless, All ICOs Are Scams’ 원문 라스베가스에서 일어난 일은 라스베가스에서 밖에 모른다. (속담) 이는 잘 알려진 속담이지만 만약 당신이 Doom 박사와 Gloom 박사에 대해 말하고 있다면 그것은 맞지 않는 속담이다. 암호 시장에 대한 비관적인 견해로 유명한 누리엘 루비니는 라스베가스에 있었고, 그가 한 말은 전세계의 블록체인 신도들 사이에서 많은 분노를 일으키고 있다. 루비니에게 블록체인은 쓸모없고 지나치게 과장된 기술","text":"Economist Nouriel Roubini Says ‘Blockchain Is Useless, All ICOs Are Scams’ 원문 라스베가스에서 일어난 일은 라스베가스에서 밖에 모른다. (속담) 이는 잘 알려진 속담이지만 만약 당신이 Doom 박사와 Gloom 박사에 대해 말하고 있다면 그것은 맞지 않는 속담이다. 암호 시장에 대한 비관적인 견해로 유명한 누리엘 루비니는 라스베가스에 있었고, 그가 한 말은 전세계의 블록체인 신도들 사이에서 많은 분노를 일으키고 있다. 루비니에게 블록체인은 쓸모없고 지나치게 과장된 기술일 뿐이다. 그것은 이해관계의 증거와 확장성 문제 때문에, 결코 어디로도 도달 할 수 없을 것이다. 아무리 늦더라도 이것은 또 다른 기준이 되지는 않을 것이 그의 주장이다. 그의 주장은 전형적인 경제학적 관점에서 시작되었다. 비트코인은 교환의 매체, 가치의 단위 및 저장 가치인 돈의 정의를 만족시키지 못한다. 지난 10년 동안 모든 종류의 확장성 솔루션이 논의되었지만 비트 코인은 Visa 또는 Master Card와 같은 전통적인 기술로 수행할 수 있는 초당 거래 수는 비교할 수 없다. 블록체인은 해킹에 대해서 방어할 수 있지만, 매일 거래소가 해킹당하고 있다. 이것은 전통적인 교류와 오늘날까지 그들이 가지고 있는 오작동과 다르지 않다고 주장할 수 있다. 암호화폐 거래는 아직 초기 단계에 있으므로이 사람들이 전체 시스템을 견고하게 만드는 데 시간이 걸릴 것다. 하지만 나는 해킹이 큰 문제를 일으키고 있으며 중요한 조치가 시행되어야 한다는 사실에 동의했다. 그 다음은 탈중앙화 문제였다. 블록체인의 개념은 탈중앙화에 관한 것이지만 현재의 거래소는 주로 중앙 집중화되어 있다. 나는 이 점에 동의하고 실제로 작동할 교환은 분산된 거래를 통해 이루어질 것이라고 덧붙였다. 그리고 블록쇼 컨퍼런스에서 그가 토론한 것이 떠올랐다. 사람들은 종종 블록체인 기술을 초기 단계에서 인터넷과 비교한다. 그는 이렇게 강조했다. 이 기술의 채택은 그 수준에 근접한 것이 아니다. (인터넷의 수준에 비할 바가 못된다.) 그러나 이 지점이 그가 틀린 곳이다. 사실, 우리는 (암호화폐) 거래로 계좌를 개설하는 기록적인 수의 사람들을 경험하고 있다. 이제 단지 암호 화폐를 사용하여 부동산, 자동차 및 긴 상품 및 서비스 목록을 구입할 수 있다. 2012년에 발생한 거래 수와 오늘날의 거래 수를 살펴보면, 차트에 대해 잘 모르는 사람조차도 현재보다 훨씬 더 큰 거래 수를 볼 수 있다. “새로운 기술을 시험하는 은행들에는 새롭고 독특한 것이 전혀 없습니다. 매일 수천 개의 신기술을 시험해 보죠.” “은행이 신기술 시험에 소액의 자본을 투자한다고 해서, 그들이 그것을 채택할 거라는 뜻은 아닙니다.” 하지만 은행들은 암호 화폐 전문가들을 고용하고 있다. 골드만삭스, 씨티뱅크, 그리고 몇몇 다른 은행들은 암호 화폐를 위한 문을 열기 위해 노력하고 있다. 그의 관점은 은행들이 우리 삶을 변화시키기 위해 핀테크라는 세 가지 기술(인공 지능,빅데이터, 사물 인터넷)을 사용한다는 것이다. 인공지능과 빅데이터는 두 개의 섹시한 단어일 뿐만 아니라 엄청난 잠재력을 가지고 있다. 하지만 블록체인 기술이 없다면 신뢰나 투명성은 없을 것이다. 나는 이더리움에 관한 주제로 넘어갔다. 하지만 그는 스마트 컨트랙트가 디자인된 방식을 믿지 않는다고 그는 말했다. ICO 산업 전체가 사기입니다. 사람들은 도둑질을 하고 가치가 없는 프로젝트를 위한 기금을 모으고 있다고 덧붙였다. 나는 강하게 반대했다. 많은 ICO들이 진정한 가치를 가지고 있지 않다는 것은 사실이다. 하지만 같은 붓으로 업계 전체를 칠할 수는 없다. (몇가지 사례로 전체를 볼 수 없다.) 특히 정부가 기술을 채택한 공급 측면과 블록 체인과 A.I의 조합으로 산업을 바꿀 수 있는 Ethereum의 실제 사용 사례가 있다. @Nouriel has expressed himself against cryptocurrencies@VitalikButerinhttps://t.co/G2xx4x3Ytl&mdash; The Cryptonomist (@Cryptonomist_en) 2018년 10월 8일 Dcentralization is a myth: miners, exchanges, developers are centralized (Buterin is &quot;dictator for life&quot; ) &amp; the inequality coefficient of BTC is worse than North Korea that has the worst inequality on earth. Crypto beats Kim Un Jung in regards to centralization &amp; inequality&mdash; Nouriel Roubini (@Nouriel) 2018년 10월 8일 Calling this a Blockchain is a joke: it is private, &quot;permissioned &amp; trusted&quot;, not distributed, not based on a consensus mechanism &amp; all managed by IBM in a centralized way. Calling&quot;Enterprise DLT&quot; a Blockchain is a joke. It is a centralized database https://t.co/p1Lza0kkY4&mdash; Nouriel Roubini (@Nouriel) 2018년 10월 8일","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 적용에 있어서의 5가지 장애물은 극복되고 있다","slug":"blockchain-and-the-five-vectors-of-progress","date":"2018-10-07T15:00:00.000Z","updated":"2018-10-08T11:40:35.000Z","comments":true,"path":"2018/10/08/blockchain-and-the-five-vectors-of-progress/","link":"","permalink":"https://www.yceffort.kr/2018/10/08/blockchain-and-the-five-vectors-of-progress/","excerpt":"Blockchain and the five vectors of progress 원문 블록체인 기술은 계속해서 광범위한 열정을 불러 일으키고 있다 업계의 비즈니스 리더들은 비즈니스 프로세스를 간소화하고 새로운 비즈니스 모델을 가능하게하며 잠재적으로 산업을 재구성할 수 있는 잠재력을 보고 있다. 그러나 대부분의 기업에서는 블록체인의 가치보다는, 장애물이 더 많았으며 지금까지 상업적 채택은 제한적이다. 기술이 계속 성숙함에 따라 5개의 벡터를 따라 진행하면 기존 장벽을 완하하여, 블록체인 채택에 도움이 되며 블록체인을 메인스트림으로","text":"Blockchain and the five vectors of progress 원문 블록체인 기술은 계속해서 광범위한 열정을 불러 일으키고 있다 업계의 비즈니스 리더들은 비즈니스 프로세스를 간소화하고 새로운 비즈니스 모델을 가능하게하며 잠재적으로 산업을 재구성할 수 있는 잠재력을 보고 있다. 그러나 대부분의 기업에서는 블록체인의 가치보다는, 장애물이 더 많았으며 지금까지 상업적 채택은 제한적이다. 기술이 계속 성숙함에 따라 5개의 벡터를 따라 진행하면 기존 장벽을 완하하여, 블록체인 채택에 도움이 되며 블록체인을 메인스트림으로 이끌어 낼 수 있다. ¶블록체인 기술 채택의 여러 장벽 분석가들은 블록체인 기술이 언젠가는 사업에 중대한 영향을 미칠 것으로 널리 예상하고 있다. 이 기술은 효과적으로 통합되어 효율성과 효율성을 향상시키고, 비용을 절감하며, 새로운 제품, 서비스, 비즈니스 모델을 개발하는 데 도움을줌으로써 수익을 증가시킬 잠재력을 가지고 있다. 이러한 비전은, 많은 기업들이 블록체인 시범 프로젝트에 시간과 자원을 투자하도록 이끌었다. 분석가들은 블록체인에 대한 기업 지출이 연 2배로, 2018년에는 21억 달러에 다다를 것으로 예측했다. 그러나 해결되지 않은 문제로 인해 많은 기업들이이 기술을 채택하지 못하게 되고 있다. 최근의 한 조사에서 ICO의 9퍼센트만이 블록체인 관련 프로젝트를 실행했거나 1년 안에 계획한 것으로 동의했다. 하나의 주요 이유: 거래를 처리하는 수단으로 블록 체인 기반 시스템을 사용하게 되면 비교적 느립니다. 블록체인의 거래 속도가 느려지는 것은 고성능 레거시 트랜잭션 처리 시스템에 의존하는 기업들에게는 큰 관심사다. 다양한 블록체인 플랫폼과 솔루션 간의 표준과 상호 운용성이 부족하다는 것도 또 하나의 과제다. 블록체인 기술이 기존 엔터프라이즈 시스템과 쉽게 연결될 수 없다면, 대규모 프로그램과 이니셔티브에서는 거의 유용하지 않을 것이다. 데이터 프라이버시, 지적 재산권, 계약 집행 가능성, 관할권 선택에 대한 법적 및 규제적 우려는 기술 채택을 저해하고 있다. 그리고 기업들은 블록체인의 기술적 복잡성 때문에 제약을 받고 있다. ¶5개 영역에서의 진보는 블록체인을 적용시키는데 도움이 될 수 있다. 그러나 이러한 장애물을 해결하는 데 진전이 이루어지고 있다. 트랜잭션 속도, 표준 및 상호 운용성, 구현 용이성 등 세 가지 영역에서 기술적 타당성을 향상시킵니다. 다른 두 가지 - 규제적 발전과 컨소시엄 확장 - 은 기술의 적용 가능성을 더 많은 수의 사용 사례 및 산업으로 확대하는 데 도움이 될 것이다. ¶처리량 및 성능 향상 블록체인은 느릴 수 있다. 비트코인 블록체인은 초당 수만 건의 거래를 처리할 수 있는 기존 거래 처리 시스템과 달리 초당 3~7건의 거래만 처리할 수 있다. 이더리움 블록체인의 거래는 초당 15건에 불과하다. 상대적으로 성능이 좋지 않아 블록체인 기술이 큰 거래에서 실행 가능하다고 생각하는 사람이 많다. 그러나 개발자들은 이 성과 격차를 좁히는 유망한 방법을 연구하고 있다. 그들은 새로운 합의 메커니즘을 개발하고 있습니다. 합의는 블록 체인 네트워크의 참가자가 디지털 원장에 기록된 거래가 유효하다는 데 동의하는 방법이다. 비트 코인 블록 체인에 의해 대중화된 합의 메커니즘은 참가자들이 서로를 신뢰하지 않더라도 거래의 유효성을 신뢰할 수 있게합니다. 그러나 이는 성컴퓨터가 사용하는 작업 증명 메커니즘에 수반되는 계산 자원을 엄청나게 사용하는 비용으로 발생합니다. 새로운 합의 메커니즘은 상당히 높은 성과를 약속한다. 그들은 시간과 에너지 집약적인 마이닝을 줄이거 나 없애고 최종적으로 간주 될 트랜잭션을 검증해야하는 노드 수를 줄이는 설계로 이를 달성합니다. 새로운 합의 메커니즘은 특정 애플리케이션에 대해 더 좋거나 나쁘게 만드는 장점과 단점을 가지고 있다. 블록체인의 응용프로그램 다양성을 고려하면, 이는 실제로 좋은 것이다. 응용프로그램은 응용프로그램에 적합한 성능, 기능 및 보안의 절충점을 선택할 수 있다. 이러한 메커니즘은 실용적인 비잔틴 결함 허용, 연방 비잔틴 협정 및 스테이크의 위임 증명과 같은 이국적인 이름을 가질 수 있으며 Hyperledger, Stellar 및 Ripple을 포함한 저명한 블록 체인 플랫폼에서 사용되고 있다. 이더리엄 플랫폼은 작업 증명 채굴과 네트워크에서 신뢰할 수 있는 행동을 유도하기 위한 지분 증명 시스템을 결합한 하이브리드 합의 메커니즘으로 나아가고 있다. 지분 증명 시스템에서는 특정 수의 암호 통화 자산을 소유한다는 것을 보여줄 수 있는 참가자만 있으므로 신뢰할 수 있는 기능에 지분을 가지고 있다. 노드가 병행하여 합의 과정을 가속화하는 수단인 공유도 이더리움에 다가가고 있다. 신생 지리카는 초당 2000여 건의 거래를 처리할 수 있다고 주장하는 파편을 실시간으로 구현한다고 발표했다. 블록체인 설계자들은 화상 증명, 용량 증명, 경과 시간 증명 등 새로운 합의 메커니즘을 계속 탐구한다. 합의 메커니즘의 진화는 블록체인 속도를 크게 향상시키고 있다. 무역 금융, 공급망 추적성, 자동차 임대, 해양 보험, 건강 관리, 보험 등 분야에서 응용을 위한 좋은 소식이다. ¶표준 및 상호 운용성 향상 표준이 없으면 블록체인 개발자의 자유가 보장된다. 연구에 따르면 클라우드 기반 코드 저장소 GitHub는 여러 코딩 언어, 프로토콜, 합의 메커니즘 및 개인 정보 보호 조치를 갖춘 다양한 플랫폼을 사용하는 6,500 개 이상의 활성 블록 체인 프로젝트를 제공하고 있는 것으로 나타났다. 표준화는 기업들이 애플리케이션 개발에 협력하고, 개념 증명을 검증하고, 블록체인 솔루션을 공유하고, 기존 시스템과 통합하기가 더 쉬워지는 데 도움이 될 수 있다. 업계 참여자들이 교차 블록체인 거래, 상호 연결성, 표준화를 가능하게 하는 작업을 점점 더 많이 하도록 돕는다. 예를 들어, 작년에 Enterprise Ethereum Alliance는 비즈니스를 위한 Ethereum 블록 체인 소프트웨어의 표준 버전을 만들기 위해 설립되었다. 2018년 7월 현재 동맹은 거의 600명의 회원을 보유하고 있다. 산업 간 블록체인 기술을 발전시키기 위해 만들어진 오픈소스 협력 노력인 하이퍼레저 재단의 회원 자격은 250개 조직에 도달했다. 재단이 지원하는 프로젝트 중 하나는 인터레저 (Inter-Ledger) 프로토콜이다. 견인력을 얻는 또 다른 표준화 노력은 블록체인 기반 정체성 시스템의 표준을 촉진하기 위해 형성된 컨소시엄인 분산화된 재단이다. 이러한 시스템은 새로운 비즈니스 모델과 공공 서비스를 관리하는 새로운 방법을 가능하게 할 수 있다. 그 컨소시엄의 회원 자격은 지금까지 60개에 가까운 조직에 도달했다. 경우에 따라 업계는 새로운 블록 체인 응용 프로그램의 맥락에서 기존 표준을 채택함으로써 상호 운용성을 위해 노력하고 있다. 예를 들어 IBM과 마이크로소프트는 공급망 고객을 위한 각 기업 블록체인 애플리케이션에서 글로벌 표준 조직의 선도적인 GS1이 개발한 데이터 표준을 구현하고 있다. “표준에 관한 좋은 점은, 당신이 선택할 수 있는 것이 많다는 것이다.” 그러나 기술에는 많은 측면들이 있으며, 각자의 표준을 필요로 하는 무수한 산업별 문제들이 있다. 우리가 보고 있는 이러한 노력은 블록체인 기술의 진보의 원동력이다. ¶복잡성 및 비용 절감 블록체인 솔루션의 구축 및 배치와 관련된 비용과 복잡성은 기술 채택에 있어 중요한 장애물이다. 이러한 문제를 해결하기 위해 Amazon, IBM 및 Microsoft를 포함한 거의 12개의 대형 기술 공급업체는 이제 서비스로서의 클라우드 기반 블록체인 기술을 제공하고 있다. 새로운 클라우드 서비스는 빠른 속도로 시장에 출시되었으며 블록체인 네트워크의 개발 및 운영에 대한 장벽을 낮출 수 있는 잠재력이 있다. 클라우드 공급업체는 이 기본 블록체인 인프라 설정을 자동화하기 위한 블록체인 템플릿을 출시하고 있다. 또한 개발을 용이하게 하기 위해 블록체인 건설 도구 개발업자들과 협력하고 있다. 예를 들어, 구글과 스타트업 Digital Asset은 디지털 자산의 블록체인 구축 도구를 Google 클라우드에서 쉽게 액세스할 수 있도록 하는 파트너십을 발표했다. 클라우드 외에도, 새로운 소프트웨어 플랫폼은 블록체인 애플리케이션의 개발 및 구현을 간소화하는 것을 목표로 하고 있습니다. 예를 들어, 오픈 소스 플랫폼 Sawtooth는 핵심 시스템을 애플리케이션별 기능성과 구분하여 개발자에게 복잡성을 숨기는 모듈식 설계를 가지고 있다. 또한 개발자는 기본 기술에 대해 걱정하지 않고 JavaScript, Python 등의 기본 언어로 앱을 만들 수 있다. 사용하기 쉬운 블록체인 툴과 플랫폼을 지향하는 명확한 경향이 있다. 이러한 진보는 시간이 지남에 따라 블록체인 기술의 채택을 증대시킬 가능성이 있다. ¶규제적 지원 규제 문제는 블록체인 채택에 대한 또 다른 주요 장벽이다. 블록체인에 정통한 임원들을 대상으로 한 최근의 딜로이트 조사에서는 다섯명 중 두 명이 블록체인 기술에 대한 투자 증가의 장벽으로 규제 문제를 꼽았다. 그 이유는 이 기술이 암호화 서명이나 스마트 컨트랙트 같은 개념과 방법을 도입하기 때문이다. 어떤 경우에는 기술 응용 프로그램이 이러한 규정이 구상하는 관행에 위배되곤한다. 예를 들어, 일부 조직은 환자 통제하에 있는 기록에 액세스하여 환자 의료 기록을 안전하게 공유하기 위해 블록 체인 사용을 모색하고 있다. 그러나 건강 보험 관련 법 규칙에 따라, 개인 건강 정보를 공개하는 많은 사례는 비즈니스 제휴 계약을 체결하도록 요구한다. 이런 문제들을 해결하려면 공식적인 조치가 필요하다. 올해만 17 개 주 의회가 블록 체인 기술 채택과 관련된 수십 개의 법안을 고려하고 통과 시켰다. 이 법안은 암호화 서명의 승인, 스마트 계약의 정의와 사용, 비즈니스 기록을 유지하기 위한 블록체인 사용과 같은 영역을 다룬다. 한편 2018년 미 의회 공동경제보고서는 블록체인을 지지하고 개발자들에게 명확성을 부여하는 공통적이고 조정된 규제 체계를 요구하고 있다. 블록체인 채택에 대한 주요 규제 장애물이 제거되기 전에 여전히해야 할 많은 작업이 있다. 하지만 추진력은 점점 커지고 있다. 여기서 계속 진행중인 진전은 블록 체인 기술의 채택을 증가시키는 데 도움이 되는 진보다. ¶블록체인 컨소시엄의 성장 네트워크 간 거래를 용이하게하는 기술로서 블록 체인 네트워크의 가치는 사용자 수에 따라 증가한다. 블록체인 컨소시엄이 성장하는 이유가 바로 이런 이유 때문이다. 블록 체인 컨소시엄은 기술에 대한 공유 목표를 달성하기 위해 협력하는 그룹이다. 여기에는 사용 사례 정의, 표준 설정, 인프라 및 응용 프로그램 개발 및 블록 체인 네트워크 운영이 포함될 수 있습니다. 어떤 컨소시엄은 전 세계적으로 열두 개 산업에 걸쳐 61개의 블록체인 컨소시엄을 만들어 냈다. 이는 전년 대비 상당한 성장이었다. 금융회사들은 블록체인 컨소시엄을 설립하는 데 앞장섰고, 열정을 유지해왔다. 예를 들어 금융산업의 블록체인 기술을 구축하는 R3는 회원이 2015년 42개 사에서 2018년 200개 회원사로 늘어난 컨소시엄을 이끌고 있다. 위험관리 및 보험 분야에서 지금까지 30개 기업이 컨소시엄에 가입해 거래비용을 낮추고 네트워크 참여자들 간의 데이터 전송 속도와 보안을 높이는 데 성공했다. 금융 서비스 외부의 기업들은 물류 분야의 주요 기업들과 생명과학 분야의 주요 기업들이 의료 공급망에서 위조품을 분리하기 위해 협력하는 메디레저 블록체인 플랫폼을 포함하는 교통 동맹의 블록체인 Blockchain in Transport Alliance 같은 자신들만의 컨소시엄을 구성하고 있다. 모든 컨소시엄이 응용 프로그램을 구축하는 것은 아니며 모든 것이 똑같이 효과적인 것은 아니다. 그러나 기업, 기술 제공자, 규제 기관 및 정부의 참여 증가는 기술 채택을 증가시키는 데 도움이 되는 블록 체인 개발의 진전이다. ¶결론 시간이 지남에 따라 여기에 설명된 다섯 가지 분야에서, 기업이 블록 체인을 배치하는 비용과 위험을 낮추고 기술의 실제 응용 프로그램을 확장하는 데 도움이 될 수 있다. 기업들은 거래 속도를 기하급수적으로 높일 수 있는 새로운 합의 메커니즘과 기법을 주시해야 한다. 블록체인 플랫폼과 솔루션 개발자들은 원장과 애플리케이션 환경에서 기존 시스템과의 상호 운용성을 높이기 위한 노력을 강화해야 한다. 블록체인을 서비스로 활용하는 벤더의 환경이 더욱 발전함에 따라 블록체인 기반 솔루션을 적용하는 복잡성이 완화될 수 있다. 기업들은 이미 블록체인을 구현하는 데 도움이 되는 다양한 옵션을 가지고 있다. 그들은 이러한 대안을 평가하고 그들의 필요에 가장 가깝게 정렬된 옵션을 선택할 수 있다. 기술에 대한 규제적 이해가 아직 초기 단계이지만, 기업은 국회의원 및 정책 입안자와 협력하여 견고한 규제 프레임 워크를 만들 수 있으며 정책 입안자의 실험 시설을 활용하는 방법을 살펴볼 수 있다. 마지막으로, 기업은 이 협업 기술로부터 최대 가치를 도출하기 위해 파트너 생태계를 창출하는 것을 고려해야 할 것이다. 이러한 파일럿과 실험에도 불구하고 경영진은 블록체인이 언제 대량으로 채택될 준비가 될지, 심지어는 언제쯤 될지 궁금해할 것이다. 그러나 이러한 과정 따라 진행하면 기술을 꽃피우는 순간을 더우 가깝게 만들 수 있을 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 금융에서 규제기관이 물어봐야 할 질문들","slug":"blockchain-finance-questions-regulators-ask","date":"2018-10-05T15:00:00.000Z","updated":"2018-10-06T04:37:36.000Z","comments":true,"path":"2018/10/06/blockchain-finance-questions-regulators-ask/","link":"","permalink":"https://www.yceffort.kr/2018/10/06/blockchain-finance-questions-regulators-ask/","excerpt":"Blockchain Finance: Questions Regulators Ask 원문 ¶1. Introduction 오늘날, 세계 금융 체계에는 많은 금융 중개자들이 존재하고 있다. 하지만, 왜 세계 금융 시스템이 그렇게 비효율적인 것인가? 금융 시스템에 많은 금융 중개자가 존재함에도 불구하고, 금융 투자 비용은 여전히 높고, 인 대출 비용 또한 많은 나라에서 심각한 문제다. 세계 금융 시스템은 수많은 금융 중개업자들을 통해 매일 수십억 명의 사람들에게 서비스를 제공하고 수십억 건의 거래를 수행한다. 그러나 글로벌 금융 시스템에","text":"Blockchain Finance: Questions Regulators Ask 원문 ¶1. Introduction 오늘날, 세계 금융 체계에는 많은 금융 중개자들이 존재하고 있다. 하지만, 왜 세계 금융 시스템이 그렇게 비효율적인 것인가? 금융 시스템에 많은 금융 중개자가 존재함에도 불구하고, 금융 투자 비용은 여전히 높고, 인 대출 비용 또한 많은 나라에서 심각한 문제다. 세계 금융 시스템은 수많은 금융 중개업자들을 통해 매일 수십억 명의 사람들에게 서비스를 제공하고 수십억 건의 거래를 수행한다. 그러나 글로벌 금융 시스템에는 많은 문제가 있으며, 이러한 문제 중 가장 큰 것은 수수료, 지연, 번거로운 서류 작업, 서비스 비용, 규제 준수 비용 등을 통해 비용을 증가시키고, 궁극적으로 부정 행위와 범죄(Tapscott 및 Tapscott)에 대한 여지가 생기는 것이다. 공식 금융 시스템은 신뢰할 수 있는 제 3 자에게 수수료 또는 무료에 대한 대가로, 한 당사자에서 다른 당사자로 금융을 이전하는데 크게 의존하게 된다. 여기에서 제 3자는 면허가 있는 은행 및 기타 면허가 있는 금융 기관을 포함할 수 있다. 그림자 은행 시스템의 다른 사람들 또한 직접적인 규제의 관점에 속하지 않는 금융 중개 활동에 참여할 수 있다. 개발 도상국에서는 제3자가 보험 회사, 소금융 은행, 전문 금융 기관, 종합 금융 기관, 종합 금융 은행, 개발 은행, 금융 예금 은행 및 개인 등을 포함할 수 있다. 이론적으로, 복수의 금융 중개자를 갖는 것의 본질은 대출 비용을 낮추고 금융 중개 비용을 낮출 수 있는 경쟁을 만드는 것이다. 그러나 실제로는 그렇지 않다. 금융 중재의 높은 비용으로 인해 금융 중재의 비용을 줄이고 이자율을 낮출 수 있는 방법을 찾을 필요가 있었다. 지금까지 금융 중재의 비용을 낮추는 방법에 대한 많은 제안과 정책 제안이 있었다. 2018년에, 금융 중재의 비용을 줄이기 위한 가장 급진적인 제안은 잠재적으로 어떤 금융 중재의 과정에 관여하는 모든 혹은 대부분의 제3자를 없앨 수 있다고 주장하는, 금융에 블록체인 기술을 사용하는 것을 지지하는 주장이다. 이전 연구들은 규제당국이 명확히 해야 하는 문제를 해결하지 않고 금융에서 블록체인 기술의 수요와 공급 측면 문제에 초점을 맞추었다. 이 논문은 금융 혁신에 관한 문헌에 많은 기여를 했다. 금감원이 블록체인 금융에서 우려하는 사안들을 부각시킨 것은 이번이 처음이다. 지금까지 대부분의 블록체인 토론은 비즈니스에서 블록체인 기술의 수요와 공급 측면에 초점을 맞추고 있다. 대신에 우리는 표준에 초점을 맞추지만, 규제당국이 블록체인 금융과 관련된 더 심각한 이슈들에 초점을 맞추고 있다. 둘째, 그 논문은 금융의 혁신에 관한 문헌에 기여한다. 이 논문은 재무 혁신의 필요성을 지지하고 규제당국이 우려하는 문제들을 조명한다. 또한 강조된 이슈는 블록체인 제공자가 블록체인 금융의 규제적 관점과 규제상의 이유로 무엇을 주의할 것인지를 이해하는 데 도움이 될 수 있는 통찰력을 제공할 수 있다. 셋째, 이 논문은 디지털 금융 문헌에도 기여한다. ¶2. 개념적 프레임워크 ¶2.1 왜 금융시스템은 비효율적인가? 금융 시스템은 혁신을 방해하는 과도한 규제로 인해 막혀 있기 때문에 비효율적이다. 또한 사후판단을 통해 만들어진 엄격한 규제가 비효율성을 유발한다는 것을 알게 되었다. 그 중 가장 큰 것은, 규제 요구를 준수하는 데 드는 높은 비용과 규제 서류 작업 비용이다. 2008년 글로벌 금융위기 직후 만들어진 지나친 수많은 규제를 기억하라. 둘째, 금융 시스템은 너무 중앙 집중화 되어 있어서 시스템 고장과 공격에 취약하기 때문에 비효율적이다. 그리고 우리는 중앙집중식 시스템이 종종 역방향 지향적이고, 덜 사전 예방적이며, 분산형 시스템에 비해 전향적이지 않다는 것을 알게 된다. 셋째, 현재의 금융 시스템은 개인 차입자들이 은행과 같은 다른 중개자로부터 대출을 받을 경우 발생하는 비용을 피하기 위해 개인차입자들이 부유한 개인이나 대형 기관차입자들과 직접 거래할 수 있는 공정한 플랫폼을 제공하지 않는다. 블록체인 금융은 잠재적으로 이러한 문제들을 제거할 수 있다. ¶2.2 블록체인의 정의 블록 체인은 활동이나 거래가 연대순으로 공개적으로 기록되는 디지털 원장이다. 블록체인 네트워크에서 트랜잭션이나 활동을 기록하는 것은 중앙 집중화되지 않으며 한 사람이나 사용자가 수행하거나 제어 할 수 없다. 오늘날 블록 체인의 가장 일반적인 사용은 암호 통화, 즉 비트 코인과 같은 암호 통화를 사고 판매하는 것입니다. 암호 블록 체인에서 비트 코인 또는 다른 암호 통화로 이루어진 트랜잭션은 연대순으로 공개적으로 기록된다. 여러 사용자가 블록 체인의 모든 트랜잭션을 볼 수 있으며 블록 체인의 트랜잭션 체인에 새로운 정보를 추가할 수 있다. 일부 블록체인은 블록체인 네트워크에 가입할 수 있는 권한이 필요하다. (프라이빗 블록체인) 액세스가 이루어지면 사용자는 네트워크에서 관심있는 블록 체인에 새로운 정보를 추가할 수 있다. 다른 블록체인은 허가가 필요하지 않으며 누구나 새로운 정보를 추가할 수 있다. (퍼블릭 블록체인) ¶2.3 블록체인 작동의 이해 Tapscott 및 Tapscott(2017년)은 블록체인 기술의 기본 5가지 기본 원칙을 강조한다. 분산 데이터베이스: 블록체인에는 분산 데이터베이스가 필요하다. 블록체인의 각 당사자는 전체 데이터베이스와 전체 기록에 액세스할 수 있다. 단일 사용자가 데이터베이스의 데이터 또는 정보를 완벽하게 제어하지 못한다. 모든 당사자는 중개자 없이 거래 파트너의 기록을 직접 확인할 수 있다. 피어 투 피어 전송: 블록체인에서는 중앙 노드가 아닌 네트워크의 피어 간에 직접 통신이 발생한다. 각 노드는 정보를 저장하고 다른 모든 참여 노드로 전달한다. 익명성 대한 투명성: 시스템에 대한 액세스 권한이 있는 모든 트랜잭션 및 관련 값은 볼 수 있다. 블록체인의 각 노드 또는 사용자에게는 블록체인을 식별하는 고유한 30자 이상의 String 주소가 있다. 사용자는 익명으로 남거나 자신의 신원에 대한 증거를 다른 사람에게 제공하는 것을 선택할 수 있다. 모든 트랜잭션은 사용자의 ID를 표시하는 블록체인 주소 간에 발생한다. 기록의 불변성: 일단 트랜잭션이 데이터베이스에 입력되고 계정이 업데이트되면, 이전에 발생한 모든 트랜잭션 레코드에 연결되어 체인 효과를 생성하기 때문에 레코드를 변경할 수 없다. 일부 블록체인에는 데이터베이스 상의 기록이 영구적이고 연대순으로 정렬되도록 배치되는 계산 알고리즘과 접근방식이 있어 한 명의 사용자가 거래를 완료한 후 트랜잭션을 변경할 수 없다. 이렇게 하면 네트워크의 모든 사용자가 사용할 수 있다. 컴퓨터 로직: 블록체인 뒤의 로직은 디지털 원장 역할을 한다는 것이다. 원장의 디지털 특성은 블록체인 트랜잭션을 기존 컴퓨터 로직에 연결할 수 있고 프로그래밍할 수 있다는 것을 의미하며, 따라서 휴먼 에러를 제거합다. 이를 통해 사용자는 노드 간 트랜잭션을 자동으로 트리거하는 알고리즘과 규칙을 설정할 수 있다. ¶3. Promoting blockchain 전 세계적으로, 그리고 최근에 금융 분야의 블록 체인 기술 옹호자들은 한 당사자에서 다른 당사자로 금융 청구의 흐름에 관련된 제 3자를 우회하기를 원한다. 일부 금융 전문가들은 블록체인 기술의 도입은 인간이 통제하는 기관이 아니라 컴퓨터 코드에만 의존하기 때문에 믿을 수 없는 방식으로 금융 청구권 이전을 허용한다고 강조한다. 이것은 금융 중개 과정이 더 이상 인간이 아닌 컴퓨터 코드에 의해 통제된다는 것을 의미한다. 나이지리아를 포함한 많은 국가의 금융 시장에 진입하여 금융 시스템의 블록 체인을 통해 회사와 정부를 설득하여 금융 사용자가 비용 절감, 대출 금리 저금리 및 지불 효율성이 높은 비즈니스 활동에 관련된 제 3자를 우회할 수 있도록 했다. 금융 블록체인 기술의 다른 지지자들은 금융의 블록체인 기술이 사용자와 금융 제공자 모두에게 '신뢰가 필요한 환경’을 요구하지 않는 금융 시스템을 만들 수 있다고 주장한다. 금융의 블록체인 기술이 금융 중재 프로세스에 관련된 금융 기관을 제거할 수 있으므로 금융 프로세스에 관련된 금융 기관을 제거할 수 있다. 금융 시장은 오늘날 신뢰가 필요한 환경이 금융 중재에 결정적이기 때문에 신뢰에 의존할 수 밖에 없게 된다. 주식, 채권, 대부분의 무역 거래와 투자는 신뢰에 의존한다. 기존 지불 시스템에 대한 신뢰를 침해할 수 있는 사건과 인간의 행동은 금융 시스템의 모든 상대방에게 공황을 일으킬 수 있으며, 대출 기관이 시장에서 자금을 인출하면 치명적인 영향을 미칠 수 있다. 대차대조표가 튼튼한 은행과 자본이 충분한 다른 은행은 주주와 예금자가 자본과 예금이 더 이상 은행에 안전하지 않다고 믿을만한 이유가 있는 경우 이 시스템이 붕괴 될 수 있다. 이것은 금융 시스템에 대한 신뢰의 중요성을 설명한다. 그러나 블록체인의 큰 이점 중 하나는 신뢰의 환경에 의존하지 않는다는 것이다. 이것은 금융에서 블록체인의 가장 큰 세일즈 지점이다. ¶4. 규제적 고민 일반적으로, 금융 시스템 규제 당국은 모든 금융 시스템 규제 문제에 있어서 규칙 제정 과정과 시행 과정에 대한 완전한 통제를 원한다. 금융 시스템 규제 당국은 다음과 같은 경우 블록체인 금융을 허용할 수 있다. 블록체인 규칙을 설정할 수 있는 전반적인 권한 어떤 당사자에게 불리한 기존 블록체인법에 대한 거부권 규칙을 적용하고, 규칙을 업데이트하며, 필요한 경우 규칙을 변경할 수 있는 권한 현재 금융 분야의 블록 체인 기술은 금융 시스템 규제 기관에 블록 체인 코딩 프로세스, 규칙 작성 프로세스 및 블록 체인 금융의 집행 프로세스를 완전히 통제하지 못한다. 실제로 일부 블록체인에서는 단일 실체(규제자 또는 조정자일 수 있음)가 시행/정리 과정이나 코드화 과정을 제어하도록 허용하지만, 이 기업은 규칙 제정 프로세스와 코드화 프로세스 모두를 직접 통제할 수는 없다. 다음은 금융 시스템 규제 당국이 금융의 블록체인 기술에 대해 걱정하고 이해하고 싶어하는 몇 가지 질문이다. 이러한 질문들은 우리가 특히 중요하다고 생각하는 블록체인 금융의 문제들로 한정된다. 누가 블록체인 금융의 규칙을 만들 것인가? 규제 기관입니까? 누구라도 있나요? 아니면 블록체인 공동체의 몇몇 멤버들인가? 왜 블록체인 규칙이 고정되지 않고 개별 블록체인에 마다 변경되어야 하는가? 예상치 못하게 개개의 블록체인이 바뀌었을 때 누가 책임 지는가? 규칙을 변경하면 예기치 않게 변경 사항을 모르는 사용자에게 재정적 손실이 발생할 수 있는가? 블록체인 금융의 엔드 이용자들이 블록체인을 코드화하거나 생성하는 방법을 모를 경우, 자본과 공정성은 유지될 것인가? 성공적으로 실행된 블록체인을 만든 사람들이 얻는 이익은 얼마인가? 그러한 마진이 공정한가 과도한가? 정말로 우리의 재정에 대한 통제권을 컴퓨터(코드)에 넘겨주고 싶은가? 시스템 전반의 블록체인 금융 시스템이 붕괴되거나 실패할 경우 발생할 수 있는 최악의 경우 또는 시나리오는 무엇인가? 기존 블록체인이 고객, 사용자 또는 공급자들의 특별한 요구를 충족할 수 없는 경우 이러한 요구를 충족하기 위해 새 블록체인을 만드는 전체 비용을 부담할 사람은 누구인가? 그리고 왜? Blockchain 네트워크의 입출력 정보의 퀄리티가 떨어진다면, 누가 BlockChain 네트워크의 높은 품질을 보장하겠는가? 60%의 블록체인 사용자가 동의한 후 블록체인 프로토콜을 갱신할 경우, 그러한 업데이트나 조치는 블록체인 프로토콜 업데이트를 지원하지 않는 나머지 40%에게 불공평한 것인가? (하드포크 문제) 어떻게 하면 불량 사용자를 식별하고 블록체인 네트워크에 침입하지 못하게 할 수 있는가? 누가 블록체인 코드에 제안된 변경이 필요한지 결정하는가? 블록체인은 변화하는 요구에 대응하여 시간이 지남에 따라 진화할 필요가 있으며 따라서 개별 블록체인의 기본 규칙을 변경할 필요가 있다. 하지만, 누가 개별 블록체인에 대한 블록체인 규칙의 변화의 빈도를 통제할 것인가? 일부 블록체인은 퍼블릭이며 코딩 내용을 편집할 수 있는 권한이 필요하지 않는다. 모든 사용자가 코드를 작성할 수 있는 권한 없는 블록체인 네트워크 (퍼블릭 블록체인)를, 나쁜 행위자로부터 사용자를 어떻게 보호할 수 있는가? 일부 블록체인은 암호화되므로 코딩 내용을 편집할 수 있는 권한이 필요하다. 허가를 내주는 기준은 무엇인가? 사기가 발생한다면, 외부 조사자들이 비용 없이 조사를 위해 암호화된 블록체인 네트워크에 접근할 수 있는가? ¶5. 결론 현재 제안된 블록체인 지배구조 아이디어는 블록체인 기반의 금융 시스템을 규제하기 위한 중앙 당국의 필요성에 저항한다. 오히려 블록체인 거버넌스를 위해 여러 사용자와 이해당사자의 입력과 협업을 선호한다다. 블록체인 지배구조는 금융시장과 금융시스템에서 중요한 이해관계자인 중앙은행과 같은 중앙당국에 의존하지 않는다. 이것이 그것의 가장 큰 도전이 될 것이고 많은 중앙은행들이 그들의 금융시스템에서 블록체인 금융을 거절한 주요 이유가 될 것이다. 미국, 나이지리아, 우간다, 스페인과 같은 나라들은 예금자의 돈을 위험에 빠뜨릴 수 있는 부정적인 외부 상황을 막기 위해 규제 대상 은행들이 비트코인과 블록체인 거래를 하는 것을 금지했다. 그러나, 금융 분야의 블록체인 기술은 오랫동안 저항할 수 없는 중요한 혁신과 혼란이 되고 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"무엇이 비트코인의 가격을 결정하는가?","slug":"what-determines-the-price-of-bitcoin","date":"2018-10-04T15:00:00.000Z","updated":"2018-10-04T21:25:00.000Z","comments":true,"path":"2018/10/05/what-determines-the-price-of-bitcoin/","link":"","permalink":"https://www.yceffort.kr/2018/10/05/what-determines-the-price-of-bitcoin/","excerpt":"What Determines The Price Of Bitcoin? 원문 비트코인은 6개월도 채 되지 않아 절반 이상을 잃었다. 크리스마스 직전에, 그것은 19,000 달러가 넘는 가격으로 거래되었. 오늘날, 그러나 지금은 겨우 8,299 달러이다. (지금은 6,500달러 선) 당연하게도 비트코인 투자자들은 당장 가격 상승이 다시 시작될 것이라고 예측해 왔다. 그러나 비트코인은 지금까지 그러한 협력(?)을 거부하며, 지난 두 달 동안 계속해서 1만 달러 아래로 머무르고 있다. 언제, 혹은 언제 다시 일어날지 어떻게 알 수 있을까","text":"What Determines The Price Of Bitcoin? 원문 비트코인은 6개월도 채 되지 않아 절반 이상을 잃었다. 크리스마스 직전에, 그것은 19,000 달러가 넘는 가격으로 거래되었. 오늘날, 그러나 지금은 겨우 8,299 달러이다. (지금은 6,500달러 선) 당연하게도 비트코인 투자자들은 당장 가격 상승이 다시 시작될 것이라고 예측해 왔다. 그러나 비트코인은 지금까지 그러한 협력(?)을 거부하며, 지난 두 달 동안 계속해서 1만 달러 아래로 머무르고 있다. 언제, 혹은 언제 다시 일어날지 어떻게 알 수 있을까? 통화 분석 업체인 Fundstrat는 그들이 비트코인의 미래 가격을 예측하는 방법을 발견했다고 생각했다. 그들은 Bitcoin이 2019년 말까지 36,000 달러에 도달할 것이라고 예측하기 위해, Bitcoin 마이닝 비용을 예상했다. CRYPTO: Our quant/data scientist @fundstratQuant publishing #bitcoin mining white paper. Crypto mining economics lead/explain $BTC price—suggests $39,000 per bitcoin by YE19. key takeaways below... pic.twitter.com/f5ZQ4py3jS&mdash; Thomas Lee (@fundstrat) May 10, 2018 그러나 이 방법은 Bitcoin 커뮤니티로부터 상당한 비판을 받았다. 트위터에서 Blockstream의 수석 전략 책임자인 Samson Mow는 Fundstrat의 예측이 논란의 여지가 있는 경제 이론에 의존한다고 주장했다. I generally like your work @fundstrat, but hashrate growth doesn’t “support” $BTC price. You’re essentially making an argument for the labor theory of value -&gt; meaning people will pay x for a hole you dug just because you spent time digging. https://t.co/caYbaS8MJy&mdash; Samson Mow (@Excellion) May 12, 2018 ‘노동가치설’은 본질적으로 상품이나 서비스의 가격이 그것을 생산하는 데 필요한 작업에 의해 결정된다고 말한다. 마르크스주의 경제학자들에게는 인기가 있지만, 대부분의 다른 경제학 학교들은 그것을 포기하고 ‘주관적 평가’를 선호했다. 이 평가는 선이나 서비스의 가치가 그것을 생산하기 위해 어떤 노력을 하든 상관없이 어떤 사람이 지불할 것인지를 의미한다. 모우의 주장은 주관적 평가가 가치의 노동 이론이 아니라 비트코인의 가격 역학을 이해하는 올바른 방법이라는 것이다. 물론 생산자가 상품이나 서비스를 시장에 지불하는 것보다, 생산하는 노력을 더 가치있게 생각한다면, 생산을 중단할 것이다. 따라서 가격이 떨어지면 한계 생산자는 공급을 줄이고 가격을 올리는 경향이 있다. 손실 시 판매할 수 있는 재고 및 / 또는 충분한 매장량을 보유한 생산자는 얼마 동안 생산을 계속할 수 있다. 그러나 시간이 지남에 따라, 시장이 청산할 수 있을 정도로 가격이 상승하게 되면 점점 더 많은 생산자가 생산을 중단하게 된다. 마찬가지로 비트코인의 가격이 떨어지면 마이닝 하는데 드는 비용이 보상을 초과하기 시작한다. 하지만, 이는 보안 위험을 초래한다. 마이닝 풀이 줄어들면서, 51퍼센트의 공격을 하려는 시도가 더욱 매력적이게 되었다. 따라서 비트 코인은 마이너들이 가격이 떨어질 때 마이닝 풀에서 빠져 나가는 것을 막기 위한 자동 조정 메커니즘을 가지고 있다. 마이너들이 해결해야 하는 알고리즘적 퍼즐은 비트코인의 가격이 올라갈수록 더욱 어려워지고, 가격이 떨어질 때는 덜 어려워진다. 이것은 비트 코인 생산 속도를 약 10 분마다 1 블록으로 유지하면서, 해시레이트 (퍼즐을 푸는 데 필요한 컴퓨팅 성능)가 비트 코인 가격으로 변동하도록한다. 해시레이트가 마이닝 비용의 주요 구성 요소인 전기 사용의 척도이기 때문에 마이너의 이탈 비용은 비트 코인 가격을 추적하는 경향이 있다. 난이도 조정으로 책정된 가격대가 비용과 가격을 합친 것이기 때문에, 손익분기 비용 추세가 비트코인의 미래 가격을 합리적으로 예측한 것이다. 그러므로 그의 비판은 약간 불공평하다. Fundstrat은 노동 가치 이론에 의존하지 않았지만, 난이도 조정보다는 마이닝 비용이 가격을 뒷받침한다는 것을 오해하게 한다. 물론, 이러한 지원은 비대칭적이다. 비트코인의 가격은 하락세에서도 지원되지만, 상승세에는 적용되지 않는다. 이는 마이닝 풀이 확장되고 있을 때 51%의 공격으로부터 방어할 필요가 없기 때문이다. 그러나 엄청난 비용 상승으로 인해 진입 장벽이 커져 마이닝 채굴 집중이 이루어지는 것은 아무에게도 발생하지 않은 것으로 보인다. 51%의 공격은 없을지 모르지만, 만약 마이닝 시장이 소수의 대기업들에 의해 지배된다면, 그 영향은 거의 동일하다고 볼수 있다. 특히 그 선수들이 협조한다면. 그리고 두 번째 문제도 있다. 비트코인은 상품처럼 거래된다. 장기적으로는 상품의 시장가격이 생산의 한계비용 쪽으로 치우친다. 다른 방법으로 말하면, 마이닝 이익은 결국 0으로 떨어진다. 앞서 언급했듯이 이익이 0으로 떨어지면 생산자들은 결국 생산을 중단한다. 그러나 마이닝이 멈추면 생필품은 여전히 거래되지만, 비트코인은 즉시 죽을 것이다. 이것은 마이너들의 진짜 일이 비트코인 생산이 아니라 거래 검증이기 때문이다. 트랜잭션 검증 없이는 비트코인을 구입할 수 없고, 판매할 수 없으며, 소비할 수도 없고, 얻을 수도 없다. 마이닝이 중단되면 기존 비트코인은 유동적이 될 것이고 부동자산은 가치가 없다. 그러므로, 상품과는 달리, 마이닝 이윤이 0으로 떨어지면, 기존의 모든 비트코인의 가치도 그렇게 될 것이다. 난이도의 조정은 마이너들의 충분한 마이너들이 계속해서 채굴을 하도록 하기 위해 인위적으로 마이너들의 이윤 마진을 보존한다. 이는 비트코인을 공격으로부터 보호하지만, 비트코인의 거래 시스템으로서의 재정적 지속가능성에 심각한 영향을 미친다. 현재, 새로운 비트코인은 채굴 보상의 일부이다. 그러나 마이닝의 새로운 비트코인 구성요소는 매 몇 년에 한 번씩 반씩 보상금을 지급한다. 결국 그것은 0에 도달할 것이다. 조정 난이도에 따라 채광 수익이 양의 값으로 유지되기 때문에, 가격 하락 또는 절반으로 인한 이윤 감소는 거래 수수료 인상으로 상쇄되어야 한다. 이 시스템의 사용자들은 마이너들이 정직하게 광산을 하도록 하기 위해 점점 더 많은 양의 비트코인을 지불해야 할 것이다. 내가 보기에 이것은 비트코인을 상품으로 보는 것은 잘못된 것이다. 마이너들은 비트코인의 사용자들이 대단히 의존하는 서비스 – 트랜잭션 검증을 제공한다. 그 서비스가 없다면 비트코인은 죽을 것이다. 그러나 마이너들은 또한 사용자들이 거래할 의지에 따라 수익에 의존한다. 요금이 너무 많이 오르면 사용자들은 비트코인 사용을 중단하게 되고 비트코인은 죽게 된다. 균형거래 수수료는 검증하기 위한 합리적인 양의 거래를 제공할 충분한 사용자와 검증을 정직하게 수행할 수 있는 마이너들이 있는 지점이 될 것이다. 궁극적으로, Bitcoin의 가치를 결정하는 것은 사람들이 그것을 사용하여 기꺼이 거래할 것인지 여부다. 여기에는 물론 비트코인 매매도 포함된다. 하지만 비트코인 가격이 사용자들이 계속해서 높은 거래 수수료를 지불할 수 있을 정도로 가파르게 상승할까? 아니면 결국에는 사용자가 시스템을 대량으로 떠나면서 가격 하락으로 촉발된 ‘죽음의 나선’이 생기고, 마이너들이 거래량을 줄이면 수수료가 0으로 낮아진다고 포기하게 될까?","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"퍼블릭 블록체인을 기업이 안전하게 활용하는 방법","slug":"how-to-make-public-blockchains-safe-for-enterprise-use","date":"2018-10-03T15:00:00.000Z","updated":"2018-10-03T21:25:00.000Z","comments":true,"path":"2018/10/04/how-to-make-public-blockchains-safe-for-enterprise-use/","link":"","permalink":"https://www.yceffort.kr/2018/10/04/how-to-make-public-blockchains-safe-for-enterprise-use/","excerpt":"How to Make Public Blockchains Safe for Enterprise Use 원문 프라이빗 블록체인의 세계는 많은 기업, 규제 기관 및 중앙 은행에게 책임 있고 중앙 집중식 주체가 있다는 편안함을 제공하지만, 이러한 허가 된 네트워크는 공공, 허가받지 않은 네트워크가 제공하는 혁신 또는 네트워크 효과와 결코 일치하지 않는다. 기업 상거래의 세계가 민간 네트워크에 의존하고 있다면, 그들은 결과적으로 금융기관을 소프트웨어 회사 및 호스팅 조직으로 대체하는 것이다. 그러나 이 두 세계를 하나로 모으고 공공 분산","text":"How to Make Public Blockchains Safe for Enterprise Use 원문 프라이빗 블록체인의 세계는 많은 기업, 규제 기관 및 중앙 은행에게 책임 있고 중앙 집중식 주체가 있다는 편안함을 제공하지만, 이러한 허가 된 네트워크는 공공, 허가받지 않은 네트워크가 제공하는 혁신 또는 네트워크 효과와 결코 일치하지 않는다. 기업 상거래의 세계가 민간 네트워크에 의존하고 있다면, 그들은 결과적으로 금융기관을 소프트웨어 회사 및 호스팅 조직으로 대체하는 것이다. 그러나 이 두 세계를 하나로 모으고 공공 분산 된 네트워크에서 똑같이 구현하는 것은 가능하며 필수적이기 까지 하다. 공공 네트워크가 약속을 이행하기 위해서는 두 가지 중요한 일이 일어나야 한다. 첫째, 규제 당국은 공공 블록체인에 존재하는 토큰, 자산 및 스마트 컨트랙트가 평가되는 방법에 대한 명확한 규칙을 제공해야 한다. 둘째, 기업은 공공 네트워크의 분산된 환경에서 이러한 규제 규칙을 시행해야 한다. 이 중 첫 번째 요소와 관련하여 미국, 유럽 및 전세계의 규제 기관들은 자산, 통화 또는 보안이 무엇인지 정의하고 있다. 모든 규제 기관이 정확하게 동일한 결론을 내릴 것으로 예상되어서는 안되지만, 어느정도 의견이 수렴하고 있는 것으로 보인다. 유틸리티 결제 코인은 증권으로 특징 지어지는 반면, 암호 화폐 또는 자산처럼 취급되고 있다. 우리가 앞으로 특히 중요하게 생각하는 한 가지 차이는 어떻게 토큰화 된 명목화폐를 규제할 것인가 하는 것입니다. 공공 블록체인에 1달러짜리 토큰을 가지고 있다면, 그리고 그것은 1달러짜리 예금통화로 뒷받침될 것이다. 지금까지, 어떤 규제기관도 이런식으로 떠오르는 범주의 블록체인 토큰에 대해 구체적으로 언급하지 않았다. 두 번째는 규제 규칙이 무엇이든 간에 토큰 및 스마트 컨트랙트로 구현해야 한다는 것이다. 특히 블록체인 전체는 분산될 수 있지만 중앙은행은 블록체인에서 자체 통화를 발행하고 취소할 수 있어야 하며 기업들은 토큰화된 자산을 관리할 수 있어야 한다. 이것이 얼마나 중요한지 설명하기 위해, 기업들이 공공 블록체인 네트워크에서 어떻게 서로 거래를 할 것인가에 대한 질문으로 돌아가 보자. 일단 회사가 재고와 자산을 토큰화하고 계약 및 금융 서비스에 사용하는 것을 시작하면, 이는 전통적인 금융 기관을 중개하는 것이 된다. 또한 이들은 또한 결과적으로 중개자의 규제 책임 중 일부를 맡아야 한다. 토큰은 예를 들어 가치가 있는 경우 돈만큼 쉽게 이동할 수 있다. 예를 들어, 소비자 패키지 상품(CPG) 회사는 전에는 이에 대해 생각해 볼 이유가 없었을지 모르지만, 일단 세제 패키지를 토큰화하면, 이러한 토큰은 실제 자금과 다른 어떤 종류의 상품에도 완벽하게 적합하게 만드는 효과적인 환율을 갖게 된다. 이는 CPG 회사들도 고객의 노하우(KYC)와 돈세탁 방지(AML) 규정 준수를 책임지게 된다는 것을 의미한다. 스마트 컨트랙트와 블록체인 토큰의 큰 이점 중 하나는 프로그래밍이 가능하다는 것이다. 앞으로 감사, KYC 및 AML 규정은 스마트 컨트랙트 및 토큰으로 작성될 수 있으며, 블록체인 전체의 중앙화에 의존하지 않고 공공 블록체인에 토큰을 사용하는 방법과 시기를 제어할 수 있다. 여기에는 도난 및 손실을 처리하기 위한 새 토큰의 취소 및 발행도 포함된다. 의심할 여지 없이, 규제 통제를 완전히 벗어난 시스템으로서 공공 블록체인의 종말을 애도할 많은 사람들이 있다. 블록체인들이 그들의 약속을 이행하기 위해서는, 이것은 불가피하지만, 어떻게 이것이 일어나는지에 대해서는 매우 중요하다. 규제 준수가 중앙집권화를 통해 전달된다면, 혁신에 큰 손실이 발생할 것이고, 우리는 다시 세분화된 인터넷이 죽는 꿈을 보게 될 것이다. 그러나 분산형 프레임워크 내에서 규제 준수라는 또 다른 방법이 있다. 스마트 계약에 대한 자발적 계약을 기반으로 한 옵트인 모델은 기업이 과도한 위험을 감수하지 않고 블록체인(블록체인)을 사업용으로 사용할 수 있다는 것을 의미한다. 그러나 동시에 개인과 창업자들은 누군가에게 허락을 구하지 않고도 급진적인 실험을 계속할 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"농장에서 블록체인으로: 상추를 추적하는 월마트","slug":"from-farm-to-blockchain-walmart-tracks-its-lettuce","date":"2018-10-01T15:00:00.000Z","updated":"2018-10-01T21:25:00.000Z","comments":true,"path":"2018/10/02/from-farm-to-blockchain-walmart-tracks-its-lettuce/","link":"","permalink":"https://www.yceffort.kr/2018/10/02/from-farm-to-blockchain-walmart-tracks-its-lettuce/","excerpt":"From Farm to Blockchain: Walmart Tracks Its Lettuce 원문 올 봄, 오염 된 로메인 상추를 먹어 병든 사람이 수십명에 달했을 때 Walmart는 많은 식료품 점이 할 일을 했다. 바로 안전을 위해 모든 선반에서 치워 버린 것이다. 월마트는 이제 어느 녹색 채소가 오염될지 정확히 파악하기 위한 더 나은 시스템이 있다고 말한다. 2년 동안의 시범 프로젝트를 마친 월마트는, Bitcoin의 데이터베이스 기술 유형인 블록 체인을 사용하여 시금치와 상추의 모든 재고를 추적할 것이라고 발표했다. 내년","text":"From Farm to Blockchain: Walmart Tracks Its Lettuce 원문 올 봄, 오염 된 로메인 상추를 먹어 병든 사람이 수십명에 달했을 때 Walmart는 많은 식료품 점이 할 일을 했다. 바로 안전을 위해 모든 선반에서 치워 버린 것이다. 월마트는 이제 어느 녹색 채소가 오염될지 정확히 파악하기 위한 더 나은 시스템이 있다고 말한다. 2년 동안의 시범 프로젝트를 마친 월마트는, Bitcoin의 데이터베이스 기술 유형인 블록 체인을 사용하여 시금치와 상추의 모든 재고를 추적할 것이라고 발표했다. 내년에는 Walmart에 초록색 채소를 공급하는 100 개 이상의 농장이 해 IBM이 개발 한 블록 체인 데이터베이스에 식품에 대한 자세한 정보를 입력해야 한다. 급성장하는 블록 체인 산업은 많은 관심과 투자와 실험을 불러 왔다. 중앙 은행은 블록체인을 활용해 자금 흐름을 추적하는 것이 좋을지 여부를 연구 하고 있다. 이스트먼 코닥 (Eastman Kodak)은 사진 작가가 자신의 소장품을 관리하고 소유권을 기록하는 데 도움을 줄 수있는 블록 체인 플랫폼을 연구했으며, 기자와 투자자들이 기술을 사용하여 일련의 뉴스 출판물을 시작했다. 그러나 본질적으로 유일하게 현실적인 용도는 거래를 저장하기 위해 자체 블록 체인을 사용하는 Bitcoin과 같은 cryptocurrencies에서 왔다. Walmart는 이제 블록 체인을 일상 소비자의 식품점으로 가져 오려고 한다. Blockchain의 Brigid McDermott 부사장은 &quot;이것은 대규모로 블록체인을 수행 한 최초의 진정한 사례&quot;라고 말했다. Walmart의 경우, 두 가지 핵심 전략, 즉 디지털에 대한 이해도를 높이고, 고객에게 신선한 음식의 품질을 강조하는 데 적합하다고 밝혔다. 블록 체인은 월마트의 돈도 절약 할 수 있다. 로메인에 영향을 미치는 대장균 발생과 같은 또 다른 음식물에 의한 병이 들었을 때 월마트는 실제로 위험에 처한 음식 만 폐기하면 된다. IBM은 막 신흥 기술의 선두 주자로 자리 잡기 위해 노력하고 있다. 마이크로소프트와 같은 기업들과 금융 거래, 음악 권리와 같은 분야에서 프로젝트를 개발해 온 이더리움과 같은 신생 기업들과 경쟁하고 있다. 월마트의 노력은 다소간 시작을 위한 시간이 필요하다. 그 동안 기업에서 개발중인 블록 체인이 구식 온라인 데이터베이스와 다른 점이 있는지 의심스러워하는 기술 비평가들의 질문에 직면 할 가능성이 있다. “블록체인 데이터 형식으로 이 작업을 수행하는 것이 어떻게 마법을 일으킬지 알 수 없다,” 라고 &quot;50피트 블록체인 공격&quot;의 작가 데이비드 제라드는 말했다. “저는 이것이 대부분 P.R.의 움직임이라고 생각합니다. 그래서 이 회사들은 스스로를 블록체인 리더로서 팔 수 있다,” 라고 그는 말했다. 월마트가 블록 체인을 채택한 이유는 미국 최대의 식료품 가게가 식량을 추적하는 것이 얼마나 어려운 일인가를 잘 보여주고 있다.지난 해 Walmart는 얇게 썰어 진 망고 소스를 추적하기 위해 실험을 실시했다. 과거 Walmart 직원이 과일을 재배 한 멕시코에서 농장을 찾는데 7 일이 걸렸었다. 월마트에 따르면 IBM에서 개발 한 블록 체인 소프트웨어를 사용하면 몇 초 안에 망고를 추적 할 수 있다. &quot;식품 체인이 항상 선형 구조를 띄는 것은 아니다.&quot;라고 월마트 식품 안전 담당 부사장인 Frank Yiannas가 말했다. 원래 블록 체인은 Bitcoin의 모든 주소와 트랜잭션이 저장된 온라인 데이터베이스다. 데이터베이스는 컴퓨터 네트워크에 의해 유지되고 저장되므로 은행과 같은 단일 기관이 기록을 보관할 필요가 없다. 여러 컴퓨터에 기록이 있기 때문에 사실 이후에 데이터를 변경하거나 되돌리는 것이 훨씬 더 어렵다. 많은 대기업들이 비슷한 데이터베이스 디자인을 사용하여 시금치를 농장에서 식료품 선반으로 옮기는 수백 명의 사람들과 같은 다양한 당사자들 사이에 기록을 유지하는 방법을 연구했다. Walmart가 채택한 버전을 포함하여 회사에서 테스트 한 블록 체인은 일반적으로 Bitcoin 또는 cryptocurrency와 관련이 없다. 이는 코인이 전혀없는 완전히 새로운 데이터베이스인 것이다. 누구나 볼 수있는 Bitcoin 블록 체인과 달리 특정 사용자 만 Walmart 데이터베이스를보고 액세스 할 수 있다. Walmart가 사용하는 시스템 인 IBM Food Trust는 Dole, Wegmans 및 Unilever를 포함한 소비재 회사를 위해 공급망을 통해 이동하는 제품을 추적하기 위해 개발되었다. 매번 월마트에서 생산물을 취급하는 사람들은 블록체인에 들어가고, 그것을 받을 때 마다 사인하고, 체인의 다음 사람에게 옮길 것이다. IBM과 월마트는 이미 이 시스템에서 요구르트나 가금류와 같은 다른 상품들을 추적하고 있다고 말한다. 블록체인은 중앙 권한을 담당하지 않고도 업데이트된 데이터베이스를 유지할 수 있도록 되어 있다. 그러나 현재 월마트 블록체인의 모든 기록은 월마트의 사용을 위해 IBM의 클라우드 컴퓨터에 저장되고 있다. 이로 인해 블록체인과 같은 분산 데이터베이스가 왜 필요한지에 대한 질문이 제기되었다. “이 아이디어는 옳지만 실행은 끝난 것 같다.” 블록 체인 채택에 관해 회사에 조언하는 컨설팅 회사인 11:FS의 공동 설립자인 Simon Taylor는 말했다. “IBM은 중간자가 필요 없는 새로운 기술을 습득하고 스스로를 중간자로 만들어 버렸다.” McDermott은 IBM이 액세스하거나 변경할 수 없도록 데이터가 암호화 될 것이라고 말했다. 블록체인에서 상품을 추적하려는 노력 또한 더 근본적인 도전에 직면해 있다. 블록체인은 시금치 상자의 디지털 레코드를 캡처할 수 있다. 하지만 누군가가 상자를 열고 시금치를 내부에서 다른 채소로 바꿔치든지, 불법 약물로 바꾸었는지는 알 수 없다. “블록체인은 사기로부터 당신을 보호하지 못할 겁니다.” 제라드 씨가 말했다. “사기꾼들을 아는 인간 감찰관이 필요하다.” 월마트는 블록체인을 통해 현장에서, 세탁 및 절단 시설을 통해, 창고와 마지막으로 상점으로 음식을 추적할 수 있다고 말한다. 심지어는 어느 쪽이 들판인지, 언제 채소가 수확되었는지를 정확히 파악할 수도 있다. Yiannas 는 Walmart가 쇠고기와 함께 전염성이 가장 높기 때문에 잎이 많은 녹색 채소에 초점을 맞추고 있다고 말했다. “우리는 시스템에 신뢰를 가져다 줄 수 있다.&quot;","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"어떻게 검은돈이 암호화폐 블랙홀에서 사라졌나","slug":"how-dirty-money-disappears-into-the-black-hole-of-cryptocurrency","date":"2018-09-30T15:00:00.000Z","updated":"2018-09-30T21:25:00.000Z","comments":true,"path":"2018/10/01/how-dirty-money-disappears-into-the-black-hole-of-cryptocurrency/","link":"","permalink":"https://www.yceffort.kr/2018/10/01/how-dirty-money-disappears-into-the-black-hole-of-cryptocurrency/","excerpt":"How Dirty Money Disappears Into the Black Hole of Cryptocurrency 원문 북한 요원, 도난카드를 가진 행상인, 8천만 달러 폰지 계획을 만든 사람들에게는 공통적인 문제가 있었다. 이들은 더러운 돈을 세탁해야 했다. 이들은 ShapeShift AG에서 해결책을 찾을 수 있었다. ShapeShift AG는 미국에서 설립된 벤처 캐피털 회사가 후원하는 온라인 거래 사이트로, 사람들이 추적할 수 있는 비트코인을 익명으로 교환할 수 있는 기능을 제공하고 있다. 비트코인이 도입된 10년전","text":"How Dirty Money Disappears Into the Black Hole of Cryptocurrency 원문 북한 요원, 도난카드를 가진 행상인, 8천만 달러 폰지 계획을 만든 사람들에게는 공통적인 문제가 있었다. 이들은 더러운 돈을 세탁해야 했다. 이들은 ShapeShift AG에서 해결책을 찾을 수 있었다. ShapeShift AG는 미국에서 설립된 벤처 캐피털 회사가 후원하는 온라인 거래 사이트로, 사람들이 추적할 수 있는 비트코인을 익명으로 교환할 수 있는 기능을 제공하고 있다. 비트코인이 도입된 10년전, 법 당국은 이 기술이 돈세탁 문제를 완화시킬 수 있다고 우려했었다. 이제 새로운 종류의 암호 통화 거래가 이러한 두려움에 긴급성을 부여하고 있으며, 이러한 관리 체계가 부족한 상태에서 사용자가 익명의 거래에 참여할 수 있도록 돕고 있다. WSJ에 따르면, 2년 동안 이러한 중개자를 통해 흘러 들어간 범죄 수익금이 약 9천만달러 인 것으로 확인되었다. 대부분은 미국 당국의 범위를 넘어선, 동유럽과 중국과 같은 장소에서 신원미상의 소유자와 주소를 가지고 운영되고 있다. 스위스에 공식적으로 등록되어 있는 이 기업은, 덴버 인근의 1980년대 사무실 건물에서 운영되고 있다. 창립자와 CEO, 마케팅 책임자 모두 덴버에 거주하고 있다. 사법 당국자, 연구원, 저널의 조사에 따르면 2014년 서비스가 시작된 이래로 일련의 범죄 용의자들이 ShapeShift서비스를 이용하고 있는 것으로 밝혀졌다. 북한에서 온 것으로 추정되는 해커들이, 이른바 WannaCry 랜섬웨어 공격으로 수백만달러를 강탈한 후, 범죄자들은 ShapeShift를 활용하여 비트코인을 Monero라고 하는 추적할 수 없는 암호 화폐로 환전한 사실을 발견했다. Moerno는 난독화된 공공원장을 활용하여, 누구든 거래를 전파하거나 전송할 수 있지만, 외부에서는 출처, 수/발신자를 알 수 없도록 만들어 졌습니다. 많은 암호 통화 거래소는, 돈세탁과 싸우기 위한 연방의 규칙을 잘 따르고 있다고 말한다. 비록, 이들이 돈세탁에 종속되어 있는지 테스트 하지 않음에도 불구하고, 그들은 고객의 신원을 기록하고 거래를 모니터링하여 의심스러운 활동을 근절하고 있다고 보고한다. 비트코인을 비록한 암호 화폐는 수천대의 컴퓨터에서 유지관리되는 디지털 원장 역할을 하는 소프트웨어를 기반으로 한다. 대부분의 원장 또는 블록체인은 공개적으로 볼 수 있으며, 익명의 온라인 계정이나 지갑에서 다음 계정으로 코인의 움직임을 추적할 수 있다. 하지만 비트코인을 달러로 거래하면 그 익명성은 깨질 수 있다. 따라서 범죄자들은 디지털에서 범죄의 흔적을 지울 방법을 찾아야 한다. 암호 화폐 자금 세탁 범위를 조사한 결과, 세탁된 거래 금액이 약 8,860만 달러 인 것으로 확인되었다. 범인으로 추정되는 많은 사람들이 알려지지 않았거나, 도망중이거나, 일부는 체포된 상태다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인 메모리풀 (Mempool)","slug":"mempool","date":"2018-09-28T15:00:00.000Z","updated":"2018-09-29T04:30:57.000Z","comments":true,"path":"2018/09/29/mempool/","link":"","permalink":"https://www.yceffort.kr/2018/09/29/mempool/","excerpt":"Mempool 원문 비트코인 트랜잭션이 네트워크로 전송되면, 사용 가능한 모든 비트코인 노드에서 먼저 확인하게 된다. 성공적으로 검증작업을 통과하면 'Mempool’에 들어가서 마이너가, 그 블록을 선택하여 다음 블록영역에 들어갈 때까지 대기하게 된다. 따라서, Mempool은 기본적으로 블록에 들어가기전에 보류중인 모든 트랜잭션에 대한 노드의 보류의 영역인 것이다. 모든 노드는 확인되지 않은 트랜잭션을 저장할 수 있는 RAM 용량이 다르다. 결과적으로, 각 노드는 보류중인 트랜잭션을 자체적으로 렌더링하게 된다. 이는 다양한","text":"Mempool 원문 비트코인 트랜잭션이 네트워크로 전송되면, 사용 가능한 모든 비트코인 노드에서 먼저 확인하게 된다. 성공적으로 검증작업을 통과하면 'Mempool’에 들어가서 마이너가, 그 블록을 선택하여 다음 블록영역에 들어갈 때까지 대기하게 된다. 따라서, Mempool은 기본적으로 블록에 들어가기전에 보류중인 모든 트랜잭션에 대한 노드의 보류의 영역인 것이다. 모든 노드는 확인되지 않은 트랜잭션을 저장할 수 있는 RAM 용량이 다르다. 결과적으로, 각 노드는 보류중인 트랜잭션을 자체적으로 렌더링하게 된다. 이는 다양한 메모리풀 크기와 서로다른 소스에서 볼 수 있는 트랜잭션 수를 설명하게 된다. 하지만 메모리 풀 크기에 따라 노드가 충돌하지 않기 위해서, 메모리 풀 크기가 RAM용량에 너무 가까워 지게 되면 노드는 최소 수수료 임계값을 설정한다. 이 임계값보다 낮은 kb당 수수료를 가진 거래는 즉시 메모리풀에서 제거되며, kb당 충분한 수수료를 가진 거래만이 메모리 풀에 엑세스 할 수 있다. 메모리풀은 BIP 35 (Bitcoin Imporvment Proposal)의 일부이며, SPV wallets(경량형 비트코인 지갑)이 트랜잭션을 기록하는 것을 돕는다. 기본적으로 메모리풀은 일종의 비트코인 네트워크의 병목현상이라 볼 수 있다. 블록체인에서 더 빠른 트랜잭션이 확인될 수록, 사용자는 더 나은 경험을 할 수 있게 된다. 신규 트랜잭션 블록 마이닝 비율이 메모리풀에 도착하는 신규 트랜잭션 속도보다 낮으면, 정체현상이 발생하고, 거래가 승인되기까지 오래 걸릴 수 있다. 노드가 새 유효한 블록을 수신하면, 해등 블록에 포함된 모든 트랜잭션이 해당 메모리풀에서 제거된다. 이는 메모리 풀 크기의 감소를 가져온다. 현재 메모리 풀의 크기는 여기서 볼 수 있다. 예를들어, 메모리 풀의 크기가 약 3MB인 경우, 트랜잭션이 확인되기 위해 평균 3블록이 소요된다는 것을 의미한다. 메모리풀 거래 중 일부는 ‘dust transactions’ (아주 소량의 비트코인을 보내는 것)과 같이 확인되기까지 오랜 시간이 걸릴 것이라는 사실을 발신자가 알고 있는, 우선순위가 낮은 거래일 것이다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"어떻게 나는 프라이빗 블록체인에 대해 신뢰를 잃었는가?","slug":"how-i-lost-my-faith-in-private-blockchains","date":"2018-09-28T15:00:00.000Z","updated":"2018-09-29T04:30:57.000Z","comments":true,"path":"2018/09/29/how-i-lost-my-faith-in-private-blockchains/","link":"","permalink":"https://www.yceffort.kr/2018/09/29/how-i-lost-my-faith-in-private-blockchains/","excerpt":"How I Lost My Faith in Private Blockchains 원문 2015년 이래로 기업으로 부터 무수히 많은 프라이빗 블록체인 관련 프로젝트가 있었지만, 이러한 프로젝트의 장기적인 생존 가능성에 대해서는 많은 질문이 제기되었다. 소수 프로젝트의 공통된 주제는 전통적인 산업에 대한 이해와 요구되는 기술적 이해 사이의 단절이다. 비즈니스 프로세스와 기술사이의 단절은 가장 분명한 요소지만, 비즈니스 사례의 개발을 제한하기 보다는 오히려 그 반대의 문제로 이어질 것으로 보인다. 바로 부당한 믿음과 기술이 할 수 있는","text":"How I Lost My Faith in Private Blockchains 원문 2015년 이래로 기업으로 부터 무수히 많은 프라이빗 블록체인 관련 프로젝트가 있었지만, 이러한 프로젝트의 장기적인 생존 가능성에 대해서는 많은 질문이 제기되었다. 소수 프로젝트의 공통된 주제는 전통적인 산업에 대한 이해와 요구되는 기술적 이해 사이의 단절이다. 비즈니스 프로세스와 기술사이의 단절은 가장 분명한 요소지만, 비즈니스 사례의 개발을 제한하기 보다는 오히려 그 반대의 문제로 이어질 것으로 보인다. 바로 부당한 믿음과 기술이 할 수 있는 일 사이의 과대 선전이다. 또한 프라이빗 블록체인이 실질적인 비즈니스 이점을 제공하는지는 아직 입증되지 않았다고 생각한다. 내가 이것에 대해 의문을 품은 이유는, 이를 찾으려고 노력하는 금융 기관들과 4년을 함께 일했기 때문이다. 처음 2년간, 이러한 잠재력에 낙관적이었지만 다른 기술에 대해 객관적으로 평가되고, 실패하는 사례가 점점 많아 지면서 객관적으로 그 기술에 대해 평가하고, 내 가정을 재평가 했다. 이로 인해 고객에게 문제에 더 적합한 기술을 활용하도록 조언하고, 공개 블록체인 및 암호화폐에 더 중점을 두도록 하는 전환을 만들어 냈다. 산업에서 프라이빗 블록체인을 적용할 때 고려할 요소는, 정의, 차이, 프로세스의 영향, 그리고 필요성에 달려 있었다. ¶정의 프라이빗 블록체인으로 문제를 설명하는데에서의 어려움은, 그것이 무엇인지 정의 하는지에서 부터 시작한다. 가장 기본적인 수준에서 블록체인은, 데이터 구조 또는 단순히 블록체인으로 정의 도리 수 있다. 그러나 블록체인에 대해 말할 때 의미하는 바가 거의 없다. 일반적으로, 블록체인에 대한 토론은 비트코인 또는 포크 된 버전이 프라이빗한 방식으로 사용되었기 때문에, 합의 과정에 대해 이야기 한다. 시간이 지남에 따라 서로다른 합의 알고리즘이 도입되었고, R3의 Corda와 같이 전세계적으로 데이터 공유를 위해 블록을 사용하지 않고 데이터를 저장하는 방법들도 도입되었다. 그 결과, ‘분산된 원장 기술’ 이라는 용어가 생겨났고, 사람들은 이를 모두 다 블록체인으로 보기 시작했다. 몇달에 한번, 세계 곳곳의 정부 기관은 규제상의 이유로 블록체인이나 분산 원장 기술을 정의하려고 노력한다. 그러나, 분산데이터 베이스와 다르거나, 혹은 구글독스와 다른 방식으로 정의하는 경우가 거의 없다는 것이다. 그리고 이러한 정의 수준에서 차별화 될 수 없다면, 전혀 다른 것으로 여겨져서는 안된다. 그래서 가능한 구체적으로, 이글에서는 중앙 통제를 막기 위해 고안된 방법으로 다른 당사자들과 데이터를 공유하는 기술에 대해 논하고자 한다. 중앙 집중식으로 제어하는 기능이 있는 경우, 데이터베이스가 존재하는 것이므로 이를 데이터베이스로 봐야 하고 그에 따라 다르게 비교해야 한다. 이 정의가 간과하고 있는 미묘한 차이가 있다는 것은 의심할 여지 없는 사실이지만, 이는 산업계 문제의 일부분이다. 도구를 정의 하지 않고도, 잠재적 편익을 크게 본다? 만약 우리가 그 도구가 무엇인지 정의하지 않는다면, 어떻게 그것이 옳고 그른 것이라고 말할 수 있을까? ¶차이 블록체인은 일반적으로, 중복성 및 손실로 부터 보호되는 데이터를 저장하고 통신할 수 있는 능력으로 인해 유익한 시스템으로 비춰진다. 데이터는 많은 수의 당사자 간에 자동적으로 조정되어, 사실상 즉각적인 데이터 전송 및 추적을 가능케한다. 데이터는 변경할 수 없으며, 사기를 방지하기 위해 데이터가 완전히 투명하다. 또 필요한 경우 다른 당사자가 볼 수 없도록 데이터를 암호화 할 수 있다. 마지막으로, 모든 당사자가 특정 방식으로 실행할 수 있는 편안함을 보고 얻을 수 있는, 복잡한 프로그램 (스마트 컨트랙트)을 실행할 수도 있다. 여기서 흥미로운 점은, 방금 설명된 모든 것이 분산 데이터베이스로 달성할 수 있다는 것이다. 산업에서 널리 사용되고 있으며, 비트코인이 출시되기 전에 수년 동안 존재하고 있었다. 그러나 이 정의한 두 기술 사이에는 중요한 차이가 있다. 블록체인은 중앙 거버넌스를 방지하기 위해 특별히 고안되었다. 그러나 이 기능은 무료가 아니다. 블록체인에서 모든 노드는 모든 데이터를 저장한다. 모든 노드는 모든 프로그램을 실행하고, 모든 트랜잭션은 네트워크 전체에 걸쳐 모든 사람들에게 전송된다. 블록체인을 변경하려면, 새로운 블록체인 소프트웨어를 만들어 현재 버전을 설치해야하는 모든 참가자에게 배포되어야 한다. 이러한 각 요구 사항은 블록체인 배치 및 지속적인 운영에 기술 및 거버넌스 비용을 추가한다. 이에 비해 데이터베이스는 관리자가 마스터를 변경하기만 하면 모든 노드에 즉시 전파한다. 계산도 최적화되어 있다. 모든 참가자가 데이터 사본과 실행중인 응용프로그램을 가질 수 있는 분산 데이터 베이스에서 무단 변경 또는 업데이트를 모니터링하고 검토할 수 있다. 따라서 블록체인을 분산 데이터 베이스로 간주하여 생각하는 것이 가장 쉬울 수 있다. 그렇다면, 그럼에도, 초당 트랜잭션, 디스크 공간, 컴퓨팅 속도 및 효율성, 유지 보수 비용 을 희생하고 대신 기술 구현을 선택하는 이유는 무엇인가? ¶프로세스의 영향 여기까지 와서, 일반적으로 사용되는 주장은 신뢰할 수 없는 기업과 거래 할 때 중앙 거버넌스를 제거하는 것이 유익하다는 것이다. 나는 이 주장에 대해 회의적이다. 기업은 항상 다른 기업과 거래를 하고, 이러한 목적 달성을 위해 계약을 체결한다. 블록체인은 계약의 필요성을 없애지 못할 것이며, 그러한 계약이 법에 명시된 모든 뉘앙스가 코드화되어야 한다는 증거는 거의 없다. 또다른 견해는 블록체인 기술이 미래라는 것이다. 이점을 수량화 할 수는 없지만, 새로운 패러다임으로 옮겨 가는 것에 더 가치를 두어야 한다. 미래를 예측하려고 시도하는 위험은 제쳐두고, 이 논리의 문제점은 '블록체인’은 하나의 모호한 기술이며, 블록체인으로 이동하는 것이 미래의 핵심요소라고 가정한다는 것이다. 그러나 그 미래의 형태를 알지 못하면, 이는 단순히 기술투자라는 대가를 치루는, 지불하지 않는 폐쇄된 네트워크에 희생하는 것이다. ¶정말로 필요한가? 프라이빗 블록체인 프로젝트를 진행하는 결정이 내려졌다고 가정하자. 이 기술을 구현하기 위해서는 기업은 블록체인 규칙을 정의해야 한다. 이를 위해 일반적으로 아래와 같은 과정으로 진행된다. 블록체인 어플리케이션 개발이 결정된다 투자를 중앙 집중화하고, 의사결정을 조정하기 위한 이해 당사자들의 컨소시엄이 구성된다 블록체인 발전을 지배하기 위한 중앙 당사자가 만들어진다. 3단계에 도달하면, 블록체인 규칙을 정의하고 업데이트 작성 및 배포 되는 방법을 정의하는 신뢰하는 중앙당사자가 존재하게 되며, 모든 이해 당사자들은 해당 당사자의 결과를 따른다. 모드느 기관이 중앙 당사자가 표준을 정의하고 업데이트를 배포한다고 신뢰하는 경우, 신뢰할 수 있는 중앙 당사자가 관리한느 분산데이터베이스에 대한 블록체인의 이점은 무엇인가? 컨소시엄 구서원들은 중앙 관계자들과 관계를 맺고 있으며, 기본적으로 모든 유지 보수 작업을 수락하고 다… 그렇다면 훨씬 더 효율적인 데이터 관리시스템을 사용하는 것이 어떤가? 즉, 이 기술은 여러 당사자가 많은 데이터 포인트와 관련된 문제를 조정하는데 도움을 줄 수 있다. 그러나 이것이 무너지는 것은 조정은 기술의 문제가 아니라 인간의 문제라는 것이다. 모든 관련 당사자들과 협력이 이루어졌을 때, 주요 이슈는 대게 이미 해결된 상태일 것이다. 결과적으로, 추가적인 기술은 필요하지 않다. 그리고, 그 목표를 실행하는데 엄청난 비용이 드는 기술이 필요한 것도 아니다. ¶탈중앙화를 강조할 필요는 없다. 결론적으로, 절반만 분산화 할 수 없다는 것이다. 어떤 수준의 중앙 집중화는, 결국 중앙 관리지점을 중심으로 통합된다. 비즈니스 및 법률 세계는 중앙 집중식 기업의 측면에서 웅영되며, 여전히 그렇지만 탈중앙화에 대한 강제적인 시도가 부족했을 수도 있다. 미래에는 분산된 기업이 있을 수도 있지만, 완전히 새로운 패러다임에서 유기적으로 성장할 수 있는 공공 블록체인 세계에서 나올 가능성이 더 크다. 그 동안 기관과 개인은 다른 기술과 마찬가지로 프라이빗 블록체인을 평가해야 한다. 이는 마법이 아니며, 다른 기술을 평가하는 것처럼 평가해야 한다. 기술의 이점은 소문, 과장, 두려움에 근거하여 가정해서는 안된다. 대신 비즈니스 문제가 무엇인지, 사용 가능한 다양한 기술 옵션이 무엇인지, 각 기술의 정량화 가능한 비용과 이점이 무엇인지를 묻는 방식으로 혜택을 평가해야 한다. 블록체인 프로젝트의 유일한 목적을 위해 기관에서 기술 선택 접근법을 변경해야하는 이유는 없다. 가장 낮은 비용으로 문제를 명백하게 해결할 수 있는 기술을 식별하고 선택해야 한다. 지금까지 나는 그런 분석이 수행되는 것을 보지 못했다. 영리한 기업은 자신의 문제를 해결할 수 있는지, 데이터베이스 또는 공공 블록 체인에서 비용을 낮추고 입증할 수 있는 부담을 위해 기술을 판매하는 사람들을 압박할 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"변동성 완화에도 계속해서 상업적 활용이 떨어지는 비트코인","slug":"Bitcoin's-use-in-commerce-keeps-falling-even-as-volatility-eases","date":"2018-09-27T15:00:00.000Z","updated":"2018-09-27T23:57:38.000Z","comments":true,"path":"2018/09/28/Bitcoin's-use-in-commerce-keeps-falling-even-as-volatility-eases/","link":"","permalink":"https://www.yceffort.kr/2018/09/28/Bitcoin's-use-in-commerce-keeps-falling-even-as-volatility-eases/","excerpt":"Bitcoin’s Use in Commerce Keeps Falling Even as Volatility Eases 원문 요즘 누가 비트코인으로 상품과 서비스를 사고 파는가? 지난 9월 4억 1,100만 달러를 정점으로 찍은 이후로, 가장 잘 알려진 암호 화폐 거래 서비스가 꾸준히 감소하여 지난 5월에 6천만 달러의 최저치를 기록 했다. Bitpay, Coinify, GoCoin과 같은 서비스가 6월에 약간 증가하여 6천9백만 달러로 증가했지만, 1년전 거래량인 2억 7천만달러와는 여전히 거리가 멀다. ![Amount of","text":"Bitcoin’s Use in Commerce Keeps Falling Even as Volatility Eases 원문 요즘 누가 비트코인으로 상품과 서비스를 사고 파는가? 지난 9월 4억 1,100만 달러를 정점으로 찍은 이후로, 가장 잘 알려진 암호 화폐 거래 서비스가 꾸준히 감소하여 지난 5월에 6천만 달러의 최저치를 기록 했다. Bitpay, Coinify, GoCoin과 같은 서비스가 6월에 약간 증가하여 6천9백만 달러로 증가했지만, 1년전 거래량인 2억 7천만달러와는 여전히 거리가 멀다. ![Amount of Bitcoin Received by Top Merchant Processors](/images/2018/09/Amount of Bitcoin Received by Top Merchant Processors.png) 비트코인 지지자들은 이런 가상 화폐가 언젠가는 사업을 하는 수단으로서, 명목화폐를 대체할 것이라고 꾸준히 주장해 왔지만, 지난 가을에 사용이 감소 한 이래로 암호 화폐는 실제로 상거래하는 목적으로는 거의 매력이 없어지고 있다. International Computer Science Institute의 연구원은, 비트코인 거래의 순비용은 신용카드 거래비용보다 크며, 비트코인에 기반을 둔 거래는 되돌릴 수 없다고 이야기한다. 이는 상인이나 소비자가 사기에 맞서야 하는 문제다. 지불에 대한 사용 감소는, 12월 가상 화폐 가격을 거의 2만달러 이상 끌어올린 투기의 급증과 일치한다. 비트코인 가격은 50%이상 폭락한후, 얼마지나지 않아 안정세를 다시 찾았지만, 소비자들은 여전히 디지털 화폐를 거래에 사용하는 것을 꺼리는 듯 하다. 작년에 가격이 빠르게 올랐던 것을 보았던 것 처럼, 언젠가는 순식간에 1,000달러를 잃어도 이상하지 않다. 그리고 커피와 같은 작은 물품을 사는데에도 수수료가 너무 비싸다. 지난 1월, 온라인 지불 플랫폼 Stripe는 비트코인 사용이 감소하고 가격 변동이 심화됨에 따라서 지원을 중단했다. 여행 서비스 제공업체인 Expedia와 같은 많은 회사들도 암호 화폐를 받아드리지 않는다. 이는 일부 투자자들에게 문제가 되는 징조다. 이들은 암호화폐가 현실세계에서 사용되어야 한다는 믿음을 가지고 있고, 장기적이 가치를 투기적 도구가 되어야 한다고 생각한다. 비트코인을 이용하는 방식 또한 변하고 있다. 비트코인에서 거래 수수료는 비싸고 다양하기 때문이다. 지난 12월에는 54달러까지 치솟았지만, 오늘날은 1달러 미만으로 떨어졌다. 이들은 커피와 같은 작은 금액의 거래로 사용하지 않는대신, 해외 위치한 프리랜서와 같은 밴더들에게 지불하기 위해 가상화폐를 더 많이 사용한다. 이경우 비트코인을 활용하는 것이 기존 금융 서비스를 이용하는 것보다 저렴하고 빠를 수 있다. BitPay관계자는, 지난 6개월 간 법률 회사, 호스팅, 회계사, 집주인, 소프트웨어 공급업체등 비트코인으로 지불하는 회사들이 늘고 있다는 것을 목격하고 있다고 밝혔다. 또한 Overstock.com Inc에서는, 올해 상반기에 비트코인 기반 구매량이 전년대비 2배 이상 증가했다고 밝혔다. 그러나 암호 금융 연구회사의 Mosaic에서는, 비트코인으로는 일상적인 거래를 하기 어려우며, 이는 돈의 특성에 부합하지 않는다고 덧붙였다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"사이드체인과 자식체인 (Sidechains and childchains)","slug":"what-are-sidechains-and-childchains","date":"2018-09-26T15:00:00.000Z","updated":"2018-09-27T12:45:01.000Z","comments":true,"path":"2018/09/27/what-are-sidechains-and-childchains/","link":"","permalink":"https://www.yceffort.kr/2018/09/27/what-are-sidechains-and-childchains/","excerpt":"What are Sidechains and Childchains? 원문 기존 블록체인 네트워크의 일반적인 문제는 확장성과 블록체인의 팽창성이다. 이러한 문제를 해결하기 위해서는 새로운 아키텍쳐가 필요하다. 사이드 체인을 통해, 개발자는 저렴한 비용으로 높은 수준의 보안에서 신속하게 확장할 수 있는 블록체인 솔루션을 배포할 수 있다. 사이드 체인은 통상 차일드체인 (자식체인)이라고도 한다. ¶사이드체인은 무엇인가 첫번째로 이해해야 할 두가지 개념이 있다. 메인체인이 차량이 이동할 수 있는 고속도로고, 고속도로에 인접한 일련의","text":"What are Sidechains and Childchains? 원문 기존 블록체인 네트워크의 일반적인 문제는 확장성과 블록체인의 팽창성이다. 이러한 문제를 해결하기 위해서는 새로운 아키텍쳐가 필요하다. 사이드 체인을 통해, 개발자는 저렴한 비용으로 높은 수준의 보안에서 신속하게 확장할 수 있는 블록체인 솔루션을 배포할 수 있다. 사이드 체인은 통상 차일드체인 (자식체인)이라고도 한다. ¶사이드체인은 무엇인가 첫번째로 이해해야 할 두가지 개념이 있다. 메인체인이 차량이 이동할 수 있는 고속도로고, 고속도로에 인접한 일련의 도로를 사이드체인이라고 생각하자. 그리고 필요할때 고속도로에 연결되어 달릴 수 있다. 따라서 사이드 체인은 양방향 연결을 통해 메인 블록체인에 연결된 블록체인으로 이해 되어야 한다. 사이드체인의 기능은 기존 블록체인의 기능을 풍부하게 할 수 있는 중요한 잠재력을 가지고 있다. 양방향연결(two-way pegs)을 활용하면, 자산을 상위 블록체인과 사이드 체인간에 교환할 수 있다. 예를 들어 비트코인을 별도의 블록체인 기본 자산으로 활용할 수 있다. 이러한 자산이 메인 블록체인과 차일드체인간에 교환되는 비율은 일반적으로 미리 결정된다. ¶사이드체인은 어떻게 작동하는가? 사이드 체인을 사용하려면, 상위체인의 사용자가 자금을 해당 주소로 보내야 한다. 코인이 해당 주소에 있으면 잠기게 된다. 즉, 더이상 다른 곳에서 이 코인을 사용할 수 없다. 이는 보안을 강화하기 위한 조치로서, 통신은 메인 체인 및 사이드 체인을 통해 전송되며 사용자의 자금이 주소로 이동한 후 대기 기간이 허용된다. 대기 기간이 끝나면, 해당 금액의 코인이 사이드 체인에 방출된다. 사용자는 코인을 사이드 체인에 사용할 수 있다. 사이드 체인에서 부모 체인으로 이동할때, 사용자는 원래 잠겨있던 사이드체인의 주소에서 보내게 된다. 대기기간이 끝나면, 같은양의 코인이 부모 블록체인으로 전송된다. ¶눈에 띄는 사이드 체인 프로젝트 ¶Rootstock Rootstock은 비트코인에 양방향 연결되어 있는 오픈소스 스마트 컨트랙트 플랫폼이다. 비트코인 마이너들은 merge-mining (서로다른 암호화폐를 같은 알고리즘을 활용하여 동시에 채굴하는 기술)을 통해 보상받음으로써 이 스마트 컨트랙트 혁명에 참여 할 수 있다.이 프로젝트는 거의 즉각적인 지불, 높은 확장성 및 스마트 컨트랙트를 가능하게 함으로써 비트코인 네트워크에 가치와 기능을 추가하는 것을 목표로 한다. 비트코인은 튜링완정성이 있는 스마트 컨트랙트를 만들어내는 능력이 부족하다. 이는 비트코인 성장에 중대한 단점 중 하나다. RST는 비트코인에 양방향 연결이 있는 블록체인으로서, 이러한 기술적인 요구를 제공하기 위해 만들어졌다. 사이드체인에는 자체 코인이 없기 때문에 비트코인과 경쟁할 필요가 없다. 이러한 merge-mining은 Rootstock을 확보하게 해준다. 즉, 이 블록체인에서 보안은 비트코인과 동일한 수준이다. RSK는 분권화를 유지하고, 대역폭 사용 및 용량을 줄여 초당 100개의 트랜잭션을 처리할 수 있도록 확장되었다. ¶Plasma 스마트 컨트랙트의 구현을 위한 프레임워크다. 플라즈마는 1초 내에 수십억개의 상태 정보를 업데이트 할 수 있도록 확장되었다. 이를 통해 블록체인은 전세계적으로 많은 분산 금융 응용 프로그램을 구현할 수 있다. ¶Alpha 알파는 비트코인 테스트넷의 사이드 체인 역할을 한다. 사이드체인 백서에 명시된 것 처럼, 중앙 집중식 프로토콜 어댑터를 통해 작동된다. 감사 가능한 서명자 집단은, 사이드체인으로 전송된 테스트넷 코인을 관리한다. 또한 서명된 블록요소를 통해 블록을 생성한다. ¶Liquid Liquid는 Blockcstream의 첫번째 상업용 사이드체인이다. 비트코인 블록체인에서 확인 지연을 기다릴 필요 없이, 거래간에 즉각적으로 자금이전을 용이하게 한다. Liquid는 모든 비트코인 거래에 참여하는 모든 유저들이 사용할 수 있다. ¶POA 이더리움의 사이드체인으로, 빠르고 안전하며 비용 효율적인 스마트 컨트랙트를 위한 공공 네트워크를 구축하는 것을 목표로 하고 있다. 여기서 합의 메커니즘은 5초미만으로 빠르게 이루어진다. 또다른 특징은 거버넌스 dApp에 검증자를 추가하거나 제거하는데 투표할 수 있게 해준다는 것이다. 다른 블록체인과 달리, 이 체인에 블록을 만드는데는 마이닝이 필요하지 않다. ¶사이드 체인의 장점 영구성: 사이드 체인을 사용할때 마다 새로운 사이드 체인을 만들 필요가 없다는 것이다. 일단 사이드 체인이 만들어지면 유지 관리가 되며, 메인체인에서 지정된 작업을 수행하는 사람이 사용할 수 있다. 서로 다른 암호 통화간의 상호작용: 개발자는 메인체인에서 출시되기 전에 베타 코인 릴리스 뿐만 아니라, 소프트웨어 업그레이드를 테스트할 수 있는 기회도 얻게 된다. ¶사이드 체인의 단점 사이드체인의 안정성 확보를 위해 마이너들이 필요하다. 이는 사이드 체인을 형성하는데 매우 값지싸게 만든다. 새로운 사이드 체인을 만들기 전에 막대한 투자를 해야 한다. 일정 크기의 운영자가 필요하다. 이는 공격자에게 또다른 취약점으로 작용할 수도 있다. 블록체인의 확장성을 위해 사용하는 사이드체인이나 자식체인이 부모체인을 손상시키거나 약화시키지 않는다. 사이드 체인은 양방향 연결을 사용하여 블록체인에 연결된 별도의 블록체인 이다. 이들은 주어진 시간에, 네트워크에서 지원할 수 있는 트랜잭션보다 더 빠르고, 낮은 비용의, 더 큰 확장성 보완 기능을 제공하는 보조 네트워크라고 볼 수 있다. 간단히 말해서, 사이드 체인은 기존 블록체인의 기능을 크게 향상 시킬 것으로 예쌍된다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인 사이트체인을 가능하게 하는 DriveChain","slug":"drivechain","date":"2018-09-25T15:00:00.000Z","updated":"2018-09-26T12:45:01.000Z","comments":true,"path":"2018/09/26/drivechain/","link":"","permalink":"https://www.yceffort.kr/2018/09/26/drivechain/","excerpt":"Drivechain: Enabling Bitcoin Sidechains 원문 비트코인 기능을 근본적으로 확장하여, 암호화폐에 새로운 기능을 추가할 수 있도록 하는 제안인 DriveChain이 테스트넷에 배포되었다. 이는 지난 2015년 11월에 처음 고안된지 거의 3년만의 일이다. 그 이후, 이 제안을 위한 모멘텀이 형성되었고, 현재는 아마도 비트코인에 대한 사이드체인을 구현하는 가장 좋은 방법으로 환영받고 있다. 2014년에 처음 설명된 사이드체인의 개념은, 비트코인 네트워크에서 분기를 만들 수 있도록 해준다. 드라이브체","text":"Drivechain: Enabling Bitcoin Sidechains 원문 비트코인 기능을 근본적으로 확장하여, 암호화폐에 새로운 기능을 추가할 수 있도록 하는 제안인 DriveChain이 테스트넷에 배포되었다. 이는 지난 2015년 11월에 처음 고안된지 거의 3년만의 일이다. 그 이후, 이 제안을 위한 모멘텀이 형성되었고, 현재는 아마도 비트코인에 대한 사이드체인을 구현하는 가장 좋은 방법으로 환영받고 있다. 2014년에 처음 설명된 사이드체인의 개념은, 비트코인 네트워크에서 분기를 만들 수 있도록 해준다. 드라이브체인을 활용하면, 여러 블록체인이 모두 동일한 21,000,000개의 비트코인을 활용할 수 있도록 해준다. 이 네트워크는, 그 외에는 모두 자율적으로 활동할 수 있게 된다. ¶오늘날 모노-체인 세팅의 문제 블록체인 기술은 경제적으로 tradeoff가 있으며, 사용자들은 최적의 tradeoff에 대해 의견이 분분하다. 하지만 오직 하나의 의견만이 자신의 뜻대로 움직일 수 있다. 비트코인 투자자들은 Z-cash, ripple, ethereum과 같은 다른 프로젝트들과 의 경쟁에 대해 걱정해야 한다. 비트코인의 창시자인 사토시는 많은 유형의 거래를 지원하고 싶었지만, 이 디자인이 유연하지 못하다는 것을 알고 있었다. 비트코인은 처음엔 화폐로 사용되기로 되어 있었지만, 일부 네트워크에서는 단순 교환을 위한 매체로 제한되어 경쟁상의 단점이 있었다. 대신, 사이드체인은 모두 동일한 비트코인 토큰을 활용하는 alt-chain (대안체인)이다. 이들은 코인이 없이 시작한다. 이들은 비트코인 예금을 수락하고, 비트코인 이전을 수락하며, 비트코인 출금을 분배한다. ¶주요 이점 ‘허가가 필요없는’ 혁신: 누구나 새로운 화폐단위를 만들어야 하는 어려운 과제에 직면하지 않고도, 새로운 블록체인 프로젝트를 만들 수 있다. 경쟁 제거: 비트코인은 존재하는 어떤 코드도 복사할 수 있기 때문에, 항상 최고의 코드를 갖는다. 선택의 자유: 사토시의 합의 프로토콜은 모든 사람이 마지막 바이트에 이르기까지 동의를 요구한다. 사이드체인을 통해, 사용자는 지불하고자 하는 혜택을 선택할 수 있다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"플라즈마: 이더리움 확장성을 위한 혁신적인 프레임워크","slug":"plasma-an-innovative-framework-to-scale-ethereum","date":"2018-09-22T15:00:00.000Z","updated":"2018-09-23T12:06:41.000Z","comments":true,"path":"2018/09/23/plasma-an-innovative-framework-to-scale-ethereum/","link":"","permalink":"https://www.yceffort.kr/2018/09/23/plasma-an-innovative-framework-to-scale-ethereum/","excerpt":"Plasma: An Innovative Framework to Scale Ethereum 원문 플라즈마는 이더리움 블록체인의 처리능력을 위한 프레임워크로, Vitalik Buterin과 Joseph Poon이 만들었다. 이전 프로젝트에서 Joseph Poon는 비트코인의 플라즈마인 라이트닝을 만들었었다. 두 프레임워크 모두 신뢰가 필요없는 다층적인 네트워크다. 신뢰가 필요없다는 것은, 사용자가 거래를 하기 위해 상대방을 알거나, 신뢰를 할 필요가 없다는 것을 의미한다. Poon과 Buterin은 일반 대중이 토큰과 암호 화폐 뿐","text":"Plasma: An Innovative Framework to Scale Ethereum 원문 플라즈마는 이더리움 블록체인의 처리능력을 위한 프레임워크로, Vitalik Buterin과 Joseph Poon이 만들었다. 이전 프로젝트에서 Joseph Poon는 비트코인의 플라즈마인 라이트닝을 만들었었다. 두 프레임워크 모두 신뢰가 필요없는 다층적인 네트워크다. 신뢰가 필요없다는 것은, 사용자가 거래를 하기 위해 상대방을 알거나, 신뢰를 할 필요가 없다는 것을 의미한다. Poon과 Buterin은 일반 대중이 토큰과 암호 화폐 뿐 만 아니라, 실제 상품과 서비스를 구매할 수 있는 분산 시장을 촉진하기 위하여 플라즈마를 개발했다. 현재 이더리움은 비트코인의 초당 7건의 거래와 비교하여, 초당 약 15건의 거래를 처리할 수 있다. 두 플랫폼의 처리능력은 그러나 초당 45,000건의 거래를 관리하는 Visa와 비교하여서는 초라하다. 플라즈마는 이더리움의 처리능력을 초당 수천, 또는 잠재적으로 수십억 거래로 확장할 수 있는 가능성을 제시한다. ¶플라즈마는 어덯게 작동하는가? 플라즈마는 자식 블록체인이 메인 부모 블록체인에서 분기되도록 허용함으로써 보안 및 확장성을 제공한다. 이러한 자식 블록체인은 마이크로 트랜잭션을 활용하여 더 빠르고 저렴한 속도로 처리한다. 자식 블록체인은 부모 블록체인에서 서로 독립적으로 공존하고 기능할 수 있다. 메인 이더리움 부모 블록체인에서 분기하여 다양한 자식 블록체인을 분기한 모습 블록체인 플랫폼은 노드네트워크를 사용하여 계정 잔액, 컨트랙트, 스토리지의 상태 값을 저장한다. 마이너는 이러한 분산 노드를 교차 참조하여 블록체인 레코드가 일치하고, 오류 또는 사기가 없는지 확인한다. 이 과정은 정확하고 공평하지만, 그러나 불행하게도 블록체인의 장부에 의존하는 것이 점점더 어려워 지고 있다. 각 노드가 더 많은 트랜잭션 및 데이터 스토리지로 채워짐에 따라, 마이너는 각 트랜잭션을 적시에 확인하는데 더 어려움을 겪고 있다. 시간이 지남에 따라, 블록체인은 큰 트랜잭션을 확인하는 동안 병목현상이 일어나게 되고, 많은 마이크로 트랜잭션이 블록체인에서 제대로 확인되지 못하게 된다. 스마트 컨트랙트를 추적하고, 글로벌 규모로 거래를 처리할 능력이 없다면 암호 화폐는 일반 소비자에게 이상적이지 못하다. 플라즈마는 자식 블록체인이 네트워큰 내의 데이터와 저장소의 대부분을 처리하게 함으로써, 이더리움의 원장으로 부터 많은 양의 병목 현상을 완화시키는 효과를 가져온다. 이더리움 블록체인의 스마트 컨트랙트는 어카운트의 업데이트 및 연산을 관리하는, 이더리움 의 코드화된 프로토콜의 일부인 이더리움 버츄얼 머신 (EVM)내에 있다. EVM을 활용하면, 분산된 응용 프로그램이 내장된 프로그래밍 언어 내에서 사기, 검열, 3자 간섭으로 부터 안전하게 보호되고 실행될 수 있다. 스마트 컨트랙트는 규칙, 조건, 지불이 사용자의 암호 지갑 사이의 교환으로 코딩되는 거래다. 플라즈마는 EVM 스마트 컨트랙트를 활용하여, 자식 블록체인의 런타임 환경을 보호하고, 이더리움의 정확성과 무결성을 유지한다. ¶플라즈마 트리 구조: 루트, 브랜치 블록체인 플라즈마 백서에서, 프레임워크의 구조는 블록체인 계층 구조에서 서로 다른 수준의 가지를 가진 나무처럼 보인다. 여기에서 이더리움의 주요 블록체인을 “뿌리(루트)” 또는 “부모” 블록체인으로 나타낸다. 플라즈마 블록체인은 이러한 '뿌리’에서 두번째, 세번째 계층 블록체인, 도는 마이크로 트랜잭쳔 채널로 분기한다. 스마트 컨트랙트 및 원장 네트워크를 더욱 분산 시킴으로써 플라즈마는 보다 효율적이고 안전한 마이크로 트랜잭션을 용이하게 한다. 사용자의 각 계정 상태의 변경사항을 메인 이더리움 블록체인에 보고하지 않고도, 자식 블록체인내에서 스마트 컨트랙트를 실행할 수 있다. 플라즈마 자식 블록체인에서, 당사자는 교환을 하기전에 서로의 새로운 계좌 잔액을 확인하기 위해 각거래에 서명해야 한다. 예를 들어, 스마트 컨트랙트를 체결한다고 가정해보자. 이 컨트랙트에는 배너 광고가 웹사이트에서 클릭 될때마다 일정비율로 지불한다는 내용이 적혀 있다. 사이트가 언급한 각 판매에는 추가 수수료 지불을 유발한다. 클릭이나 판매가 코드화된 컨트랙트를 트리거할 때마다 정기적으로 내 지갑에서 상대방 지갑으로 자금이 이전하게 된다. 이런식의 어래가 일어날 때 마다 둘다 자식 블록체인 내에서 계좌 잔액을 확인한다. 분기 블록체인은 이 중 한명이 계정 상태를 확인하려고 할 때만, 루트 체인에 데이터를 전송한다. 만약 내가 웹사이트에서 광고를 삭제하기로 결정했다면, 스마트 컨트랙트 자식 블록체인을 종료한다. 계정 최종상태는 부모 블록체인에 기록 될 수 있지만,반드시 있을 필요는 없다. ¶플라즈마의 보안 각 플라즈마 블록체인은 네트워크 파일 시스템이나 다른 프로세스에 엑세스 하지 않고, EVM의 스마트 컨트랙트를 활용하여 자체 비즈니스 논리, 계약 조건 및 트리거 이벤트와 공존할 수 있다.이렇나 블록체인은 공정한 거래를 시행하기 위해, 부모 블록체인에 의존할 수 도 있다. ¶자식 블록체인은 어떻게 안전하게 유지되는가? 인프라가 큰 대도시에 많은 이웃들이 사는 것처럼, 자식 블록체인은 주요 도시 중심가의 교외에 존재한다. 이 교외 지역은,스마트 컨트랙트 거래를 위해 마이크로 채널을 재공함으로써 사용자를 위한 공간을 만든다. 인센티브를 받은 검증자는 이웃 감시와 마찬가지로, 소규모 지역 사회내에서 보안을 유지한다. 경찰은 물건을 팔고있는 상점 주인을 보지 않는다. 경찰은 부동산 구매자가 주택구매를 중개하는 과정을 보기 위해 주변을 순찰하지 않는다. 마차ㄴ가지로, 각 마이크로 채널은 마이너의 검증 없이 원장 및 스마트 컨트랙트를 독립적으로 유지한다. ‘지역’ 검증자는 독립 공동채내에서 사기성 행동을 방지하기 위한 파수꾼으로 일하도록 인센티브를 받는다. 파수꾼이 범죄자 (사기 행위)를 발견하면 이웃 (자식 블록체인)에서 커뮤니티에 경고를 내리고 대피할 수 있다. 파수꾼은 이에 따른 결과를 집행할 권한은 없지만, 경찰서에 이를 보고할 수 있으며, 이는 범죄자를 법원 (부모 블록체인)으로 데려올 것이다. 나무구조대신에 미국 법원을 상상해보자. 지방법원, 주법원, 대법원이 있다. 플라즈마 내에서 이더리움은 대법원이다. 사법 재판소의 계층 구조는 균형잡힌 보안 시스템을 만든다. Plasma의 Ethereum 마이크로 트랜잭션 효율성을 향상시키는 능력은 대다수의 소비자가 상품, 은행, 거래 등을 구매하기 위해 블록 체인 기술을 사용할 수 있는 길을 열어줍니다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://www.yceffort.kr/tags/ethereum/"}]},{"title":"이더리움 지분 증명","slug":"ethereum-pos","date":"2018-09-20T15:00:00.000Z","updated":"2018-09-21T04:37:17.000Z","comments":true,"path":"2018/09/21/ethereum-pos/","link":"","permalink":"https://www.yceffort.kr/2018/09/21/ethereum-pos/","excerpt":"아래 글은 이더리움 공식 깃헙 FAQ에서 일부분을 발췌해서 번역한 글입니다. ¶지분 증명은 무엇인가? Proof of Stake (이하 지분 증명)은 검증자의 지분에 의존하여 퍼블릭 블록체인에 대해 합의를 하는 알고리즘의 일종이다. 작업증명 (PoW) 기반의 퍼블릭 블록체인 알고리즘은, 트랜잭션을 검증하고 새로운 블록을 만들기 위해, 암호화 퍼즐을 해결하는 참가자들에게 보상을 제공한다. PoS기반 퍼블릭 블록체인 (Ethereum에서 구현 예정인 Casper)에서 검증자들은 차례로 다음 블록을 제안하고, 투표하는데 드는 비중은 검","text":"아래 글은 이더리움 공식 깃헙 FAQ에서 일부분을 발췌해서 번역한 글입니다. ¶지분 증명은 무엇인가? Proof of Stake (이하 지분 증명)은 검증자의 지분에 의존하여 퍼블릭 블록체인에 대해 합의를 하는 알고리즘의 일종이다. 작업증명 (PoW) 기반의 퍼블릭 블록체인 알고리즘은, 트랜잭션을 검증하고 새로운 블록을 만들기 위해, 암호화 퍼즐을 해결하는 참가자들에게 보상을 제공한다. PoS기반 퍼블릭 블록체인 (Ethereum에서 구현 예정인 Casper)에서 검증자들은 차례로 다음 블록을 제안하고, 투표하는데 드는 비중은 검증자의 지분의 크기에 따라 달라진다. 이렇나 지분증명의 이점은 중앙 집중화 위험 감소 및 에너지 효율의 증가다. 일반적으로 지분증명 알고리즘은 다음과 같다. 블록체인은 일련의 검증자들을 추적하며, 이들은 블록체인의 기본 암호 통화를 보유한 사람은 특별한 이더리움 거래를 통해 검증자가 된다. 여기서 새로운 블록을 만들고 동의하는 과정은, 모든 현재 검증자가 참여할 수 있는 합의 알고리즘을 통해 수행된다. 합의 알고리즘의 종류에는 여러가지가 있으며, 합의 알고리즘에 참여하는 검증자에게 보상을 할당하는 방법은 다양하게 존재하므로, 이는 각 지분증명의 '취향’에 따라 달라 있다. 알고리즘 관점에서 볼때, 이는 크게 두가지 유형으로 나눌 수 있다. 체인 기반 지분증명과 BFT 스타일의 지분 증명. 체인 기반 지분 증명에서는, 알고리즘은 매 시간 (10초 정도의 간격이 될 수 있음) 동안 검증자를 무작위로 선택하고, 이 검증자에게 단일 블록 생성 권한을 할당한다. 그리고 이 블록은 이전 블록 (보통 가장 긴 체인의 끝에 있는 블록)을 가르켜야 하므로 시간이 지남에 따라 대부분의 블록은 끊임없이 성장하는 단일 체인으로 수렴하게 된다. BFT 스타일의 지분 증명에서, 검증자는 블록을 만들 권리를 무작위로 할당하지만, 모든 검증자가 각 라운드 동안 특정 블록에 대해 '투표’를 보낸다. 이러한 라운드 프로세스를 통해 어떤 블록을 인증할지 동의하고, 프로세스가 끝날때 모든 검증자가 영구적으로 동의 하게 된다. 주요 차이점은 블록에 대한 합의는 한블록 내에서 이루어 질 수 있으며, 블록 이후의 체인 길이나 크기에 따라 달라지지 않는 다는 것이다. ¶지분 증명은 작업 증명보다 무엇이 나은가? 자세한 내용은 여기에서 볼 수 있다. 요약하자면, 블록체인을 확보하기 위해 다량의 전기를 소비할 필요가 없다. (비트코인과 이더리움의 기존 작업증명 메커니즘은 하루에 백만달러 상당의 전기 및 하드웨어 비용을 소비하는 것으로 추정된다) 많은 양의 전력 소모가 필요 없으므로, 참가자들이 네트워크에 계속 참여하는 동기를 부여하기 위해 새로운 코인을 발행할 필요가 없다. 지분 증명은 중앙 집중식 카르텔이 생성되는 것을 막고, 네트워크가 유해한 방식으로 행동하는 것을 막기 위해 게임 이론적인 메커니즘을 사용할 수 있는 더 광범위한 여지를 남겨 둔다. 규모의 경제 문제가 덜 부각 되므로, 중앙 집중화의 위험이 감소한다. 1,000만 달러 짜리 코인은 100만 달러 보다 정확히 10배 높은 수익을 올릴 수 있다. 작업 증명보다 51% 공격에 대해서 더 비싼 페널티를 지불하게 하는 경제적 제재를 가할 수 있다. 내용이 부족해서 조금더 가져와보았다. 원문 ¶지분 증명이란 무엇인가? 지분 증ㅁ여은 거래의 유효성을 확인하고, 분산 합의를 달성하는 또다른 방법이다. 작업증명과 이루고자 하는 목표는 동일하지만, 목표에 도달하는 과정이 상당히 다르다. 2011년 비트코인 포크 포럼에서 지분 증명이라는 아이디어가 제안 되었지만, 이 방법을 사용한 최초의 코인에는 2012년 Peercoin, ShadowCash, Nxt, BlackCoin, NuShares/NuBits, Qora, Nav Coin 등이 처음으로 사용했다. 알고리즘이 거래를 검증하고 새로운 쁠록을 만드는 목표로 수학적인 문제를 해결하도록 요구하는 작업증명과는 달리, 지분증명에서 새로운 블록의 작성자는 지분의 양에 따라 결정론적인 방식으로 선택된다. ¶블록 보상이 없다. 또한, 모든 디지털 통화는 미리 만들어진 상태이며, 이 총양은 변하지 않는다. 즉, PoS 시스템에서 블록 보상이 없으므로 마이너가 이런 트랜잭션 수수료를 가져가게 된다. 그래서 지분증명 시스템에서는 마이너라는 용어 대신 forger(대장장이) 라는 용어를 사용한다. (근데 진짜 자주 쓰나? 난 처음 보는데.) ¶왜 이더리움은 지분증명을 선택했는가? 작업증명에 기초한 분산 합의는 마이너가 많은 양의 에너지를 소비해야 한다. 한 비트코인 트랜잭션은 하루동안 1.57가구에 전력을 공급하는 것과 같은 전력량을 필요로 한다. 이러한 에너지 비용은 디지털 통화 가치에 대한 지속적인 하향 압력을 초래 한다. 최근 연구에서는 2020년까지 덴마크 국가 만큼의 전력을 소비할 수도 있다고 밝혀졌다. 개발자들은 이 문제에 대해 심각하게 접근하고 있으며, 이더리움 커뮤니티는 보다 친환경적이고 저렴한 분산 형태의 합의를 하기 위해 지분 증명 방법을 사용하려 하고 있다. ¶어떻게 마이너로 선택될 수 있는가 Casper 프로토콜이 실행된다면, 검증자 풀이 존재하게 될 것이다. 사용자는 이 풀에 가입하여 마이너로서 활동할 수 있다. 이 과정은 캐스퍼 컨트랙트를 호출하고, 이더 또는 이더리움 네트워크에 권한을 부여하는 코인을 보내는 기능을 통해 활용할 수 있게 된다. 유효성 있는 풀 자체에 가입하기 위한 우선순위계획은 없다. 다른 참가자에 상관없이, 누구든 라운드에 참여할 수 있다. 이러한 검증자에 대한 보상은 약 2~15%가 될 것이라고 내다봤지만, 아직 확실하지는 않다. ¶결론 지분 증명 시스템에서 검증자는, 자신의 컴퓨팅 성능을 활용할 필요가 없다. 왜냐하면 채굴 가능성에 영향을 미치는 유일한 요인은 자신의 코인 (지분)과 네트워크의 현재 복잡도 이기 때문이다. 따라서 지분증명의 이점은 에너지 절약 공격이 더 비싸질 수록, 안전한 네트워크가 된다. 해커가 총 코인의 51%를 소유하는 것이 훨씬 더 비싸다. 이런식으로 CASPER 프로토콜은 경제적 컨센서스 시스템에 의존하는 보안 프로토콜이 될 것이다. 노드 (검증자)는 새로운 블록생성을 위한 합의의 일부가 되기 위하여 일정량의 보증금을 지불해야 한다. 프로토콜은 보안 예금에 대한 관리를 위해 검증자가 받을 특정 보상 금액을 결정하게 된다. 한 검증자가 만약 부적절한 블록을 만들면, 그 보증금은 사라지게 되고, 또한 네트워크 합의의 일부가 될 수 있는 특권도 사라지게 된다. 다시말해, 이 프로토콜은 베팅과 같은 시스템인 것이다. 지분 증명 시스템에서 베팅은, 합의 규칙에 따라 검증자가 베팅한 각 체인과 더불어, 유효한 검증을 한 검증자에게 상금을 지급하는 거래가 되는 것이다. 따라서 Casper 프로토콜은 검증자가 다른사람들의 베팅에 따라 베팅하고, 합의를 가속화 할 수 있는 긍정적인 결과를 내놓을 것이라는 믿음을 기반에 두고 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://www.yceffort.kr/tags/ethereum/"}]},{"title":"블록체인이 비즈니스를 향상시키고 스마트 경제를 만드는 방법","slug":"how-blockchain-will-accelerate-business-performance-and-power-the-smart-economy","date":"2018-09-19T15:00:00.000Z","updated":"2018-09-19T21:45:40.000Z","comments":true,"path":"2018/09/20/how-blockchain-will-accelerate-business-performance-and-power-the-smart-economy/","link":"","permalink":"https://www.yceffort.kr/2018/09/20/how-blockchain-will-accelerate-business-performance-and-power-the-smart-economy/","excerpt":"How Blockchain Will Accelerate Business Performance and Power the Smart Economy 원문 정치경제학자 프란시스 후쿠야마는 사회자본이 물리자본만큼 중요한 미래를 예측했으며, 높은 수준의 사회적 신뢰를 가진 사회만이 새로운 경제에서 경쟁할 수 있는 대규모 조직을 창출할 수 있다고 예측했다. 20년이 지난 지금, 모든 거래의 수준에서 사회적 토대를 확대하는 놀라운 도구가 등장하고 있다. 원래 비트코인이라는 암호화폐 아래 데이터 기술로 명성을 얻은 오늘날 블록체인 기술은 통화","text":"How Blockchain Will Accelerate Business Performance and Power the Smart Economy 원문 정치경제학자 프란시스 후쿠야마는 사회자본이 물리자본만큼 중요한 미래를 예측했으며, 높은 수준의 사회적 신뢰를 가진 사회만이 새로운 경제에서 경쟁할 수 있는 대규모 조직을 창출할 수 있다고 예측했다. 20년이 지난 지금, 모든 거래의 수준에서 사회적 토대를 확대하는 놀라운 도구가 등장하고 있다. 원래 비트코인이라는 암호화폐 아래 데이터 기술로 명성을 얻은 오늘날 블록체인 기술은 통화의 범위를 훨씬 넘어서고, 전 세계의 거래적 사회적 신뢰와 관련된 문제를 해결하고 있다. 블록체인은 기업이 신뢰 경계를 넘어 자산의 소유권을 디지털 방식으로 추적하여 조직 간 협업 및 상상력이 풍부한 새로운 비즈니스 모델을 위한 새로운 기회를 열어 줄 수 있는 암호화적으로 안전한 공유 데이터 계층이다. 공유된 신뢰의 원천으로서 단일 회사에서 공급 업체, 고객 및 파트너와 공유하는 프로세스로 디지털 변환의 범위를 확장할 수 있다. 블록체인은 어떻게 작동할까? ¶진실에 대한 신뢰와 단일 근원을 구축하는 스마트 원장 엑셀 스프레드시트와 같이 당신이 잘 아는 장부를 상상해보라. 블록체인은 스프레드시트와 비슷하지만 몇 가지 중요한 차이점이 있다. 첫째, 변경할 수 없다. 데이터를 대체할 수 없다. 새로운 거래 만이 그 안에 기록 될 수 있다. 둘째, 블록체인 스프레드시트는 암호화로 안전하다. 이는 데이터가 조작되지 않은 높은 수준의 신뢰도를 제공한다. 셋째, 스프레드시트는 여러 당사자간에 공유된다. 마지막으로, 블록 체인 스프레드 시트는 사용자 간의 상호 합의에 의해 스프레드 시트에 배치되는 것을 결정하는 합의 알고리즘이라고하는 메커니즘을 가지고 있다. 이 원장 위에는 많은 블록체인이 ‘스마트 컨트랙트’를 제공한다. 이는 코드 내 비즈니스 프로세스를 표현한 것이다. 조직은 자신의 사업이 어떻게 수행 될지 정의하는 계약에 동의할 수 있으며 참가자가 상호 작용을 입증할 수 있는 기록과 함께, 구현된 내용이 일관되게 실행됩니다. 완전히 자동화된 경우 블록체인은 실행의 일관성을 강화하고, 분쟁 해결을 지원하며, 책임성을 높이고 더 나은 비즈니스 결정을 알릴 수 있는 종단 간 투명성을 제공할 수 있다. ¶Good for Business, Good for Society 아이스크림을 만들고 전 세계 기업에 자사 제품을 판매하는 회사를 상상해보라. 농장에서 공장으로 이동하는 경로는 다양하며 트럭, 보트, 비행기 및 창고 등이 포함될 수 있습니다. 블록체인 구동 솔루션은 공급망 전체의 참가자들과 다른 관점에서 제품에 대한 정보를 포착한다. 블록체인 데이터는 그 제품의 원산지에 대한 진실의 원천이 될 수 있었다. 우유가 나온 소와 바닐라가 공급한 농지까지. 블록 체인은 공급망 참가자, 생산자 및 소비자에게 중요한 증명을 기록할 수 있다. 여기에는 농장이 지속 가능한 관행을 활용하고 공정한 무역 관행에 부합하도록 보장하는 것이 포함된다. 블록 체인에는 스마트 컨트랙트에 포함된 비즈니스 워크 플로우가 포함될 수 있기 때문에 공급망 구성원 간의 계약을 자동으로 정의, 모니터링 및 시행하는 데 사용할 수 있다. 예를 들어, 최종 수령인에게 물품을 배달할 때 스마트 컨트랙트는 자동으로 지불을 유발할 수 있으며 분쟁이 있을 때 계약은 참가자간에 청구가 어떻게 처리되는지 통제할 수 있다. 자동화 된 블록 체인 트리거 및 실행은 2008 년 우유 스캔들, 강제 아동 노동의 사용 중단, 유럽 식량 공급을 독살하기 위한 ISIS의 최근 위협 관리와 같은 경제 거래로 인한 인도 주의적 재앙을 피하는 데 도움이 되었을 수도 있다. ¶IOT 기술과 함께 공급망에 활용 IoT와 Blockchain을 활용하면 공급망 전반에 걸친 준수를 모니터링하고 적용하는 새로운 방법을 제공합니다. 그 아이스크림 회사를 다시 한번 보자: 아이스크림은 고기, 우유, 약과 같은 많은 종류의 제품들 중 하나다. 아이스크림은 저장된 환경에 의해, 소비의 안전성에 영향을 받을 수 있다. 아이스크림은 운송 중에 녹고 재냉동할 수 있으므로 소비자에게 위험에 처해 있다는 명백한 징후를 인지하미 못하고 소비하는 것이 안전하지 않을 수 있다. 이는 아이스크림 회사의 운송 파트너는 재정적 책임을 초래할 수 있으므로 문제를 인식하지 못하거나, 혹은 책임 회피를 위해 아이스크림 회사 또는 고객과 정보를 공유하지 않을 수 있다. 블록 체인 솔루션을 사용하면 센서가 온도 및 습도 정보를 스마트 컨트랙트에 전달할 수 있으므로 공급망 참가자가 동의한 조건에 대해 환경 상태를 모니터링할 수 있다. 온도 또는 습도가 허용 범위 밖으로 떨어지면 스마트 컨트랙트 내에서 규정을 준수하지 않는 것으로 볼 수 있다. 모든 당사자들이 블록체인을 하나의 진실의 원천으로 사용하기로 합의했기 때문에, 아이스크림 회사는 실시간으로 이 사실을 경고할 것이고, 이는 공급망에서 제품을 꺼내 운송 계약 조건을 위반한 적절한 당사자에게 책임을 물을 수 있게 한다. 블록체인과 결합된 IoT 센서는 제약 산업이 주요 공공 안전 문제인 위약을 다루는 데 도움이 될 수 있다. 위약은 업계에 연간 약 2,000 억 달러의 비용이 소요되는 것으로 추정된다. 개발 도상국의 약제 중 3 분의 1은 위약이며 30%는 실제 약효가 없다. 그래서 3M과 같은 회사들은 질적으로 낮은 수준의 건강 문제 및 공공 문제를 해결하기 위해 공급망을 탐지하고 방지할 수 있는 블록체인 방식의 솔루션을 도입하고 있다. ¶디지털 세계에 힘을 실어주고 신뢰할 수 있는 블록체인 기술의 진정한 힘은 조직 전체에 걸쳐 많은 속성이 통합될 때 가장 잘 활용된다. 이 시나리오를 생각해보자. 시애틀에 기반을 둔 인기 있는 공유 서비스의 운전자 John은 훌륭한 운전자이며 고객과 함께 뛰어난 명성을 얻고 있다. John은 고급 자동차를 사서 더 높은 서비스 계층을 제공하고 싶지만 자금은 제한적이다. 운전면허증, 대출, 보험증이 필요할 것이다. 오늘날 자동차 제조업체, 은행, 보험 회사 및 정부 기관은 모두 디지털 기능과 서비스를 병행하여 진화하고 있다. 그들이 벽 너머의 기회에 눈을 돌리고 스마트 경제에 힘을 실어줄 수 있는 방법에 초점을 맞추면 어떻게 될까? ‘스마트 이코노미’ 접근법을 통해 밀레니엄 세대가 자동차를 적게 구입하고 있다는 사실을 인식한 자동차 제조업체들은 자동차 판매 및 임대를 위한 대체 모델을 모색하기 시작한다. 그들은 자격을 갖춘 운전자를 위한 대출을 인수하기 위해, 차량 공유 서비스와 사업을 하기 위한 스마트 컨트랙트를 만듭니다. John은 그 스마트 컨트랙트 이용해서 자동차 제조업체로부터 차를 임대하는 것을 신청한다. 응용 프로그램 프로세스에 대한 스마트 컨트랙트는 여러 아래와 같은 평판 소스를 사용합니다. 정부는 John의 신원을 증명한다 교통부는 현재 이 유형의 차량을 운전할 수 있는 면허가 있음을 증명한다. 차량 공유 서비스는 그의 운전 평판 (승차감, 운전빈도, 가치) 등을 증명한다. 은행은 John의 재산과 지불능력을 증명한다. 자동차 제조업체는 차량 서비스 기록과 부품의 출처를 증명한다. 그런 다음 알고리즘이 이 데이터에 적용되고 John에게 어떤 유형의 제안을 해야하는지에 대한 결정이 내려진다. 낮은 점수가 책정된다면, John은 합리적인 요금으로 자동화되고 스마트 컨트랙트 기반 프로세스를 사용하여 임대 계약을 제공할 수 있다. 좋은 점수가 나온다면, John은 제조업체 또는 대출 서비스 회사에 직접 운임의 일정 비율을 할당한 대출 조건으로 무료로 차를 제공할 수 있다. 좀 더 좋은 점수가 나온다면, John은 연료 및 통행료의 적용 범위뿐만 아니라 무료로 자동차를 제공 받게 되며,이 모든 요금은 요금의 일정 비율로 지불된다. John은 또한 그의 새 차에 대한 보험이 필요할 것이다. 보험 회사는 차량 서비스 기록, John의 고용 세부 사항 및 John의 운전 기록에 액세스하여 차량에 대한 맞춤형 보험 견적을 생성할 수 있다. 통행료 및 임대 지불과 마찬가지로 스마트 컨트랙트를 활용하여, 승차 요금의 수익금을 자동차 제조업체에 지불과 연동될 수 있다. 공공 안전 관점에서 볼 때, 정부 규제 기관과 자동차 서비스 라이더는 자신의 승차가 안전할 것이라고 확신할 수 있다. 존이 범죄 배경 조사를 통과했고, 유효한 면허를 가지고 있으며, 지역 사회에서 운전한 이력이 있으며, 법으로 허용되는 것보다 더 많은 시간을 운전하지 않았으며, 운전자로서의 긍정적인 명성을 가지고 있음을 보여주는 증명과 투명성을 얻을 수 있다. 그들은 또한 존이 운전하는 차가 안전하다는 것을 믿을 수 있다. 정부는 또한 차량 공유 서비스에서 블록 체인의 동기화된 사본을 가지고 있어 준수를 보장하고 집행 비용을 줄이기 위해 실시간 감사를 제공할 수 있다. ¶경계가 없어진다. 블록체인에 수십억 달러가 투자되고 있으며, 지구상에서 가장 똑똑한 사람들 중 일부는 이 기술이 어떻게 조직과 산업을 재창조할 수 있는지 이해하는 데 종사하고 있다. 블록체인의 잠재적 영향은 기업들이 기존 비즈니스 모델을 재고하고, 이전에 실행 불가능하다고 생각했던 기회를 재검토하고, 수익에 영향을 미치고 사회에 도움이 될 수 있는 새로운 기회의 경계를 탐구하도록 유도하고 있다. 혁신적인 디지털 신뢰 플랫폼을 기반으로 구축된 새로운 스마트 글로벌 경제가 구축되고 있다. 이 기술은 더이상 변두리에 머물러 있지 않으며, 새로운 방향과 가능성이 있는 기회는 무한하다. 점진적 변화를 활성화하고 이를 실현하기 위해서는 성장을 위한 마인드셋과 사명 중심의 접근 방식이 필요하다. 재창조의 민첩성을 지닌 조직, 즉 상업적으로 실행 가능한 속도로 새로운 비즈니스 기회를 열어주는 소음을 뛰어넘는 조직은 디지털 시대에 번창할 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"리플 컨센서스 알고리즘","slug":"the-XRP-ledger-consensus-process","date":"2018-09-19T15:00:00.000Z","updated":"2018-09-19T21:45:40.000Z","comments":true,"path":"2018/09/20/the-XRP-ledger-consensus-process/","link":"","permalink":"https://www.yceffort.kr/2018/09/20/the-XRP-ledger-consensus-process/","excerpt":"The XRP Ledger Consensus Process 원문 ¶소개 P2P XRP 원장 네트워크는 응용프로그램에 콘텐츠의 상태에 대한 정보를 저장하고 있는 공유 원장을 전세계적으로 저장한다. 이러한 상태 정보에는 아래와 같은 정보가 포함되어 있다. * 각 계정의 설정정보 * 계정 간 잔고 * 분산 거래 * 네트워크 설정. 예) 거래 비용, 유보 금액 등 * 타임스탬프 원장에 대한 전체적인 기술 설명은 여기에서 확인할 수 있다. XRP 원장은 몇 초마다 새로운 버전을 갖게 된다. 그 이전의 원장버전은 원장의","text":"The XRP Ledger Consensus Process 원문 ¶소개 P2P XRP 원장 네트워크는 응용프로그램에 콘텐츠의 상태에 대한 정보를 저장하고 있는 공유 원장을 전세계적으로 저장한다. 이러한 상태 정보에는 아래와 같은 정보가 포함되어 있다. 각 계정의 설정정보 계정 간 잔고 분산 거래 네트워크 설정. 예) 거래 비용, 유보 금액 등 타임스탬프 원장에 대한 전체적인 기술 설명은 여기에서 확인할 수 있다. XRP 원장은 몇 초마다 새로운 버전을 갖게 된다. 그 이전의 원장버전은 원장의 기록으로 남게된다. 가장 최근에 검증된 원장 조차도 짧은 시간전의 네트워크 상태를 나타내기 때문에 이력의 일부로 남게 된다. 현재 네트워크는 다음 원장버전에서 적영되고 완료 될 수 있는 일부 거래를 검증하게 된다. 원장 인스턴스는, 원장 인덱스라고도 불리는 시퀀스 번호로 (원장 인스턴스는 컨텐츠의 디지털 지문인 해시에 의해 고유하게 식별될 수 있다.) 식별될 수 있다. 원장은 번호 순으로 증가하게 된다. 마지막으로 유효한 원장이 N이면, 이전은 N-1, 그 다음은 N+1이다. N+1원장은 원장 N에 일련의 트랜잭션을 적용하여 생성된다. 원장이 사용자 수준에서 변경된다는 것은 트랜잭션의 결과로 이루어진다. 이 트랜잭션의 예로는 지불, 계정 설정, 거래 제안 등이 있다. 각 트랜잭션은 원장 변경을 승인하고, 계정 소유자가 암호화하여 서명한다. 트랜잭션은 계정 변경을 승인하는 유일한 방법이다. 또한 원장 인스턴스에는 해당 트랜잭션에 대한 일련의 트랜잭션 및 메타 데이터가 포함되어 있다. 트랜잭션은 이전 원장에 적용되어 새 인스턴스를 만든 트랜잭션이다. 메타데이터는 트랜잭션이 원장에 미치는 영향을 정확하게 기록한다. 원장 인스턴스에 포함된 트랜잭션 세트 (위 그림에서 여러개의 네모, 트랜잭션)는 해당 원장에 기록되며, XRP Ledger 이력에서 확인 될 수 있다. 검증된 원장에 나타나는 트랜잭션이 원장을 변경하는데 성공했거나, 요청된 작업을 수행하지 않고 처리되었을 수도 있다. 성공적인 트랜잭션에는 요청된 변경사항이 원장에 적용되고, 수수료가 청구되었음을 나타내는 tesSUCCESS 결과 코드를 가지고 있다. 원장의 다른 트랜잭션에는 tec 클래스 결과 코드가 있다. 이 코드는 수수료를 청구하고, 다른 변경사항을 수행하지 않는 트랜잭션을 나타낸다. tec 클래스의 트랜잭션은 수수료를 청구할때, 계정잔액을 변경하기 때문에 원장에 포함된다. tes 및 tec 클래스 결과 코드 외에도, ter, tef, tem 클래스 코드가 있다. 후자 3가지는 API에 호출에 의해 반환되는 잠정적인 실패를 나타난다. 원장에는 test와 tec 코드만 남게 된다. 리플 API로 작업할때, 어플리케이션은 반드시 원장에 포함되도록 제안된 후보 트랜잭션과 검증된 원장에 포함된 검증된 트랜잭션을 구분해야 한다. 검증된 원장에서 발견된 트랜잭션 결과만 변경이 불가능하다. 후보 트랜잭션은 검증된 원장에 포함될 수 있거나, 포함되지 않을 수도 있다. 중요: 일부 리플 API는 후보 트랜잭션을 기반으로 잠정적인 결과를 제공한다. 어플리케이션은 트랜잭션의 최종결과를 결정하기 위해 이러한 잠정적인 결과에 의존해서는 안된다. 트랜잭션이 마침내 완전하게 성공했다는 것을 확실하게 알 수 있는 유일한 방법은 유효성있는 원장에 포함될때까지 트랜잭션 상태를 확인하고 결과코드 tesSUCCESS를 갖는 것이다. 트랜잭션이 다른 결과 코드가 있는 유효한 원장에 있으면, 해당 트랜잭션은 실패한 것이다. 트랜잭션의 마지막 원장 시퀀스에 지정된 원장이 유효성 검증을 받았지만, 거래가 원장 또는 그 원장 이전에 나타나지 않는다면, 해당 트랜잭션은 실패하여 어떠한 원장에도 나타나지 않을 것이다. 검증된 원장에 나타나거나 나중에 라스트 원장 시퀀스 제한으로 인해 표시될 수 없는 트랜잭션에서만 최종결과로 볼수 있다. (하단 참조) ¶XRP 원장 프로토콜의 컨센서스와 검증 P2P XRP 원장 네트워크는 트랜잭션을 수용하고 처리하는 '노드’라고 불리우는 많은 분산 서버로 구성된다. 클라이언트 어플리케이션은 트랜잭션에 서명하고 전송하는 처리를 위해, 네트워크 전체에서 이러한 서명된 후보 트랜잭션을 릴레이한다. 클라이언트 어플리케이션의 예로는 모바일/웹 지갑, 금융기관의 게이트웨이 및 전자 거래 플랫폼이 있다. 트랜잭션을 수신, 릴레이 및 처리하는 노드는 노드를 추적하거나 노드를 검증할 수 있다. 노드의 주요기능을 추적하는 것에는 클라이언트로부터 트랜잭션을 배포하고, 원장에 대한 쿼리에 응답하는 것도 포함된다. 검증 노드는 노드 추적과 동일한 기능을 수행하고, 원장 시퀀스를 발전시키는 데 추가로 기여하게 된다. 클라이언트 어플리케이션에서 제출한 트랜잭션을 수락하는 동안, 각 추적노드는 마지막으로 검사된 원장을 시발점으로 사용한다. 승인된 거래는 각각 후보로 남게 된다. 노드는 이러한 후보 트랜잭션을 피어에게 릴레이하여, 후보 트랜잭션이 모든 네트워크 전체에 전파되도록 한다. 이상적으로 각 후보 트랜잭션은 모든 노드에게 전파되며, 각 노드는 동일한 트랜잭션 세트가 마지막으로 검사된 원장에 적용될 수 있다고 간주할 수 있다. 그러나 트랜잭션이 전파되는데에는 시간이 꽤 소모되기 때문에 노드는 항상 동일한 후보트랜잭션 세트로 작동하지 않는다. 이를 설명하기 위해 XRP 원장은 컨센서스라고 하는 프로세스를 활용, 동일하나 트랜잭션이 처리되고 검증된 원장이 P2P XRP 원장 네트워크에서 일관성을 유지하도록 한다. ¶Consensus 네트워크 노드는 후보 트랜잭션에 대한 정보를 공유한다. 합의 프로세스를 통해, 검증 노드는 후보거래의 특정 합위 집합에 대해 다음 원장에 대해 고려하도록 동의 한다. 이러한 합의는 노드가 제안 또는 후보 트랜잭션 세트를 중계하는 반복적인 프로세스다. 노드는 대다수의 피어가 동일한 후보 트랜잭션 세트에 동의할때까지 계속해서 업데이트 한다. 컨센서스 과정에서 각 노드는 선택된 검증자라고 불리는 특정 피어세트의 컨센서스 제안을 평가한다. 선택된 검증자들은 이러한 컨센서스 제안 들에 대해 사기를 방지하고, 신뢰를 얻기 위해 평가하게 된다. 여기서 말하는 '신뢰’의 의미는 각 개별 검증자를 신뢰할 필요가 없다는 것이다. 오히려, 검증자는 네트워크에 중계된 데이터를 위조하기 위한 노력을 하지 않을 것이라는 기대에 따라 선택된다. 합의가 시작될때 노드는 서로 다른 트랜잭션 세트로 작동한다. 수많은 제안이 원장에 적용할 거래와 향후 컨센서스를 기다려야 할 거래를 결정한다. 합의된 제안에 포함되지 못한 후보들은 후보로 남게 된다. 이들은 다음 합의에서 고려 될 수 있다. 노드는 합의된 트랜잭션 세트 (녹색)를 마지막으로 유효성있는 원장에 적용한다. 세트에 없는 거래 (빨간색) 은 다음 라운드에서 합의 될 수 있다. 일반적으로, 컨센서스를 통과하지 못한 거래는 다음 라운드에서 성공한다. 그러나 어떤 상황에서는 거래가 무기한 컨센서스를 통과하지 못할 수도 있다. 이러한 상황은, 네트워크가 기본수수료를 트랜잭션이 제공하는 것보다 높은 값으로 증가시키는 경우다. 향후 수수료가 낮아지면 거래가 성공할 수 있다. 마지막 원장 시퀀스(LastLedgerSequence) 트랜잭션 필드는 합리적인 시간내에 실행되지 않으면, 이러한 트랜잭션을 만료시키는 매커니즘이다. 어플리케이션은 각 트랜잭션에 이 매개변수를 포함시켜야 한다. 이렇게 하면 트랜잭션이 지정된 원장 시퀀스 번호, 또는 그 이전에 성공하거나 실패하게 되므로 최종 트랜잭션 결과를 얻기 전에 응용 프로그램이 기다려야 하는 시간이 제한된다. 자세한 내용은 [여기](Reliable Transaction Submission)를 참조. ¶검증 합의 라운드가 완료 되면 각 노드는 최종 유효성있는 원장에 합의된 트랜잭션 세트에, 후보 트랜잭션을 적용하여 새로운 원장을 만들어 낸다. 각 추적 노드는 마지막으로 유효한 원장에 동의한 트랜잭션을 적용한다. 노드를 확인하면 전체 네트워크에 결과를 보낸다. 검증 노드는 원장의 새버전을 만들어내고, 그 결과를 네트워크에 릴레이하며, 각 합의 중에 제안된 후보 트랜잭션을 기반으로 계산된 원장의 서명된 해시를 보낸다. 검증이라고 하는 이러한 서명 된 해시는 각 노드가 계산한 원장을 피어 원장과 비교할 수 있도록 한다. 노드는 계산된 원장을, 선택한 검증 노드에서 수신한 해시와 비교한다. 동의하지 않으면 노드가 올바른 원장을 다시 계산하거나 검색해야 한다. 네트워크의 노드는 피어의 대다수가 동일한 검증 해시에 서명하고 브로드 캐스트 될때, 유효성이 확인 된 것으로 잉ㄴ식한다. 앞으로 트랜잭션은 시퀀스 번호 N+1이 업데이트되고 현재 유요한 원장에 적용된다. 소수에 속하는 노드가 피어와 다른 원장을 계산한 경우에는, 노드는 계산된 원장을 무시한다. 올바른 원장을 다시 계산하거나, 필요에 따라서는 올바른 원장을 검색한다. 네트워크가 유효성 검사에 대한 초 대다수 합의를 달성하지 못한다는 것은, 거래량이 너무 많거나 컨센서스 프로세스가 일관된 제안을 하기에는 네트워크 대기 시간이 너무 컸다는 것을 의미한다. 이 경우 노드는 컨센서스 프로토콜을 반복한다. 컨센서스가 시작된 이래로 시간이 지남에 따라, 각 컨센서스 라운드가 의견차이를 줄임에 따라 대다수의 노드가 동일한 후보트랜잭션을 받을 가능성이 커진다. XRP 원장은 이러한 조건에 대한 응답으로 거래비용과 컨센서스를 기다리는 시간을 동적으로 조정한다. 결국 컨센서스 프로세스의 마지막라운드에는, 노드가 검증된 노드로 업데이트 하게 된다. 검증에 대한 초 대다수 합의에 도달하게 되면, 노드는 새로운 검증된 원장인 시퀀스 번호 N+1과 동작하게 된다. 컨센서스 및 검증 프로세스는 지난 라운드에 포함 되지 않은 후보 트랜잭션과, 그동안 제출된 새로운 거래를 고려하여 반복한다. ¶요약 XRP 원장에 제출된 트랜잭션은 즉시 처리되지 않는다. 일정기간 각 거래는 후보로 남아있게 된다. 단일 트랜잭션의 라이프 사이클은 아래와 같다. 계정 소유자가 트랜잭션을 작성하고 서명한다. 트랜잭션이 네트워크에 제출된다. 잘못 생성된 거래는 즉시 거부 될 수 있다. 올바르게 생성된 거래는 임시적으로 성공할 수도 있고, 나중에 실패할 수 있다. 올바르게 생성된 거래는 임시적으로 실패할 수도 있고, 나중에 성공할 수 있다. 컨센서스 과정 중에, 각 거래는 원장에 포함된다. 성공적인 컨센서스 라운드의 결과로 검증된 원장이 나오게 된다. 컨센서스 라운드가 실패하게 되면 컨센서스 프로세스가 성공할 때까지 반복한다. 검증된 원장에는 트랜잭션과 원장 상태에 미치는 것들이 포함된다. 어플리케이션은 잠정 결과가 아닌 유효성 있는 원장의 정보에만 의존해야 한다. 일부 리플 API는 잠정적인 (임시) 결과를 반환한다. 이 트랜잭션의 결과는 해당 트랜잭션이 검증된 원장에 포함되거나, 트랜잭션에 마지막 원장 시퀀스 (Last Ledger Sequence)가 포함되며, 해당 시퀀스 번호 이하에서 검증된 원장에 나타나지 않을때만 변경할 수 없게 된다. 트랜잭션을 제출하는 어플리케이션의 모범사례는 아래와 같다. LastLedgerSequnce 매개변수를 활용하여 트랜잭션이 결정적이고, 신속한 방식으로 검증 또는 실패하는지 확인한다. 검증된 원장에서 트랜잭션 결과를 확인한다. 트랜잭션을 포함하는 원장이 검증되거나, LastLedgerSequnce에 통과되기 전까지의 결과는 잠정적 (임시) 이다. 결과코드 tesSUCCESS 및 validated: true 외의 결과는 모두 영구적으로 실패를 의미한다. 트랜잭션 LastLedgerSequence에서 확인한 검증된 원장까지, 검증된 원장에서 나타나지 않는 트랜잭션은 영구적으로 실패를 의미한다. 이 경우를 탐지하기 위해 연속성있는 원장 이력을 보유한 노드를 활용해야 한다. LastLedgerSequence에서 확인한 원장이 유효성을 검사할 때까지 반복적으로 트랜잭션 상태를 확인해야할 수도 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"},{"name":"ripple","slug":"ripple","permalink":"https://www.yceffort.kr/tags/ripple/"}]},{"title":"PoA(권한 증명)은 어떻게 작동하는가?","slug":"how-does-proof-of-authority-consensus-work","date":"2018-09-18T15:00:00.000Z","updated":"2018-09-18T21:45:40.000Z","comments":true,"path":"2018/09/19/how-does-proof-of-authority-consensus-work/","link":"","permalink":"https://www.yceffort.kr/2018/09/19/how-does-proof-of-authority-consensus-work/","excerpt":"How Does Proof of Authority Consensus Work? 원문 권한증명(이하 PoA)는 지난 2017년 3월 이더리움 프로토콜을 기반으로 한 블록체인에 제안되었다. 이는 원래 이더리움의 Ropsten 테스트 네트워크에 대한 스팸공격을 해결하기 위한 해결책으로 개발되었었다. 이 새로운 네트워크는 Kovan으로 명명되어 오늘나라 모든 이더리움 사용자가 사용할 수 있는 기본 테스트 네트워크로 자리잡았다. PoA합의는 기본적으로 지분 증명 모델에서 실제 지분을 보유하는 방법대신, 검증자의 신원(Identity)을","text":"How Does Proof of Authority Consensus Work? 원문 권한증명(이하 PoA)는 지난 2017년 3월 이더리움 프로토콜을 기반으로 한 블록체인에 제안되었다. 이는 원래 이더리움의 Ropsten 테스트 네트워크에 대한 스팸공격을 해결하기 위한 해결책으로 개발되었었다. 이 새로운 네트워크는 Kovan으로 명명되어 오늘나라 모든 이더리움 사용자가 사용할 수 있는 기본 테스트 네트워크로 자리잡았다. PoA합의는 기본적으로 지분 증명 모델에서 실제 지분을 보유하는 방법대신, 검증자의 신원(Identity)을 지분처럼 활용하는 모델이다. 이 신원은 각 네트워크 내의 트랜잭션 및 블록을 검증하기 위해, 사전 승인된 유효성 검증자 그룹(검증자)에 의해 확인된다. 검증자 그룹은 네트워크의 효율성과 관리 가능한 보안을 보장하기 위해 일반적으로 상당히 작은 크기 (25이하)를 유지해야 한다. PoA 네트워크의 주요 특징은, 요구되는 연산 능력이 상대적으로 낮고, 합의에 도달하기 위한 노드간의 통신 요구 사항이 없으며, 네트워크의 연속성은 공개 도메인에서 교차 검증을 통해 사전 승인되고 검증가능하게 신뢰할 수 있기 때문에 사용가능한 노드의 수와 독립적이라는 것이다. PoA는 알고리즘을 해결하기 위해 전력을 소비해야 하는 PoW모델 보다 덜 계산 집약적이도록 설계되었다. 또한 PoA는 PoS모델 내에서 두 당사자간의 지분이 동일할 수도 있지만, 각각의 가치는 보유 지분에 따라 달라질 수 있다는 우려를 없앴다. 예를 들어 엘리스는 1000개의 xyz토큰을 가지고 있고, bob도 1000개의 xyz 토큰을 가지고 있다고 가정해보자. 그러나 이들의 실제 재산에 차이가 있다면, 실제 자신의 자산이 더 작은 쪽이 해당 xyz 네트워크의 성공에 투자할 가능성이 크다. 그다지 적절한 예 &amp; 표현은 아니었던 것 같다. 검증자 (validator)가 되기 위해서는 기본적으로 아래와 같은 3가지 요구 사항이 있다. 이들의 신원은 공개 도메인 (예: 공증 데이터베이스)에서 사용할 수 있는 신뢰할 수 있는 데이터를 통해, 신원을 상호 참조 할 수 있는 기능이 있는 상태에서 신원을 공식적으로 식별이 가능해야 한다. 검증자가 될 수 있는 자격은, 장기적으로 검증자가 재정적,평판적으로 정직한 검증자로 남아있기 위한 분명한 동기로 작동하기 위하여, 어려워야 한다. 검증자를 설정하는 프로세스는 일정해야 한다. 위의 요구사항을 약간씩 변형한 몇가지 플랫폼이 있다. 이 플랫폼들은, 결과적으로 검증자들이 장기적으로 네트워크의 일부로 남아 있으며, 부정직하게 행동되는 것이 도움이 되지 않도록 하는 데에 중점을 두고 있다. 악의적으로 행동하는 검증자는 검증 프로세스 상에서 쉽게 제거하고 교체할 수 있어야 한다. 검증자의 최종 결과는 미래의 재정적인 수입 손실 뿐만 아니라, 명성에 대해서도 손실이 있을 것이다. 인터넷 소셜미디어의 현재 환경에서, 우리는 사람들이 논평이나 발언을 제대로 하지 못함으로써 대중의 비난을 통해 명성을 잃는 것이 얼마나 쉬운지 반복적으로 지켜보았다. 공공영역에서 평판의 취약성에 대한 인식이 높아 짐에 따라, 검증자가 시스템 내에서 정직하게 행동할 수 있는 이러한 평판이 강력한 인센티브가 되어야 한다. 동시에, PoA는 주로 프라이빗 블록체인에 가장 효과적으로 보인다. 예를 들어, 각 은행이 자체 검증자 역할을 하는 검증 가능한 은행 네트워크를 들 수 있다. 블록체인의 상태를 확인 하기 위해서는 대다수가 필요하며, 프로세스 상에서의 상당한 영향력, 개인정보보호, 권한 등을 포기하지 않고도 거래 검증과 합의에서 향상된 효율성을 유지할 수 있다. ¶현재 구현된 PoA 앞서 언급되었뜻이, PoA는 현재 이더리움의 Kovan 테스트 넷에서 사용중이다. 또한 여러 유명 플랫폼에서 사용되며, 현재 시점에서는 프라이빗 블록체인 네트워크를 구현하려는 여러 기관에게 가장 그럴듯한 합의 매커니즘으로 보인다. Autority Network (POA Network)에서 증명은 블록체인에서 PoA합의를 구현하는 원칙에 기반한 플랫폼이다. PoA 네트워크는 스마트 컨트랙트를 위한 공개 플랫폼으로, 독립적인 검증자로 구성된 노드가 있는 이더리움의 사이드 체인이다. 누구나 쉽게 확인할 수 있고, 온체인 확인과 상호 참조가 가능하므로 공공 데이터베이스 검증자를 자격 검증 메커니즘으로 사용한다. 본질적으로, 검증자들은 2단계를 통해서 공식적으로 신원을 확인한다. 클라이언트 측 PoA 네트워크 Dapp 과 공증인 시스템. 또다른 예로는 VeChainThor 블록체인 네트워크가 있다. 이 네트워크는 주로 공급망 및 물류 영역에서 정보 및 추적의 투명한 흐름 공개를 위한 엔터프라이즈 수준의 공개 블록체인에 중점을 둔다. VeChain은 자체 독점 검증 프로세스를 통해 유효성 검증 노드를 선택하고 네트워크에서 PoA 컨센서스를 사용하여 거래 및 블록 체인 상태를 확인하는 효율을 활용으로써 해당 노드에 이점을 제공한다. 만약 Vechain이 PoS 또는 PoW에 합의 모델을 의존한다면 Bitcoin 및 PoS 플랫폼과 같은 PoW 암호 화폐가 겪고 있으며 극복해야 하는 확장성 솔루션을 연구, 최적화 및 적절하게 구현해야하므로 플랫폼 출시가 크게 지연 될 수 있다. 이미 공급망 산업에 종사하고 있는 회사가 네트워크 내에서 유효성 검사자가 되도록 허용하면 프라이빗 블록 체인 네트워크에서 쉽게 달성할 수 있는 네트워크 보안을 만드는 데 도움이 되는 집단으로 조정할 수 있다. PoA 컨센서스의 최적화 된 버전의 다른 구현에는 Hyperledger 및 Ripple 등도 있다. Hyperledger Fabric의 합의는 실용적인 비잔틴 결함 허용에 근거하지만, 컨소시엄 블록 체인을 위한 open-source umbrella framework 의 일부로 PoA 컨센서스를 사용한다. 리플은 PoA 합의의 반복적 형식을 사용하고 있다. 자세한 정보 ¶PoA의 장점과 우려 PoA 합의가 일부 퍼블릭 블록 체인에서 구현되었지만, 그들은 여전히 Bitcoin과 Ethereum이 열망하는 진정한 의미의 분산화 부족하다. 여기서 의미는 PoA 합의 플랫폼이 실제로 완전히 분산되어 있다고 주장하는 것이 아니라, 탈중앙화와 중앙 집중화로 인한 효율성 사이의 절충안을 의미한다. 한편으로 PoA 모델에 대한 몇 가지 우려 중 하나는, 다소 분산되어 있지만 여전히 중앙 집중식 시스템의 효율적인 버전이라는 것이다. 이는 프라이빗 블록체인, 심지어 일부 퍼블릭 블록체인의 이상적인 특성에 대한 회의론으로 보인다. 사설 블록체인으로서 은행이 PoA 합의 네트워크를 사용한다고 가정해보자. 거래 또는 네트워크를 사용하는 특정 업체의 검열 및 블랙리스트 지정은 대부분의 검증자(은행)의 큰 관심사가 될 수 있으며, 이 시점에서부터 블록체인을 불변의 원장형태로 사용한다는 아이디어가 쓸모없게 된다. 즉, 과연 모두가 공평하게 분산원장을 가짐으로서 블록체인으로서의 의미가 있는데, 일부 검증자들에게 그 권한을 주는 것이 블록체인의 기본적인 사상에 옳은가 하는 궁극적인 질문이다. 약간 이상해보이는 또 다른 우려도 있다. 어떤 사람들은 단순히 자신의 평판에 신경 쓰지 않는다는 사실이다. 이와 비슷하게, 그들의 명성을 망치는 것에 대한 보상은, 그것이 네트워크 내에서 그들의 행동의 직접적인 파생물이든 제3자가 부정한 행동을 하도록 획득한 재정적 인센티브이든 간에, 단순히 비용보다 더 크다는 것이다. 이는 노드 수에 제한이 있는 검증자의 모델에 내재된 문제이며, 제3자의 외부 영향력에 노출된게 된다. 평판, 명성 다 까고 그냥 한탕 하기 위해서 오작동하는 검증자는 어떻게 할 것인가? PoA 컨센서스 네트워크의 장점은 상당히 분명하다. 트랜잭션 시간 및 전체 네트워크 컨센서스의 효율성 향상. PoA 컨센서스를 사용하는 이러한 모델은 분산된 응용 프로그램에서도 훨씬 효과적이며 분산된 네트워크에 비해 쉽게 확장할 수 있다. 또한 관련 기술의 혁신은 검증자가 서로 독립적이며 제 3 자 개입에 취약한 네트워크를 더욱 안전하게 유지하는 데 도움이 될 수 있다. 예를 들어, Intel의 SGX 보안 컴퓨팅 기술은 노드에서 실행되는 검증자 소프트웨어를 외부 간섭으로부터 보호하는 데 도움이 되는 방법으로 채택되었다. ¶결론 Ropsten 테스트 네트워크의 내재적 문제를 극복하기 위해 고안된 합의 모델에서 스마트 컨트랙트, 사이드 체인 및 글로벌 공급망 추적의 거대한 산업에 초점을 맞춘 퍼블릭 블록체인의 공식 검증 방법에 이르기까지 Proof of Authority 합의는 다양한 합의 메커니즘을 테스트하고 구현하는 데있어 중요한 발전이다. PoA 합의가 궁극적으로 프라이빗 블록 체인에서 주로 사용되거나 공공 및 분산 네트워크의 중요한 사이드 체인으로 사용 될 수 있는지 여부는 아직 알려지지 않았습니다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"더 좋은 지구를 만들기 위한 블록체인","slug":"building-blockchain-for-better-planet","date":"2018-09-17T15:00:00.000Z","updated":"2018-09-17T21:45:40.000Z","comments":true,"path":"2018/09/18/building-blockchain-for-better-planet/","link":"","permalink":"https://www.yceffort.kr/2018/09/18/building-blockchain-for-better-planet/","excerpt":"Building Block(chain)s for a Better Planet 원문 블록체인은 인간의 거래 방식을 변화시킬 수 있는 잠재력이 있었기 때문에, 비즈니스, 정부, 사회가 운영되는 방식을 재정의 할 수 있었다. 하지만 여전히 극복해야할 많은 도전을 가지고 있는 초기 기술이다. 이 기술이 성숙하고 더 넓은 분야에 적용됨에 따라서, 금융이나 산업 뿐만 아니라 인류와 지구를 위한 블록체인의 잠재력을 실현할 수 있는 도전과 기회가 있다. 이 보고서에는 블록체인이 환경자원을 관리하는 방식에서의 파괴적인 혁신과, 지속가능한 성장","text":"Building Block(chain)s for a Better Planet 원문 블록체인은 인간의 거래 방식을 변화시킬 수 있는 잠재력이 있었기 때문에, 비즈니스, 정부, 사회가 운영되는 방식을 재정의 할 수 있었다. 하지만 여전히 극복해야할 많은 도전을 가지고 있는 초기 기술이다. 이 기술이 성숙하고 더 넓은 분야에 적용됨에 따라서, 금융이나 산업 뿐만 아니라 인류와 지구를 위한 블록체인의 잠재력을 실현할 수 있는 도전과 기회가 있다. 이 보고서에는 블록체인이 환경자원을 관리하는 방식에서의 파괴적인 혁신과, 지속가능한 성장과 가치 창출을 촉진할 수 있는지 설명한다. 이 기술은 블록체인이 세계에서 가장 위급한 환경 시스템 과제에 적용될 수 있는 65개이 상의 사용사례를 설명하며, 이 기술이 근본적으로 현재 시스템과 접근 방식을 개선할 수 있는 8개의 '게임체인저’를 밝힌다. 지금까지 이러한 기회는 개발자, 투자자 및 정부에 의해 미개발된 상태이지만, 현재 환경 시스템 내에 내장되어 있는 가치를 얻고, 수익을 창출 할 수 있는 기회를 만들어 낸다. 이 보고서는 또한 해결해야할 현재 많은 문제를 강조하고, 환경을 위한 블록 체인 응용 프로그램을 개발하기 위한 일련의 원칙을 설명하며, 책임있는 블록 체인 생태계를 배양하기 위한 글로벌 플랫폼의 필요성을 확인한다. ¶현재 지구가 직면하고 있는 문제 기후변화 생물 다양성의 보존 건강한 바다 수자원 확보 깨끗한 공기 날씨와 재난에 대한 탄력성 ¶블록체인 개발의 역사 ¶현재 직면한 도전과제에 대한 블록체인 활용 가능성 ¶블록체인이 당면한 과제 ¶지구가 블록체인을 감당할 수 있을까? 블록체인 응용 프로그램의 중요한 과제는 에너지 사용에 관한 문제다. 현재 블록체인 중 가장 널리 사용되고 있는 응용 프로그램인 암호화폐 비판의 초점이기도 하다. 설계상, 암호 화폐는 작업 증명 프로토콜을 사용하여 채굴하고 있는데, 이는 매우 에너지 집약적이다. 더 많은 마이너들이 가격 성장세를 보이는 비트코인으로 이익을 얻기 위해 네트워크에 진입함에 따라 작업증명의 난이도는 증가한다. 이 난이도는 4년마다 증가하며, 또한 채굴할 수 있는 비트코인 수에 대한 제한이 있어 마이너간의 경쟁은 더욱 촉진되고 있다. 이러한 어려움과 경쟁이 촉발하면서 마이너들은 더 강력하고 에너지를 많이 소비하는 컴퓨터와 데이터 센터를 필요로 한다. 이러한 방정식은 암호 화폐의 잠재력을 제한 할 수 있다. 암호 화폐를 넘어 블록체인에는 많은 응용 프로그램이 있으며, 이더리움, Neo, Cardana등은 덜 에너지 집약적인 ‘지분 증명’ 프로토콜에서 작동한다. 이더리움의 경우 비트코인 거래 보다 에너지 소비량이 12~14배가 더 적다. 혹은 단순화되고 더접근 하기 쉬운 증명인 ‘중요성 증명 (Proof of Importance)’ 프로토콜을 개발하고 있다. 그외에도, Proof of Authority (PoA), Proof of Space (PoS) 등 다양한 알고리즘이 개발 중이다. 그러나 블록체인의 전반적인 에너지 시스템에 대한 광범위한 영향을 이해하는 것은 더 복잡하며, 블록체인 솔루션과 기존 방법의 상대적 에너지 영향을 고려하는 시스템 전반의 관점을 채택하는 것이 중요하다. 예를 들어, 에너지 관리는 블록체인의 상대적 에너지 절약 편익이 시스템 에너지 사용량보다 클 수 있는 영역이다. 블록체인 솔루션은 또한 재생 에너지와 에너지 효율의 흡수를 장려하기 위해 개발되고 있다. 이러한 솔루션의 확장은 올바른 &quot;활성화 환경&quot;에 의해 지원될 경우 에너지 시스템의 전반적인 탈세화와 온실가스 배출을 줄이기 위한 전세계 노력을 지원하고 잠재적으로 가속화할 수 있다. 여기의 예로는 기업, 정부 및 개인이 생산하거나 구매하는 재생 에너지의 근원 증거를 제공하는 이니셔티브, 재생 에너지 생성 또는 소싱에 대한 비트코인 광부들에게 보상하는 재생 에너지 코인이 포함될 수 있다. ¶지구를 위한 블록체인에 대한 원칙 ![ Blockchain-for-the-planet-principles](/images/2018/09/ Blockchain-for-the-planet-principles.png) 블록체인이 실제로 문제를 해결할 수 있는가? 블록체인이 당면한 문제에 올바른 해답인가? 투명성과 추적가능성이 이 문제에 중요한 요소인가? 이 해결책에 탈중앙화가 중요한 요소인가? 새로운 자본 출처에 엑세스 하여 트랜잭션을 활성화 하려고 하는가? 부정적인 위험과 의도치 않은 결과를 받아드릴 수 있는가? 데이터 보안 규정과 위험의 영향을 고려했는가? 데이터 품질, 실제 인터페이스의 제약과 관련된 위험을 고려했는가? 새로운 솔루션의 상대적인 에너지 소비는 적절한가? 에너지 최적 플랫폼을 찾는가? 블록체인 사용에 확장성 문제가 존재하며, 이를 극복할 수 있는가? 이해관계자를 위한 생태계를 구축했는가? 솔루션에 필수적인 이해 관계자들의 생태계와 협력을 위해 중요한 분야를 파악했는가? 책임있는 사용을 위해 사용자와 광범위한 이해관계자가 모두 참여했는가? 이해 당사자들이 블록체인을 사용하는 방법을 이해하고, 신뢰할 수 있도록 어떻게 할것인가?","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인 작업증명의 올바른 가격","slug":"the-fair-cost-of-bitcoin-proof-of-work","date":"2018-09-17T15:00:00.000Z","updated":"2018-09-17T21:45:40.000Z","comments":true,"path":"2018/09/18/the-fair-cost-of-bitcoin-proof-of-work/","link":"","permalink":"https://www.yceffort.kr/2018/09/18/the-fair-cost-of-bitcoin-proof-of-work/","excerpt":"The fair cost of Bitcoin proof of work 원문 ¶블록체인 2009년 사토시 나카모토라는 익명의 개발자가 시작한 디지털 통화인 비트코인은, 신뢰할 수 없는 사람들 사이에서 제3의 중개자, 또는 신뢰가 필요한 권한이 없어도 인터넷을 통해 가치를 교환할 수 있음을 보여주었다. 비트코인은 100억달러 이상의 자본화에 도달했고, 이 시스템은 지금까지도 심각한 공격에 의해 도전 받지 않고도 수만건의 거래를 처리하고 있다. 블록체인은 비트코인의 주요 기술이다. 비트코인 네트워크에 참여하는 모든 사람이 사용할 수","text":"The fair cost of Bitcoin proof of work 원문 ¶블록체인 2009년 사토시 나카모토라는 익명의 개발자가 시작한 디지털 통화인 비트코인은, 신뢰할 수 없는 사람들 사이에서 제3의 중개자, 또는 신뢰가 필요한 권한이 없어도 인터넷을 통해 가치를 교환할 수 있음을 보여주었다. 비트코인은 100억달러 이상의 자본화에 도달했고, 이 시스템은 지금까지도 심각한 공격에 의해 도전 받지 않고도 수만건의 거래를 처리하고 있다. 블록체인은 비트코인의 주요 기술이다. 비트코인 네트워크에 참여하는 모든 사람이 사용할 수 있는 분산원장이다. 네트워크에서 비트코인 트랜잭션은 공개되며, 유효한 트랜잭션은 시가나 순대로 원장에 등록된다. 트랜잭션의 유효성은 네트워크 참가자들이 확인하고, 유효한 트랜갲션은 평균 10분 마다 암호화되며, 이전에 블록에 붙게 된다. 블록은 연대순으로 구성된다. 그래서 블록체인이다. ¶합의 메커니즘 비트코인 블록체인의 기초는 블록을 결합시키는 검증, 그리고 암호화 메커니즘이다. 비트코인에서 이 메커니즘은 다수결이다. 비트코인에서 노드의 상당부분이 트랜잭션 목록과, 이전블록에 있는 정보에서 주어진 난이도 수준보다 작은 해시 번호 (난스)를 생성하는 확인 프로세스에 관여 한다. 해싱은 임의의 길이의 입력사이에 지정된 길이 (비트코인의 경우 256비트)를 매핑하는 함수다. 자격d을 갖춘 다수를 차지하기위해 암호화 프로세스는 우연히 주어진 값보다 작은 해시번호를 생성해야 하는 매우 계산 집중적인 작업을 하게 된다. 이 아이디어는 '한개의 CPU당 1개의 투표’라는 말을 빌려, 계산능력을 보여주도록 함으로써 잘못된 중복을 피하기 위한 것이다. 이문제를 해결하는 첫번째 노드 (작업증명)은 비트코인에서 보상을 받는다. 이것이 새로운 비트코인이 생성되는 원리다. ![estimated-hash-rates-and-associated energy-consumption](/images/2018/09/estimated-hash-rates-and-associated energy-consumption.png) 하드웨어별 비트코인 마이닝에 걸리는 해시레이트와 에너지 소비량. 현재는 더이상 CPU와 GPU는 사용되지 않는다. ¶작업 증명의 비용 현재 비트코인 작업 증명은 매우 비싸다. 전세계 마이너들은 매초마다 수십억 해시를 생성해 내고 있다. 해싱은 비교적 효율적인 작업이지만, 현재 10억개의 해시를 만들어내면서 10억 와트가 매초마다 세계적으로 소비되고 있다. 전세계 전기가격은 변하고 가격은 많은 요인에 좌우되지만, 이 에너지는 대략 시간당 5만달러를 차지할 것으로 보인다. 시스템이 현재 시간당 10,000개 미만의 트랜잭션을 처리하고 있다는 점을 고려하면, 트랜잭션당 약 5달러를 초과하는 비용이 발생한다. 이 비용은 사용자가 지불하지 않고, 새로 만들어진 비트코인이 수락되는 보상으로 마이너가 차지하게 된다. 현재 가장 빠른 마이너에게 주어지는 보상은 (가격 변동에 따라 달라지지만) 15,000달러에 해당하는 25비트코인이다. 이전 추정치에 따르면, 마이너는 10분 마다 평균약 5만달러 / 6 =8,333 달러의 전기를 소비하여 블록을 생산하고, 하드웨어 기반 구조에 따라서 상당한 이익을 가져다주고 있다. 흥미롭게도, 이 보수는 곧 절반인 12.5 비트코인으로 줄어들게 되면 더 적은 마진이 남게 된다. 비트코인 채굴 1년간 총 전기료는 4억달러가 넘는 엄청난 비용이며, 이는 어찌되었건 엄청난 낭비다. 반면에, 작업 증명이라는 거래의 유효성을 검증하기 위해 경쟁하는, 그리고 공격에 값비싼 대가를 치르게 하기 위한 블록체인을 순수하게 유지하기 위하는 메커니즘이다. 과연 이 비용은 정당할까? ¶작업증명의 정당한 비용 비트코인 작업 증명의 정당한 비용은 얼마일까? 내 견해로는, 이중 지출 공격을 수익성있지 않게 하는 가격이 올바른 작업증명 비용이라고 생각한다. 이 원칙내에서, 작업 증명의 공정한 비용을 추정하는 것은 상대적으로 간단하다. 어느정도의 비트코인을 소유하고 있으며, 이를 여러 사용자에게 같은 비트코인을 사용하려는 공격, 즉 이중 지출 공격을 가정해 보자. 탐욕스러운 공격자는 가능한 가장 많은 한 양의 비트코인을 두배로 소비하려고 시도하지만, 현재 블록 당 거래액이 약 백만달러 수준에서 제한되고 있다. 블록의 일반적인 총 트랜잭션 값보다 훨씬 더 큰 비트코인을 가지고 있는 트랜잭션은 네트워크에서 원치않는 어그로를 끌 수 있다. 때문에 이중 지출 금액을 약 백만달러로 제한한다. 물론, 복제 또는 병렬, 연속적으로 반복될 수도 있지만, 곧 알 수 있듯이 현재 계산의 결과에는 영향을 미치지 않는다. 어쨌든, 공격자가 백만달러의 잠재적인 이익을 얻을 수 있다. 성공하기 위해서는 공격자는 중복된 트랜잭션에 대해 모두 유효성 검사를 해야 하며, 이전 블록에 두 블록이 연결된 포크를 생성해야 한다. 공격자가 충분한 컴퓨팅 파워를 가지고 있다고 가정했을때, 두 개의 유효한 해시를 생성하여 두 블록을 암호화 하고 두거래가 모두 확인되었다고 해야 한다. 그러나 거래의 최종 완성을 위해, 통상적으로 6번의 확인이 필요하다. 따라서 공격자는 이중 지출 거래가 해결된 것으로 간주되기전에, 6개의 유효한 해시를 생성하기 위해 컴퓨팅 파워를 사용해야 한다. 두 포크 중 하나만 공격자가 인위적으로 검증해야 하며, 다른 하나는 시스템에 유효한 것으로 간주되어 다른 마이너들에게 전파 될 수 있다. 공격자는 이를 전파 함과 동시에 이에 대해서도 보상으로 보상받을 수 있다. 물론, 그렇게 오랫동안 포크를 전파하는 것을 아무도 모른다는 것은 비현실적이지만, 단순한 가설로 삼자. 포크의 인공적인 전파에는 작업증명 비용 * 6이 필요하다. 이 비용이 이득보다 열등하다면, 공격자는 이익을 얻을 것이다. 요약하자면, 매우 간단한 공식을 만들 수 있다. $$ \\textrm{equilibrium fair cost of proof of work per block} = \\frac{\\textrm{duplicated action of the value of a block}}{\\textrm{number of blocks required for setting}} $$ $$ {블록당 작업 증명 비용} = \\frac{블록에 대한 중복 작업}{체인 정착에 필요한 블록의 수}$$ 현재 값과 계산을 정확하게 하기 위해, 공격자는 블록의 일반적인 가치 60% (60만달러)를 이중 지출 공격에 사용한다고 가정할 수 있다. 블록체인에 성공적으로 정착하기 위해서는, 6블록을 요구하는 현재 상태에서 다음과 같은 추정치가 나올 수 있다. $$ \\textrm{equilibrium fair cost of proof of work per block} \\approx $10,000$$ 이 계산은 블록 값의 작은 부분에 대한 공격이 먼저 선행되어야 하며, 모든 블록이 검증되지 않은 상태에서 한 시간 이상 긴 포크가 전파되지 않을 가능성은 매우 낮기 때문에 이 비용은 과대 평가 되었다고 불 수 있다. 따라서 위 비용의 10% 정도도 공격자에게 충분한 억제 효과가 발생할 수 있다. 이는 비트코인에서 작업증명을 위한 현재 전력 비용 정도의 규모다. 따라서 우리는 비트코인의 작업증명에 대한 현재 비용이 크고 낭비적이지만, 필요하다고 결론 내릴 수 있다. 이러한 비용 절감은 정착에 필요한 블록수를 늘리거나, 초기단계에서 포크를 자동으로 감지하고 차단하여 만들어 낼 수 있다. 반면에 공격자는 전기를 훔치거나 (-_-;) 마이닝 풀을 해킹하여 비용을 줄일 수 있다. 모든 기능을 하는 다수결의, 저렴한 메커니즘을 구현할 수 있을까? 블록체인은 계산 집약적인 작업증명이 필요하지 않은 몇가지 다른 메커니즘을 통해 구성될 수 있다. 실제로 작업증명은 익명의 신뢰할 수 없는 당사자들 간 시스템에서 자격을 갖춘 '유권자’를 배출하기 위해 만들어진 메커니즘이다. 유권자의 신원을 확인할 수 있거나, 통제 되지 않는 유권자의 중복을 피할 수 있는 메커니즘이 있다면, 이러한 비용을 줄이거나 없앨 수도 있다. 그러나 이러한 다른 매커니즘도 익명성, 개방성 또는 평등한 ㅏ분산 검증과 같은 일부 다른 속성도 완화해야 한다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인과 잊혀질 권리","slug":"blockchains-and-the-right-to-be-forgotten","date":"2018-09-16T15:00:00.000Z","updated":"2018-09-16T21:27:29.000Z","comments":true,"path":"2018/09/17/blockchains-and-the-right-to-be-forgotten/","link":"","permalink":"https://www.yceffort.kr/2018/09/17/blockchains-and-the-right-to-be-forgotten/","excerpt":"Law and Autonomous Systems Series: Blockchains and the Right to be Forgotten 원문 블록체인 기술은 거리에서 새로운 단어이다. 블록 체인은 본질적으로 합의 알고리즘에 의해 유지되고 여러 노드 (컴퓨터)에 저장되는 분산 데이터베이스다. 이 기술은 아직 미성숙하고 완성된 응용 프로그램은 별로 없지만, 비즈니스 모델, 상호 작용 및 시장을 분산시킬 수 있는 파괴적인 힘으로 널리 간주되고 있다. 새로운 형태의 데이터 저장 및 관리라는 점을 감안할 때 블록체인과 EU의 일반 데이","text":"Law and Autonomous Systems Series: Blockchains and the Right to be Forgotten 원문 블록체인 기술은 거리에서 새로운 단어이다. 블록 체인은 본질적으로 합의 알고리즘에 의해 유지되고 여러 노드 (컴퓨터)에 저장되는 분산 데이터베이스다. 이 기술은 아직 미성숙하고 완성된 응용 프로그램은 별로 없지만, 비즈니스 모델, 상호 작용 및 시장을 분산시킬 수 있는 파괴적인 힘으로 널리 간주되고 있다. 새로운 형태의 데이터 저장 및 관리라는 점을 감안할 때 블록체인과 EU의 일반 데이터 보호 규정(GDPR) 간의 관계를 둘러싼 질문이 많다. GDPR은 데이터가 중앙에서 수집, 저장 및 처리되는 세계를 위해 만들어졌지만, 블록 체인은 이러한 프로세스를 분산시키고 있다. 이러한 급진적인 패러다임 변화로, 중앙 집중화 영역을 위해 구축된 법적 프레임 워크를 블록체인에 적용하는 것은 쉬운 일 만은 아니다. 여기에서는 GDPR의 특정 측면, 즉 소위 '잊혀 질 권리’에 중점을 둡니다. ¶GDPR 17조 (잊혀질 권리) 정보주체는 본인에 관한 개인정보의 삭제를 정보처리자에게 요청할 권리를 가지며, 정보처리자는 다음의 각 호가 적용되는 경우, 부당한 지체 없이 개인정보를 삭제할 의무를 갖는다. (a) 개인정보가 수집 목적 또는 다른 방식으로 처리되는 목적에 더 이상 필요하지 않은 경우; (b) 정보주체가 제6조 (1)항의 (a) 또는 제9조 (2)항의 (a)에 따른 처리의 기반이 되는 동의를 철회하고 해당 처리에 대한 기타의 법적 사유가 없는 경우; © 정보주체가 제21조 (1)항에 따라 관련 처리에 반대하고 관련 처리에 대해 우선하는 정당한 사유가 없거나, 정보주체가 제21조 (2)항에 따라 처리에 반대하는 경우; 탬퍼링 방지 (의도적으로 오작동하거나 방해하는 행위를 방지)는 블록체인의 특징 중 하나이다. 블록체인은 그 정의상 수정에 저항하도록 설계되었기 때문에 삭제될 수 없다. 블록체인에 대한 데이터 수정은 원칙적으로 가능하지만, 대부분의 경우 이를 실현하는 것은 매우 비싸고 부담스럽다. 이러한 수정은 더 나아가 일관된 블록체인 블록체인의 성격을 변화시킨다. 한 블록의 데이터가 손상된 경우 모든 후속 블록의 해시는 물론 관련 해시가 수정되어야 한다. 블록체인(Blockchain)에서 데이터를 변경하거나 삭제하는 데 어려움이 있는 경우, 이러한 신기술에 '잊혀질 수 있는 권리’를 직접 적용할 수는 없다. 블록체인에서는 공용 키 (public key) 와 트랜잭션 데이터가 모두 개인 데이터로 간주 될 수 있다. 트랜잭션 데이터와 관련하여 여러 가지 가능한 솔루션이 있을 수 있다. 블록체인 자체와는 반대로 개인 데이터가 참조되고 암호화되며 수정이 가능한 데이터베이스('오프체인 스토리지’라고 함)에 기록되는 경우, 데이터 보호 요구 사항 없이 데이터 보호와 함께 삭제할 수 있다. 공개키와 관련하여 규정 준수는 더욱 부담이 된다. 우선, 잊혀질 권리는 절대적 권리가 아니라는 점을 기억해야 한다. 제17(2)항 GDPR은 삭제 요청이 있을 경우 데이터관리자는 '사용 가능한 기술과 구현 비용’을 파악한 후 '기술적 처리와 관련된 합리적인 조치’를 취하여 데이터 처리에 관한 정보를 통제자에게 제공해야 한다고 규정하고 있다. 여기서 '사용 가능한 기술’에 대한 언급이 블록 체인의 기술적 한계에 비추어 보았을때, 완벽한 삭제를 배제할 수도 있다는 GDPR의 해석으로 이어질 수 있는지에 대한 질문이 제기된다. 완벽한 삭제와 달리 암호화 된 데이터는 여전히 체인에 존재하지만 데이터 주체 (private key의 독점적 인 제어를 통해)에서만 액세스 할 수 있거나, 다른 외부인에 대해서는 더 이상 액세스 할 수 없다. 또한, 가지 치기는 체인의 지속을 위해 더 이상 필요하지 않은 구형 블록에서 구식 트랜잭션을 삭제하는 데 사용할 수 있다. 하지만, 그 아이디어는 (GDPR에 적용 가능한지는) 여전히 논란의 여지가 있다. 또 다른 옵션은 특정 제약 조건 하에서 승인된 당국에 의해 블록 체인에 블록의 내용을 다시 작성하거나, 완전한 투명성과 책임 성을 갖는 카멜레온 해시를 사용하는 것이다. 그러나 이러한 접근법에는 여러 가지 문제가 있다. 첫째, 잠금 키가 파괴되거나 손실되면 체인은 사실상 불변의 것으로 되돌아 가게 된다. 이 해결책은 정부, 특별기구 또는 중재자와 같은 신뢰할 수 있는 제 3 자의 필요성을 다시 도입할 것이며, 일부는 블록 체인 사용의 이점을 없애기 때문에 받아 들일 수없는 것으로 판명 될 공산이 크다. 둘째, 카멜레온 해시는 수정된 정보를 담고 있는 블록체인의 오래된 사본을 제거할 수 없으며 마이너들은 변경 사항을 수용할지 여부에 대해서도 재량권을 가지고 있다. 매우 예외적인 경우 블록 체인을 변영하는데 사용할 수 있는 하드 포크는 GDPR에 적용가능한 컴플라이언스 도구 가 아닐 가능성이 높다는 점을 기억해야 한다. 하드 포크는 가장 최근에 채굴된 블록에 대해서만 의미가 있다. 이후의 모든 블록이 무효로 만들어져 이 블록에 저장된 과거 모든 트랜잭션을 재 처리해야 한다. 이것은 사용되는 합의 프로토콜에 관계없이 너무 비싸며 매우 오랜 시간이 걸린다. 이러한 해결책들 중 어떤 것이 제17조 GDPR의 요건을 충족시킬 수 있을지는 두고 보아야 한다. '삭제(erasure)‘의 정확한 의미는 GDPR에 정의되어 있지 않으며, 절대적인 삭제보다는 다른 해석에 문을 열 가능성이 있다. 특정 국가의 (삭제의’)이행’에 대한 법률들은 이미 잊혀질 권리의 더 부드러운 버전을 지향하고 있다. 독일 법률 프레임워크에서는 특정 스토리지 모드가 이를 불가능하게 만드는 경우(데이터 복원이 불가능한 경우) 데이터를 삭제해도 되지 않는다고 이야기 한다. 블록체인에 개인정보가 있는한, 블록체인에서 생성되는 모든 데이터에는 이전의 데이터를 갖고 있기 때문에, 모든 블록들이 개인정보를 처리하고 있다고 봐야 한다. 그럼에도 불구하고 독일의 접근법은 GDPR이 그 목표를 각각의 기술적 특성과 결합하는 것으로 해석 될 수 있음을 보여줌으로써 흥미 롭다. 이것은 적어도 원칙의 문제로서 원장의 불변성과 대안 해결책의 필요성을 설명하는 잊혀질 권리에 대한 해석을 위한 문을 여는 것처럼 보인다. 그러나 다른 회원국들은 그 선택을 예견하지 않았다. 이 위험은 해당 규칙을 파편화 할 위험이 있으며, 이는 GDPR이 제거하고자 하는 것이다. 따라서 검열에 저항하는 데이터베이스로서 GDPR의 잊혀질 권리와 블록 체인 사이의 긴장이 존재한다는 것이 분명하다. 이 기술은 정부와 사법부를 포함한 제 3 자의 (개인적) 정보에 대한 간섭을 피하기 위해 만들어졌다. 그러나 현실 세계는 완벽하게 ‘수정 불가능한’ 블록체인을 받아들이지 않을 것이다. 블록체인이 현실 세계에 의해 받아 들여지기 위해서는 법을 준수해야하며, 그러한 기술을 받아들이는 법의 경우, 기술은 수정할 수 있어야 한다. 블록체인은 사법 결정으로 인한 것과 같은 사슬 외부적인 요소에 비추어 소유권의 변화를 반영할 수 있어야 한다. 따라서 GDPR에 관한 논의는 블록 체인 기술과 법률 시스템 간의 상호 운용성이 어떻게 보장 될 수 있는지에 대한 질문의 한 측면에 불과하다. 다른 모든 시나리오에서와 마찬가지로, 우리는 현재의 도전을 극복하기 위해 둘 사이에 다리를 건설해야 한다. 이 다리는 이 새로운 기술 혁신의 물결이 어떻게 가장 잘 관리 될 수 있는지를 공동으로 결정하기 위해 학제 간 (변호사와 컴퓨터 과학자 간의 협력과 같은)뿐만 아니라 기관 간 (규제 기관, 산업계, 기타 이해 관계자 및 전문가 연합)이어야 한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"삼성SDS리포트: 블록체인은 각 산업들을 어떻게 변화시키고 있는가","slug":"unlocking-blockchain’s-transformative-power-across-industries","date":"2018-09-14T15:00:00.000Z","updated":"2018-09-15T04:20:16.000Z","comments":true,"path":"2018/09/15/unlocking-blockchain’s-transformative-power-across-industries/","link":"","permalink":"https://www.yceffort.kr/2018/09/15/unlocking-blockchain’s-transformative-power-across-industries/","excerpt":"Unlocking Blockchain’s Transformative Power Across Industries 원문을 개인적인 학습을 위해 요약한 내용입니다. 앞 부분은 블록체인 소개라 그냥 넘어갔습니다. 제가 궁금한건 NexLedger이기 때문에… 삼성SDS는 정부, 제조, 물류 등 다양한 산업에 쓰일 수 있는 플랫폼인 NexLegder를 통해 이러한 시장 기회를 다루고 있으며 이미 금융 산업에서 상용화된 사례를 보유하고 있습니다. 많은 수의 산업에 걸쳐 사용 사례가 있는 삼성 SDS는 상용화된 최초의 글로벌 공급 업체 중","text":"Unlocking Blockchain’s Transformative Power Across Industries 원문을 개인적인 학습을 위해 요약한 내용입니다. 앞 부분은 블록체인 소개라 그냥 넘어갔습니다. 제가 궁금한건 NexLedger이기 때문에… 삼성SDS는 정부, 제조, 물류 등 다양한 산업에 쓰일 수 있는 플랫폼인 NexLegder를 통해 이러한 시장 기회를 다루고 있으며 이미 금융 산업에서 상용화된 사례를 보유하고 있습니다. 많은 수의 산업에 걸쳐 사용 사례가 있는 삼성 SDS는 상용화된 최초의 글로벌 공급 업체 중 하나이며 블록 체인 기반 세관 기술 검증을 성공적으로 수행한 세계 최초의 업체이기도 합니다. 또한 Nexledger는 자체 전문 컨센서스 알고리즘을 포함하여 플랫폼과 관련된 30 개 이상의 특허를 보유하고 있습니다. 자체 컨센서스 알고리즘을 갖고 있다는 것은 이더리움의 ERC20을 사용하지 않고 자체적인 블록체인 합의 알고리즘을 만들어서 사용했다는 의미로 볼수도 있습니다. 오픈 소스 하이브리드, 개인 허용 블록 체인 플랫폼인 Nexledger는 모니터링 도구, 외부 링크, 응용 프로그램 프로그래밍 인터페이스 및 구조화된 DevOps 환경과 같은 다양한 구성 요소를 통합하는 블록 체인 코어로 구성됩니다. 이것은 Bitcoin을 지원하는 공개 블록 체인에서 볼 수 있는 것보다 더 많은 성능 증가와 함께 다양한 사용 사례를 위한 전체 플랫폼을 만들었습니다. 삼성SDS가 달성한 새로운 성과는 초당 거래와 플랫폼에 추가된 노드(파트너) 측면에서 플랫폼 확장 능력면에서 대부분의 기업 요구 사항을 충족시키고 있습니다. ¶블록체인 프로토콜의 커스터마이제이션 이 플랫폼은 오픈 소스 블록 체인, Hyperledger 및 Ethereum의 기본 아이디어를 활용합니다. 삼성SDS는 자체 작업으로 이러한 영역을 더욱 강화했습니다. 예를 들어 트랜잭션 출력, 공개 / 개인 키 및 핵심 엔진과 같은 오픈 소스 프로토콜의 측면은 Nexledger 블록 체인 플랫폼에서 찾을 수 있으며 삼성 SDS 팀이 만든 다양한 새로운 기능과 함께 찾을 수 있습니다. ¶자체 내장된 인증 솔루션 삼성 SDS는 또한 인증 기관을 이용하는 전반적인 아키텍처로 Hyperledger Fabric을 채택했습니다. Ethereum에서 삼성 SDS는 체인 전체에서 거래를 사용자 정의하고 자동화하는 프로그래밍 가능한 인터페이스인 엔터프라이즈 수준의 스마트 컨트랙트 개념을 활용하고 있습니다. 그들은 또한 이를 뒷받침하는 자체 특허 컨센서스 알고리즘을 개발했습니다. 오픈 소스 하이브리드 모델인 Nexledger는 글로벌 분산원장의 원칙을 따르기 위해 쉽게 통합할 수 있는 오픈 소스 커뮤니티의 유연한 업데이트를 지원합니다. 그 결과 블록체인 플랫폼이 생겨났고, 이미 입증된 여러 서비스가 즉시 활용될 수 있습니다. 이더리움에서 많은 부분 아이디어를 가져와 공개 블록체인에 적합한 합의 알고리즘 (지분증명) 대신 프라이빗 블록체인에 어울리는 좀더 간단한 합의 알고리즘을 추가한 것 같습니다. ¶빌트인 시큐리티 삼성 SDS는 인증 및 권한 관리를 포함하는 다양한 보안 서비스를 통해 이 서비스 내의 보안을 해결했습니다. 사용자 인터페이스 수준에서 플랫폼에 액세스하는 데 필요한 장치 유형에 대한 고려가 이루어 졌기 때문에 모바일, 스마트 장치 및 브라우저가 지원됩니다. ¶효율적인 처리 이 외에도 플랫폼이 상업적으로 우호적인 제공임을 보장하면서 삼성 SDS 고객의 상업적 요구를 충족시키기 위해 플랫폼에 몇 가지 맞춤형 변경이 있었습니다. 블록 체인 기술 플랫폼으로 설명된 Nexledger는 자격을 갖춘 자체 컨센서스 알고리즘을 사용합니다. 핵심 알고리즘은 노드가 네트워크에서 누락되어도 합의에 도달할 수 있으므로 자체적으로 내결함성 플랫폼이됩니다. 또한이 플랫폼은 허가 기반이며 Bitcoin을 뒷받침하는 공공 블록 체인 내에서 발견되는 성능 및 보안 문제를 해결했습니다. 삼성 SDS에 따르면 Nexledger는 Bitcoin을 지원하는 블록 체인 플랫폼보다 100 배 이상 빠릅니다. Bitcoin에 권한을 부여하는 공개 블록 체인의 알려진 한계를 둘러싼 문제와 우려를 해결하기 위해 대규모 데이터 트랜잭션을 처리하고 트랜잭션 수를 늘리는 데 도움이 되는 관리 및 모니터링 도구가 도입되었습니다. 퍼플릭이 아닌 프라이빗 블록체인 입니다. (당연한 얘기지만) 당연히 글로벌 하게 합의를 하는 퍼블릭보다는 빠르겠죠. 전반적으로 Nexledger는 시스템을 공개 블록 체인보다 비즈니스 용도에 훨씬 더 적합하게 만드는 다양한 도구 및 성능 기준을 통합합니다. 이 플랫폼은 여러 디지털 서비스에 대한 단일 지원 지점을 갖춘 광범위한 서비스를 가능하게합니다. 필요한 경우 삼성 SDS의 도움을 받아 고객이 조직이나 컨소시엄의 요구를 충족시키는 맞춤형 응용 프로그램을 제공할 수 있는 유연한 개발 플랫폼이 제공됩니다. ¶고객 이용 사례 ¶금융 서비스 ¶케이스 1 : 신용 카드 고객을 위한 간단한 서드파티 로그인 모듈. 이 프로젝트는 고객의 신원 정보를 삼성 카드와 사용하여 타사 로그인 사용자를 인증하는 것을 포함합니다. 예를 들어, 버거 킹 (많은 사람들이 ID를 가지고 있지 않은)에 로그인하는 것은 사용자가 신원 생성 프로세스를 거쳐야하기 때문에 번거로울 수 있습니다. 삼성카드의 블록체인 인증으로 사용자들은 간단한 검증 방법을 통해 자신을 인증할 수 있어 이들에게 원활한 보안 경험을 제공할 수 있습니다. 게다가 삼성카드는 특정 고객이 블록체인 원장을 이용해 삼성카드 자격증을 어떻게 사용했는지 추적할 수 있을 것입니다. 그렇게함으로써 블록 체인 솔루션은 운영 비용과 위험을 낮추는 데 도움이됩니다. ¶사례 2: 통합 고객 인증 시스템 은행연합회와의 이 프로젝트에서 삼성SDS는 18개 은행의 내부, 은행 간 및 금융 부문 간 비즈니스 프로세스 개선을 위한 블록체인 네트워크를 구축하는 업무를 맡았습니다. 한국에서는 기존 시스템에서 고객이 가입한 새로운 서비스를 위해 은행으로 등록하도록 요구하기 때문에 새로운 통합 고객 인증 시스템이 절실히 요구되고 있습니다. 삼성SDS는 은행 및 규제당국이 활용할 수 있는 사용자 ID 시스템을 만들어 규제당국에 필요한 사항을 준수하는 동시에 시스템 효율성을 개선해야 했습니다. 삼성SDS NexLedger는 전체 노드가 100개 이상인 클라우드 환경에서 초당 수천 개의 상호작용을 처리해야 하는 스트레스 테스트를 성공적으로 거쳤습다. 삼성SDS NexLedger가 거래, 품질, 확장성, 완성도, 속도 향상을 위해 노력했다는 증거입니다. ¶사례 3 : 보험 제공자 및 환자를위한 신뢰할 수 있는 환경. 최근 프로젝트에서 삼성 SDS는 블록 체인 플랫폼을 기반으로한 여러 생명 보험 제공 업체를 위한 공동 인증 시스템을 구축하기 위해 노력하고 있습니다. 이 공동 인증 시스템은 의료 보험 청구, 평가 및 상환 프로세스를 혁신하기 위해 의료 제공자 및 건강 보험 회사와 환자를 연결합니다. 시스템이 완전히 활용되면 환자는 온라인 앱을 사용하여 의료 제공자의 데이터를 보험 회사에 자동으로 전송하고 의료 보험 청구를 자동화할 수 있습니다. 게다가, 건강보험 회사들은 수동 데이터 입력 오류로 인해 더 이상 잘못된 금액을 다시 부과하는 것에 대해 더 이상 어려움을 겪지 않을 것이다. ¶물류 ¶사례 4: 혁신적인 전자계약 관리 시스템. 삼성 SDS는 또한 전자 계약 / 문서 관리 주제에 관한 해양 물류 컨소시엄과 협력했습니다. 이 프로젝트는 선하증권과 신용장 등의 내용을 다루면서 한국, 중국, 일본, 베트남, 태국, 인도, 아랍에미리트(두바이), 네덜란드, 미국 등 11개 지역 간 화물을 정화하는 데 15일에서 3일이 소요되는 시간을 단축시켰다. ¶사례 5: 효율적인 제품 출처 추적. 한국 어묵 제조업체인 삼진 어묵은 삼성 SDS의 블록 체인 플랫폼을 배치하여 베트남 원산지에서 국내 판매 지점까지 제품의 출처를 추적했습니다. 추적은 사료 생산 및 번식 상태와 같은 측면을 포함하여 원산지의 생선 생산 품질에서부터 유통, 세관, 소매에 이르기까지 전체 공급망에 걸쳐있었습니다. 소비자는 QR 코드를 스캔하여 삼진 아묵의 제품의 출처를 확인할 수 있습니다. 블록체인은 제품의 재료 상태, 위치 및 처리를 여러 단계로 추적하여 제품의 품질을 보장하는 데 사용되었습니다. 이 프로젝트의 성공으로 삼성 SDS는 한국의 8 개 해산물 가공 회사를 대표하는 ASK (All About Seafood Korea)와 함께 PoC를 추가로 실행했습니다. ¶제조업 ¶사례 6: 효과적인 전자계약 관리 시스템과 문서 검증 시스템. 삼성의 신재생에너지 부문인 삼성SDI의 도전 과제는 다양한 배터리 및 기타 재생에너지 형태를 제조하기 위해 공급망에 진입하는 원자재를 인증하는 것이었습니다. 공급망은 많은 수의 하청 업체와 다양한 수준의 보안으로 수많은 지역을 건넜습니다. 삼성SDS는 사기성 위험과 위조 가능성을 없애기 위해 블록체인 플랫폼을 배치했습니다. 문서 관리 및 문서 검증을 위한 디지털 스탬핑과 전자 계약과 같은 여러 모듈을 활용합니다. 그 결과 삼성SDI의 공급망에 들어가는 사기성 활동이나 위조 문제가 완화되었습니다. 또한 블록 체인에 가입하기 위해 검증되어야하는 하청 업체는 제출하는 문서가 신속하게 확인되어 프로세스의 속도를 향상시킴에 따라 더 빠른 지불로 이익을 얻을 수 있게 되었습니다. ¶정부 ¶사례 7 : 정부의 미래 블록 체인 컨설팅 프로젝트. 삼성 SDS는 또한 서울시와 함께 다음과 같이 작업했습니다. 관리 프로세스에서 블록체인 기술을 구현하기 위한 전략을 개발합니다. 시민을 위한 서비스의 편의성을 높이기 위해 기관 및 사무실 간의 운영 투명성을 향상시킵니다 (예 : 중고차 시장의 전반적인 투명성 향상). 2022 년까지 복지, 공공 안전 및 운송 서비스를위한 블록 체인 응용 프로그램의 향후 계획 및 설계를 진행합니다. . 또 삼성SDS는 물류산업에서 블록체인과 IoT를 통합해 사용사례를 확대하고 공공부문에서 일부 사용사례를 활용하는 방안을 추진 중입니다. ¶도전과 기회 성공적인 삼성 SDS NexLedger 사용 사례는 투명한 거래를 가능하게하는 불변의 기록을 제공하는 수단으로 블록체인의 유용성을 입증했습니다. 그러나 신흥 기술은 여전히 많은 조직의 레이더에서 벗어났습니다. 블록체인 컨설팅, 블록체인 플랫폼 구현, 블록체인 시스템 전체 운영에 대한 삼성SDS의 경험은 이 기술의 잠재력을 깨닫는 조직에게 다시 한번 귀중한 것으로 여겨질 것입니다. 현재 시장은 블록체인 기술을 이해하고 구현하는 데 필요한 지식이 부족합니다. 특히, IDC 연구에 따르면 분산 원장 시장은 여전히 매우 초기입니다. 일반적으로 최상위 끝에 있는 시장의 작은 부분 만이 블록 체인 이니셔티브의 모든 형태에 적극적으로 착수하고 있습니다. 오늘날 블록체인 시장은 삼성 SDS와 같은 퍼스트 무버들이 개척해나가는 척박한 땅입니다. 기술이 관심을 끌기 시작하면, 플랫폼 제공업체는 몇 가지 성공적인 맞춤형 사용 사례를 구현하기 위한 중요한 경험을 얻을 수 있기 때문에 이 기회를 잡을 수 있습니다. 또한 삼성 SDS는 파트너 생태계를 확장하여 비즈니스 가치를 분명히하고 원하는 기술적 결과에 대한 기술 전문 지식을 모집하고 있습니다. 예를 들어, 삼성 SDS는 이미 글로벌 회계 및 컨설팅 회사인 Ernst &amp; Young과 협력하여 블록 체인 시장에서 새로운 비즈니스 기회를 발견하고 시장 동향 및 글로벌 기술에 대해 공유하고 있습니다. 또한 삼성 SDS는 블록 체인을 서비스로 제공하기 위해 AWS를 클라우드 서비스 파트너로 선택했습니다. ¶결론 아직 초기이지만 블록 체인 기술이 거래 속도 증가, 서류 작업 감소 및 문서의 무결성 및 보안 증가 측면에서 상당한 절감 효과를 가져올 수 있는 잠재력은 중요합니다. 이 기술을 적용할 수 있는 분야가 다르지만 컨소시엄의 &quot;회원&quot;이 늘어남에 따라 기술의 가치가 높아질 것입니다. 블록체인이 제공할 수 있는 것의 대부분은 디지털 변환 전략을 뒷받침할 것이다. 삼성SDS는 대기업의 일원이라는 장점이 있으므로 다양한 산업 분야에서 여러 가지 제품을 테스트하고 생산할 수 있었습니다. 이로 인해 신흥 블록 체인 시장을 장악할 수 있는 잠재적인 글로벌 플레이어로서 강력한 위치에 있습니다. IDC는 이 시장이 향후 몇 년 동안 상당한 성장세를 보일 것으로 예상하며, 앞서 언급한 바와 같이, 대부분의 기회는 이 분야의 최초 개발자가 가져가게 될 것입니다. 일단 비용 절감과 효율성이 증명된다면, 이것이 올바른 길이라는 것이 업계 나머지 사람들에게 분명해질 것입니다. 지속적인 절감과 효율성은 새로운 현실의 일부이지만 조기 채택자는 이러한 혜택을 먼저 보게 될 것입니다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인과 스마트 컨트랙트: 결합의 스테로이드?","slug":"smart-contracts-and-blockchains-steroid-for-collusion","date":"2018-09-13T15:00:00.000Z","updated":"2018-09-14T03:02:07.000Z","comments":true,"path":"2018/09/14/smart-contracts-and-blockchains-steroid-for-collusion/","link":"","permalink":"https://www.yceffort.kr/2018/09/14/smart-contracts-and-blockchains-steroid-for-collusion/","excerpt":"Smart Contracts and Blockchains: Steroid for Collusion? 원문 ¶스마트 컨트랙트란 무엇인가 스마트 컨트랙트에 대한 아이디어는 1994년 컴퓨터 과학자 Nick Szabo에 처음으로 개념화 되었다. 스마트 컨트랙트는 계약 조건을 실행하는 전산화된 거래 프로토콜이다. 스마트 컨트랙트 설계의 일반적인 목적은 계약 조건을 충족시키고, 악의적이거나 우발적인 예외를 최소화 하며 신뢰할 수 있는 중개자의 필요성을 최소화 하는 것이다. 이와 관련된 경제적 목표에는 사기 손실 감소, 중재 및 집행 비","text":"Smart Contracts and Blockchains: Steroid for Collusion? 원문 ¶스마트 컨트랙트란 무엇인가 스마트 컨트랙트에 대한 아이디어는 1994년 컴퓨터 과학자 Nick Szabo에 처음으로 개념화 되었다. 스마트 컨트랙트는 계약 조건을 실행하는 전산화된 거래 프로토콜이다. 스마트 컨트랙트 설계의 일반적인 목적은 계약 조건을 충족시키고, 악의적이거나 우발적인 예외를 최소화 하며 신뢰할 수 있는 중개자의 필요성을 최소화 하는 것이다. 이와 관련된 경제적 목표에는 사기 손실 감소, 중재 및 집행 비용 및 기타 거래 비용이 포함된다. Szabo의 인용문에서 알 수 있듯이, 가장 간단한 형태의 스마트 컨트래트는 기계가 판독 가능한 컴퓨터 프로그램으로 작성된다. 예를 들어, 가장 인기 있는 스마트 컨트랙트 플랫폼인 이더리움에서 스마트 컨트랙트는 Solidity라는 특정 프로그래밍 언어를 통해서 만들어진다. ¶Implications for collusion 기업들은 소위 블록체인 컨소시엄을 구성할 수 있으며, 이 컨소시엄들은 빠른 속도로 성장하고 있다. 2017년 8월 딜로이트 보고서에 따르면 , 그당시까지 6개월 간 40개 이상의 컨소시엄이 전세계적으로 형성되었다. 유명한 컨소시엄에는 PTDL (post-trade distributed ledger group), DTC (digital trade chain), B3i (blockchain insurance industry initiative), R3 등이 있다. 이 컨소시엄의 블록체인은 비공개이며 가입및 권한이 필요하다. 임대 계약의 예를 들자면, 당신이 아는 모든 사람이 아닌 친한 다섯명의 친구에게만 계약을 하는 것과 유사하다. 이는 암호 화폐 비트코인과 같은 공개 블록체인과는 대조적이다. 이러한 프라이빗 또는 허가된 블록체인에서는 구성원만 호스트된 정보에 엑세스 할 수 있다. 경제학자들과 법원은 정보 공유와 투명성이 담합을 촉진할 수도 있다는 사실을 인식하고 있다. 블록체인의 스마트 컨트랙트와 그에 따른 대응 방법을 자세히 살펴보자. 먼저 명시적인 담합의 경우부터 살펴보자. 카르텔은 카르텔 계약을 효율적으로 실행하는 두 가지 방법으로 개인 / 허가 블록 체인의 분산 시스템을 활용할 수 있다. 첫째, 카르텔 회원들이 전통적인 ‘오프라인’ 토론을 통해 합의를 도출한 다음 블록체인을 이용해 경쟁적으로 민감한 정보 (생산, 판매, 가격 등)를 공유하는 것이 바로 ‘전통적 방식’이다. 카르텔 구성원의 행동을 감시하고 속임수를 줄이는 것을 인센티브로 활용할 수 있다. 반독점 당국의 관점에서 볼 때 여기에 새로운 것은 별로 없습니다. 두 번째 방법은 훨씬 더 정교하고 블록체인과 스마트 컨트랙트에 의한 것이다. 카르텔은 개인 블록 체인을 사용하여 정보를 공유하는 것 외에도 계약을 스마트 컨트랙트로 성문화할 수 있다. 예를 들어, 그러한 스마트 컨트랙트는 특정 조건이 충족 될 때 에만 이전하거나, 부수적인 지불 을 자동화하고 부정 행위를 감지 할 때 처벌 할 수 있다. 카르텔의 기업들은 사물인터넷(IoT)을 이용해 다른 카르텔 회원들에게 인공지능(AI) 기반 센서에 접근할 수 있도록 허용해 경쟁자의 생산 활동을 자동으로 감시할 수 있다. 인공지능이 카르텔 협정과의 어떤 편차를 감지하면 스마트 계약서에 성문화된 자동적으로 보복 반응을 일으킬 수 있다. 이론적으로는 스마트 컨트랙트가 블록체인을 기반으로 이루어지기 때문에 다른 카르텔 회원들이 알지 못하는 한 어떤 당사자도 스마트 컨트랙트를 수정할 수 없다는 사실을 기억한다면, 이러한 절차는 처벌의 신뢰성을 크게 증가시킨다. 우리가 볼 수 있듯이, 스마트 컨트랙트와 블록체인은 계약을 이행하는 완전히 새롭고 효율적인 방법을 제공한다. 노골적인 카르텔이 이러한 스마트 컨트랙트의 능력을 최대한 이용하려고 하는 것은 쉬운결정이라고 생각할 수도 있다. 하지만 그런가? 오늘날 대부분의 국가에서는 명시적 카르텔이 불법이며, 이는 많은 가격결정 사례에서 카르텔 회원들이 당국의 감지를 피하기 위해 고심하고 있는 이유를 설명해 준다. 그들은 개인 호텔 방에서 만나 그들의 논의를 소수의 관련자로 엄격하게 제한한다. 카르텔은 공식적인 계약이나 계약이 거의 없다. 컴퓨터 코드의 집합이긴 하지만, 스마트 컨트랙트는 전통적인 종이 계약처럼 종이에 흔적을 남긴다. 이는 위에서 언급한 블록체인의 “감사할 수 있는” 기능과 관련이 있다. 물론 이러한 컴퓨터 코드 스크립팅 계약을 완전히 이해하려면 특정 프로그래밍 전문 지식(예: 위에서 설명한 대로 Ethereum의 무결성)이 필요하다. 이제 좀 더 흥미로운 암묵적 담합 사례로 넘어가보자. 명백한 공모와 마찬가지로, 어떤 정보 공유와 투명성은 암묵적인 결탁을 용이하게 할 수 있다. 사실, 투명성 제고가 실제 시장에서 암묵적인 담합으로 이어졌다는 몇몇 경험적인 증거가 있다. 기업은 블록체인에서 공유할 정보와 정보 공유가 경쟁을 저해하기 위한 암묵적인 방법으로 해석될 수 있는지에 대해 신중하게 생각해야 한다. 그러나 어떤 상황에서는 결탁이 좀 더 미묘한 방법으로도 촉진될 수 있다. 일부 경쟁사가 블록체인 컨소시엄을 구성해 사업 운영에 있어 스마트 컨트랙트 최대한 활용하려 한다고 가정하자. 예를 들어, 그들은 운송이 성공적으로 고객의 배송 항구에 도착할 경우, 자동으로 고객으로부터 판매자에게 자금을 이전하는 스마트 컨트랙트를 구축하고자 한다. 이러한 스마트한 컨트랙트를 이행하기 위해서는 외부 정보(예: 발송물이 실제로 배달되었는지 확인)가 필요하다. 이러한 외부 정보는 이른바 &quot;오라클 서비스&quot;라는 것을 통해 제공된다. 블록체인 컨소시엄의 다른 회사도 고객의 배달 위치에 존재한다고 가정하면(서로 믿는다면) 컨소시엄 멤버는 서로를 &quot;레코드 보관자&quot;로 사용할 수 있다. 오라클 서비스 즉, A 회사는 B, C, D, … 회사에 선적이 실제로 도착했는지 여부를 확인하도록 요청할 수 있다. 여기서 확인은 단순한 도착에서 부터 간단한 예 또는 아니오 확인에서 잠재적으로 선적 수량을 예측하는 것까지 다양 할 수 있다. 여기에서 AI 센서와 IoT를 활용할 여지도 있다. 분명히 이러한 오라클 서비스는 스마트 컨트랙트의 가치를 완전히 활용하는 데 중요하다. 이러한 환경에서 시카고 대학의 부스 경영대학원의 두 경제학자는 최근의 논문에서 충돌 결과를 더 쉽게 얻을 수 있다는 것을 보여 주었다. 논문에서, 저자들은 카르텔 회원들의 행동을 불완전하게 감시하는 것은 수요 불확실성과 함께 가격 전쟁으로 이어질 수 있고, 카르텔 가격을 올리거나 유지하는 계획을 방해할 수 있다는 것을 보여준다. 카르텔 회원이 선수의 행동을 관찰하지 않을 경우(예: 생산 또는 판매), 자신의 매출 감소가 다른 사람의 부정 행위 또는 단순히 불운한 총 수요 충격으로 인한 것인지 알 수 없다. 사실, 총수요가 변동성이 클수록 이 추론은 더욱 어려워진다. 수요 불확실성을 내재화하기 위해 그린과 포터는 가격 전쟁이 카르텔 회원들의 합리적이고 징벌적인 행동으로 이어질 수 있다는 것을 보여준다. 경쟁업체들이 서로 &quot;오라클 서비스&quot;를 제공하는 새로운 스마트 컨트랙트와 블록체인 환경으로 돌아가면, 이제 경쟁사들은 통합 수요와 개별 기업 매출을 감시할 수 있는 좋은 기회를 갖게 된다. 이는 통합 수요 불확실성의 불안정한 영향을 완화할 수 있다. 블록체인 컨소시엄에서 스마트 컨트랙트의 잠재적 부작용을 어떻게 해결해야 할까? 직관적으로 매력적인 접근법은 단순히 경쟁자와 기록 보관 인을 분리하는 것이다. 그러나 실제로는, 특히 다른 기록 보관인이 없을 때에는 몇 가지 어려움을 겪을 수 있다. 또 다른 가능성은 컨소시엄의 경쟁사들이 자금을 지원하는 독립적인 제3자 오라클 서비스 제공자를 설립하는 것이다. 완전한 분리가 불가능하거나, 분리하는데 있어 비용이 비싸면 회사 내에서 방화벽을 설치하여 기록 유지 기능을 다른 비즈니스 운영과 분리할 가능성을 모색하는 것이 또 다른 가능성이다. 이것은 시도해볼만 하다. 마지막으로 우리는 경쟁 업체가 제공하는 오라클 서비스가 전 세계적으로 독점 금지 당국이 수년 동안 씨름 해 왔던 (담합) &quot;촉진 관행&quot;으로 간주 될 수 있음에 주목한다. ¶결론 이 논문에서 우리는 스마트 컨트랙트, 블록체인, 블록체인 컨소시엄이라는 개념을 소개했다. 표준 설정 및 불공정 경쟁과 같은 블록 체인 컨소시엄과의 다른 독점 금지 고려 사항이 있지만, 이러한 신흥 기술이 명시적이고 암묵적인 담합에 미치는 영향에 중점을 두었다. 우리는 스마트 컨트랙트가 모든 종류의 계약을 시행하는 효율적인 방법을 제공한다는 사실에도 불구하고 명시 적 카르텔은 불법 계약을 현명한 계약의 형식으로 성문화하는 것이 부당하다는 것을 알 수 있다. 물론 카르텔이 스마트 컨트랙트를 이용해 사업을 운영하지 않는다는 뜻은 아니다. 이러한 행위를 밝히기 위해 독점 금지 기관은 스마트 컨트랙트의 설계 및 프로그래밍에 대한 전문 지식을 쉽게 이용할 수 있기를 요구할 수도 있다. 우리는 또한 최근의 학술 연구에서 강조한 바와 같이 담합이 어떻게 더 미묘한 방식으로 발생할 수 있는지에 대해서도 논의했다. 공개적인 의문은 기록 보관인이 제공하는 분산 합의의 효율성, 그리고 담합의 독점 금지 위험 사이에서의 트레이드 오프다. 많은 독점 금지 실무자들이 블록체인 컨소시엄에 가입하고 공유할 정보를 결정할 때 기업에 이미 주의를 기울 이도록 권고한 것은 고무적이다. 기술의 방향은 예측하기가 어렵지만, 더 많은 기업과 정부조차 블록체인 기술이 무엇을 제공해야 하는지 계속 탐구할수록 독점금지법과 경제공동체의 우리들에게는 더 미묘한 독점금지법 문제가 발생할 것이라고 가정하는 것이 안전하다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smartcontract","slug":"smartcontract","permalink":"https://www.yceffort.kr/tags/smartcontract/"}]},{"title":"비트코인이 퀘벡을 먹고있다","slug":"bitcoin-is-eating-quebec","date":"2018-09-12T15:00:00.000Z","updated":"2018-09-12T21:12:01.000Z","comments":true,"path":"2018/09/13/bitcoin-is-eating-quebec/","link":"","permalink":"https://www.yceffort.kr/2018/09/13/bitcoin-is-eating-quebec/","excerpt":"Bitcoin is eating Quebec 원문 캐나다의 수력발전소가 비트코인 마이너들에게 환영받고 있다. 그리고 이는 곧 과잉으로 이어졌다. 언뜻 보기에 몬트리올에서 동쪽으로 60마일 떨어진 퀘벡주의 세인트 하이어신스의 이 노화된 산업단지에 특별하게 최첨단으로 보이는 거슨 없다. 하지만 여기 새로운 첨단 기술이 일어나고 있다. 건물 밖에서 수천대의 컴퓨터가 웅웅 거리는 소리를 들을 수 있다. 각각 컴퓨터는 매일 똑같은 작업을 반복한다. 변화나 중단 없이. 이 컴퓨터들은 북미 최대의 암호 통화 마이닝 업체 중 하나인 Bit","text":"Bitcoin is eating Quebec 원문 캐나다의 수력발전소가 비트코인 마이너들에게 환영받고 있다. 그리고 이는 곧 과잉으로 이어졌다. 언뜻 보기에 몬트리올에서 동쪽으로 60마일 떨어진 퀘벡주의 세인트 하이어신스의 이 노화된 산업단지에 특별하게 최첨단으로 보이는 거슨 없다. 하지만 여기 새로운 첨단 기술이 일어나고 있다. 건물 밖에서 수천대의 컴퓨터가 웅웅 거리는 소리를 들을 수 있다. 각각 컴퓨터는 매일 똑같은 작업을 반복한다. 변화나 중단 없이. 이 컴퓨터들은 북미 최대의 암호 통화 마이닝 업체 중 하나인 Bitfarms의 자산이다. 한 때 버려졌던 이 공장에서는 약 7,000여개의 신발 상자 만한 기계 (7월까지 두배로 수가 증가할 것으로 보인다.)가 건물을 양분하는 단층에서 천장까지 줄지어 선반에 놓여져 있다. 반대편에는 컴퓨터 뒤쪽을 빠져나가는 와이어와 라우터가 차가운 캐나다 공기에 노출되어 있다. 다른 한쪽에는 수천개의 동일한 팬이 빈 판지 상자의 더미를 지나 다른 빈 공간으로 뜨거운 공기를 밀어 넣고 있다. 소수 바쁜 직원들이 얇은 티셔츠와 청바지를 입고 양쪽 사이를 오간다. {:width=“400px”} 이런 컴퓨터들을 'RIG’라고 부르는데, 이 컴퓨터들은 목적이 있다. 온도와 습도의 변화에 견딜 수 있는 이 장치는 매초 마다 1조번의 계산을 일시중지 없이 반복하도록 프로그래밍 되어 있다. 이들은 또한 에너지 돼지다. 여기 7000개의 기계들은 몬트리올 캐나다 인근 하키 경기장보다 더 많은 에너지를 소비한다. {:width=“800px”} 전세계쩍으로 이러한 컴퓨터가 수백만대가 운영되고 있으며, 이는 2009년에 시작된 암호 화폐 붐의 일부다. 비트코인이 시작된 이래로 10년 동안 마이닝이라고 불리는 작업의 대부분은 풍부한 전기와 여유있는 규제를 제공하는 중국과 루마니아와 같은 국가에서 일어나고 있다. 2016년 Hydro-Québec은 마이크로소프트와 아마존이 운영하는 데이터 센터에게 구애하기 위한 계획을 발표했다. 그리고 뒤이어 암호 화폐 마이너들에게도 제안을 했고, 이 제안은 곧 압도적인 관심을 이끌어 내어 전력회사가 수용할 수 있는 것보다 더 많은 요청을 이끌어 냈다. 퀘벡이 이들 중 일부라도 받아드릴수 있다면, 이 지방은 암호 화폐 마이닝의 새로운 글로벌 허브가 될 수 있다. 그리고 이는 Hydro-Québec이 겨울에 이러한 에너지 수요를 얼마나 잘 유지 할 수 있을지 의문을 제기하게 되었다. 한편 환경론자들과 사회정의옹호론자들은 이 캠페인의 생태학적, 문화적 영향에 대해 우려하고 있다. 그리고 이는 암호 화폐의 진정한 가치에 대한 어려운 윤리적 질문으로 귀결 되었다. ¶가치가 없는 퍼즐 암호 화폐는 본질적으로 에너지 집약적이다. 비트코인은 현존하는 가장 큰 분산원장시스템으로서 '작업증명’이라는 접근법이 주는 보안에 의존한다. 약 10분마다 비트코인은 거래의 블록을 확인하는 계산상의 문제를 성공적으로 해결하는 대가로 새로운 통화를 제공한다. 참가자들은 이러한 거래를 나타내는 데이터를 '해시’라고 하는 일련의 코드로 변환하여 득정 기준에 충족하는 코드에 도달 할 때 까지 몇번이고 시도한다. 이 과정에서 세련된 계산법이 필요한 것은 아니고, 복권번호를 때려 맞추는 것 과 같은 상당한 운이 필요하다. MIT의 한 교수는 본질적으로 수학적으로 풀 수 없는 무가치한 퍼즐을 풀고 있다고 말한다. 이 퍼즐을 풀 수 있는 근육은 마니어들의 컴퓨터에 전력을 공급하는데 사용되는 전기의 형태로 나온다. 자원 집약성은 비트코인처럼 분산된 시스템에 내재되어 있다. 미국 연방 준비은행과 같은 중앙은행에 의해 보장되는 대신, 모든 거래가 모든 참가자가 투명하게 검증가능하게 함으로써 비트코인과 같은 암호 화폐가 보장된다. 그리고 이러한 원장을 조작하려는 시도는 자멸되어야 한다. 기본적으로 사용자와 공격자들 사이에 경제적 비용이 부과되는 셈이다. 거래를 속이거나 합법적인 거래를 되돌려서 시스템을 파괴하고 싶다면, 엄청난 양의 에너지와 계산을 소비해야한다. 그러나 합리적인 경제 주체가 그런일을 하진 않을 것이다. 왜냐하면 공격비용이 이익보다 훨씬 크기 때문이다. 그러나 이는 합법적인 거래가 이 스스로의 타당성을 증명하기 위해서는 에너지를 막대하게 소비해야 한다는 것을 의미한다. 현재 총 글로벌 비트코인 해시 비율은 초당 약 25,000,000,000,000,000,000, 즉 초당 2천5백만 테라 해시다. 이는 불과 4년전 초당 30만 테라 해시에서 증가한 수치이며, 앞으로 몇년, 몇달간 계속해서 증가할 것을 보인다. 컴퓨터를 냉각시키는데 필요한 추가 에너지 소비요인 (컴퓨터가 40도이상에서는 정상작동할 수 없다.)까지 합치면, 비트코인이 전체 아일랜드 국가만큼 전기를 소비하고 있다고 추정한다. 비트코인이 가장 큰 작업 증명 암호 통화지만, 또 암호화폐가 이것만 있는 것은 아니다. 약 1,500개의 암호 화폐가 존재하고, 각각 자체적으로 에너지를 소비하고 있다. 의심할 여지 없이, 전기가 마이닝에서 가장 큰 비용을 차지 한다. 따라서 수익성이 높으려면 전력 비용이 저렴해야 한다. 중국이 마이닝 붐이 일어난 것은 다른 이유가 아니다. 일부 중국 지역에서는 전기요금이 킬로와트 시간당 3 센트에 불과하다. 그러나 정부 규제가 증가하고 전력 자원이 다 떨어질 수 있다는 우려로 마이너들이 다른 장소를 물색하고 있다. 중국은 수년동안 엄청난 규모로 온실가스를 배출하고 있다. 물론 인구가 가장 많은 나라여서 그럴수 있다. 하지만 가장 큰 이유중 하나는 가장 더러운 에너지 원인 석탄을 이용해 전력을 생산하기 때문이다. 암호 화폐 채광에서 두번째로 인기 있는 국가인 미국은 화석연료로 전기의 대부분을 얻는다. 전세계 채광작업에 뛰어든 업계는 일년에 약 29,000킬로톤의 탄소를 배출한다. 이는 아프카니트산, 크로아티아, 케나, 파나마 등이 매년 배출하는 양보다 많다. Bitframs의 설립자가 퀘벡에 5개의 마이닝 업장을 설치하나 이유기도 하다. 퀘벡은 수력발전소에 의존하여 2만대의 컴퓨터에 연료를 공급할 수 있다. 이 회사는 2009년 설립되어, 퀘벡 붐에 맞춰 2017년 말에 마이닝 시설을 퀘벡으로 옮겼다. 우리는 많은 에너지를 사용합니다. 그리고 에너지 원이 깨끗해야 합니다. 환경에 오염을 남긴다면, 이는 안좋은 일입니다. Hydro-Québec은 수력발전을 이상적인 해결책으로 선전했다. 대량으로 공급할 수 있는 청정하고 재생가능한 에너지원. 그러나 이 에너지가 녹색이라고 하는 주장은 생물학자로 부터 많은 의심을 샀다. 비트코인만 생사하는 산업은 말할 것도 없고, 이 수력발전의 영향이 산업에 대비 너무 높다고 말한다. ¶수백만 에이커의 땅 전기를 생산하는 터빈을 돌리기 위해 움직이는 물을 사용하는 수력발전은 다른 화석연료보다 깨끗한 것은 명백하다. 그럼에도 불구하고, 이 역시 환경에 영향을 끼친다. 가장 큰 것 중 하나는 물 공급을 위해 지어진 저수지가 끼치는 피해다. 퀘벡과 같은 곳에서는 이 저수지가 기존에 있는 숲에 영향을 끼치고 있다. 수중에서 나무가 썩으면서 메탄으로 저장된 ㅣ탄소를 방출한다. 이는 이산화 탄소보다 강력한 온실가스다. 수십, 수백만 에이커의 땅을 물속에 넣는 일이다. 온실 가스를 대기에 방출하고 탄소를 낳는 능력을 멈추게 한다. 이는 생태계 전체를 잃게 할 수 있다. 연구자들은 전세계쩍으로 수력전기의 탄소영향을 계산했다. 만약 모든 암호 화폐 채광이 수력 발전으로 이동한다면, 산업은 매년 9,000 킬로톤 이상의 이산화 탄소와 150킬로톤 이상의 메탄을 생성할 것이다. 더 추운 지방에서 수력발전은 열대성 기후보다 탄소와 메탄을 덜 방출하는 경향이 있지만, 그렇다고 탄소 배출이 없는 것은 아니다. 여기에서 또한 고유한 환경 가격표가 붙어 있다. Hydro-Québec에서 만드는 전력은 인구 밀집 지역에서 멀리 떨어져 있으므로 전기를 보내는 변압기를 광범위하게 설치해야 하며, 이는 역시 환경파괴를 불러온다. Hydro-Québec대변인은 댐이 건설되기 전에 환경영향 연구가 완료되었다고 확신했다. 그는 새롭게 떠오르는 블록체인 작동에 대한 분석을 수행하고 있으며, 전력발전에 있어 업데이트가 필요할 경우 회사가 자금을 조달할 책임이 있다고 말했다. 퀘벡에서는 주민들이 전기로 집을 데운다. 그러므로 온도가 낮아지면 수요가 증가할 가능성이 있으며, 이 겨울 동안에는 블록체인 회사들이 활동을 중단하도록 하는 방법을 해결책중 하나로 보고 있다. 하지만 매일 수만달러 이상의 가치를 생산해내는 마이너들이 이러한 해결책에 순응할지는 미지수다. 그러나 일부 마이너들은 네트워크 서버와 인터넷 처럼, 블록체인도 그들과 같은 수준을 존재하고 있을 것이라고 말한다. 그리고 이를 수력발전으로 유지하는 것은 암호 화폐의 관심을 충족 시킬 수 있는 가장 친환경적인 방법이라고 말한다. 그리고 또한 이같은 기업이 주는 추가적인 이점, 지역사회의 창고와 공장을 재활용하고, 자원을 투입하고, 주민들을 고용하는 것 들도 주목할 필요가 있다고 말한다. ¶대안은 없는가? 그렇다면 암호 화폐와 같은 블록체인 응용 프로그램이 지구에 얼마나 영향을 미칠까? 이는 에너지 소비가 큰 작업 증명 접근법을 계속 하용하는지에 따라 달려 있다. 여러가지 작업증명에 대한 대안이 있지만, 여전히 Bitfarms와 같은 마이닝 회사들이 계속 성장하고 있다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인과 선거: 일본, 스위스, 미국의 경험","slug":"blockchain-and-elections-the-japanese-swiss-and-american-experience","date":"2018-09-11T15:00:00.000Z","updated":"2018-09-12T09:20:16.000Z","comments":true,"path":"2018/09/12/blockchain-and-elections-the-japanese-swiss-and-american-experience/","link":"","permalink":"https://www.yceffort.kr/2018/09/12/blockchain-and-elections-the-japanese-swiss-and-american-experience/","excerpt":"Blockchain and Elections: The Japanese, Swiss and American Experience 원문 자유롭고 공정한 선거는 건강한 민주주의를 이루는 근간중 하나다. 미국에서 부터 시에라리온에 이르기까지, 블록체인 옹호자들은 이 기술이 선거 과정에서 새로운 수준의 투명성, 공정성, 효율성을 가져올 수 있다고 믿는다. 블록체인 공동체의 열정과, 정치단체의 지원에도 불구하고 이 기술을 구현하려는 시도는 성공과 비판 모두를 맞닥드리고 있다. ¶일본 과학 허브 도시에서의 블록체인 지난 8월말, 일본 도시","text":"Blockchain and Elections: The Japanese, Swiss and American Experience 원문 자유롭고 공정한 선거는 건강한 민주주의를 이루는 근간중 하나다. 미국에서 부터 시에라리온에 이르기까지, 블록체인 옹호자들은 이 기술이 선거 과정에서 새로운 수준의 투명성, 공정성, 효율성을 가져올 수 있다고 믿는다. 블록체인 공동체의 열정과, 정치단체의 지원에도 불구하고 이 기술을 구현하려는 시도는 성공과 비판 모두를 맞닥드리고 있다. ¶일본 과학 허브 도시에서의 블록체인 지난 8월말, 일본 도시 츠쿠바는 투표 시스템에서 블록체인 기술의 사용을 시도했다. 츠쿠바는 이미 과학연구와 밀접한 관련이 있는 도시이며, 블록체인을 시도하여 혁신을 위한 새로운 방법을 모색하려 했다. 유권자들은 2015년에 도입된 12자리 ID인 My Number Card를 사용하여 참여할 수 있었다. 도시의 공식 웹사이트에 발표된 자료에 따르면, 유권자는 다양한 사회 프로그램을 위해 투표권을 행사할 수 있었다. 블록체인의 민주적이고 투명한 속성이, 투표과정에서 부정을 최소화 시키는데 도움이 될지 여부를 결정하기 위한 시도를 펼쳤다. 처음에는 블록체인의 잠재력에 회의적이었지만, 츠쿠바의 시장은 다음 과 같이 언급했다. 처음에는 블록체인이 더 복잡한 절차를 포함할 것이라고 생각했지만, 이내 그것이 작고 쉽다는 것을 깨닫게 되었다. 블록체인 이용을 위한 일본의 최근 사례가 순조롭게 진행된 것으로 보이지만, 기술의 잠재력을 활용하려는 정부의 모든 노력이 모두 이와 같은 반응을 보인 것은 아니다. ¶시에라리온: 블록체인 선거가 아니었다 2018년 3월 7일, 시에라리온이 선거 과정에서 블록체인 기술을 구현한 최초의 국가가 되었다고 보고 된 바 있다. 스위스 회사인 Agora Technologies는 시에라리온의 첫번째 블록체인 기반 선거를 감독했다는 일련의 트윗을 발표했다. 그러나 현실은 조금 다른 것으로 밝혀졌다. 시에라리온 선거관리위원회는 선거기간 동안 블록체인 기술을 사용했다는 것을 부인하면서 트위터에 성명서를 발표했다. Agora CEO 는 오해가 있는 이 사실을 바로 잡아야 했다. 이 기업이 선거와 함께 자신들의 블록체인 솔루션을 시험하도록 인가되었다는 사실은, 언론의 열광에도 불구하고 정부기관이 선거과정을 효율적으로 만드는 새로운 방법에 대해 개방적이라는 것을 나타낸다. 그 새로운 방법에는 블록체인이 포함되어 있었다. 시에라리온의 선관위와 겉보기엔 장밋빛 관계였지만, 그 회사가 선거에 참여한다는 것에 대해서는 반응이 엇갈렸다. 그 시스템은 훌륭하다. 하지만 실제로 테스트 하지는 않았다. 왜냐하면 이들의 솔루션은 기본저긍로 선거 결과를 종이카드로 받아 단순히 시스템에 넣는 수준이었기 때문이다. 다른 사람들도 이렇게 하고 있으며, 이는 새로운 솔루션이 아니다. ¶스위스 '크립토 밸리’의 블록체인 투표 스위스의 Zug는 산의 전망과 기이한 스위스 건축물로 유명해졌지만, 최근 낮은 세율과 암호 화폐와의 연관성으로 유명해지면서, 크립토 밸리라고 불리게 되었다. 최근 6월 25일부터 7월 1일까지, 구속력이 없는 투표에 240명 중 72명만이 온라인 투표 시스템에 접속했다. 이 설문에는 시민들에게 블록체인 기반 eID 시스템이 향후 국민 투표에 사용되어야 하는가 와 같은 사소한 지방 자치 문제에 블록체인 사용 여부를 투표하도록 요청되었다. 스위스 통신에 따르면 3명은 디지털 투표가 쉽지 않다고 헀고, 22명은 세금 신고서나 설문조사에 블록체인을 사용할 것이라고 응답했고, 19명은 디지털ID로 주차료를 지불할 것이라고 했으며, 3명은 도서관에서 도서를 빌릴 것이라고 밝혔다. ¶웨스트 버지니아에서의 블록체인 투표 시도 웨스트 버지니아는 2018년 11월에 Voatz라는 앱으로 해외 거주시민들과, 군복무중인 시민들에게 스마트폰으로 투표할 수 있도록 할 계획이다. 이는 연방선거에서 스마트폰으로 투표하는 첫사례가 될 전망이다. 웨스트 버지니아 관계자는 이 과정을 요약한 PDF를 게시했다. 투표에 필요한 것은 애플이나 안드로이드 모바일 기기와 승인되거나 유효한 연방 신분증 뿐이다. 이 아이디어는 텍사스의 SouthWest 기술축제가 주최한 회담에서 처음 나타났다. 웨스트 버지니아 국무담당은 앱의 생체 인식 인증 시스템과 블록체인 기반 보안요소에 깊은 인상을 받았다. Voatz를 만든 Warner와 Boston의 스타트업은 이 시스템이 안전하다고 주장한다. 그리고 주정부는 지난 5월에 PoC를 성공적으로 마무리했다. 투표 절차에서 블록체인 기술을 사용하게 된 배경에는, 최근 선거사에서 나타난 스캔들을 기반으로 하고 있다. 2000년에는 표가 잘못집계된 사례가 있었고, 2016년 에는 여러사람이 한개 이상의 주에서 투표를 했다는 주장도 나왔다. 브루킹스 연구소에 따르면 보안, 유권자 강제, 인증 및 지방 공무원의 불편함과 같은 전자투표의 광범위한 적용을 위해 해결해야 할 여러가지 고려사항을 제시했다. 블록체인 기술이 투표 프로세스를 변형시키는 가능성에 대해서는 긍정적이지만, 블록체인이 보다 광번위한 구현과 비융을 고려하여 포괄적으로 테스트 되어야 한다고 결론 지었다. 펜실베니아 대학에서는 블록체인이 시스템에 약점을 도입한다고 비판하면서 보고서에 대해 비판적인 입장을 취했다. 그리고 다른 방식으로 투표 시스템을 확보하는 것이 더 쉽고 간단하며, 안전하게 수행된다고 밝혔다. 또한 앱이 유권자의 데이터를 암호화 할 수는 있어도, 전화와 서비스 네트워크에 대해서는 취약할 수 있다고 밝히기도 했다. ¶여전히 우려는 남아 있다. 암호학자이자 컴퓨터 과학자및 암호화와 컴퓨터 보안에 관한 여러 권의 책을 저술한 Bruce Schneier는 선거에서 블록체인 사용을 반대하는 블로그를 발표했다. 선거를 악의와 사고로부터 안전하게 보호하는 유일한 방법은 해킹할 수 없거나, 신뢰할 수 있도록 만드는 것이다. 그렇게 하는 가장 좋은 방법은 종이로 가능한 많은 시스템을 백업하는 것이다. 그는 투표시스템을 자동화하려는 과거의 노력이 변화의 잠재적인 위험에 대한 메시지를 담고 있다고 믿는다. 2007년 캘리포니아와 오하이오주는 전자 투표 기계에 대한 포괄적인 감사를 수행했다. 결과는 긍정적이지 못했다. 이 리뷰는 거의 모든 요소에서 취약성이 있다는 것을 발견했다. 연구자들은 투표 집계를 변경하고, 감사기록을 지우고, 시스템에 악성 프로그램을 넣을 수 있었다. 이런 공격 중 일부는 일반 여론 조사원보다도 권한이 없는 일반 개인에 의해서 만들어 질 수 있다. 그리고 다른 사람들도 원격으로 할 수 있었다. 전자 투표기가 손상된 사례는 또 있다. 2017년 Defcon에서는 25개의 개표 관련 장비를 해킹하도록 대회가 열렸다. 주말이 끝날 무렵, 참가자들은 악의적인 소프트웨어를 장치에 로드하여 익명으로 개표를 손상했고, 장치가 충돌하게 만들었다. 블록체인 투표에 대한 비판은 그러나 정부가 가까운 장래에 기술을 구현하려는 시도를 막지 못할 것으로 보인다. 지금은 국가적인 수준이 아닌, 시, 도 정부 수준에서만 이야기 할 수 있지만, 미국, 일본, 스위스에서 점차 성공적으로 실시된다면 세계최고의 민주주의 국가들로 부터 DLT에 대한 관심을 이끌어내는 것은 과장이 아닐 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인과 다른 분산원장 기술의 운영","slug":"blockchain-and-other-distributed-ledger-technologies-in-operations","date":"2018-09-11T15:00:00.000Z","updated":"2018-09-12T09:20:16.000Z","comments":true,"path":"2018/09/12/blockchain-and-other-distributed-ledger-technologies-in-operations/","link":"","permalink":"https://www.yceffort.kr/2018/09/12/blockchain-and-other-distributed-ledger-technologies-in-operations/","excerpt":"Blockchain and other Distributed Ledger Technologies in Operations 원문 블룩체인과 다른 분산 원장 기술은 점점 더 많은 어플리케이션을 만들고 있는 신흥 기술이지만, 플랫폼 마다 특수적으로 구현된 부분이 다양하여 아직 표준이나 안정성을 달성하지 못했다. 비트코인은 블록체인 부문에 있어 주목할 만한 응용 프로그램이다. 오늘날에는 블록체인과 관련하여 수천개의 다른 어플리케이션이 있지만, 블록체인과 암호 화폐의 연관성은 종종 부정적인 사회적 의미를 불러 일으킨다. 한 조사에 따르면","text":"Blockchain and other Distributed Ledger Technologies in Operations 원문 블룩체인과 다른 분산 원장 기술은 점점 더 많은 어플리케이션을 만들고 있는 신흥 기술이지만, 플랫폼 마다 특수적으로 구현된 부분이 다양하여 아직 표준이나 안정성을 달성하지 못했다. 비트코인은 블록체인 부문에 있어 주목할 만한 응용 프로그램이다. 오늘날에는 블록체인과 관련하여 수천개의 다른 어플리케이션이 있지만, 블록체인과 암호 화폐의 연관성은 종종 부정적인 사회적 의미를 불러 일으킨다. 한 조사에 따르면 2018년 블록체인 솔루션에 20억 달러 이상을 전세계적으로 지출하며, 블록체인 관련 LinkedIn 일자리가 3배이상 증가할 것이라고 예측한 이 수치는 과대 광고가 아니다. 새로운 파트너십, 합작 투자, 프로젝트가 지속적으로 발표되지만 성공한 예가 거의 없다. 통계에 따르면 2016년에 시작왼 26,000개의 새로운 프로젝트 중 2017년에는 단 8%만이 살아 남았다. 금융시장과 경제 전반에 거품이 형성되는 징후가 있다. 한 음료회사는 단순히 업종을 블록체인 채광으로 전환한다고 발표하고 사명을 바꾼 것 만으로, 이틀 후 주가가 344% 올랐다. 참고 이 이야기 들은 인터넷의 발전과 닷컴 붐을 연상시킨다. 이 기술은 점진적으로 등장하여 세계경제에 큰 혼란을 가져오고 거품을 겪었지만, 오늘날에는 세계 경제의 일부를 차지하고 있다. 블록체인은 가시성, 정보 집계, 검증, 계약 자동화, 시스템 탄력성 등을 제공하여 공급망 운영을 개선할 수 있다. 블록체인은 보다 안정적이고, 투명하며, 부안이 강화되고, 윤리적이며 견고한 공급망을 만들 수 있으며, 공급망과 금융을 결합할 수 있다. 블록체인은 전통적인 공급망 관리에서 발생하는 의문들에 대해 새롭고 흥미로운 방법을 제공하는 것 외에도 흥미로운 비즈니스 모델, 고전적인 공급망관리 문제에 대한 새로운 관점을 도입할 수 있는 잠재력을 제공한다. 동시에 우리는 블로겣인 주변의 과대 광고에 빠지지 않도록 주의해야 한다. 블록체인 기술은 단점과 도전도 있다. 예를 들어, 개인 블록체인 네트워크에서 공급망은 계약 그 이상의 것이 되며, 때문에 규제되어야 하는 대상으로 변하게 된다. 블록체인 개발은 산업 조직의 관점에서 흥미로운 문제를 야기한다. 그리고 이러한 논의가 블록체인 연구에 있어서 흥미진진한 길이 될 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인과 스마트 컨트랙트와 DAO의 법적인 관점","slug":"blockchain-smart-contracts-and-daos-legal-perspective","date":"2018-09-10T15:00:00.000Z","updated":"2018-09-11T09:20:16.000Z","comments":true,"path":"2018/09/11/blockchain-smart-contracts-and-daos-legal-perspective/","link":"","permalink":"https://www.yceffort.kr/2018/09/11/blockchain-smart-contracts-and-daos-legal-perspective/","excerpt":"Blockchain, Smart Contracts and DAOs from a Legal Perspective 원문 비트코인을 기반으로 하는 블록체인 기술에 대한 관심이 높아지는 것을 보는 우리는 혁신의 독특한 호황을 목격하고 있는 증인이다. 처음에는 작은 암호화폐 애호가들에게만 인식된 기술의 잠재력은 현재 중앙은행, 정부, 주요 금융기관들 사이에서도 인정되고 있다. 이러한 블록체인의 잠재력은 금융계를 훨씬 뛰어넘을 것이라는 사실은 이미 분명하다. 그리고 진정한 혁명은 스마트 컨트랙트와 탈중앙화 자율 조직 (DAO)라는 개념이","text":"Blockchain, Smart Contracts and DAOs from a Legal Perspective 원문 비트코인을 기반으로 하는 블록체인 기술에 대한 관심이 높아지는 것을 보는 우리는 혁신의 독특한 호황을 목격하고 있는 증인이다. 처음에는 작은 암호화폐 애호가들에게만 인식된 기술의 잠재력은 현재 중앙은행, 정부, 주요 금융기관들 사이에서도 인정되고 있다. 이러한 블록체인의 잠재력은 금융계를 훨씬 뛰어넘을 것이라는 사실은 이미 분명하다. 그리고 진정한 혁명은 스마트 컨트랙트와 탈중앙화 자율 조직 (DAO)라는 개념이 처음으로 실행되면서 시장된다. 이것은 또한 법의 혁명이기도 하다. ¶스마트 컨트랙트와 DAO의 태동 2016년 5월, DAO에 대한 첫 ICO는 새로운 경제모델의 개발이자 기존 법률 시스템에 있어서 획기적인 순간이었다. ICO는 알고리즘의 형태로 존재하는 계약을 기반으로 1억 5천만 달러에 해당하는 금액을 모으는데 성공했다. 그리고 이 기금은, 사이버 공간에만 존재하는 자율적이고 분산된 조직에 전달되었다. 두번째로 중요한 것은 자연어로 작성된 ICO 문서였다. ICO 참가자의 권리와 의무는 컴퓨터 코드 형태로 입력되었다. ICO 이후에 발생한 해킹은 이러한 해결책이 얼마나 혁신적이고 선구적인지를 강조하면서도, 전체 사업에 극적인 영향을 미쳤다. TheDAO에서 발생한 이 사건이 스마트 컨트랙트가 DAO의 종말을 초래한다고 생각하지 않는다. 반대로, DAO와 ICO를 둘러싼 사건이 이러한 솔루션에 관심을 불러 이르켰다. 이들은 경제 성장과 공공 부문에 거대한 잠재력을 가지고 있다. ¶스마트 컨트랙트는 법률과 변호사가 직면한 도전 DAO와 스마트 컨트랙트를 이용한 이 첫번째 실험은 이러한 솔루션이 거의 완전히 규제 되지 않은 환경에서 기능한다는 것을 분명하게 보여준 사례다. 많은 흥미로운 시도들 사이에서 이것은 점점더 심각한 장벽을 나타낸다는 것은 명백하다. 그리고 이러한 장벽들의 규모는 어마어마하다. 이러한 도전에 처음으로 제기된 법률 시스템은, 새로운 경제 모델을 창출하고, 인터넷의 탄생 자체와 비교할 수 있는 혁신의 물결을 타기 위한 기회를 갖는다. 이는 적은 노력으로도 효과적으로 이러한 혁신에 지원될 수 있음을 보여준다. 그리고 이러한 기술들은 엄청난 잠재력을 지닌 기술이지만, 규제의 지원이 없이는 풀 수 없다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smartcontract","slug":"smartcontract","permalink":"https://www.yceffort.kr/tags/smartcontract/"}]},{"title":"블록체인과 GDPR","slug":"blockchains-and-the-GDPR","date":"2018-09-09T15:00:00.000Z","updated":"2018-09-10T09:20:16.000Z","comments":true,"path":"2018/09/10/blockchains-and-the-GDPR/","link":"","permalink":"https://www.yceffort.kr/2018/09/10/blockchains-and-the-GDPR/","excerpt":"Blockchains and the GDPR 원문 ¶블록체인과 GDPR 블록체인은 현재 유럽을 비롯한 여러 곳에서 적극적으로 실험되고 있다. 이러한 복제 및 변조 방지 데이터베이스는 새로운 데이터 처리 방법을 제공한다. 블록체인의 특성은 규제 당국이 GDPR을 만들 때 염두해 둔 중앙 집중식 데이터 관리의 특성과 대조된다. 최근 논문에서는 분산 수집, 관리, 데이터 저장을 기반으로 한 이 기술이 데이터 사일로 용으로 만들어진 GDPR과 호환 될 수 있는지 여부를 조사했다. 이 질문은, GDPR이 유럽의 블록체인 프로젝트 뿐만 아","text":"Blockchains and the GDPR 원문 ¶블록체인과 GDPR 블록체인은 현재 유럽을 비롯한 여러 곳에서 적극적으로 실험되고 있다. 이러한 복제 및 변조 방지 데이터베이스는 새로운 데이터 처리 방법을 제공한다. 블록체인의 특성은 규제 당국이 GDPR을 만들 때 염두해 둔 중앙 집중식 데이터 관리의 특성과 대조된다. 최근 논문에서는 분산 수집, 관리, 데이터 저장을 기반으로 한 이 기술이 데이터 사일로 용으로 만들어진 GDPR과 호환 될 수 있는지 여부를 조사했다. 이 질문은, GDPR이 유럽의 블록체인 프로젝트 뿐만 아니라 전세계의 블록체인 프로젝트와 관련이 있기 때문에 굉장한 중요성을 지니고 있다. 결론부터 말하자면, 중앙 집중화의 영역을 위하여 관련된 법적 틀이 이러한 분권하에 쉽게 적용될 수 없다고 결론 지었다. ¶블록체인에 있는 개인정보 GDPR은 개인 데이터에 대한 정의를 ‘확인되거나 식별 가능한 자연인과 관련된 모든 정보’, 즉 '데이터의 주체’로 받아들인다. 데이터가 개인 데이터로서 역할을 할 수 있는 경우, 여러 조건에 따라 처리해야 하며, 데이터 피험자는 데이터와 관련하여 특정한 실제 권리를 얻는다. 블록체인은 본질적으로 합의 알고리즘에 의해 유지되고 여러 노드에 저장되는 데이터베이스다. 데이터는 일반 텍스트 형태로 블록체인에 저장되거나, 체인에 암호화되거나 해시 될 수 있다. 암호화되거나 해시된 데이터는 EU법에 따라 개인 데이터로서의 조건을 충족하고 있으며, 니는 가명화되어 있다. 즉, 블록체인에서 공개키는 해시된 자연인과 관련된 데이터와 마찬가지로 개인 데이터로 인식된다. 결과적으로, 공개 키 이외에 분산 원장에 저장된 암호화적으로 수정된 데이터는 GDPR의 영향을 받는다. 이러한 발견은, 데이터 피험자가 데이터를 엑세스하고 수정하거나 삭제할 권리를 포함한 GDPR 상의 권리를 휘두를 수 있는 위치에 있기 때문에 블록체인에 광범위한 영향을 미친다. (잊혀질 권리) 그러나 변조 방지 원장에서는 이러한 권리를 쉽게 구현할 수 없다. 현재 대부분의 블록체인은 이러한 권리를 이행할 수 없으므로, GDPF을 준수하지 못한다고 가정하는 편이 쉽다. 미래에 이것을 촉진할 수 있는 많은 기술 솔루션이 현재 개발중이지만, 아직은 존재 하지 않는다. 또한 어떤 주체가 이러한 의무를 받아드리는 수취인이 될지 결정하는 것은 매우 어렵다. GDPR은 데이터 컨트롤러, 즉 개인 데이터 처리의 목적과 수단을 결정하는 자연인 또는 법인이 이러한 원칙을 준수해야 한다고 말한다. 처리의 목적과 수단을 결정하는 사람의 문제는, 주어진 블록체인의 정확한 거버넌스 방식에 따라 달려 있다. 대부분의 경우 노드가 데이터 컨트롤러로 수행해야 한다는 주장이 있지만, 일부 상황에서는 다른 행위자도 이를 염두에 둘 수도 있다. 가장 큰 문제는 중앙 집중식 컨트롤러와는 달리 노드와 데이터의 주체가 저장된 정보에 대한 제한적인 영향을 고려한다면, GDPR을 블록체인이 준수 할 수 없다는 것이다. ¶책임 있는 혁신 촉진 대부분의 현재 블록체인 프로젝트는 GDPR을 준수할 수 없을 것이다. 이는 법적인 틀이 시행되기도 전에 (GDPR은 6월에 시행되었습니다.) 데이터 관리의 최신 기술과 관련해서는 이미 구식이 된다는 것을 의미한다. 블록체인 상황에서 뿐만 아니라, 빅데이터, 기계학습, 인공지능에도 쉽게 적용될 수 없다. 현재 이를 준수하는 제품을 만들고자 하는 혁신가는 아마 쉬운 답을 찾기 어려울 것이고, 디지털 시장에 대한 많은 제약으로 인해 혁신적인 기술 개발이 질식될 위험이 있다. 현재 법적 확실성이 부족하여, EU 규제 당국에 데이터 컨트롤러의 성격, 공개키가 개인 데이터인지 여부 및 실질적인 권리를 구현해야 하는지 등, GDPR을 블록체인에 적용하는 방법을 명확히 하도록 압박이 가해지고 있다. 블록체인과 GDPR사이의 긴장은, EU 법의 두가지 규범적인 목표인 기본 권리 보호와 혁신 촉진 사이에서 충돌을 되풀이 한다. 규제자들은 앞으로 이러한 목표들의 균형을 신중하게 유지해야 한다. 이러한 맥락에서, 블록체인이 어떻게 구성되느냐에 따라서 데이터 보호를 훼손하거나 촉진하는데 사용될 수 있다. 기술이 특정 개인 정보보호 장치를 내장하지 못한다면 체인에 저장된 모든 개인데이터가 공개될 수 있다. 그러나 적절하게 설계되면 GDPR의 기본 목표인 데이터에 대한 통제력을 부여하는데 상당한 기여를 할 수 있다. 결론은 이렇다. 블록체인은 GDPR의 기본 목표를 훼손할 수 있는 위험이 있다. 이 단계에서 블록체인은 데이터를 보호하거나, 혹은 데이터를 보호할 수 있는 창의적이고 유연한 기술이다. 기술은 중립적일 수 있지만, 중립적인 방식으로 사용되지 않고 주변의 규범, 목표 및 신념을 반영하게 되어 있다. 내일의 블록체인은 오늘날의 입력에 의해 형성될 것이다. 기술이 만들어지는 초기에 혁신가, 규제 기관, 기타 이해관계자 간의 대화의 중요성을 강조한다. 규제자는 확립된 기본 권리 보호를 준수하고 이를 준수하는 시스템을 구축하는 방법에 대한 지침을 제공하기 위해 개발자에게 인센티브를 제공해야 한다. 반면에 혁신가들은 규제 원칙을 존중하면서 제품을 개발할 자유를 부여 받아야 한다. 이것이 그렇다고 해서 새로운 2차 입법이 필요하다는 뜻은 아니다. 기관 위협, 지침 발행, 규제 샌드 박스와 같은 보다 부드러운 인센티브 조치가 적절할 것이다. 여전히 블록체인에 대해 사회에 긍정적이거나 부정적인 영향을 미칠지에 대해서 논의 중이다. 향 후 몇년간은 방향을 크게 형성하는 시간을 갖게 될 것이다. EU는 이러한 현실을 깨닫고 데이터 보호와 관련하여 사회에 도움이 되는 방식으로 기술을 사용하라 수 있는 방법에 대해 업계 전문가, 이해관계자와 대화해야 한다. 기술 개발이 허용되면 블록체인은 우리와 함께 있을 수 있을 것이다. 인터넷 혁신의 물결과는 다르게, 유럽은 특히 베를린에서 활기찬 블록체인 생태계를 갖게 된 것이 행운이다. 현재 혁신과들과 대화하면서, EU는 기술 생태계가 계속 발전함과 동시에 데이터 보호를 포함한 유럽의 가치와 양립할 수 있는 방식으로 충분히 유도할 수 있을 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smartcontract","slug":"smartcontract","permalink":"https://www.yceffort.kr/tags/smartcontract/"}]},{"title":"스마트 컨트랙트는 죽일 수 있다","slug":"smart-contracts-can-kill","date":"2018-09-08T15:00:00.000Z","updated":"2018-09-09T09:20:16.000Z","comments":true,"path":"2018/09/09/smart-contracts-can-kill/","link":"","permalink":"https://www.yceffort.kr/2018/09/09/smart-contracts-can-kill/","excerpt":"Law School Professor: “Smart Contracts Can Kill” 원문 브루클린의 로스쿨에서는 어떻게 블록체인이 사람의 책임을 증가시키는가라는 논문을 발표, ‘인공적인 책임(Artificial Responsibility)’ 이라는 용어를 사용했다. 인공적인 책임은 ‘인간이 의사결정을 거부하거나 통제를 취소할 수 있는 기회가 제한된 중요한 문제를 통제하는 능력’ 을 의미한다. 인공지능이 가장 똑똑한 인간보다 조금 더 똑똑하다 해도, 그렇다고 우리를 노예로 만들 수 있다는 뜻은 아니다. 타인에 대한 지배는","text":"Law School Professor: “Smart Contracts Can Kill” 원문 브루클린의 로스쿨에서는 어떻게 블록체인이 사람의 책임을 증가시키는가라는 논문을 발표, ‘인공적인 책임(Artificial Responsibility)’ 이라는 용어를 사용했다. 인공적인 책임은 ‘인간이 의사결정을 거부하거나 통제를 취소할 수 있는 기회가 제한된 중요한 문제를 통제하는 능력’ 을 의미한다. 인공지능이 가장 똑똑한 인간보다 조금 더 똑똑하다 해도, 그렇다고 우리를 노예로 만들 수 있다는 뜻은 아니다. 타인에 대한 지배는 단지 지능의 기능에 지나지 않는다. 기계가 우리를 조종하거나, 조종할 수 있는 능력 때문에 실질적인 통제력을 쥐지 않는 한, 통제력이 없는 기계의 초지능에 대해 걱정할 필요는 없다고 주장한다. 대신, 더이상 우리의 이익을 위해 봉사하지 않는 기계에서 통제권을 되찾고, 애초에 통제권을 주지 않는 것은 쉽다고 말한다. 그러나 DAO(분권화된 자율 조직)처럼, 효과적으로 작동하는 기계는 인간 사용자가 기계 프로그래밍을 통제할 수 없으며, 스마트 컨트랙트가 일단 코딩되고 배치되면 뭔가 잘못되고 있는 경우 개입할 수 없기 때문에 완전히 자동화된 방식으로 불리한 결정을 내릴 가능성이 있다고 주장한다. TheDAO를 ‘인공적인 책임’ 이 잘못되고 있는 한가지 예로 봤다. TheDAO는 2016년 블록체인 프로젝트를 위한 벤처 캐피털 펀드로 활동하기 위해 설립된 최초의 DAO였다. TheDAO가 1억 6천만 달러 상당의 이더를 모은직후, DAO를 기반으로 한 스마트 컨트랙트가 해킹되었다. DAO 해킹을 위해 해커는 암호를 해독하기위해 DAO 스마트 컨트랙트의 취약점을 이용하였다. 그리 스마트하지 않는 컨트랙트에 의존하는데 따른 피해는 재정적으로만 발생했지만, 인간의 개입을 허용하지 않는 스마트 컨트랙트 주도의 자율조직의 잠재적인 위험은 크다. DAO의 기본 컨트랙트와 같이, 스마트하지 않는 컨트랙트가 얼마나 위험한지 쉽게 알 수 있다. 한 연구에서, 수만건의 스마트 컨트랙트가 가진 취약성을 감안할때, DAO를 괴롭히는 버그와 같은 종류의 버그는 불가피 할 것이다. 결함이 있거나, 취약한 코드는 스마트 컨트랙트 기반의 IoT 제품 및, 서비스가 이러한 기계가 작동중인 프로그램에 ‘끄기’ 버튼이 없으면 무력해질 수 있다. 그의 논문에서, TheDAO가 살아남아서 해킹되지 않았다면, Slock.it과 같은 기업에 투자했을 가능성이 있다고 주장했다. Slock.it은 스마트 컨트랙트 기술로 실제 장치를 연결하는 것을 목표로 하는 스타트업이다. Slock.it 과 같은 스타트업의 작업을 통해, 언젠가 문 잠금 장치, 자동차 시동, 의료 기기를 제어하는 스마트 컨트랙트를 볼 수 있을 것이다. 이는 블록체인 기반의 스마트 컨트랙트가 곧 물리적 세계에 상당한 영향을 미칠 수 있음을 의미한다. 스마트 컨트랙트와 결합된 IoT의 성공은 DAO호텔, DAO택시, DAO은행과 같은 제품으로 이어질 수도 있다. 이론적으로 이러한 서비스들이 더 빠르고 효율적이며, 노동집약적인 서비스를 제공함으로써 사회에 기여할 수도 있지만, 스마트 계약이 ‘스마트 하지 않다면’ 사용자에게 단점으로 작용할 수도 있다. DAO 호텔에서 손님은 방에서 갇힐수도 있고, DAO 택시는 예기치 않은 사고를,DAO 은행은 사용자가 알지도 못한체 돈을 이체할 수도 있다. 블록체인과 IoT의 결합은 창의성, 자유로운 표현, 민주주의, 경제적 효율성을 증진시킬 수 있는 기회를 약속한다. 하지만 전체장치의 복잡성을 고려할때, 우리가 고삐를 당기는 것이 어렵거나 불가능할 기계를 만드는 위험을 증가시킬 수 있다. 기술이 초기 단계인점, 코딩 오류 가능성에 비추어 볼때, 스마트 컨트랙트 기반 기계는 철저한 테스트를 거쳐야 하며, 인간에게 해를 끼칠수도 있는 가능성이 있는 경우 완전히 자율적이어서는 안된다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smartcontract","slug":"smartcontract","permalink":"https://www.yceffort.kr/tags/smartcontract/"}]},{"title":"블록체인은 실제로 얼마나 안전한가?","slug":"how-secure-is-blockchain-really","date":"2018-09-07T15:00:00.000Z","updated":"2018-09-08T04:20:16.000Z","comments":true,"path":"2018/09/08/how-secure-is-blockchain-really/","link":"","permalink":"https://www.yceffort.kr/2018/09/08/how-secure-is-blockchain-really/","excerpt":"How secure is blockchain really? 원문 블록체인을 사용하는 사람들의 가장 큰 이유는 안전하고 조작이 불가능한 방법으로 다른 귀중한 데이터를 신뢰하지 않는 사람들과 공유 하는데 있다. 블록체인은 정교한 수학과 공격자가 조작하기 매우 어려운 혁신적인 소프트웨어 규칙을 통해 데이터를 저장하기 때문이다. 하지만 가장 잘 설계된 블록체인 시스템 조차도, 숙련된 사기꾼과 접촉하는 곳에서는 실패할 수 있다. 왜 그런지 이해하기 위해서는, 블록체인이 ‘안전하게 만드는 요소’ 부터 이해할 필요가 있다. 비트코인은 좋은","text":"How secure is blockchain really? 원문 블록체인을 사용하는 사람들의 가장 큰 이유는 안전하고 조작이 불가능한 방법으로 다른 귀중한 데이터를 신뢰하지 않는 사람들과 공유 하는데 있다. 블록체인은 정교한 수학과 공격자가 조작하기 매우 어려운 혁신적인 소프트웨어 규칙을 통해 데이터를 저장하기 때문이다. 하지만 가장 잘 설계된 블록체인 시스템 조차도, 숙련된 사기꾼과 접촉하는 곳에서는 실패할 수 있다. 왜 그런지 이해하기 위해서는, 블록체인이 ‘안전하게 만드는 요소’ 부터 이해할 필요가 있다. 비트코인은 좋은 예다. 비트코인의 블록체인에서 공유된 데이터는 지금까지 만들어진 모든 비트코인의 거래 히스토리, 즉 원장이다. 이 원장은 '노드’라고 불리는 컴퓨터 네트워크의 여러 사본이 저장된다. 누군가 장부에 거래를 전송할 때 마다 노드는 거래가 유효한지 확인한다. 이 들 중 일부는 유효한 거래를 '블록’으로 패키지화 하고 이전 거래 체인에 추가하기 위해 경쟁한다. 이 노드의 소유자들을 '마이너’라고 한다. 체인에 새로운 블록을 성공적으로 추가한 마이너는 보상으로 비트코인을 얻는다. 이 시스템을 이론적으로 변조 불가능하게 만드는 것은 두가지다. 각 블록의 고유한 암호화 지문과 네트워크의 노드가 공유된 히스토리에 동의하는 ‘합의 프로토콜’. 해시라고 불리우는 이 지문은 처음에는 많은 연산 시간과 전력을 필요로 한다. 따라서 블록체인에 블록을 추가한 마이너가 비트코인 보상을 얻기 위해 계산 작업을 했다는 증거로 사용된다. (작업증명) 블록을 변경하려면 새로운 해시가 생성되어야 한다. 해시가 블록과 일치하는지 여부를 확인하는 것은 쉽고, 노드가 완료되면 블록체인의 각 사본을 새로운 블록으로 업데이트 한다. 이것이 바로 합의 된 절차다. 최종 보안요소는 해시가 블록체인의 링크 역할을 한다는 것이다. 각 블록에는 이전 블록의 고유한 해시가 포함된다. 따라서 원장항목을 소급하여 변경하려면 해당 블록 뿐 만 아니라 후속 블록에 대한 모든 새로운 해시를 적용 해야 한다. 그리고 다른 노드가 체인에 새로운 블록을 추가하는 작업보다 더 빨리 해내야 한다. 따라서 다른 노다보다 더 강력한 컴퓨터가 없다면, 추가하려고하는 모든 블록은 기존 노드와 충돌하고 다른 노드는 자동으로 변경을 거부한다. 이것이 블록체인을 변조하게 할 수 없게 만드는 이유다. ¶창의적으로 사기치는 법 비트코인처럼 시스템이 잘 작동한다는 단순한 사실이 그렇다고 해서 안전하다는 것은 아니다. 개발자들이 안전하다고 믿는 방식을 사용하더라도, 실수로 그것을 안전하지 않은 방법과 결합하는 것은 쉽다. 비트코인의 경우에는 가장 철저하게 테스트를 거쳐왔다. 사람들은 또한 속임수를 쓰는 다른 창의적인 방법을 발견했다. 광부의 채광력이 절반에 미치지 못하더라도 블록체인을 파괴하는 방법이 있음을 보여주었다. 세부사항은 기술적이지만, 본질적으로 이기적인 광부는 다른 노드를 속여 이미 해결된 암호 퍼즐에 시간을 낭비하게 하여 불공정한 이점을 얻을 수도 있다. 블록체인 노드는 데이터를 비교하기 위해 일정한 통신을 유지해야 한다. 한 노드의 통신을 제어하고, 나머지 네트워크에서 나온 거짓 데이터를 받아드리도록 속일 수 있다. 마지막으로 블록체인 프로토콜이 아무리 변조되지 않아도 안전한 것은 아니다. 블록체인 시스템이 실제 시스템과 연결되는 곳에서 실패가 발생할 수 있다. 예를 들어, 소프트웨어 클라이언트나 타사 응용프로그램과 같은 곳에서 실패가 발생할 수 있다. 해커들은 암호 화폐를 소유하는 사람이 소비하기 위해 필요한 개인 암호키를 저장하기 위한 인터넷 응용프로그램인 '핫 월렛’에 침입할 수 있다. 많은 온라인 암호 화폐 거래소가 고객의 자산을 ‘콜드 월렛’ 에 보관한다고 저장한다고 말한다. 저장 장치는 대부분 즉 인터넷과 분리되어 있다. 그러나 일본에서 암호 화폐 해킹이 발생한 것 처럼, 모든 자산이 '콜드 월렛’에 있는 것은 아니다. 블록체인과 현실세계에서 가장 복잡한 연결 고리는 ‘스마트 컨트랙트’ 일 것이다. 이는 거래를 자동화 할 수 있는 블록체인에 저장된 컴퓨터 응용 프로그램이다. 2016년 해커들은 블록체인 기반의 새로운 투자 펀드인 분산 자치 기구 (DAO)로 부터 당시 8천만 달러에 달하는 3560만 이더를 훔치기 위해 이더리움 블록체인에 쓰이는 스마트 컨트랙트의 취약점을 이용했다. DAO 코드가 블록체인에 존재하므로, 이더리움 커뮤니티는 돈을 돌려받기 위해 '하드포크’라고 하는 논란의 여지가 있는 소프트웨어 업그레이드를 진행해야 했다. 연구자들은 여전히 스마트 컨트랙트가 오작동하지않도록 보장하는 방법을 개발중이다. ¶중앙집중화 문제 블록체인 시스템이 보안을 보장할 수 있는 이유는 ‘분권화’ 다. 블록체인의 복사분이 널리 분산된 노드 네트워크에 저장된다면, 공격할 만한 약점이 별로 없으며, 네트워크를 파괴할 수 있는 충분한 컴퓨팅 파워를 확보하기도 어렵다. 하지만 최근 연구에 따르면 비트코인이나 이더리움이 그다지 생각만큼 분권화 되있지 않은 것으로 보인다. 이들은 상위 4개의 비트코인 마이닝 작업이 평균 마이닝 파워의 53% 이상을 차지 하는 것으로 나타났다. 마찬가지로, 이더리움은 마이너 3명이 61% 정도를 차지하고 있다. 일부 전문가들은 마이닝에 의존하지 않는 대안 합의 프로토콜이 더 안전할 수 있다고 주장한다. 그러나 이 가설은 검증되지 않았고, 새로운 프로토콜은 이들 만의 보안 문제를 내제하고 있을 것이다. 다른 이들은 비트코인과는 다르게 사전에 가입허가를 받는 블록체인에서 잠재력을 본다. 이러한 시스템은 암호화폐의 정신에 반하는 것이지만, 이 접근 법은 공유 암호화 데이터베이스 이점을 이용하는 금융기관과 기타 기관에 매력적이다. 하지만 이런 허가기반 블록체인은 문제점이 있다. 누가 허가를 내릴 권한이 있는가? 시스템이 검증자가 자신이 허가받은 당사자라고 보장하는 방법은 무엇인가? 허가 기반 시스템은 소유자를 안전한 것 처럼 느끼게 할 수 있지만, 실제로는 더 많은 통제력을 필요로 한다. 블록체인 신봉자들은 블록체인이라는 아이디어에 반하는 것이라고 생각할 수도 있다. 결국 '안전’이라는 것은 블록체인 맥락에서 정의하기가 매우 어려워진다. 누구로부터? 무엇으로부터? 이는 당신의 관점에 따라 달라진다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 51% 공격이 규칙적으로 일어나고 있다","slug":"blockchain-51-attack","date":"2018-09-06T15:00:00.000Z","updated":"2018-09-06T22:14:32.000Z","comments":true,"path":"2018/09/07/blockchain-51-attack/","link":"","permalink":"https://www.yceffort.kr/2018/09/07/blockchain-51-attack/","excerpt":"Blockchain’s Once-Feared 51% Attack Is Now Becoming Regular 원문 Monacoin, bitcoin gold, zencash, verge, 그리고 litecoin cash. 최근 적어도 5건의 암호 화폐가 공격을 받았다. 이들 공격의 경우 모두 공격자들은 네트워크를 손상시키고, 거래를 재조정하며, 은행강도와 동등한 수준으로 수백만 달러를 갈취할 수 있는 컴퓨팅 능력을 보유하고 있었다. 놀라운 사실은, 이들 공격이 모두 소위 51% 공격이라고 알려져 있는 위험한 암호 통화 공격 수단이","text":"Blockchain’s Once-Feared 51% Attack Is Now Becoming Regular 원문 Monacoin, bitcoin gold, zencash, verge, 그리고 litecoin cash. 최근 적어도 5건의 암호 화폐가 공격을 받았다. 이들 공격의 경우 모두 공격자들은 네트워크를 손상시키고, 거래를 재조정하며, 은행강도와 동등한 수준으로 수백만 달러를 갈취할 수 있는 컴퓨팅 능력을 보유하고 있었다. 놀라운 사실은, 이들 공격이 모두 소위 51% 공격이라고 알려져 있는 위험한 암호 통화 공격 수단이라는 것이다. 물론 과거에도 이러한 공격이 성공적으로 실행된 사례가 있었지만, 그렇게 흔한 일은 아니었다. 이러한 일들은 매우 희귀 했고, 일부 전문가들은 마이너들이 어떤 큰 블록체인에 대해 결코 희생되지 않을 것이라고 주장했다. 51%공격을 위해서는, 너무 비싼 비용이 수반된다는 것이 그들의 주장이었다. 그러나 최근 연구 결과에 따르면, 장비를 필요로 하지 않고 단순히 충분한양의 전력만 있으면 쉽게 51% 공격을 할 수 있다는 사실이 밝혀졌다. ¶공격을 살펴보자 암호 화폐는 ‘이중 지출 문제’ 라고 불리는 오랜 컴퓨터 과학 문제를 해결하는 것을 목표로 한다. 본질적으로, 컴퓨터 스스로가 나쁜 행동을 모니터링하고 예방할 인센티브를 만들지 않고서는 금전 시스템을 만들 수 없다. 따라서 마이너들이 전기를 소비하여 하는 행동들이 모두 이러한 것을 목표로 하는 것이다. 51% 공격으로 돈을 벌기 위해서는, 해커들에게 몇가지 요소가 필요하다. 공격자들이 해싱파워를 대부분을 차지 함으로써 할 수 있는 것은 특정 조건하에서 거래 금액을 두배로 뻥튀기 하는 것이다. 예를 들어, 한잔에 3달러 짜리 커피의 거래 금액을 두배로 늘리기 위해 이러한 해싱파워를 차지 하는 것이 아니다. 공격자는 수천 달러 혹은 수백만달러의 거래 금액을 훔칠 수 있을 때만 이러한 투자로 이익을 얻을 수 있다. 해커들은 여러가지 조건을 통해 추가적으로 돈을 벌 수 있을지 확인하는 다양한 방법을 발견했다. 그래서 앞서 언급한 모나코인, 비트코인골드, 젠캐시, 라이트 코인을 노리게 된 것이다. 네트워크 해싱파워의 절반 이상을 축적함으로써, 비트코인 골드 공격자들은 거래소로 송금된 비싼 거래를 두배로 지출하여 이익을 차지 할 수 있었다. 젠캐시의 경우에는 3번의 성공적인 공격을 통해 21,000젠 (50만달러 이상)을 차지 할 수 있었다. ¶작은 코인은 위험에 처해 있다. 하지만 이런 공격이 오랜시간 동안 흔치 않았는데, 최근 왜 갑자기 공격이 터지는 것일까? 작은 코인이 공격 당하는 것은 결코 우연이 아니다. 마이너의 수가 적기 때문에 네트워크의 과반수를 차지하는데 필요한 컴퓨터 성능을 구매/임대하는 것이 상대적으로 쉽기 때문이다. ¶51% 공격의 예상 이익률 젠캐시의 창립자는 마이닝 환경을 효과적으로 임대하고 설치할 수 있는 환경이 구축되어, 더 많은 시간이 나 돈을 쓰지 않고도 이러한 공격이 잦아졌다고 주장했다. 또한, 시장이 더많은 해시 파워를 축적하고 있기 때문에 공격하기가 쉬워지고 있다. Crypto51은 암호화폐가 51% 공격에 당하기 위해서는 얼마나 많은 피용이 필요한지 보여주고 있다. ¶해결책: 더 오래 기다리자 사용자 거래가 사기를 당하지 않도록 하는 한가지 방법은 더 오래된 코인을 승인하거나, 더 많은 확인 과정을 거친, 즉 더 많은 거래들에 의해 승인된 코인 만 받아지도록 하는 것이다. 여러 노드에서 확인 될 수록 51% 공격에서 자금을 훔치기 어렵다. 최초 비트코인골드를 훔친 거래는 다섯번의 확인만을 필요했고, 공격자는 해싱파워로 이 다섯개 확인을 모두 되돌렸다. 이 공격에 대응하여, 현재 비트코인골드는 확인의 횟수를 50회로 늘렸다. 이 때문에, 개발자와 연구들은 해싱파워가 더 큰 블록체인 일 수록, 확인의 필요성이 적어지므로 더 안전하다고 주장한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryotocurrency","slug":"cryotocurrency","permalink":"https://www.yceffort.kr/tags/cryotocurrency/"}]},{"title":"왜 라인은 암호화폐를 만들었을까?","slug":"why-japans-biggest-messaging-app-line-decided-to-create-its-own-crypto","date":"2018-09-05T15:00:00.000Z","updated":"2018-09-06T00:14:32.000Z","comments":true,"path":"2018/09/06/why-japans-biggest-messaging-app-line-decided-to-create-its-own-crypto/","link":"","permalink":"https://www.yceffort.kr/2018/09/06/why-japans-biggest-messaging-app-line-decided-to-create-its-own-crypto/","excerpt":"Why Japan’s Biggest Messaging App Line Decided to Create Its Own Crypto 원문 지난 8월 31일, 일본에서 가장 큰 메세징 앱인 라인이 LINK라고 불리는 자사 고유의 암호화폐를 발행했다. 이 암호 화폐는 올해 7월에 만들어진 BitBox거래소에서만 거래할 수 있다. 라인은 해당 암호화폐를 ICO하지 않는 대신, 에어드랍 형태로 라인 생태계내에서 제품을 활용하는 유저들에게 제공하기로 했다. 본질적으로, LINK는 블록체인 네트워크에서의 활동을 사용자들의 인센티브 화 시켜,","text":"Why Japan’s Biggest Messaging App Line Decided to Create Its Own Crypto 원문 지난 8월 31일, 일본에서 가장 큰 메세징 앱인 라인이 LINK라고 불리는 자사 고유의 암호화폐를 발행했다. 이 암호 화폐는 올해 7월에 만들어진 BitBox거래소에서만 거래할 수 있다. 라인은 해당 암호화폐를 ICO하지 않는 대신, 에어드랍 형태로 라인 생태계내에서 제품을 활용하는 유저들에게 제공하기로 했다. 본질적으로, LINK는 블록체인 네트워크에서의 활동을 사용자들의 인센티브 화 시켜, 개발팀이 배포한 분산 응용 프로그램(DApps)의 채택을 넓히기 위해 고안된 토큰이다. 라인팀은, 가까운 장래에 콘텐츠, 거래, 게임, 거래 등과 관련된 DApps과 서비스를 출시할 것이라고 밝혔다. 이 모든 서비스는 LINK를 지불 수단으로 사용한다. 개념상 LINK는 EOS, ADA, 이더리움등과 유사하다. 즉, DApps 및 블록체인 네트워크에서 제공하는 다양한 서비스에 연료를 공급하는 역할을 한다. ¶DApp 배포를 위한 한국 최대 블록체인 네트워크와 전략적 파트너십 지난 5월 Line은 공식적으로 국내 최대 블록체인 프로젝트인 ICON과 전략적 파트너십을 맺어, UnChain이라는 합작투자회사를 설립, LINK 블록체인 네트워크를 기반으로 DApps를 개발하기 시작했다. ICON 과의 파트너십을 통해 Line은 DApp 배포 프로세스를 가속화하고, 블록체인 네트워크를 유지하는데 필요한 모든 기술과 개발팀을 확보하면서 결국 자체 암호화폐를 만들 수 있다. 그러나 블록체인 메인넷을 구축하는 것은 콘텐츠 제작, 소셜미디어, 디지털 자산 거래 등 메세징 거인의 실제 토큰 이코노미를 위한 이니셔티브의 첫걸음에 불과하다. 앞으로 수년동안 DApps 및 다양한 블록체인 솔루션을 적극적으로 개발하여 수억명의 사용자에게 충분한 서비스가 될 수 있또록 생태계를 개발해야 할 것이다. ¶LINK의 생존력과 실용성 암호 통화 커뮤니티 일부는 개발단계에서, LINK 블록체인 네트워크의 고유 암호 화폐의 생존가능성과 필요성에 대해 의문을 제기 했다. 이에 CEO는 DApp의 생태계를 구축하겠다는 의도를 밝혔지만, 적어도 단기간 내에 사용될 수 있는 정확한 유즈 케이스를 보여주지는 못했다. 텔레그램, 라인, 카카오톡 등 메시지 앱에는 사용자에게 스티커, 이모티콘 및 테마를 판매하는 내재된 시장을 가지고 있다. 가까운 미래에 라인은 LINK과 앞서 언급한 작은 품목 (이모티콘, 스티커 등) 구매에 사용될 것으로 예상되며, Dapp 및 블록체인 생태계가 성장함에 따라 LINK는 라인에 더큰 영향을 미칠 것으로 보인다. 라인은 이더리움, EOS, 에이다와 같은 기존 암호통화를 인센티브의 주요 수단으로 사용할 수도 있다. 그러나 라인 팀은 회사의 장기전략은 라인 메시징 플랫폼에 적용된 DApps를 용이하게 하기 위해 특별히 설계되고 구조화된 블록체인 네트워크를 만드는 것이라고 설명했다. ICON과의 파트너십, 자체 블록체인 네트워크를 만들기로 한 결정에 따라 Link블록체인 네트워크의 핵심 인프라가 확장성 및 다중 프로토콜을 중심으로 진화할 가능성이 크다. 확장성이 높은 다중 체인 프로토콜을 사용하면, 다른 공개 블록체인 네트워크 보다 더많은 트랜잭션을 처리할 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryotocurrency","slug":"cryotocurrency","permalink":"https://www.yceffort.kr/tags/cryotocurrency/"}]},{"title":"저작권을 위해 블록체인이 할 수 있는것, 그리고 없는 것","slug":"what-blockchain-can-and-cant-do-for-copyright","date":"2018-08-30T15:00:00.000Z","updated":"2018-08-30T18:39:37.000Z","comments":true,"path":"2018/08/31/what-blockchain-can-and-cant-do-for-copyright/","link":"","permalink":"https://www.yceffort.kr/2018/08/31/what-blockchain-can-and-cant-do-for-copyright/","excerpt":"What Blockchain Can and Can’t Do for Copyright 원문 저작물을 관리하는데 유용한 시스템이 필요하다고 주장하는 사람들이 꾸준히 있었으며, 복잡한 저작권 관리 시스템의 연구 및 개발은 상업적인 용도로 지속적으로 요청이 있었다. 거래 비용을 낮출 수 있는 시스템이 있었음에도, 이러한 기존의 시스템은 여전히 중앙화된 중개자가 필요하다. ㄷ블록체인 플랫폼은 자동화된 라이센스 및 집행 기능을 수행할 수 있도록 구현할 수 있다. 따라서 블록 체인 플랫폼은 권리 보유자가 중개자가 될 가능성을 제시하거나, 권","text":"What Blockchain Can and Can’t Do for Copyright 원문 저작물을 관리하는데 유용한 시스템이 필요하다고 주장하는 사람들이 꾸준히 있었으며, 복잡한 저작권 관리 시스템의 연구 및 개발은 상업적인 용도로 지속적으로 요청이 있었다. 거래 비용을 낮출 수 있는 시스템이 있었음에도, 이러한 기존의 시스템은 여전히 중앙화된 중개자가 필요하다. ㄷ블록체인 플랫폼은 자동화된 라이센스 및 집행 기능을 수행할 수 있도록 구현할 수 있다. 따라서 블록 체인 플랫폼은 권리 보유자가 중개자가 될 가능성을 제시하거나, 권리 보유자와 사용자간의 관계를 직접 중개할 수 있다. 블록체인 프로토콜은 또한 관할 구역에서 운영되어 국가 집단 라이센스 시스템 및 상호 관계의 복잡성과 부조리 함을 제거할 수 있다. 또한 실시간 콘텐츠 배포 네트워크, 자동화된 라이센스 에이전트 및 라이세스 조건을 자동화하고, 사용자 신원가 상호 작용할 수 있는 개방형 DRM 시스템에 연결할 수 있다. 이러한 기술 시스템을 관리하기 위해선서는 일단 새로운 법률 구조가 필요하다. 블록체인의 기술인프라는 분쟁 해결기관의 결정과 연동될 필요가 있다. 예를 들어, 어떤 권리를 소유했는지, 지정된대로 수행된 자동화된 라이센스인지에 대한 분쟁이 존재할 수 있다. 예를 들어, 저작권 예외와 관련된 법안을 입법하기 위하 스마트 컨트랙트 시스템으로 이러한 법안을 번역할 필요가 있다. 스마트 컨트랙트는 기술 코드의 매개변수를 넘어서 편집하거나 삭제할 수 없다. 법률 거버넌스에 필요한 적응력을 갖춘 인프라 구축하기란 단순한 일이 아니다. 블록체인 라이센스는 개인 만이 이용할 수 있는 것은 아니다. 게시자는 저작물의 ‘롱테일’ 경제의 특점에서만 시스템으로 사용하는 것이 거래비용에 유익하기 때문에, 출판사보는 개인보다 더 중요한 사용자 계층일 수 있다. 또한 민간 블록체인이 더 나은 접근바식일 수 있음을 나타내는 정보, 데이터 무결성을 검증하는 것과 관련하여 기술적 인프라를 관리하기 위핸 새롱누 중개자의 도입이 요구될 수 있다. 이러한 모든 문제는 저작권의 법적 시스템을 블록체인 기술에 연결하기 위해 해결해야 한다. 이러한 모든 문제가 어떻게 해결될지는 불분명하지만, 향 후 10년 동안 블록체인 프로토콜은 저작권 시스템 개발 및 해당 시스템에 의존하는 산업에 중요한 영향을 미칠 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"어떻게 블록체인이 의료비용을 낮추는가?","slug":"How-blockchain-could-help-lower-health-costs","date":"2018-08-30T15:00:00.000Z","updated":"2018-08-30T18:39:37.000Z","comments":true,"path":"2018/08/31/How-blockchain-could-help-lower-health-costs/","link":"","permalink":"https://www.yceffort.kr/2018/08/31/How-blockchain-could-help-lower-health-costs/","excerpt":"How Blockchain Could Help Lower Health Costs 원문 저렴한 의료 서비스를 지속적으로 추진하면서 생기는 가장 큰 걸림돌 중 하나는, 의사, 보험사, 병원, 환자 간에 전자 데이터가 공유되는 방식이 혼란스럽고 오류가 많다는 것이다. 이에 대한 해결책이 블록체인이 될 수 있다. 미국의 의료 서비스는 다양한 기록체계가 얽혀있는 상황에서, 의사, 보험사, 병원 직원들이 환자 데이터를 여러번 재입력하면 잘못된 정보가 입력 될 가능성이 커진다. 이러한 오류는 환자가 받는 치료의 질에 심각한 영향을 미칠 수","text":"How Blockchain Could Help Lower Health Costs 원문 저렴한 의료 서비스를 지속적으로 추진하면서 생기는 가장 큰 걸림돌 중 하나는, 의사, 보험사, 병원, 환자 간에 전자 데이터가 공유되는 방식이 혼란스럽고 오류가 많다는 것이다. 이에 대한 해결책이 블록체인이 될 수 있다. 미국의 의료 서비스는 다양한 기록체계가 얽혀있는 상황에서, 의사, 보험사, 병원 직원들이 환자 데이터를 여러번 재입력하면 잘못된 정보가 입력 될 가능성이 커진다. 이러한 오류는 환자가 받는 치료의 질에 심각한 영향을 미칠 수 있으며, 작은 불일치는 보험 적용 거부를 초래하거나, 시스템 비용이 증가하게 된다. 이와 대조적으로 블록체인은 환자, 보험업자, 공급자를 모두 같은 영역에 넣는다. 블록체인 기술은 정보를 관리하는데 드는 비용도 적고, 분산된 접근 방식 덕분에 모든 당사자들이 강력한 암호화 데이터의 원본에 접근하여 의료 서비스를 제공할 수 있으며, 데이터가 변경될때 마다 흔적을 남겨 정보의 무결성과 진위성을 보장한다. 결국 블록체인을 활용하여 모든 개별 환자에게 안전하고 정확한 병력을 제공할 수 있다. MIT 에서 개발중인 블록체인 시스템인 MedRec은 환자가 자신의 기록을 관리하고 다른 의사 또는 제공자에게 기록에 엑세스 하고 업데이트 할 수 있도록 설계되었다. 예를 들어, 다른 의사가 예방접종을 놓아주었다면, 모든 정보를 블록체인에서 얻을 수 있다. MedRec은 의료 제공자가 모든 환자 의료 데이터를 다루는 것을 목표로 하지만, 이미 다른 프로젝트에서는 보험 청구 프로세스, 의료 정보 제공자의 정확성, 의사 라이센스를 확인할 수 있는 능력과 같은 의료 관리 시스템의 여러부분에 블록체인을 활용하고 있다. 지난 1월, Change Healthcare는 보험 청구를 처리하기 위한 블록체인 시스템을 도입, 80만명의 의사, 117,000명의 치과 의사및 6만여개의 약국에서 사용하고 있다. 여기에서는 모든 당사자가 데이터의 전후관계를 살피지 않아도 실시간으로 청구에 대한 동일하고 정확한 정보를 볼 수 있다. 이렇게 하면 환자가 정보를 확인하기 위하여 여러 당사자에게 연락해야 하는 부담을 덜어준다. 데이터가 변경될 때 마다, 디지털 원장에 기록이 표시되어 책임이 있는 당사자를 식별한다. 변경사항은 관련 당사자의 검증이 필요하며, 기록의 정확성을 다시 확인하는 절차를 거친다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인 에너지 소비 인덱스","slug":"bitcoin-energy-consumption","date":"2018-08-29T15:00:00.000Z","updated":"2018-08-29T18:39:16.000Z","comments":true,"path":"2018/08/30/bitcoin-energy-consumption/","link":"","permalink":"https://www.yceffort.kr/2018/08/30/bitcoin-energy-consumption/","excerpt":"Bitcoin Energy Consumption Index 원문 설명값현재 추산되는 비트코인 연간 전력 소비랑73.12 TWh현재 추산되는 비트코인 연간 전력 최소 소비량53.8 TWh연간 전세계 마이닝 수익$5,389,021,006연간 전세계 마이닝 비용$3,656,073,069현재 채굴 대비 이익 비율67.84%비트코인 전력 소비량과 비슷한 국가Austria전일 비트코인을 위해 소비된 전력량200,332,771GH/s 당 와트0.16총 네트워크 해시 비율53,324트랜잭션 당 전력 소비량929비트코인 전력을 사용할 수 있","text":"Bitcoin Energy Consumption Index 원문 설명 값 현재 추산되는 비트코인 연간 전력 소비랑 73.12 TWh 현재 추산되는 비트코인 연간 전력 최소 소비량 53.8 TWh 연간 전세계 마이닝 수익 $5,389,021,006 연간 전세계 마이닝 비용 $3,656,073,069 현재 채굴 대비 이익 비율 67.84% 비트코인 전력 소비량과 비슷한 국가 Austria 전일 비트코인을 위해 소비된 전력량 200,332,771 GH/s 당 와트 0.16 총 네트워크 해시 비율 53,324 트랜잭션 당 전력 소비량 929 비트코인 전력을 사용할 수 있는 미국 가정 수 6,770,506 단일 거래로 소비되는 전기를 사용할 수 있는 미국 가정 수 31.41 전세계 전력 소비량 대비 비트코인 전기 소비량 0.33% 연간 탄소 배출량 35,830 거래당 탄소 배출량 455.44 ¶기본적인 사실 비트코인의 신뢰 최소화 합의가 시작된 이래로, 비트코인의 작업증명 알고리즘에 의해 운영되고 있다. '작업’을 수행하는 기계는 현재 엄청난 양의 에너지를 소비하고 있다. 이 데이터에는 Bitcoin과 BitcoinCash가 포함되어 있다. ¶마이너들은 무슨 작업을 하는가? 소위 마이너들이 약 10분 마다 비트코인의 블록체인에 새로운 블록을 추가한다. 마이너들은 서로 신뢰하지 않아도 되며, 여기서 마이너들이 신뢰하는 유일한 것은 비트코인을 운영하는 코드다. 이 코드에는 새로운 트랜잭션을 검증하는 몇가지 규칙이 포함되어 있다. 예를들어, 송신자가 실제로 송신하는 금액을 소유하는 경우에만 트랜잭션이 유효하다. 모든 마이너들은 이러한 규칙을 준수하는지 여불르 개별적으로 확인하여 다른 마이너를 신뢰할 필요성을 제거한다. 여기서 트릭은 모든 마이너들이 동일한 거래 히스토리에 동의하도록 하는 것이다. 네트워크의 모든 마이너는 블록체인에 다음 거래 배치를 준비하는 임무를 끊임없이 수행한다. 이 블록중 하나만 무작위로 선택되어 체인의 최신 블록이 된다. 분산 네트워크에서 무작위로 선택하는 것은 쉽지 않으므로, 여기서 작업 증명이 이루어진다. 작업 증명에서 다음 블록은 유효한 블록을 생산하는 첫번째 마이너에게서 나타난다. 네트워크의 모든 마이너가 평균 10분 마다 하나의 유효한 블록을 생산할 수 있도록 프로토콜에 의해 난이도가 정기적으로 조정된다. 마이너가 마침내 유효한 블록을 생산하면 이를 나머지 네트워크에 알린다. 다른 마이너들은 이 블록이 모든 규칙을 준수한다는 것을 확인한다음 자신이 작업한 블록을 폐기한다. 첫번째 블록을 만든 행운의 마이너는 블록에 처리된 거래에 속한 수수료화 함께 고정된 양의 비트코인을 보상으로 받는다. 그리고 다음 사이클이 다시 시작된다. 유효한 블록을 생산하는 과정은 주로 시행착오에 기반하고 있다. 마이너들은 매초마다 ‘nonce’ 라고 불리는 블록 구성요소에 대한 올바른 값을 찾기 위해 시도하며, 완성된 블록이 요구 사항과 일치하기를 희망한다.(결과를 예측하는 방법이 없다. 그저 시도할뿐) 이런 이유로 마이닝은 자신의 번호를 선택할 수 있는 복권과 비교 되기도 한다. 초당 시도의 수는 채굴장비의 해시레이트에 주어진다. 일반적으로 초댕 10억개의 해시를 처리한다. ¶지속성 이러한 계속된 블록 채굴 사이클은 전세계 사람들에게 비트코인 채굴을 장려한다. 마이닝이 견고한 수익 흐름을 제공하므로, 사람들은 전력 소비가 큰 기계를 운영하여 블록을 만들 의향이 있다. 수년에 걸쳐 통화 가격이 계속 최고치를 갱신함에 따라 비트코인 네트워크의 총 에너지 소비가 계속해서 증가되었다. 비트코인 네트워크 전체는 현재 국제 에너지기구가 발표한 보고서를 기반으로 여러 국가를 합친 것 보다 더 많은 에너지를 소비한다. 비트코인이 국가라면, 에너지 소비 순위는 아래와 같다. 이와 별도로 비트코인 에너지 소비량을 세계 최대 에너지 소비국과 아래와 같이 비교할 수도 있다. ¶탄소 배출 비트코인의 가장 큰 문제는 엄청난 에너지 소비량이 아니라, 이러한 전력을 중국 석탄 화력 발전소가 대부분 연료 공급을 한다는 것이다. 석탄 기반 전기는 매우 낮은 가격에 이용가능하다. 보수적으로 계산하더라도, 비트코인 거래에 대해 극단적인 탄소배출을 요구한다. ¶비트코인 에너지 소비량을 다른 지불 시스템과 비교 비트코인 네트워크가 소비하는 에너지를 VISA와 같은 다른 지불 시스템과 비교할 수 있다. VISA에 따르면, 이회사는 모든 작업에 대해 전세계쩍으로 총 674,922기가 줄의 에너지를 소비했다. 이는 VISA가 약 17,000 가구의 에너지 수요와 동일한 수요를 갖고 있음을 의미한다. 또한 VISA가 2017년 1112억건의 거래를 처리했다는 사실도 알고 있다. 이 수치를 통해 비교하면 아래와 같다. (아래 차트는 단일 비트코인 거래를 10만 VISA거래와 비교했다.) 물론 이 수치는 완벽하지 않다. (예를 들어 VISA 사무소의 에너지 소비는 포함되지 않았다) 그러나 그 차이는 너무 극단적이어서 포함 여부와 상관없이 충격적이다. 일반 금융 시스템의 평균 비현금거래와 비교하면 비트코인 거래에는 평균 수천배의 에너지가 필요하다는 것을 알 수 있다. 이는 신뢰할 수 있는 제3자가 필요없는 거래에 수반되는 가격이라고 치기에는 너무 높다. ¶대안 작업 증명은 스스로를 증명할 수 있는 최초의 합의 알고리즘이지만, 이것이 유일한 합의 알고리즘은 아니다. 최근엔 지분 증명과 같은 에너지 효율적인 알고리즘이 개발되고 있다. 지분 증명은 마이너가 아니고 소유주가 블록을 생성하므로, 가능한 많은 해시를 생산하는 전력 소비 기계가 필요하지 않다. 비트코인은 잠재적으로 이러한 합의 알고리즘으로 전환하여 지속 가능성을 향상 시킬 수 있다. 여기서 유일한 단점은, 아직 이러한 합의 알고리즘에 여러가지 버전이 있으며 이들중 어느것도 완전히 입증되지 않았다는 것이다. 그럼에도 이러한 알고리즘에 대한 연구는 미래에 좋은 희망을 제공한다. ¶비트코인 에너지 소비량 측정","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"암호 화폐 사기의 특징","slug":"bitcoin-wannabes-show-hallmarks-of-fraud","date":"2018-08-29T15:00:00.000Z","updated":"2018-08-29T18:39:16.000Z","comments":true,"path":"2018/08/30/bitcoin-wannabes-show-hallmarks-of-fraud/","link":"","permalink":"https://www.yceffort.kr/2018/08/30/bitcoin-wannabes-show-hallmarks-of-fraud/","excerpt":"Buyer Beware: Hundreds of Bitcoin Wannabes Show Hallmarks of Fraud 원문 암호 화폐로 인해 과열된 시장에서 수백개의 테크 회사들이 사기를 바탕으로 투자자들을 유혹하고 있다. WSJ는 1450여개의 ICO를 위해 제작된 문서를 검토한 결과 표절된 문서, 수익 모델 및 가짜 임원이 포함되어 있는 위험한 ICO 271개를 발견했다. \"Jeremy Boker\"는 온라인 지불 프로젝트인 Denaro의 공동 설립자로 등록되어 있었다. 그는 3월 830만달러를 모금했다고 주장한 투자자 문","text":"Buyer Beware: Hundreds of Bitcoin Wannabes Show Hallmarks of Fraud 원문 암호 화폐로 인해 과열된 시장에서 수백개의 테크 회사들이 사기를 바탕으로 투자자들을 유혹하고 있다. WSJ는 1450여개의 ICO를 위해 제작된 문서를 검토한 결과 표절된 문서, 수익 모델 및 가짜 임원이 포함되어 있는 위험한 ICO 271개를 발견했다. &quot;Jeremy Boker&quot;는 온라인 지불 프로젝트인 Denaro의 공동 설립자로 등록되어 있었다. 그는 3월 830만달러를 모금했다고 주장한 투자자 문서에서, 암호화폐 스타트업의 강력한 팀 인 것을 자랑했다. 그리고 그는 자신의 이력에서 Denaro에서 일하기전에 컨설팅 회사에서 일한 경력이 있음을 언급했다. 사실 저 인물의 사진은 그냥 단순한 stock photo였고, 그가 존재한다는 증거는 없었다. 나머지 팀은 허구인 것 처럼 보였다. Denaro의 뒤에 있는 실체를 확인할 수 없었고, 그 회사에 연락하려는 시도들은 답이 없었다. Boker로 알려진 이 이미지는 사실 폴란드의 한 은행원인 것으로 밝혀졌다. 개인 웹 사이트에 자신의 사진을 게시한 실제 폴란드 은행원은 이 사실에 대해 충격적이라고 밝혔다. 당연하지만 denaro 웹사이트는 닫혀있는 상태다. 사이트가 궁금하다면 Wayback Machine을 통해 확인할 수 있다. 온라인 거래 기록등을 검토한 결과, 이러한 위험한 ICO 271개에 약 10억 달러 이상이 투자된 것으로 밝혀졌다. 기업들은 여전히 자금을 모으고 있거나, 혹은 폐쇄되었다. 소송 및 규제 조치에 따르면 투자자들은 이러한 프로젝트에서 최대 2억 7,300만 달러의 손실을 입었다고 주장했다. 기업들은 코인을 이용하여 자신의 디지털 화폐를 판매하고 자금을 조달한다. 비트코인 열풍에 휩싸인 이러한 프로젝트들은 2014년 이래로 영미권 사용자들을 겨냥하고 있었다. 리서치 회사인 Satis Group에 따르면 2017년 부터 암호화폐가 전세계쩍으로 90억 달러 이상의 수익을 창출한 것으로 밝혀졌다. 12월 이래로 증권거래위원회는 ICO와 관련된 4가지 사례에 대해서 회사와 개인에 대한 민사 소송을 제기 했다. 적어도 12개의 기업이 질문에 대한 응답을 보류하고 있다고 밝혔다. 대부분의 이런 ICO의 핵심에는 회사의 미션, 팀원 및 프로젝트 기술적 세부사항을 자세히 설명하는 회사의 백서 (whitepaper)가 존재했다. 그러나 1450개의 백서중 111개가 다른 백서에서 사용한 단어를 전체 섹션에서 반복하는 것을 발견했다. 이러한 복사된 단어에는 마케팅 계획, 보안 문제 및 다른 프로그래머 개발한 데이터베이스와 상호 작용할 수 있는 방법과 같은 기술 기능이 포함되어 있었다. 적어도 121개 프로젝트는 직원이름 한명 조차 밝히지 못했고, 그들 중 몇명은 앞선 사례 처럼 존재하지 않거나 실제 신원에 대한 인지 없이 사용되고 있는 사람들이었다. 또한 SEC가 금지하는 위험부담없이 투자자에게 금전적인 보상을 약속하는 24개 이상의 기업도 확이되었다. 이 백서는 매주 수익을 보장하거나, 두 배이상의 수익률을 보장했다. 심지어 한달내 1354%의 이익을 약속하여 1500만달러를 모금한 PlexCorp에 대해 법적인 조치를 취하기도 했다. 이 기업은 이메일에 응답하지 않았다. 23일 페이스북에 해당 프로젝트는 죽지 않았으며, 일부 법원 명령이 프로젝트 개발을 못하게 하여 보류 중이라는 성명서을 올리기도 했다. (아래 참고) 비트코인과 암호 화폐에 대한 관심은 작년말 사상 최고치를 기록하면서 폭발 했다. 규제 기관이 조사를 강화하고 투자자들에게 사기에 대한 경고를 보내면서 업계의 많은 사람들에게 영향을 미치고 있다. 기업 공개와는 다르게, ICO는 엄격한 규제 틀 밖에서 발생하며 공식 서류를 많이 제출할 필요가 없다. 그래서 투자자들은 무엇이 진짜고 아닌지에 대해 상당부분 유추해야 한다. 금융 산업 규제 기관(Financial Industry Regulatory Authority) 전직집행위원장은 ‘복사된 표현, 직원의 부재, 높은 수익을 보장하는 것은 투자자들에게 경고하는 신호’ 라고 언급했다. 이런 시장에서 먹이를 찾기위해 프리랜서들은 다돈 100달러에 백서를 쓰기 시작했다. 또한 적어도 5개의 프로젝트가 온라인 stock 이미지나 다른 사이트에서 직접 가져온 이미지로 백서나 웹사이트를 채웠다. PremiumTrade (역시 사이트 접근이 안되서 waybackmachine으로 대체) 가 대표적인 경우다. 여기에서 나오는 CEO는 사실 그냥 흔히 찾을 수 있는 stock 이미지다. 이 아저씨는 다른 사이트에서도 이미지가 사용 중이다. {:width=“200px”} {:width=“200px”} 사이트에서 쓰인 이미지 stock 이미지 {:width=“400px”} 해당 사이트에서 팀원이라고 밝힌 사람들의 사진이 온라인 상에서 사용된 횟수 이 사이트는 가장 극단적인 사례였다. 5인조 경영진은 이미지는 거의 500개의 관련 ㅇ벗는 사이트에서 사용중이었다. 이 사이트는 여러건의 연락에도 답이 없었다. 지난해부터 돈을 모으기 시작한 프로젝트 LoopX는 가장 진보된 거래 플랫폼을 구축하겠다고 주장했다. 이 회사는 어떤 팀원 이름도 밝히지 않았고, 플랫폼을 어떻게 구축할 건지도 밝히지 않았다. 백서는 다른 코인 프로젝트와 동일한 몇가지를 주요 항목으로 언급했다. Along this journey, we found great partners and mentors who were strongly committed and excited to work with the ever-progressing vision 이 문구는 여러 코인 백서에서 동일하게 언급되는 문구다. UTRUST 가 원본이다. LoopX BITLIONCOIN 450만 달러를 모금했다고 주장한 이후에, 이 회사는 2월초에 인터넷에서 사라졌다. (하지만 지금은 다시 접속이 된다.) 웹사이트는 다운되었고, 트위터 계정에는 창업자가 도망쳤다고 주장하는 뉴스기사들이 속속 나왔다. UTURST의 CEO는 해당 백서가 표절된 사실을 알고 있었지만, 그에 대해 별다른 조치를 취할 필요를 못느낀다고 말했다. 그는 백서 사본이 이미 많이 돌아다니고 있으며, 심지어 자신의 사진, 인상착의, 팀, 웹사이트까지도 복사되고 있다고 말했다. 샌프란시스코 미디어 제작사 공동 소유주인 Amanda Gavin은 자신이 이름도 들어본적이 없는 Pixiu에서 이미지가 사용중이었다. 황당하게도, 실존인물의 링크드인 링크까지 연결해두었다. 당연히, 그녀의 링크드인의 페이지에는 해당 코인에 대한 이력이 없다. Paragon Coin은 캘리포니아 연방법원에 제기된 소송에 따르면, 공개당시 7천만 달러 이상을 모금했는데 이 사업은 ‘매우 야심차고, 모호하며, 비현실적인’ 부동산 투자라고 주장하고 있다. 이 코인은 ‘블록체인을 통해 대마초 산업에 연결할 것’ 이라고 회사 백서에 밝혔다. 올 7월, 이 회사는 LA에서 독점적으로 암호 통화를 지불하는 공동 작업 공간을 열 계획이다. 이 코인의 최고 경영자는 “가능한 모든 법률을 준수하고 ICO 프로세스 전체에서도 준수하고자 노력했다” 라고 성명서에 밝혔다. 그러나 현재 연락이 닿지 않는 상태다. Denaro ICO가 종료된 후, 해당 기업의 웹사이트는 불투명해졌고, 투자자들은 소셜미디어를 통해 창업자들이 수백만달러를 가지고 도망쳤다고 주장했다. Daniel Amstrong은 Denaro에서 프리랜서로 일했다고 말했는데, 회사의 문서를 편집하면서 이 스타트업은 편집된 문서, slack메시지 등으로 미뤄보았을 때 리투아니아인들이 운영했다고 믿었다. 그는 그들을 위해 마케팅 용 문서를 작성했으며, 원어민이 아닌 사람이 엉망으로 작성해 보냈었다고 밝혔다. Denaro는 죽지않았다. 최근에는 Pluto Coin이라고 하는 비슷한 웹사이트와 동일한 백서가 있는 새로운 지불 시스템에 대한 제안이 등장했다. Denaro 팀원 중 절반이 이 코인에 재활용 되었는데, 여기에는 앞서 언급한 Boker도 있었다. 그의 이름은 Denver로 바뀌었다. {:width=“200px”} Denaro에서 사용되었던 CFO ‘JEREMY BOKER’ 출처 Pluto Coin에서 사용되었던 CFO ‘IVAN DENVER’ 출처 현재 사이트 접속은 되지만, 팀원들 목록은 가린 상태며, waybackmachie으로 본 결과 그의 존재 흔적(?) 을 발견할 수 있었다. Pluto Coin은 투자자들에게 최소 1000만달러를 모았다고 주장했다. 그러나 해당 사이트는 연락이 닿지 않았다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"민주주의에서 블록체인: 암호경제를 통한 유권자 참여의 인센티브화","slug":"incentivizing-voter-participation-through-cryptoeconomics","date":"2018-08-28T15:00:00.000Z","updated":"2018-08-28T18:39:16.000Z","comments":true,"path":"2018/08/29/incentivizing-voter-participation-through-cryptoeconomics/","link":"","permalink":"https://www.yceffort.kr/2018/08/29/incentivizing-voter-participation-through-cryptoeconomics/","excerpt":"Democracy on the Blockchain: Incentivizing Voter Participation through Cryptoeconomics 원문 민주주의는 투표라는 공개 과정을 통해 특정 인구 집단이 지도자를 선택하는 거버넌스의 한 종류다. 많은 문제점을 가지고 있기는 하지만, 정치적 거버넌스의 가장 좋은 형태 중 하나로 널리 알려져 있다. ¶민주주의는 작동하고 있는가? 연구자들은 매년 세계 행복보고서와 민주주의 국가에 높은 순위를 가지고 있는 국가들 사이에 평행선이 있음을 볼 수 있었다. 건강한 민주주의 국가","text":"Democracy on the Blockchain: Incentivizing Voter Participation through Cryptoeconomics 원문 민주주의는 투표라는 공개 과정을 통해 특정 인구 집단이 지도자를 선택하는 거버넌스의 한 종류다. 많은 문제점을 가지고 있기는 하지만, 정치적 거버넌스의 가장 좋은 형태 중 하나로 널리 알려져 있다. ¶민주주의는 작동하고 있는가? 연구자들은 매년 세계 행복보고서와 민주주의 국가에 높은 순위를 가지고 있는 국가들 사이에 평행선이 있음을 볼 수 있었다. 건강한 민주주의 국가들이 행복지수에서 높은 순위에 올라가 있다는 것을 발견했다. 물론, 행복지수에 기여하는 다른 요인이 있을 수 있지만, 이둘 사이에 상관관계가 있을 가능성이 더 높다. 이상적인 형태로, 민주주의는 소수민족의 인권을 보호하면서 대다수 인권의 열망을 적절한 형태로 표현해야 한다. 또한 투표 과정은 유권자를 위한 강제, 강압, 폭력 없이 수행되어야 한다. 그러나 실제로는 민주적인 절차와 그들을 지원하고 지지하는 제도가 그다지 민주적이지 않아 많은 사람들의 분노를 사고 있다. 민주주의가 직면한 도전은 무수히 많고 점점더 복잡해지고 있다. 그러나 이러한 문제는 크게 세가지로 나눌 수 있다. 정보, 인구와 유권자 문제, 그리고 마지막으로 정부와 유권자, 정책임안자들 사이에 어떻게 전달되는가 하는 문제다. ¶세발의 야수 정보는 민주주의의 필수적인 요소다. 모든 지식을 가지고 있는 유권자 만이 자신의 열망을 대표하는 선택을 할 수 있기 때문이다. 그러나 정보를 제공하는 메커니즘이 여러면에서 오작동 하고 있다는 것이 점점더 분명해지고 있다. 가짜뉴스 현상부터 기업이 후원하는 연구에 이르기까지, 사람들은 신뢰할 수 없는 정보에 노출되는 경우가 많다. 많은 가짜 뉴스 소스가 미디어의 경계 내에서 작동하지만, 문제는 주류 미디어에도 존재한다. 오늘날의 세계가 빠르게 움직이는 특징으로 인해 매스미디어 출판물은 사실이 아닌 감각주의를 위해 설계된 헤드라인을 통해 저널리즘이 변질되고 있다. 또한 미디어 하우스가 주요 정치적 성향에 부합하는 꼭기로 뉴스를 발표할 가능성이 높아지면서 객관성이 계속해서 공격받고 있다. 부적절한 정보의 문제는 유권자에게 큰 문제로 다가온다. 포퓰리즘은 불완전하고 때에 따라서 완전히 잘못된 정보를 기반으로 결정을 내리게 된다. 불행히도, 올바른 정보에 노출되지 못하는 시민들은 정치인들이 제안하는 단기 정책에 계속해서 흔들릴 가능성이 크다. 더 중요하나 것은, 이들은 또한 민족주의 또는 극단주의 정치 철학에서 비롯된 해로운 아이디어에 더 취약해 진다는 것이다. 게다가, 유권자의 무관심은 전세계적으로 증가하는 추세다. 선거기간 동안 투표에 나선 사람들의 수는 민주주의 건강을 나타내는 지표다. 이는 사람들이 민주적인 과정을 믿고 선출된 지도자들에게 믿음을 보내준다는 것을 의미한다. 통계에 따르면, 이러한 유권자의 무관심은 전세계적으로 민주주의가 직면한 보편적인 문제다. 2011년에서 부터 2015년까지 기간을 살펴보면, 전세계 유권자 투표율이 계속해서 부족한 것으로 나타났다. 1940년대와 1980년대 사이에 유권자 투표율이 가장 높았던 유럽에서 유권자 투표율이 1990년대 이후 크게 감소했다. 유럽의 쇠퇴는 다른 지역의 감소보다 중요하다. 아시아와 미주 지역에서는 유권자 투표율이 시간이 지남에 따라 안정적으로 보여지고 있다. 그러나 두 지역 모두 투표율은 1940년대 이후 세계 평균 보다 훨씬 낮았다. 아프리카는 일반적으로 1950년대 이후 전체 기간 동안 가장 낮은 투표율을 보인다. 정치인들은 단기적인 정책을 추구하여, 두번째 혹은 더 오랜 임기를 보장하기 위해 유권자들에게 더 좋게 보이기 위해 노력할 것이다. 이러한 지속불가능한 정책을 지속적으로 제정하면 불안정한 국가와 민주주의가 생겨난다. 분명한 결론은, 민주주의는 현재 어려움에 직면하고 있으며, 이를 재조정하기 위한 조치를 취해야 한다는 것이다. ¶경제 문제로서의 민주주의 호주 대학에서의 한 논문은 블록체인 기술을 활용하여 민주주의를 향상시키는 방법을 탐구하는 논문을 발표했다. 이 논문의 제목은 'The economics of crypto-democracy’다. 이 논문에서, 선거 과정에서 블록체인을 적용할 수 있는 방법을 탐구한다. 또한 연구자들은 기술의 고유한 특징이 잘 작동하는 민주주의에 필수적인 원칙을 더욱 향상 시킬 수 있다고 주장한다. 블록체인은 불변의 정보를 추적하는 것이 가능한 네트워크 이므로, 이 기술은 민주적인 과정에서 도움을 줄 수 있다. 연구자들은 중앙 선거 기관이 마련한 선거의 맥락에서 블록체인 기술이 보안 및 보존의 기능으로 인해 사용될 수 있음을 발견했다. ¶2차 투표 이 논문에서는 2차 투표의 개념을 소개한다. 2차 투표는 블록체인 기술을 민주적인 과정에서 추가함으로써 가능한 메커니즘이다. 이는 투표에 경제적 측면을 도입함으로써 작동한다. 민주주의에 존재하는 1인 1표제에서 가장 큰 문제는 유권자가 당면한 문제에 얼마나 많은 관심을 갖고 있는지 설명하지 않는다는 것이다. 2차 투표는 유권자가 투표한 각 투표에 토큰을 지급한다는 것을 의미한다. 이들이 뭔가를 위해 투표를 하기를 원한다면, 자금을 송금해야 한다. 유권자가 특정 문제에 얼마나 관심이 있는지에 따라 투표를 하고 지불한다. 투표를 하려면 돈을 지불해야 한다. (예 1표당 1달러, 2표당 2달러, 3표 9달러, 10표 100달러 등…) 이러한 지불에 사용된 토큰은 모든 유권자들에게 재분배 될 수 있는 풀에 모이게 된다. 따라서 2차 투표는 투표 가격 책정과 투표권의 재배치 매커니즘이라고 볼 수 있다. 추가된 재정적 인센티브를 통해 유권자들의 무관심의 문제를 다룰 수 있다. 이는 아직 초기 단계에 있는 아이디어지만, 오늘날 민주주의가 직면한 문제를 해결할 수 있으며, 이를 적용할 경우 매력적인 해결책이 될 수 있다. 암호 경제적으로 주도된 모델을 통해 미래의 민주주의는 현재 국가 보다 사회에 더 많은 혜택을 주는 새로운 형태를 취할 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"세그윗이란 무엇인가?","slug":"what-is-segwit","date":"2018-08-28T15:00:00.000Z","updated":"2018-08-28T18:39:16.000Z","comments":true,"path":"2018/08/29/what-is-segwit/","link":"","permalink":"https://www.yceffort.kr/2018/08/29/what-is-segwit/","excerpt":"What is SegWit? 원문 Segwit (Segregated Witness)는 데이터 저장 방법을 변경하는 프로토콜을 업그레이드 하는 방식이다. 이는 2017년 5월 10일에 라이트코인에서 최초로 활성화되었고, 2017년 8월 23일에는 비트코인에서도 활성화되었다. 개발자 Pieter Wiulle은 2015년 12월 Scaling Bitcoin 컨퍼런스에서 아이디어를 처음 발표했다. 많은 사람들은 비트코인 스케일링 문제에 대한 오랫동안 기다려온 해결책으로 굉장히 환영했다. 주 프로토콜의 최대 블록크기 1mb는 비트코인","text":"What is SegWit? 원문 Segwit (Segregated Witness)는 데이터 저장 방법을 변경하는 프로토콜을 업그레이드 하는 방식이다. 이는 2017년 5월 10일에 라이트코인에서 최초로 활성화되었고, 2017년 8월 23일에는 비트코인에서도 활성화되었다. 개발자 Pieter Wiulle은 2015년 12월 Scaling Bitcoin 컨퍼런스에서 아이디어를 처음 발표했다. 많은 사람들은 비트코인 스케일링 문제에 대한 오랫동안 기다려온 해결책으로 굉장히 환영했다. 주 프로토콜의 최대 블록크기 1mb는 비트코인이 처리할 수 있는 트랜잭션의 수를 초당 약 7개로 제한한다. 이는 비트코인의 잠재적인 성장을 제한하고, 많은 양을 처리하는 지불 시스템이 되는 것을 막을 것이다. 업그레이드로 인해 비트코인 블록에서 더 많은 수의 트랜잭션이 가능해졌지만, SegWit의 초기 의도는 트랜잭션 가단성을 해결하기 위한 것이었다. Segwit은 서명정보를 제거하고 기본 트랜잭션 블록 외부에 저장하여 해당 문제를 해결했다. 이를 통해, 트랜잭션 ID에 영향을 미치지 않고 서명 및 스크립트를 변경할 수 있었다. ¶슬리밍 다운 서명정보가 없어지므로써 중요해진 장점 중 하나는 거래가 한층 가벼워졌다는 것이다. 즉 블록에 더 많은 정보를 담을 수 있으며, 비트코인은 블록 크기를 변경하지 않고 더 큰 처리량을 처리할 수 있게 되었다. SegWit은 '블록무게’라는 사로운 개념을 도입했다. 이는 블록크기의 매시업으로 4mb로 제한되고, 기본 트랜잭션 블록의 크기는 1mb로 유지된다. 즉, 이 업그레이드는 이전 프로토콜과 호환되며 하드포크가 필요하지 않다. 따라서 Segwit은 블록 크기 제한을 침해하지 않으며, 1mb사이즈 내에서 더 많은 수의 트랜잭션을 가능하게 한다. 4mb 제한에는 기술적으로 1mb 기본 트랜잭션 블록의 일부가 아닌 분리된 데이터가 포함된다. ¶Building on Top SegWit이 가능하게 한 또 다른 발전은 라이트닝 네트워크와 같은 두번째 계층 프로토콜의 개발을 지원하다는 것이다. 가단성 수정은 확인되지 않은 트랜잭션에 의존하는 모든 기능을 덜 위험하고 설계하기 쉽도록 만들었다. 라이트닝 네트워크는 사용자가 준비될때만 비트코인 블록체인에 저장할 수 있도록 하면서, 빈번하고 작은 트랜잭션을 오프 체인으로 사용하여 비트코인 트랜잭션 용량을 더욱 향상시킨다. Segwit의 활성환느 또한 더 복잡한 비트코인 스마트 계약을 가능하게 하는 등 다른 개발 작업을 향상 시켰다. ¶모두가 행복하지는 않다. 비트코인 커뮤니티의 모든 사람들이 세그윗이 비트코인이 기다리던 솔루션이라는 것에 동의하는 것은 아니다. 어떤 사람들은 이 해결책이 언발에 오줌누기 식의 임시방편이라고 이야기 한다. 세그윗에 더한 저항은 새로운 거래 구조에 의존하는 것이 아닌, 더 블록 크기 제한을 구현하기로 선택한 비트코인 네트워크의 하드포크 버전인 비트코인개시를 만들어내는 요소가 되었다. ¶현재 어디에 있는가? 명백한 장점에도 불구하고 업그레이드는 느리게 진행되고 있었다. (그러나 현재는 거래의 절반 정도가 세그윗을 지원하고 있다. 여기를 참조) 주된 이유 중 하나는 아직 대다수의 지갑이 세그윗을 지원하지 않기 때문이다. 주요 비트코인 코드가 세그윗 친화적인 조정을 수행함에 따라 사용, 추가기능, 실험 모두에서 향상될 수 있다. 더 많은 지갑이 업그레이드를 포용하면서 세그윗을 사용하는 거래의 비율이 증가하고,블록에 더 많은 거래가 포함되므로 비트코인 수수료가 낮아 진다. 이러한 변화는 하룻밤사이에 일어나지는 않을 거시지만, 변화는 중요하며 앞으로 나아갈 큰 발걸음이 될 것이다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인 라이트닝 네트워크","slug":"bitcoin-lightning-network","date":"2018-08-27T15:00:00.000Z","updated":"2018-08-27T18:22:16.000Z","comments":true,"path":"2018/08/28/bitcoin-lightning-network/","link":"","permalink":"https://www.yceffort.kr/2018/08/28/bitcoin-lightning-network/","excerpt":"The Bitcoin Lightning Network 원문 라이트닝 네트워크란 신뢰할 수 있는 제3자에게 자금 관리를 위임하는 위험을 제거하는, 대규모 소액지불을 위한 분산 시스템이다. 세계에서 가장 널리 사용되고 가치 있는 디지털 통화인 비트코인은 신뢰할 수 있는 중개자가 없이 가치를 보낼 수 있다. 비트코인에는 사용자가 자금에 대한 지침을 프로그래밍 할 수 있는 고급 스크립팅 시스템이 포함되어 있다. 그러나 이러한 비트코인 분산된 디자인에는 몇가지 단점이 있다. 비트코인 블록체인에서 거래가 온전히 확인되기 위해서는 최대 1","text":"The Bitcoin Lightning Network 원문 라이트닝 네트워크란 신뢰할 수 있는 제3자에게 자금 관리를 위임하는 위험을 제거하는, 대규모 소액지불을 위한 분산 시스템이다. 세계에서 가장 널리 사용되고 가치 있는 디지털 통화인 비트코인은 신뢰할 수 있는 중개자가 없이 가치를 보낼 수 있다. 비트코인에는 사용자가 자금에 대한 지침을 프로그래밍 할 수 있는 고급 스크립팅 시스템이 포함되어 있다. 그러나 이러한 비트코인 분산된 디자인에는 몇가지 단점이 있다. 비트코인 블록체인에서 거래가 온전히 확인되기 위해서는 최대 1시간이 걸린다. 소액 지불 또는 몇 센트 미만의 지불도 마찬가지로 오랜시간이 걸렸고, 이러한 거래를 확인하는 수수료로 인해 오늘날 네트워크에서 이러한 거래가 실행되기 어렵게 했다. 라이트닝 네트워크는 이러한 문제를 해결한다. 비트코인의 내장 스크립팅을 이용한 다자간 스마트 컨트랙트 (프로그래밍 가능한 돈)를 구현한 최초 사례중 하나다. 라이트닝 네트워크는 다자간 금융 컴퓨팅 분야에서 기술개발을 선도하고 있다. ¶즉시 지불 비트코인은 거래를 10분 간격으로 블록으로 집계한다. 지불은 6블록 혹은 1시간에 걸친 확인 끝에 비트코인 네트워크 내에서 안전하고 간주된다. 라이트닝 네트워크 내에서 지불은 블록 확인을 필요로 하지 않으며, 즉각적이다. 라이트닝 네트워크는 사용자 대 디바이스 트랜잭션을 통해 소매점에서 사용하거나, 인스턴트 지불이 필요한 곳에서 사용할 수 있다. ¶소액 지불 소액 결제의 가능성으로 새로운 시장을 만들어 낼 수 있다. 라이트닝 네트워크는 관리상의 위험없이 0.0000001 비트코인의 자금을 보낼 수 있게 한다. 비트코인 블록체인은 현재 최소 출력 크기를 수백배 이상 높이고, 소액결제를 비실용적으로 만드는 고정 거래당 수수료를 부과하고 있다. 라이트닝 네트워크는 실제 비트코인 거래를 활용하여 비트코인으로 표시된 최소 지불을 허용한다. ¶확장성 비트코인 네트워크는 자동화된 지불에 따른 수요를 충족시키기 위해 보다 큰 거래량의 주문을 지원해야 한다. 인터넷에 연결된 장치가 증가하면서 기계 간 지불 및 자동화된 소액 지불 서비스를 위한 플랫폼이 필요하다. 라이트닝 네트워크 트랜잭션은 신뢰 및 소유권 위임 없이 블록체인에서 수행되므로, 사용자는 다른 장치간에 거의 무제한 트랜잭션을 수행할 수 있다. ¶어떻게 작동하는가? 자금은 양자의 다중 서명 ‘채널’ 비트코인 주소에 배치된다. 이 채널은 비트코인 공개 원장의 항목으로 표시된다. 채널에서 자금을 지출하기 위해서는 양 당사자가 새로운 잔고에 동의 해야 한다. 현재 잔액은 채널 주소에서 지출한 가장 최근 거래로 저장된다. 결제를 위해, 양 당사자는 채널 주소에서 새로운 출구 거래 지출에 서명한다. 모든 이전 출구 트랜잭션은 무효화 된다. 라이트닝 네트워크는 채널을 종료하기 위해 상대방과 협력할 필요가 없다. 양 당사자는 일방적으로 채널을 닫고 끝낼 수 있는 옵션을 가지고 있다. 모든 당사자는 이 네트워크에 있는 많은 다른 사용자가 있는 여러개의 다중 서명 채널을 가지고 있기 때문에, 이 네트워크를 통해 다른 당사자에게 지불 할 수 있다. 안전한 암호화 해시에 따라 지급 조건을 포함시킴으로써, 어떤 당사자도 자금의 일방적인 소유권을 가질 필요 없이 채널 네트워크를 통해 지급할 수 있다. 라이트닝 네트우크는 독점에 취약한 신뢰할 수 있는 금융 시스템에서 이전에는 불가능한 것을 가능하게 하며, 네트워크에 대한 참여는 동적이며 모두에게 개방적이다. 원문 설명이 너무 어려운 것 같다. 조금 더 쉽게 써보자. 라이트닝 네트워크의 가장 큰 아이디어는 모든 트랜잭션이 블록체인에 기록될 필요는 없다는 것이다. 사소한 금액의 모든 것들을 블록체인에 기록하지 않는 대신, 지불 채널이라는 것을 만들어 사소한 거래를 기록할 것이다. 이 지불 채널을 통해 여러번 거래를 할 수 있으며, 몇 시간, 몇일, 혹은 몇 주 동안 이채널을 열어 둘 수 있다. 이 내역이 블록체인에 저장되는 시간은 바로 채널을 닫을 때다. 채널을 닫으면, 발생한 거래의 최종 상태를 블록 체인에 쓴다. 두 사람은 각각 동등한 금액을 멀티 시그 주소에 예치하며, 이 작업은 ‘오프닝 거래’ 형태로 블록체인에 기록되고, 두사람간에 지불 채널이 열리게 된다. 그리고 이 돈은 아무도 쓸수 없으며, 여기에 있는 돈은 서로 거래하는데만 사용하게 된다. 만약 한사람이 2개 코인을 보내주길 원한다면, 해당 소유권을 상대방에게 넘겨주게 된다. 그리고 이 둘은 계속해서 거래를 하기를 원하므로 이 상태에서 계속 머물러 있는다. 그리고 다른 상대방이 1개의 코인을 보내주기를 원한다면, 동일한 방법으로 소유권을 이전하면 된다. 마짐막으로 서로 더이상 거래를 하기를 원하지 않는다면, 마지막 거래의 결과에 따라 소유권을 나눠 갖게 된다. 그리고 이는 블록체인에 기록된다. 이는 직접적인 지불 채널이 없는 상황에서도 위와 같이 사용할 수 있다. 이와 같은 지불 채널 네트워크를 활용하면, 막대한 양의 거래를 체인 외부에서 수행할 수 있게 되며, 거래 수수료 또한 발생하지 않는다. 참고","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인으로 성별간 임금 격차를 좁히는 법","slug":"how-blockchain-could-close-the-gender-pay-gap","date":"2018-08-27T15:00:00.000Z","updated":"2018-08-27T18:22:16.000Z","comments":true,"path":"2018/08/28/how-blockchain-could-close-the-gender-pay-gap/","link":"","permalink":"https://www.yceffort.kr/2018/08/28/how-blockchain-could-close-the-gender-pay-gap/","excerpt":"How Blockchain Could Close the Gender Pay Gap 원문 성별 임금 불평등은 여전히 노동계에서 큰 문제다. 투명성이 높은 블록체인 기술은 특히 공유 경제에서 이러한 문제를 줄일 수 있는 잠재력을 가지고 있다. 정교한 기술의 출현으로, 프리랜서는 9-5 사무실 근무를 대체할 인기있는 모델이 되었다. 많은 사람들이 전통적인 직업을 유지하는 방향으로 가고 있지만, 집에서 일하는 시간이 차츰 잦아지고 있다. 또 다른 사람들은, 추가 작업을 온라인에서 처리하기도 하고, 어떤 사람들은 풀타임으로 프리랜서로","text":"How Blockchain Could Close the Gender Pay Gap 원문 성별 임금 불평등은 여전히 노동계에서 큰 문제다. 투명성이 높은 블록체인 기술은 특히 공유 경제에서 이러한 문제를 줄일 수 있는 잠재력을 가지고 있다. 정교한 기술의 출현으로, 프리랜서는 9-5 사무실 근무를 대체할 인기있는 모델이 되었다. 많은 사람들이 전통적인 직업을 유지하는 방향으로 가고 있지만, 집에서 일하는 시간이 차츰 잦아지고 있다. 또 다른 사람들은, 추가 작업을 온라인에서 처리하기도 하고, 어떤 사람들은 풀타임으로 프리랜서로 일하면서 사무실을 완전히 버리기도 한다. 온라인 작업 공간의 등장으로, 성별 임금 격차가 줄어들 것이라고 가정한다. 불행히도, 이는 아직 사실이 아니다. 프리랜서의 급여격차가 사무실 급여격차보다 좁지만, 여전히 존재한다. 다행히 블록체인과 같은 기술은 성별에 따른 임금 불평등을 제거하거나 적어도 더욱 줄일 수 있다. 블록체인은 또한 덜 발달된 시장에서 여성들에게 일할 수 있는 기회를 제공할 수 있다. ¶왜 많은 사람들이 프리랜를 선택하는가? 프리랜서는 전통적인 사무실 일자리가 제공하지 못하는 자유를 제공한다. 사람들은 자신의 일을 완료시킬 수 있는 어디서든 일할 수 있다. 이는 두가지 주요한 이유에서 이득이다. 어디서든 일할 수 있다는 것은, 집에서 많은 시간을 소요해야하는 사람들이 그들의 일과 타협하지 않아도 일과 가정을 모두 돌볼 수 있다는 것을 의미한다. 이러한 위치 독립성은 또한 사람들이 특정 도시나 국가에 국한되지 않는 다는 것을 의미한다. 그들은 어디서나 와이파이로 작업할 수 있다. 프리랜서들이 언제 일하고 싶은지 정확히 선택할 수 있다는 점이다. 모든 직원의 상황은 다르므로 모두가 9-5로 일하는 것은 비현실적이다. 이에 반해 프리랜서는 언제든 자유롭게 작업할 수 있다. 그러므로 새벽에 가장 잘 일하는 사람들은 그렇게 할 수 있고, 올빼미족들은 또 밤에 일할 수 있다. ¶성별 임금 격차와 블록체인 전통적인 직업 시장에서는 여성들이 남성의 79%밖에 벌지 못하며, 만약 유색인 여성이라면 이 격차는 더 커진다. 프리랜서들에게는 그 격차가 더 좁은 편이지만, 아직 이런 노동력은 성별 중립적이지 못하다. 블록체인은 여기에 도움이 될 수 있다. 블록체인 기반의 시스템이 프리랜서만을 위한 네트워크를 가지고 있고, 커뮤니티를 만들 수 있다면 이러한 프리랜서들은 서로 교류할 수 있다. 다른 프리랜서와 관계를 구축하는 것은 사람들이 무엇을 요구해야하는지에 대한 판단을 도울 수 있다. 블록체인 기술은 분산되어 단일 권한이 없다. 따라서, 돈은 인종과 성별 등 성과와 무관한 요소들 대신에 프리랜서의 결과와 산출물에 기초한다. 블록체인 기반의 시스템을 사용하는 개방형 선두주자들의 투명성을 높일 수 있다. ¶개발도상국에서의 여성 일부 개발도상국에서, 여성과 관련된 법은 남성에 비해 차별적이다. 여성들이 이제 막 직업 선태의 자유를 가진 나라에서, 그들이 실제로 권리를 행사할 수 있는 기반시설이나 시스템이 없을 수도 있다. 세계 은행은, 개발도상국의 여성들이 신분증이나 출생증명서를 가질 가능성이 더 적다고 이야기 한다. 블록체인 기술은 개인 기록을 저장할 수 있으므로, 여성들은 그들의 정보를 안전하게 저장하기 위해 디지털 ID를 제공할 수 있다. 또한 이 나라의 여성들은 공식적인 신분을 유지하는 믿을만한 소식통으로 정규직을 찾을 수도 있다. ¶은행계좌가 없는 여성 포츈지에서는 전세계 여성의 42%가 은행계좌를 갖고 있지 않다고 이야기한다. 이것은 엄청난 숫자이며, 블록체인 또한 여기에서 유용할 수 있다. 블록체인은 안전하고, 분산되어 있으며 은행이나 기타 제 3자가 금융거래에 참여할 것을 요구하지 않는다. 따라서 여성은 돈을 받기 위해 은행에 접근할 필요가 없을 것이다. 블록체인은 두 당사자간의 원활한 자금 이전을 허용하기 때문에, 일반적으로 자금이전과 관련된 비용 또한 더 낮을 수 있다. 이것은 특히 거래비용을 감당할 수 없는 개발도상국 여성들에게 도움이 된다. 또한 은행과는 달리 유지비가 없으므로 암호 지갑을 통해 돈을 절약할 수 있다. ¶모든 성별에 대해 동일한 기회 제공 불행하게도, 노동력은 여전히 성별 격차가 있다. 프리랜서에서도 남성과 여성이 받는 임금 차이가 있다. 블록체인은 여성들이 그들 분야의 다른 프리랜서와 연결시켜줌으로써 그들에게 무엇을 요구해야하는지 보여줄 수 있다. 블록체인은 또한 일자리를 찾거나 은행계좌를 개설하는데 필요한 수단이 부족한 개발도상국의 여성들에게 힘을 실어주는 것을 도울 수 있다. (암호 화폐로 임금을 제공한다는 것을 의미하는 듯) 글이 뭔가 시시하게 끝나서… 참고자료 몇개 더 붙여놓는다. Can blockchain disrupt gender inequality? How can Blockchain reduce pay inequality? Women Tech Leaders Say Blockchain Can Help Close Tech’s Gender Gap In Asia Commentary: 3 Ways Blockchain Can Empower Women Worldwide","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"ICO의 토양이 되는 ERC 20","slug":"erc20-basis-icos","date":"2018-08-26T15:00:00.000Z","updated":"2018-08-26T18:22:16.000Z","comments":true,"path":"2018/08/27/erc20-basis-icos/","link":"","permalink":"https://www.yceffort.kr/2018/08/27/erc20-basis-icos/","excerpt":"ERC20: The Basis of Most ICOs 원문 대다수의 ICO는 이더리움의 ERC20 표준을 기반으로 한다. 코인마켓캡이 토큰 목록을 살펴보면, 상위 20개 토큰 중 19개가 이더리움을 기반 플랫폼으로 사용하고 있는 것을 확인할 수 있다. 상위 100개의 토큰을 살펴보면, 이더리움을 사용하지 않는 경우가 더 예외적인 상황이라는 것을 알 수 있다. 왜 그럴까? 왜 이더리움은 블록체인 토큰의 표준이 되었을까? 정답은 ERC20 표준에서 확인할 수 있다. 이전에, ERC20이전에는 블록체인에서 토큰이 어떻게 만들어졌","text":"ERC20: The Basis of Most ICOs 원문 대다수의 ICO는 이더리움의 ERC20 표준을 기반으로 한다. 코인마켓캡이 토큰 목록을 살펴보면, 상위 20개 토큰 중 19개가 이더리움을 기반 플랫폼으로 사용하고 있는 것을 확인할 수 있다. 상위 100개의 토큰을 살펴보면, 이더리움을 사용하지 않는 경우가 더 예외적인 상황이라는 것을 알 수 있다. 왜 그럴까? 왜 이더리움은 블록체인 토큰의 표준이 되었을까? 정답은 ERC20 표준에서 확인할 수 있다. 이전에, ERC20이전에는 블록체인에서 토큰이 어떻게 만들어졌는지를 확인해보자. ¶Colored Coin: 비트코인 기반의 토큰 현재 암호화폐 시장에서 가장 핫한 주제는 ICO 다. 이는 마이너들이 토큰이나 코인을 만들기 이전에, 투자자들에게 먼저 코인을 파는 것을 의미한다. 그렇게 하기 위해서는 일단 비트코인이나 이더리움과 같은 네이티브 블록체인 통화처럼 작동하지만, 마이너들에 의해 만들어지지 않은 블록체인 토큰을 몇개 두는 것이 유용하다. 이러한 개념은 2013년에 비트코인의 블록체인에 토큰을 가져오는 방법을 만들어냈다. 그 주인공은 MasterCoin과 ColoredCoin이다. MasterCoin은 Counterparty와 Omni등으로 변형되었으며, ColredCoin은 OpenAssets이나 Coinprisim과 같은 여러 하위 프로토콜 등으로 분리되었다. 약간의 사소한 차이점 외에, 이 모든 개념은 비트코인 거래에서 토큰을 새기기 위해 몇가지 기술을 사용한다는 공통점이 있다. 이를 위해 비트코인의 OP_RETURN을 사용하여 트랜잭션에 데이터를 추가하였다. ColoredCoin의 예제 OP_RETURN을 통해 비트코인 블록체인에 작성된 코인엔 여러가지가 있다. Tether의 경우에는, Omni를 사용하여 비트코인 블록체인에서 유로, 달러 등을 전송한다. 누군가 달러 지폐에 ‘나는 유로다’ 라고 쓰는 것을 상상해보자. 일부 특별한 지갑은 이러한 메시지를 해석할 수 있다. 비트코인에 대한 이러한 토큰들은 어느 정도 효과가 있다. 그러나 이들은 몇가지 단점을 공유한다. 가장 심각한 문제는, 블록체인에 기본적으로 저장이 되지 않는 다는 것이다. 이는 단지 거래에 첨부된 메시지 수준에 불과하며, 그리고 이들 대부분은 메시지의 진위성을 증명하기 위한 메시지 해시다. 비트코인 거래의 서명이나, 이전 비트코인의 amount 이외에, 이 메시지는 블록체인의 기본정보가 아니다. 위 예제에서의 글자들은 복사하거나, 붙여넣거나, 철자가 확인되는 등의 부가작업을 할수 없다. 그 결과 비트코인 네트워크는 비트코인 트랜잭션을 검사하는 것과 동일한 방식으로 토큰 전송 (메시지 확인)을 검사하지 않는다. 비트코인 노드와 마이너들은 보내진 금액이 잔액에 의해서 뒷받침 되는지 (잔고가 남았는지 확인하는지) 확인하지 않는다. 심지어 토큰이 위조되거나, 이중으로 사용되는지 알지 못한다. 또한 토큰이 올바르게 생성되었는지 확인하지 않는다. 물론, 이러한 문제는 비트코인 위에 프로토콜을 얹어서 확인할 수 있다. 특수 지갑 소프트웨어는 비트코인 외부의 데이터베이스로 토큰의 유효성을 검사할 수도 있다. ¶ERC20은 무슨 차이를 만드는가? 이더리움 개발자들은 ERC20 토큰 표준을 발표했다. 이더리움 블록체인 상에서 작동하는 '토큰을 위한 표준 인터페이스’다. 토큰을 전송할 수 있는 기본 기능을 제공하고, 토큰을 승인하여 다른 체인 써드파티에서도 사용가능하게 한다. 이더리움의 모든 토큰이 다른 응용 프로그램에서 재사용되도록 허용하는 것이다. ERC20의 성공은 부정할 수 없다. 이들은 거의 모든 이더리움 지갑을 지원한다. 수백개의 ERC20 토큰이 만들어졌으며, 이는 다른 대부분의 암호 화폐보다 가치가 있다. 의심하라 여지 없이, 이 형식은 암호화폐의 가장 성공적인 구현 중 하나가 되었다. 이는 토큰업계에서 승자가 되었다. 그러나 비트코인은 그렇지 못했다. 왜 그런지, 이 질문에 대답하기 위해서는 ERC20 토큰이 Colored Coin이나 Omni 토큰과 거의 공통점이 없다는 것을 알아야 한다. 이더리움의 가상 머신 (EVM)을 이용하면, 복잡한 스마트 컨트랙트를 만들어 지갑이 이 컨트랙트와 상호작용할 수 있다. 비트코인은 지폐에 토큰을 새겨 놓은 것을 상상할 수 있다면, ERC20은 블록체인의 회계사와 같은 것이다. ERC20 컨트랙트는 토큰의 모든 소유자에 대한 내역을 보유한다. 토큰의 수를 정의하고, 토큰을 보유하고 있는 주소도 나타낸다. 아래는 ICONOMI 토큰을 나타내는 방법이다. ERC 20 토큰을 다른 주소로 전송하면, 비트코인 토근과 마찬가지로 이 주소에 트랜잭션을 저장하지 않는다. 대신 ERC20 컨트랙트에 소유자 목록을 변경하도록 지시한다. 이는 사용자가 가지고 있던 토큰을 제거하고, 새로운 주인에게 추가한다. 이 모든 것은 거래 당사자와 상호작용하는 것이 아니라, 컨트랙트 상에서만 상호작용 하게 된다. 이 차이가 굉장이 중요하다. 이는 블록체인의 데이터 구조에서 토큰을 기본요소로 만드는 것이다. 마이너가 계약을 올바르게 실행한 경우, 이더리움 네트워크의 모든 노드가 이를 확인한다. 토큰 컨트랙트가 올바른 잔액을 유지하거나, 트랜잭션이 올바르게 처리되는 경우, 유효성을 검사한다. ERC20 토큰의 모든 단일 활동은 네트워크의 모든 피어에서 기본적으로 유효하다. 피어는 그러므로 외부데이터베이스와 상호작용할 필요가 없다. 거래를 추적하기 위해 비트코인의 경우 처럼 이더리움 외부의 프로토콜을 따를 필요가 없다. 다른 모든 표준 트랜잭션과 마찬가지로 상태를 확인해야 한다. 그래서, ERC20 토큰을 사용하는 것이 매끄럽다. 블록체인에서 토큰을 만들고 처리하기 위해 ERC20을 사용하는 것이 매우 편리하다. 지난 2년 동안 이러한 힘을 인상적으로 보여주었다. 블록체인 토큰은 ERC20이전에는 거의 영향을 미치지 못했지만, 이더리움이 이 표준을 발표한 이후 암호 화폐 생태계에서 그 역할이 폭발적으로 증가했다. ICO에 대한 과대 광고로 20억 달러가 스타트업 예산으로 쏟아진 것은 ERC20의 토큰 표준화의 결과다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://www.yceffort.kr/tags/ethereum/"}]},{"title":"블록체인 스케일링 문제","slug":"blockchain’s-scaling-problem","date":"2018-08-22T15:00:00.000Z","updated":"2018-08-22T18:22:16.000Z","comments":true,"path":"2018/08/23/blockchain’s-scaling-problem/","link":"","permalink":"https://www.yceffort.kr/2018/08/23/blockchain’s-scaling-problem/","excerpt":"Blockchain’s Scaling Problem, Explained 원문 ¶1. 정확히 무엇이 문제인가? 암호화폐와 블록체인이 인기와 대중의 인식을 얻고 있지만, 기술이 수요를 따라갈 수 없는 위험이 존재한다. 비즈니스에서 가장 널리 알려진 비트코인과 이더리움은 블록을 사용하여 거래를 처리한다. 그러나 개발 초기에는 비트코인의 경우 최대 블록 크기가 1MB로 제한되어 있다. 이 메커니즘은, 비트코인을 더욱 안전하게 만들기 위하여 설계 된 것이지만, 네트워크의 미래를 보장하지는 못했다. 각 거래마다 데이터가 최대 1MB로 제한","text":"Blockchain’s Scaling Problem, Explained 원문 ¶1. 정확히 무엇이 문제인가? 암호화폐와 블록체인이 인기와 대중의 인식을 얻고 있지만, 기술이 수요를 따라갈 수 없는 위험이 존재한다. 비즈니스에서 가장 널리 알려진 비트코인과 이더리움은 블록을 사용하여 거래를 처리한다. 그러나 개발 초기에는 비트코인의 경우 최대 블록 크기가 1MB로 제한되어 있다. 이 메커니즘은, 비트코인을 더욱 안전하게 만들기 위하여 설계 된 것이지만, 네트워크의 미래를 보장하지는 못했다. 각 거래마다 데이터가 최대 1MB로 제한되어 있으면, 한번에 처리할 수 있는 데이터 양이 제한적이다. 비트코인은 초당 약 3~4번의 거래를 처리할 수 있다. 그러나 주류가 되기 위해서, 소비자와 기업에 대한 막대한 지연 없이 경제가 움직일 수 있도록 초당 수십만건의 거래를 처리해야 한다. 안타깝게도, 이더리움 또한 비슷한 문제가 있다. 이는 비탈릭 부테린이 인정한 것과 맥락이 같다. 이더리움 네트워크도 초당 최대 15건의 거래내역만 처리할 수 있으며, 현 상태가 계속 된다면 업계의 인프라가 대처할 수 없을 것이라고 경고했다. ¶2. 그런데, 왜 처리능력을 올리지 않는 걸까? 불행하게도, 이는 하룻밤 사이에 업데이트 될 만큼 간단한 문제가 아니다. 암호화폐의 업계 관계자들은 기존 금융기관을 추월하기 위해서는 프레임워크 확장성 문제를 해결해야 한다는 것에 동의하지만, 솔루션을 제시하는데는 시간과 많은 노력이 필요하다. 무슨 제안이든지 간에, 마이너, 개발자, 기업 및 기타 이해관계자의 지원을 받아야 시행될 수 있다. 몇달이 걸릴 수도 있고, 심지어는 의견차이로 해결되지 못할 수도 있다. 일례로 비트코인은 수년에 걸쳐 블록 크기를 변경하기 위하여 적극적으로 토론을 펼쳤다. 일부는 두배로 만족했지만, 다른 일부는 8배, 32배 등도 논의 했었다. 2018년 5월 비트코인캐시는 블록크기를 32MB로 늘리는 업그레이드를 성공적으로 마쳤다. 이는 암호 화폐가 미래의 수요를 충족시키고 새로운 기능을 도입할 수 있는 길을 열어줄 수 있을 것으로 기대된다. 그러나 비평가들은 이러한 변화가 전체 노드를 보다 더 비싸게 만들고, 이는 네트워크가 덜 분산 될 수 있다고 주장했다. 2017년 8월 비트코인의 하드포크에 대한 결과였던 비트코인캐시의 지지달은 이러한 블록크기가 비트코인 보다 우수한 점이라고 말한다. ¶3. 다른 해결책은? 예를 들어, 라이트킹 네트워크는 블록체인 위에서 작동하는 보조 계층이다. 이론적으로 블록체인에 공개적으로 기록되지 않는 무제한의 거래 및 지불을 처리할 수 있다. 모든 트랜잭션이 완료되면 최종 밸런스가 원장에 추가 된다. 이것이 비트코인의 스케일링 문제를 해결할 것이라는 희망이 있었지만, 보안에 대한 문제가 남아 있었다. 이러한 프로토콜이 더 작고 일상적인 지불을 위한 표준으로 끝날 수 있다. 더 많은 실질적인 거래를 위해 수수료를 떨어뜨리는 방법도 논의되고 있다. 앞서 언급한 이더리움도 블록체인 스케일링 솔루션을 생각해 냈다. 플라즈마 캐쉬 라고 불리는 이 아이디어는, 사용자가 자신이 가진 코인이 포함된 블록에만 집중할 수 있게 하여 데이터를 최적화하는데 도움이 된다. 부테린에 따르면, 이 솔루션은 사기성 거래를 방지되고 거래가 해킹되면 암호화폐 투자가가 돈을 잃지 않도록 막을 수 있다고 하였다. ¶4. 오프체인 스케일링 분산 응용 프로그램이 모두 블록체인에서 완전히 실행될 필요가 없다. 즉 많은 프로세스가 오프 체인에서 처리될 수 있다. 어떤 면에서 이는 PC나 스마트폰에서 사용할 수 있는 앱과 비슷하다. 이러한 소프트웨어는 인터넷에 연결될 수 있지만, 특정 작업은 오프라인에서 완료되어 회사의 서버가 트래픽에 압도당하는 것을 방지한다. 오프체인 스케일링 솔루션은 마인 없이 특정거래가 완료 되어 필수정보만 동기화 할 수 있도록 한다. 커뮤니티의 모든 이해 관계자로부터 승인을 얻는 힘든 과정 없이 업그레이드를 합의 하고 구축할 수 있으며, 전체 블록체인이 중단되지 않고 새로운 기능을 배포 할 수 있다. 물론 단점도 있다. 오프체인 거래는 대중들이 거래를 확인하기가 어렵고, 컴플라이언스 문제를 만들 수도 있다. 또한 사용자들은 이러한 업데이트에서 자신의 의견을 피력할 수 없다면 환멸을 느낄 수 있다. 실제로, 일부 암호화폐의 미래에서는 블록체인이 전혀 없을 수도 있다고 주장한다. Byteball, IOTA와 같은 플랫폼은 블록을 전혀 사용 하지 않는 대신, 새로운 거래가 이전 지불을 확인하는 책임이 있다. 지지자들은 이것이 블록체인 기반 암호 화폐가 직면한 속도, 보안, 확장성, 개인 정보 보호, 지속 가능성 등 문제를 해결하는 해답이 될 수 있다고 생각한다. ¶5. 만약 스케일링 문제가 해결되지 않는다면? 블록체인 확장 문제를 명확하게 해결 하지 못한다면, 광범위한 파급효과가 발생할 수 있다. 조치를 취하지 않으면, 거래를 처리하는데 점점 오랜 시간이 걸릴 가능성이 크다. 디지털 경제에서 블록체인 플랫폼이 강력한 이점을 제공하면서 실행 가능한 대안이 되기 위해서는, 일반적인 현금 지불과 같은 동일한 기능을 제공한다는 전제가 필요하다. 그렇지 않으면, 열렬한 지지자들 조차 기술을 포기할 수 있다. 사용자 수 감소는 주요 암호 화폐 가격 급락으로 이어질 것이다. 결국 중앙집중화 현상이 계속해서 이어진다는 것을 의미할 수도 있다. Fractonet은 블록체인의 완전한 재설계로 확장성 문제를 해결했다고 주장한다. 이 스타트업은 1.5gb의 블록크기로 PoC 중에 초당 33,888건의 거래를 성공적으로 처리했다고 말한다. 자사 프로토콜이 실제 데이터 불변성으로 데이터를 저장할 수 있다고 주장하고 이것이 타당하다면, 기업은 더이상 민감한 정보를 제 3자에게 위탁할 필요가 없다. 데이터 동기화를 용이하게 만들기 위해 RIFT라는 새로운 프로토콜을 만들었으며, 블록의 크기가 커지면 거래 및 마이너 관련 비용이 절감될 것이라고 주장했다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"블록체인: 데이터 보호를 방해하는가?","slug":"blockchain-disrupting-data-protection","date":"2018-08-21T15:00:00.000Z","updated":"2018-08-21T18:39:05.000Z","comments":true,"path":"2018/08/22/blockchain-disrupting-data-protection/","link":"","permalink":"https://www.yceffort.kr/2018/08/22/blockchain-disrupting-data-protection/","excerpt":"Blockchain: Disrupting data protection? 원문 비트코인, 블록체인, 분산 원장 기술에 대한 이야기를 자주 들었을 것이다. 그리고 몇년 전 클라우드 컴퓨팅 처럼 비즈니스 운영방식을 변화시키는 파괴적인 기술이 될 수 있는 방법도 있었다. 흥미롭게도 클라우드 컴퓨팅과 비슷하지만, 이 기술은 많은 기회를 창출하고 있으며, 데이터 보호에 본질적으로 비 우호적인 특정 기능을 가지고 있다. ¶블록체인? 분산원장? 분산원장은 종종 트랜잭션 레코드를 분산하여 데이터베이스에 저장하는 기술로 설명된다. 블록체인은 블","text":"Blockchain: Disrupting data protection? 원문 비트코인, 블록체인, 분산 원장 기술에 대한 이야기를 자주 들었을 것이다. 그리고 몇년 전 클라우드 컴퓨팅 처럼 비즈니스 운영방식을 변화시키는 파괴적인 기술이 될 수 있는 방법도 있었다. 흥미롭게도 클라우드 컴퓨팅과 비슷하지만, 이 기술은 많은 기회를 창출하고 있으며, 데이터 보호에 본질적으로 비 우호적인 특정 기능을 가지고 있다. ¶블록체인? 분산원장? 분산원장은 종종 트랜잭션 레코드를 분산하여 데이터베이스에 저장하는 기술로 설명된다. 블록체인은 블록과 체인을 사용하여 레코드르 저장하고 무결성을 보장하는 특정 종류의 분산원장이다. 비트코인은 블록체인을 기술을 기반으로 하는 특정 암호 화폐 응용 프로그램이다. 즉, 비트코인은 분산원장의 하위집합인 블록체인의 하위집합이다. 그러나 비트코인의 성공으로 인해 그 특성은 종종 블록체인과 분산원장의 대표로 오해되곤 한다. ¶익명성? 익명은 블록체인이나 분산원장에서 분리할 수 없는 특징이 아니고, 단지 선택사항이다. 비트코인은 식별 및 검증 없이도 누구나 공개 노드로 가입할 수 없는 ‘허가가 필요없는’ 블록체인으로 구현된다. 그러나 블록체인 또는 분산원장 응용 프로그램은 노드로 가입하기 전에 사용자의 신원을 확인하기 위한 적절한 거버넌스가 있는 '허가’프로세스를 추가하여 설계 및 구현할 수 있다. ¶보안과 투명성 보안에는 기밀성, 무결성, 가용성의 세가지 요소가 있다. 비트코인을 포함하여 허가가 필요없는 블록체인은 노드에 누구나 원장에 액세스 할 수 있으므로 기밀성 보호가 없다. 개인 데이터가 관련되어 있으면 공개 문제가 발생한다. 허가된 블록체인 또는 분산원장의 경우 원장이 다른 노드에서 읽을 수 있는지 여부는 설계에 따라 달라질 수 있다. 이는 허가된 원장의 데이터가 암호화되거나 원장을 다른 모든 노드에 복사할 필요가 없지만, 유효성 검사와 백업을 위해 신뢰할 수 있는 노드 중 소수에 복사 할 필요가 있기 때문이다. 마지막으로 보안측면에서 볼때, 가장 약한 링크에 대한 공격은 가장 쉬운 옵션이며, 과거 비트코인 거래 등 전자 지갑이나 엔드포인트에서 비트코인 등의 해킹이 가능했다. 그러나 이는 어디까지나 엔드포인트의 문제이지, 블록체인 자체의 문제는 아니다. ¶불변성? 불변성은 블록체인과 분산원장의 가장 핵심적인 특징이다. 블록 내부의 데이터를 변경하거나 제거하면, 블록 내부의 모든 데이터가 더이상 신뢰할 수 없게 된다. 기록 관리 관점에서는 훌륭한 특징이지만, 개인 데이터의 수집에 대한 법적 근거가 더이상 유효하지 않아 제거해야 하거나, 데이터가 GDPR 하에서 지울 권리를 행사하게 되면 문제가 발생한다. Immutable? Immutability is perhaps the best core feature of blockchain and DLT. Altering or removing data inside a block would simply render all the data inside the block no longer trustworthy. While from a record management point of view it is a great feature, it creates issues when the legal basis for the original collection of personal data is no longer valid and the data needs to be removed, or when a data subject exercises the right to erasure under the GDPR in the future. ¶해독할 수없는 특성? 일부 기술자들은 블록체인이나 분산원장에 저장된 개인 데이터가 암호화 될 수 있다는 아이디어를 떠올렸고, 삭제가 필요한 경우에는 암호 해독키를 삭제하기 만 하면 된다. 이 아이디어는 암호화된 개인데이터는 개인데이터가 아니며, 키가 없으면 암호화된 데이터의 암호를 해독할 수 없다는 개념에 기반을 둔 것 같다. 당연히 이 두가지 가정은 문제를 가지고 있으며, 어떤 암호화를 빠르게 해독할 수 있는 양자 컴퓨팅을 포함한 기술이 빠르게 발전하고 있는 현시점에서는 받아드릴 수 없다. ¶블록체인을 수정할 수 있는가? 일반적으로 블록체인의 블록이 변경되면 해시가 변경되게 된다. 그러나 일부 업체들은 해시 매커니즘을 약화시켜, 편집되 블록이 동일한 해시를 유지하도록 수정가능한 블록체인 기술을 만들었다. 이 약하된 해시 매커니즘(카멜레온 해시)을 통해 편집/삭제를 위해 일부 정보를 블록에 추가하여 결과 해시가 동일하게 유지되도록 하는 방법을 차증ㄹ 수 있다. 카멜레온 해시는 엄격한 관리하에서만 재계산할 수 있으며, 블록이 편집되었다고 표시할 수 있는 마커를 블록에 집어넣어야 한다. 이 솔루션은 기술적으로 혁신적이지만, 블록체인의 가치가 편집가능해 질때, 과연 어디에 있는지 생각해봐야 한다. ¶하이브리드 솔루션? 블록체인과 DLT는 원래 작은 데이터만 포함하는 트랜잭션을 기록하도록 설계되어 있다. 따라서 의료 데이터를 처리하는데 사용하고자 하는 플레이어들이 많아지거나, 다른 비금융 거래 응용 프로그램에서 활용하기 위하여 외부 데이터베이스를 필요로 하는 경우가 있다. 이러한 하이브리드 시스템에서는 데이터가 외부 데이터베이스에 저장될 수 있으며, 이 데이터베이스는 노드의 전부 또는 일부에 배포될 수 있고, 데이터의 해시가 블록체인 또는 분산 원장에 저장된다. 이러한 방식은 양쪽의 장점을 모두 채용할 수 있다. 실제 데이터는 기존 데이터베이스에 저장되며, 여기에 확인할 필요가있는 원칙에 근거한 엑세스 제어, 신뢰할 수 있는 백업을 위해 다른 지정된 노드에 일부 기록을 복제하고, 법적 기반 만료시 기록을 삭제하거나 요청에 따라 세분화된 여러 컨트롤을 기존 데이터베이스에 저장한다. 동시에 블록체인 또는 분산원장에 유지되는 불변의 해시는 외부 데이터 베이스에 저장된 데이터의 변경이 쉽게 감지되도록 한다. ¶검색이 가능한가? 블록체인과 분산원장은 거래기록을 저장하는 원장으로 설계되어있으므로, 기록을 추적하는 것이 더 쉬워졌다. 일반적인 검색을 위해 블록체인 또는 분산 원장에 저장된 데이터 새긴을 외부 데이터베이스에 보관하여 검색할 수 있어야 한다. 이러한 경우는 하이브리드 모델의 여러 유형의 응용 프로그램에서 더 적합할 수 있다. ¶국경간 블록체인? 블록체이노가 분산원장은 여러조직에 걸쳐 있는 응용프로그램에 적합하므로, 필연적으로 노드가 서로 다른 관할 구역 간에 존재할 수 있다. 국경 간 제한, 노드가 어디에 있을 수 있는지에 대한 불확실성으로 인해 개인데이터를 외국 관할 구역에 저장하는 것에 동의를 얻는 것은 실용적이지 않다. 하이브리드 모델은 개인데이터가 중앙, 분산, 또는 부분적으로 분산된 데이터 베이스가 외부에 저장될 수 있는 유연함을 제공한다. 따라서 각 개인정보 데이터는 유사한 데이터 보호법이 있는 국가의 특정 노드에 선택적으로 복사할 수 있다. ¶책임은 누구에게 있는가 참가자가 네트워크 또는 조직의 동등한 플레이어로 가입하는 블록체인 또는 분산원장의 경우 잠재적으로 데이터 컨트롤러와 같은 네트워크 또는 조직이 책임을 공유할 수 있다. 이는 심층적인 연구가 필요한 다소 미지의 영역이다. 정확한 상황에 따라, 거버넌스 구조가 있는 허가된 블록체인 또는 분산원장의 경우 개인 데이터를 수집하는 주체들은 모두 데이터 컨트롤러로 간주될 수 있다. 그리고 거버넌스 구조 이외의 주체가 데이터 컨트롤러로 간주되는 경우에도 일부 책임을 공유할 수 있다. 더욱이, 특정 참여자들이 개인 데이터를 처리해야 하는 검증노드로 보여지게 되면, 그들은 자신들도 모르게 데이터 보호법에 의해 감시받고 있을 수도 있다. ¶다른 고려사항 규제 및 통제, 책임, 법적근거, 적용가능한 관할권, 결제, 스마트 컨트랙트와 같은 블록체인 및 분산원장 사용과 관련된 다른 규제및 법적 문제가 있으며, 이에 대한 논의가 필요한 시기다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"자동차 산업에서의 블록체인","slug":"blockchain-in-automotive-domain","date":"2018-08-21T15:00:00.000Z","updated":"2018-08-21T18:39:05.000Z","comments":true,"path":"2018/08/22/blockchain-in-automotive-domain/","link":"","permalink":"https://www.yceffort.kr/2018/08/22/blockchain-in-automotive-domain/","excerpt":"Blockchain in Automotive Domain 원문 자동차 제조 업체는 블록체인 서비스 공급자와 제휴하여 기존 장비 제조업체 (OEM) 네트워크 사이에 고유한 원장을 만들 수 있다. 부품 품질 보장과 같은 문제를 해결하여, 물류 모니터링 및 제어를 강화하는데 도움이 될 수 있다. 예를 들어, 선적 추적시간을 며칠에서 단 몇 초로 줄일 수 있다. 향상된 추적성으로 자동차 제조업체와 OEM 업체는 부품 공급의 신뢰성을 보장할 수 있다. ¶소프트웨어 기반 제조 블록체인을 기반으로 하는 소프트웨어 기반 제조는, 제조 생산성","text":"Blockchain in Automotive Domain 원문 자동차 제조 업체는 블록체인 서비스 공급자와 제휴하여 기존 장비 제조업체 (OEM) 네트워크 사이에 고유한 원장을 만들 수 있다. 부품 품질 보장과 같은 문제를 해결하여, 물류 모니터링 및 제어를 강화하는데 도움이 될 수 있다. 예를 들어, 선적 추적시간을 며칠에서 단 몇 초로 줄일 수 있다. 향상된 추적성으로 자동차 제조업체와 OEM 업체는 부품 공급의 신뢰성을 보장할 수 있다. ¶소프트웨어 기반 제조 블록체인을 기반으로 하는 소프트웨어 기반 제조는, 제조 생산성과 품질을 쉽게 향상 시킬 수 있으며 보증, 유지 보수, 추적 비용을 크게 줄일 수 있다. 제품 제작, 버전관리, 리콜에 대한 추가 검사와 관련되어 있는 요소도 단순화 될 수 있다. 예를 들어, 장비 공급업체(OES)에서 출하되기 전에 각 부품 팔레트에 고유한 센서를 추가하고, 실시간 상태와 위치를 추적하여 출하가 예상 도착 시간을 준수하도록 할 수 있다. 이 모든 것은 사물인터넷과 연계해 블록체인의 원칙에 입각한 기술을 활용하여 각 공급망 파트너가 제품의 상태 업데이트에 적극적으로 참여하는 효과적인 전략을 수립할 수 있다. 이러한 전반적인 개념은 자동차 제조 업체, OEM, 소프트웨어 개발자 및 사이버 보안 회사간의 광범위하고 철저한 협업을 요구 하고 있다. ¶차량 유지 관리 르노는 2017년 7월 25일, 블록체인을 활용하여 모든 차량 수리 및 정비 기록을 한곳에 기록하는 시범 사업을 발표했다.현재 르노에 따르면, 차량의 유지 관리 이력에 대한 정보는 수리점이나 딜러점을 비록한 다양한 정보원에 유지되기 때문에 새로운 변경사항을 파악하기 어렵다. 이와 대조적으로 블록체인 기반의 디지털 유지보수 로그 프로토타입은 이 모든 정보를 한곳에 보관한다. 차세대 파일럿은 IoT와 연동하는데 필수적인 차량기반 마이크로 트랜잭션에 중점을 둘것이라고 언급했다. ¶자동차 금융 및 차량 임대업 자동차를 이용한 자금 조달은 거래의 성격에 따로 다르지만, 일반적으로 KYC와 같은 기존의 은행 고객 점증과 같은 번거로운 프로세스를 보다 효율성을 높이기 위해 블록체인을 적용할 수 있다. 대출 승인, 여러 곳에서 출처가 표시된 문서의 검토, 문서 보관등은 블록체인을 지원하는 스마트 컨트랙트를 통해 중개인의 필요 없이 임대 계약자와 새로운 자동차 임대 및 기타 조건에 대한 지불을 자동으로 협상할 수 있다. 또한, 필요한 당사자에게 안전한 암호화 지불을 보장한다. 전용 블록체인 시스템은 차량의 실제 마모 및 손상에 대한 정보의 가장 필요한 투명성을 제공하여, 자동차 금융 제공 업체가 계약 날짜가 끝날 때 차량의 잔존가치를 보다 정확하게 측정하는데 도움이 된다. 예를 들어 온보드 진단 장치는 모바일 네트워크를 통해 차량을 연결하여 운전자의 행동, 안전 문제, 서비스 문제와 관련된 데이터를 추적할 수 있다. ¶결론: 통합 응용 프로그램 확장성과 상호운용성의 기본을 기반으로 하는 블록체인 플랫폼은 자동차 제조업체, 자동차 딜러, 규제기관, 자동차 금융 및 보험회사, 차량 임대회사, 구매자, 판매자 및 차고 간에 공유원장을 사용하여, 많은 이해 관계자에게 이익을 줄 수 있으며 높은 수준의 투명성을 제공할 수 있다. 동시에 이는 프로세스를 상당히 간소화 할 수 있다. 특히 규제 및 규제 준수 승인에 의존하는 프로세스에서 더욱 큰 효과를 누릴 수 있다. 블록체인은 공급망을 가동하고 있는 기존 시스템에 투명성과 효율성을 제공하여 보다 능동적이고 예측가능하게 만들 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인이 할 수 없는 것","slug":"what-blockchain-cant-do","date":"2018-08-21T15:00:00.000Z","updated":"2018-08-21T18:39:05.000Z","comments":true,"path":"2018/08/22/what-blockchain-cant-do/","link":"","permalink":"https://www.yceffort.kr/2018/08/22/what-blockchain-cant-do/","excerpt":"What Blockchain Can’t Do 원문 블록체인은 놀라운 일을 할 수 있는 잠재력을 갖고 있다. 이 기술은 거래의 불변성을 가지고 있으며, 저렴한 비용으로 데이터의 무결성을 확인하는데 사용될 수 있다. 비용이 많이 드는 중개자에 의존하지 않고 기업들과 개인들이 시장 내의 진정한 상황에 전세계적으로 합의하도록 도울 수 있다. 이는 경제적 인센티브와 암호화의 현명한 조합을 통해 달성할 수 있으며, 언제든지 디지털 레코드가 관련된 주요 이해관계자들 사이에 진정한 '합의’를 반영하도록 보장한다. 따라서 디지털 기록과 자산을","text":"What Blockchain Can’t Do 원문 블록체인은 놀라운 일을 할 수 있는 잠재력을 갖고 있다. 이 기술은 거래의 불변성을 가지고 있으며, 저렴한 비용으로 데이터의 무결성을 확인하는데 사용될 수 있다. 비용이 많이 드는 중개자에 의존하지 않고 기업들과 개인들이 시장 내의 진정한 상황에 전세계적으로 합의하도록 도울 수 있다. 이는 경제적 인센티브와 암호화의 현명한 조합을 통해 달성할 수 있으며, 언제든지 디지털 레코드가 관련된 주요 이해관계자들 사이에 진정한 '합의’를 반영하도록 보장한다. 따라서 디지털 기록과 자산을 공유하는 경우에는 당사자간의 신뢰의 필요성을, 거래의 기록을 확인하고 유지하기 위한 중앙기관의 필요성을 대체하라 수 있다. 그러나 블록체인 비즈니스 모델을 평가할 때 블록체인이 할 수 없는 것이 무엇인지 이해하는 것이 중요하다. 병원 병동과 아기를 추적하는 문제를 생각해보자. 이는 매우 심각한 문제다. 아기가 다른 아기로 오인된다면 끔찍한 결과를 야기한다. 따라서, 아디글의 현재 위치가 담긴 기록을 불변하고 검증가능하도록 저장하는 것은 블록체인 기술을 많이 사용하는 것 처럼 보인다. 하지만 이런 문제를 위해 블록체인을 사용하는 것은 큰 문제가 있다. 디지털 기록은 불변할 수도 있고, 입증될 수도 있지만, 어떤 디지털 기록이 어떤 아기에게 부착되어 있는지는 어떻게 아는가? 블록체인의 항목을 실제 아기에게 연결하기 위해서는 물리적태그를 통해서나 미래세계에서는 작은 칩이나 디지털 게놈기록을 연결하는 물리적 식별자를 주어야 한다. 그리고 여기에서 블록체인의 가능성이 무너진다. 이 프로세스는 도움이 될 수 없으며, 검증의 가장 중요한 단계가 올바르게 진행되고 있는지 확인할 수 없다. 오프라인 세계와 디지털 표현의 인터페이스에서의 기술의 유용성은 여전히 디지털 기록과 물리적 개인, 기업, 장치, 이벤트 사이의 마지막 거리를 효과적으로 연결할 수 있는 신뢰할 수 있는 매개체에 달려 있다. 이 예에서, 기술은 아기와 디지털 기록 사이의 일치점을 정확하고 정직하게 구현하기 위해 인간에 의존할 것이다. 만약 인간이 잘못된 정보를 얻거나, 데이터를 조작한다면, 진실성을 가지고 있다고 믿어지는 시스템에서 이것은 부정적인 결과를 초래 할 수 있다. 한편, 개인과 개인 의료 기록 사이의 연관성이 성공적으로 확립되고, '마지막 거리’의 문제를 효과적으로 해결할 수 있다면, 블록체인으느 데이터 무결성을 보장하거나 의료 데이터에 대한 사용방법을 통제할 수 있다. (연구 목적, 피트니스 앱, 상업적 약물 개발 등) 다른 비슷한 예가 있다. 마케팅에서 종종 발생하는 문제 중 하나는 광고주가 지불하는 '광고 타켓’이 실제로 그들이 해야할 사람들에게 속하지 않을 수 있다는 것이다. 예를 들어, 광고주는 30대 중반 남성에게 람보르기니를 광고하는데 돈을 지불한다고 생각할 수 있지만, 이 광고는 미니밴을 운전하는 사람들에게 보여질 수도 있다. 더 나쁜 것은 광고가 봇에게 노출되는 가능성이다. 블록체인 기술은 어떤 디지털 식별자가 광고를 보는 것과 연관되어 있는지 추적할 수 있지만, 인간성이나 구매자의 의도에 대한 정직성을 확인하는데 도움이 될수는 없다. 디지털 신원의 배후에 누가 있는지 확인하려면 오프라인 확인이 필요하다. 명백한 구매의도의 정식성으르 확인하는 것은 현재 우리가 가지고 있는 어떤 기술도 뛰어넘을 것이다. 긍정적인 측면으로 본다면, 블록체인 기술을 사용하여 디지털 콘텐츠 제작자, 광고주, 소비자 간의 관계를 변경할 수 있다. 광고주는 사용자들에게 독점적인 온라인 콘텐츠를 접근할 수 있게 함으로써 사용자들의 관심에 보상을 할 수 있다. 콘텐츠 제작자들은 블록체인의 저렴하고 효과적인 거래를 만들어 낼 수 있는 새로운 수익화 모델을 탐구할 수 있다. 소비자들은 소액결제에 필요한 정신적인 비용 때문에 소액 결제를 싫어하지만 (소액지불은 소비자의 머리에서 일어나는 택시 미터와 같다) , 이를 유료의 벽과 구독(subscribe)이 다양한 디지털 속성에서 어떻게 작동하는지 재구성할 수 있다. 게다가 광고를 보는 것이 실제 사람인지 여부를 걱정하는 대신, 브라우징 데이터 같은 디지털 기록에 대한 소유권을 보장하는 데 쓰인다면, 블록체인은 완벽하게 작동할 수 있다. 프라이버시의 경제성을 확립하는데 직면하는 문제 중 하나는 데이터에 대한 소유권 문제다. 블록체인은 이를 완벽하게 해결할 수 있는 위치에 있다. 블록체인 기술 주변의 생태계가 발달함에 따라서, '마지막 거리’문제를 오프라인과 동기화하여, 디지털 기록을 실제 비즈니스 기회로 바꾸는 새로운 형태의 중개업체들이 속속 등장할 것이다. 기술은 초기 단계지만, 이러한 핵심적인 보완이 성숙함에 따라서 블록체인은 디지털 데이터 및 매일 사용하는 디지털 플랫폼에 대한 소유권을 근본적으로 재구성할 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 그 자체로는 해결책이 되지 않는 이유","slug":"Why-blockchain-is-not-a-solution-in-and-of-itself","date":"2018-08-20T15:00:00.000Z","updated":"2018-08-20T18:00:00.000Z","comments":true,"path":"2018/08/21/Why-blockchain-is-not-a-solution-in-and-of-itself/","link":"","permalink":"https://www.yceffort.kr/2018/08/21/Why-blockchain-is-not-a-solution-in-and-of-itself/","excerpt":"Why blockchain is not a solution in and of itself 원문 개인들이 점점 데이터 보안의 중요성에 대한 이해를 발전시키고 있는 것 같다. 지난 5월 GDPR 준수가 발효되었고, 수천만명의 페이스북 사용자들이 정치와 관련된 마이크로 타겟팅 캠페인에 활용되고 있는 데이터와 관련된 스캔들로 인하여 사람들이 흔들리기 시작했다. 블록체인 기술은 모든 사용자 데이터를 수집하여 기업에 이익을 위해 판매하는 판옵티콘을 끝낼 수 있는 기술로 칭송받고 있다. 블록체인에 대한 언급만으로도 모든 산업 측면에서 분권","text":"Why blockchain is not a solution in and of itself 원문 개인들이 점점 데이터 보안의 중요성에 대한 이해를 발전시키고 있는 것 같다. 지난 5월 GDPR 준수가 발효되었고, 수천만명의 페이스북 사용자들이 정치와 관련된 마이크로 타겟팅 캠페인에 활용되고 있는 데이터와 관련된 스캔들로 인하여 사람들이 흔들리기 시작했다. 블록체인 기술은 모든 사용자 데이터를 수집하여 기업에 이익을 위해 판매하는 판옵티콘을 끝낼 수 있는 기술로 칭송받고 있다. 블록체인에 대한 언급만으로도 모든 산업 측면에서 분권화, 혁신 및 무한 잠재력에 대한 비전을 블러이르키고 개인데이터를 눈에 띄지 않게 한다. 하지만 진실은 이것이 대부분 과장된 것이라는 것이다. 블록체인 기술은 세계 데이터 문제를 해결하기 위해 휘두룰 수 있는 마법의 지팡이가 아니다. 분산형 원장의 힘은 본질적으로 공공성에 있다. 이 힘은 모든 사람이 한주소에서 다른 주소로 자금이나 데이터의 흐름을 추적할 수 있는데에서 나온다. 가명성은 종종 개인정보와 얽혀 있으며, 이는 위험한 평행성이기도 하다. 비트코인에서 단순하게 가치를 교환하는 것에서 시작하여 많은 것을 얻어왔다. 까다로운 스마트 컨트랙트를 통해 블록체인 플랫폼 위에 복잡한 어플리케이션을 구축할 수 있다. 인터넷 접속이 가능한 사람은 누구든지 계약서나 자료를 보고 분석할 수 있으며, 이더리움 위에서 운영하는 비즈니스도 만들 수 있다. 제3자가 기밀정보에 접근하지 못하도록 막는 것이 실행 가능한 해결책일까? 절대 그렇지 않다. 독립형 솔루션으로서의 블록체인은 금융, 의료, 그리고 거의 모든 이용사례에서 좋지 못하다. 이는 이더리움이 직면한 유일한 문제는 그것만이 아니다. 이런 방식으로 데이터를 저장하는 것이 현명하다는 가정을 세우더라도, 처리해야할 수수료 문제가 있다. 블록체인에 몇 줄 텍스트를 저장하는데 드는 비용은 상당하다. 이경우 네트워크의 모든 전체 노드가 사본을 다운로드 해야한다는 점을 기억해야 한다. 대규모로 이런 일을 처리하게 되면 사업이 파산이 날 것이다. 분명 불변성과 검열에 저항한다는 것은 가치 있다. 그러나 데이터 저장은 아니다. 앞으로 나아갈 길은 두가지 매우 강력한 도구의 효율성을 극대화 하기 위한, 블록체인 기술과 분산된 스토리지의 조합이다. P2P 스토리지가 이러한 목적에 이상적으로 적합하다고 생각한다. 블록체인 처럼, 이는 분산되어 있다. 중앙집중식 당사자를 통해 데이터 패킷을 라우팅 하는대신, P2P 방법을 사용하면 참여자들이 직접 토렌트 처럼 정보조각을 다운로드 할 수 있다. 이는 특정 파일에 대한 엑세스 할 수 있는 권한, 소유권 을 추적하기 위해 분산원장과 융합될 수 있는 안전한 대안이다. 이러한 하이브리드 솔루션은 개발자가 새로운 분산 응용 프로그램을 설계할 때 훨씬 더 유연성을 부여한다. 텍스트 문서에서 HD영화에 이르기까지, 파일을 굥유하는 비용은 존재하지 않는다. 스마트 컨트랙트를 통해 제작자는 콘텐츠를 통해 수익을 창출을 위해 정해진 가격을 개인에게 부과할 수 있다. 기업은 민감한 정보를 이더리움 네트워크 전체에 노출시키지 않고, 블록체인 기술의 힘을 이용하여 운영할 수 있다. 앞서 언급한 페이스북의 케임브리지 스캔들은 한가지 뼈아픈 사실을 분명히 했다. 즉 비즈니스 모델이 수익을 창출하는데 초점을 맞추고 있는 회사들에게 적극적으로 데이터가 전달되고 있다는 것이다. 규제 당국에 의해 취해진 조치들은 디지털 시대에 적응하기엔 너무 느리다. 법률 뿐만 아니라 기술적 수단으르 통해서도 보호롤 보장받을 필요가 있다. 분산된 액세스 부여 프로토콜은 이와 같이 때때로 필요하다. 개인은 자신의 데이터에 대한 완전한 소유권을 유지하면서도 적합하다고 판단할때 엑세스를 허용하고 취소할 수 있다. 블록체인은 데이터 저장에 대한 해결책이 아니다. 하지만 블록체인은 그 문제에 대한 해답의 일부다. 새로운 기술을 활용하면, 자체 주권을 특징으로하는 인터넷의 특징을 또 한번 누릴수도 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"Blockchain Technology Adoption","slug":"blockchain-technology-adoption","date":"2018-08-19T15:00:00.000Z","updated":"2018-08-19T18:00:00.000Z","comments":true,"path":"2018/08/20/blockchain-technology-adoption/","link":"","permalink":"https://www.yceffort.kr/2018/08/20/blockchain-technology-adoption/","excerpt":"Blockchain Technology Adoption 원문 일반적인 Technology Adoption CycleGoogle Trends: BlockchainGoogle Trends: BitcoinBlockchain: News ArticlesBlockchain: Book Titles전반적으로 웹검색, 잡지 기사, 책 제목을 기반 증거에서는 블록체인의 확산이 주로 처음 두 그룹 (혁신가, 얼리어답터) 내에 있음을 나타낸다. 이 두그룹 모두 블록체인이 두가지 이유로 높은 수준의 불확실성과 관련이 있음을 나타낸다. 첫째, 블록체인","text":"Blockchain Technology Adoption 원문 일반적인 Technology Adoption Cycle Google Trends: Blockchain Google Trends: Bitcoin Blockchain: News Articles Blockchain: Book Titles 전반적으로 웹검색, 잡지 기사, 책 제목을 기반 증거에서는 블록체인의 확산이 주로 처음 두 그룹 (혁신가, 얼리어답터) 내에 있음을 나타낸다. 이 두그룹 모두 블록체인이 두가지 이유로 높은 수준의 불확실성과 관련이 있음을 나타낸다. 첫째, 블록체인은 아직 실험단계에 있다. 즉 기능이 완전히 개발되지 않았을 수도 있다. 이는 분산 동기화 문제 (비잔틴 장군의 문제)를 해결하기 위한 솔루션이 증가하고 있음이 나타낸다. 작업증명외에도 지분증명, 협력증명, 투표 시스템 드잉 있다. 둘째, 신기술을 기존 프로세스와 통합하는 방법에 대해 명확한 그림을 가지고 있지 않을 수 있으며, 더 중요한 것은 예상되는 이점이 분명하지 않을 수도 있다는 것이다. 보고서 대다수는 기술을 채용하는 사람들이 기술을 수익화 하기 보다는 블록체인을 더 잘 이해하려고 시도하는 것으로 났다. 킬러앱은 아직 출현하지 않은 것으로 보이며, 일부 어플리케이션은 블록체인이 문제를 찾는 해결책으로 남아 있다고 주장하기도 한다. 따라서 전략적 관점에서 볼때, 경쟁사 보다 앞서 블록체인에 투자하는 이점은 투자가 긍정적이고 중요한 성과를 제공하지 못할 위험도 존재하므로 균형을 이루고 있다. 일반적으로 블록체인 채택을 고려하는 기업은 강력한 재정적 지위에 대한 높은 욕구를 가지고 있다. 후자는 구현 실패로 인한 잠재적인 실패도 감당할 수 있다. 이러한 증거는 유행보다는 합리적인 선택에 의해 주도되는 것으로 보이지만, 연구자와 실무자들은 여전히 회의론을 권장한다. 이들 중 일부는 블록체인 이니셔티브가 필요한지 여부를 질문한다. 몇몇 연구는 관계형 데이터베이스가 보다 효율적이고 효과적인 솔루션이라고 주장한다. ¶결론 블록체인은 많은 산업에서 기업의 외부 환경 (고객, 기존 경쟁자, 잠재적인 신규 진입자, 공급업체, 파트너, 규제 환경의 위험 또는 기회)을 변화시킬 가능성이 있다. 이는 가능한 모드 이해 관계자 (즉, 블록체인 생산자, 채택자, 투자자, 분석가)에게 기회와 위협이 있음을 의미한다. 그러나 최근의 과대광고에도 불구하고 기술 채택률은 상대적으로 낮다. 이는 채택자가 여전히 기술적 제한, 규제 문제 및 예쌍되는 효익의 자본화를 위한 잘 정의된 사업모형의 결여에 대해 우려하고 있음을 나타낸다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"우주산업에서의 블록체인","slug":"Blockchain-in-the-space-industry","date":"2018-08-19T15:00:00.000Z","updated":"2018-08-19T18:00:00.000Z","comments":true,"path":"2018/08/20/Blockchain-in-the-space-industry/","link":"","permalink":"https://www.yceffort.kr/2018/08/20/Blockchain-in-the-space-industry/","excerpt":"Houston, We Have a Solution: Blockchain in the Space Industry 원문 우주는 역사적으로 거의 모든 정부가 연구해 온 영역으로, 철저하고 수준 높은 연구와 상당한 자금이 필요한 복잡한 연구다. 최근에는 SpaceX와 같은 대담한 스타트업의 출현으로 덜 독점적인 영역이 되었다. 그러나 이제 블록체인의 기본 기술이 이전에 공유되지 않은 영역에 더 많은 힘을 불어 넣고 있는 것으로 보인다. 빅 플레이어들은 우주 탐사를 위해 블록체인을 채택하고 있다. 미국 항공 우주국 (이하 NASA)와","text":"Houston, We Have a Solution: Blockchain in the Space Industry 원문 우주는 역사적으로 거의 모든 정부가 연구해 온 영역으로, 철저하고 수준 높은 연구와 상당한 자금이 필요한 복잡한 연구다. 최근에는 SpaceX와 같은 대담한 스타트업의 출현으로 덜 독점적인 영역이 되었다. 그러나 이제 블록체인의 기본 기술이 이전에 공유되지 않은 영역에 더 많은 힘을 불어 넣고 있는 것으로 보인다. 빅 플레이어들은 우주 탐사를 위해 블록체인을 채택하고 있다. 미국 항공 우주국 (이하 NASA)와 유럽 우주국 (이하 ESA) 등 우주 거물들은 블록체인을 이용해 임무를 수행하는 방법을 연구하고 있다. 지금까지 발견된 것은 이 기술이 지상과 (데이터 관련 프로세스 촉진)우주 (깊은 우주를 탐색하는데 도움이 되는 것)에서 모두 유용할 수 있음을 시사한다. ¶NASA 2017년, NASA는 블록체인 기반의 자율 우주선 개발을 지원하는 데 33만달러의 보조금을 지급하여 블록체인 도입을 향한 첫 걸음을 내디뎠다. Resilient Networking and Computing (RNCP) 패러다임이라고 하는 이 새로운 시스템은 블록체인에 의존하며 사람의 개입을 필요하지 않다. RNCP는 까다로운 우주 환경 조건에 적용할 수 있는 보안 컴퓨팅 시스템 개발을 위해 이더링룸 기반 블록체인 스마트 컨트랙트의 적용을 검토한다. 이 프로젝트에서 이더리움 블록체인 기술은 깊은 우주 탐험을 위한 분산되고 안전한 인지 네트워킹과 컴퓨팅 인프라를 개발하기 위해 활용될 것이다. 기반 구조의 탄력성을 개선하기 위해 블록체인 합의 프로토콜에 대해 더 자세히 연구할 것이다. 환경적인 위협을 인식하고 피할 수 있는 기술을 개발하여 많은 과제를 자동화로 완수 할 수 있도록 하고 싶다. 좀 더 자세히 설명하자면, RNCP 시스템은 스마트 컨트랙트를 활용하여 자동으로 신속하게 장애물을 감지하고 피할 수 있는 우주선을 개발하는 것이다. 우주 공간에서 기존 통신 수단은 신호가 약해짐에 따라서 신뢰성이 떨어진다. 따라서 블록체인 솔루션을 갖춘 우주선이 잠재적인 환경 위협을 감지하는데 시간을 낭비할 필요가 없기 때문에 더 많은 작업을 완료하고, 더 많은 데이터를 제공하며, 과학자에게 정보 분석에 더 많은 시간을 줄 수 있다. 구체적인 개발 일정은 아직 공개 되지 않았다. ¶ESA 유럽의 NASA인 ESA는 블록체인을 내부 프로세스를 능률화 하는 방향으로 연구하고 있다. 2017년 9월 ESA는 ‘분산원 장 기술: ESA의 성공을 위한 블록체인 활용’ 이라는 보고서를 발표 했다. 이 보고서에서는 블록체인의 일반적인 장단점을 몇가지 구체적인 예를 사용하여 요약한다. 특히 물류, 신속 정확한 지불, 데이터 변경에 대한 실시간 엑세스, 엑세스 권한에 대한 원활한 업데이트 및 변경 불가능한 투표 시스템에서 스마트 컨트랙트를 사용하는 등 ESA에 적합한 잠재적인 이익에 중점을 두었다. 여기에서, ‘전세계 다양한 우주 행위자가 증가하는 상황’ 으로 정의된 Space 4.0ㅅ의 맥락에서 블록체인을 적용하는 전망을 논의한다. 논문의 저자 중 한명은 유럽 워크숍에서 아래와 같이 의견을 밝혔다. 우주 4.0 시대에서는 우리 자신의 삶에서와 마찬가지로, 혼란과 기회에 대한 적극성, 그리고 개방적인 문화의 변화를 위해 적응하고 육성해야 한다. ¶더욱 민주화됨으로써 스타트업이 우주에 한걸음 내딛다 실제로 우주에 대한 연구는 더이상 연구 프로그램에 지속적으로 현금을 투입할 수 있는 수단을 가진 정부에만 국한되지 않는다. 저렴한 인공위성이 등장하게 되면, 블록체인은 우주로 발사할 수 있으며, 완전히 분산되지 않는 인프라 시설과 연계될 수 있다. 페이스북과 구글은 여전히 광섬유 케이블로 연결되어 있다. 여기에 우주를 더 민주화 하기를 원하는 스타트 업들이 있다. 하지만 이들 대부분은 특정한 일정을 특징할 수 없고, 따라서 미성숙한 상태로 남아 있다. ¶Space Decentral Space Decentral은 2018년 초에 발표된 백서에서 밝혀진 싱가포르 기반 스타트업이자 분산 자치 단체 (DAO)다. 본질적으로 미국, 러시아와 같은 우주 개척자들이 우주 탐험에 중요한 반면, 우주 개발은 더욱 민주화 되고 있으며, 이제는 기본적으로 개인에게도 Space 4.0과 같은 기회가 있다는 생각을 바탕으로 하고 있다. 이 프로젝트의 계획은 상당히 모호하지만, '수십만 명의 새로운 행위자들이 재정 지원자로써 뿐만 아니라 다양한 우주자금을 제공하는데 있어서, 국적에 관계없이 기여하여 글로벌 우주 기관의 일부가 될 수 있도록 크라우드 펀딩 수단을 제공’하고 있다. 이들은 FTL Coin (Faster than Light Coin)이라는 유틸리티 토큰을 발행할 계획을 표명했다. 전직 NASA직원 4명으로 이루어진 Coral이라는 스타트업은 첫번재 분산 우주 프로그램을 발표했다. 여기에서 주 목표는 우주 정착민을 위한 인프라 구축을 위해, 달 표면에서 3D 프린트를 용이하게 하는 것이다. ¶SpaceChain 스타트업 SpaceChain은 직접적인 우주 탐사보다는, 우주를 포함한 블록체인에 대한 경험을 개선하기 위해 기존 인프라를 활용하는 방안에 대해 논의 하고 있다. 기본적으로 SpaceChain은 블록체인 노드에서 실행되는 세계 최초의 오픈소스 위성 네트워크를 구축하고 있다. 이 회사의 CEO는 진정한 분권화의 가치를 알고 있는 것으로 보인다. 분산형 전자 상거래 플랫폼을 운영할 수는 있지만, 백엔드에서는 Amazon Web Service를 사용하고 있다. 이들의 기술 인프라가 모두 중앙집중식 서비스에 의존하면, 진정한 분권화를 이뤄내기 어렵다. 전 비트코인 개발자이자 Bloq의 CEO인 Jeff Garzik, 그리고 가장 유명한 암호화폐 투자자인 Tim Draper가 후원한 SpaceChain은 2018년 2월 저렴한 CubeSat 기술을 기반으로 최초의 저궤도 위성을 발사했다. SpaceChain의 오픈소스 운영체제가 지원하는 원전히 분산된 네트워크를 구축하여, 다른 개발자를 위한 블록체인 샌드박스가 되는 것을 목표로 한다. 위성은 데이터 처리, 전송, 우주 내 데이터 저장 및 응용 프로그램 개발을 위한 블록체인 노드로 사용된다. SpaceChain 은 또한 Qtum가 통합되어 스마트 컨트랙트 및 블록체인 응용프로그램에 대한 기본적인 API를 제공한다. ¶BlockStream BlockStream이라고 하는 스타트업은 2017년 위성 프로젝트를 발표하면서 블록체인을 모든 지구인들에게 전송하고, 첫번 째 거래를 수행하기 시작했다. 우주 기반 블록체인을 실행하기 위해 이 위성은 오픈 소스 기술에 의존 했다. 누구나 작은 위성 접시와 USB SDR 인터페이스로 신호를 수신할 수 있다. 사용자의 총 장비 비용은 약 100달러다. 소프트웨어는 무료다. 소프트웨어 인터페이스는 수신기인 오픈소스 GNU 라디오 소프트웨어다. GNU 라디오는 비트코인 브로세스 이며, 블록이 있는 FIBRE (Fast Internet Bicoin Relay Engine) 프로토콜에 데이터를 보낸다. 아프리카, 유럽, 남아메리카, 북미에서 사용자가 베타 노드를 최초로 다운로드 할 수 있었다. 이는 지구으 2/3을 커버한 것이다. 아직 다른 지역은 공개되지 않은 것으로 보인다. ¶Nexus 애리조나에서 시작된 스타트업 Nexus는 소위 세계 최초 3차원 블록체인을 발표했다. Vector Space Systems (미국의 우주 기술 회사로, 소형 위성을 궤도로 쏘아올리는 것을 목표로 한다.)과 협력하여 위성 네트워크를 개발하고 있다. 여기에서 미션은 ‘지구의 저 궤도 위성 네트워크에서 소프트웨어 플랫폼을 사용하여 디지털 통화 및 자율 인터넷 인프라에 대한 글로벌 엑세스를 제공하는 것’ 이다. 위 프로젝트와 유사하다. Nexus는 또한 거대한 기업이 지배하는 세계에서 분권화의 중요성을 강조한다. 우주 기반 플랫폼은 위성이 정부나 기업체의 규제 또는 통제에 저항하기 때문에 분산된 응용 프로그램에 대한 보안을 제공한다. 또한 이 스타트업은 위성 기반 블록체인 네트워크를 통해 ‘신뢰 가능하고 저렴한’ 인터넷 엑세스를 제공하고 있으며, 상용 응용 프로그램에서 모은 수익은 일반 고객을 위한 비용을 낮추고 네트워크 유지 보수 비용을 지불하는데 사용된다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"상품거래에서 블록체인 활용에 대한 팩트 체크","slug":"A-reality-check-for-blockchain-in-commodity-trading","date":"2018-08-19T15:00:00.000Z","updated":"2018-08-19T18:00:00.000Z","comments":true,"path":"2018/08/20/A-reality-check-for-blockchain-in-commodity-trading/","link":"","permalink":"https://www.yceffort.kr/2018/08/20/A-reality-check-for-blockchain-in-commodity-trading/","excerpt":"A Reality Check for Blockchain in Commodity Trading 원문 상품 거래를 업으로 일하는 사람들 입장에서는, 블록체인은 만병통치약으로 보인다. 블록체인 기반 플랫폼은 비효율성과 신뢰문제, 일반적으로 여러 상대방이 포함되어 있는 거래의 복잡성 등의 문제를 해결해 줌으로서 상품 거래 산업이 운영되는 방식을 개선해 준다. 복잡한 거래를 투명하게 기록하고, 상품을 추적하고, 사기를 줄이는 이 기술의 능력은 상품 거래 비즈니스에 적합하다. 그러나 그렇게 빠르지 않다. 기업들은 이미 신뢰를 키우고 다른","text":"A Reality Check for Blockchain in Commodity Trading 원문 상품 거래를 업으로 일하는 사람들 입장에서는, 블록체인은 만병통치약으로 보인다. 블록체인 기반 플랫폼은 비효율성과 신뢰문제, 일반적으로 여러 상대방이 포함되어 있는 거래의 복잡성 등의 문제를 해결해 줌으로서 상품 거래 산업이 운영되는 방식을 개선해 준다. 복잡한 거래를 투명하게 기록하고, 상품을 추적하고, 사기를 줄이는 이 기술의 능력은 상품 거래 비즈니스에 적합하다. 그러나 그렇게 빠르지 않다. 기업들은 이미 신뢰를 키우고 다른 장애물을 해결하기 위하여 다양한 메커니즘에 투자했다. 그리고 블록체인은 시장의 비효율성에 의존하여 돈을 벌고 있는 트레이더와 같은 특정 플레이어들에게는 나쁜 소식이 될 수 있다. 블록체인 플랫폼으로 전환하는 것은 기존 시스템에서 보다 저렴하게, 그리고 파괴적으로 개편하는 것을 포함한다. 의사 결정권자들은 블록체인이 주는 혜택과 단점을 신중하게 고려해야 한다. 또한 초기 기술에 대한 과대 광고를 이용하는 방법을 고려해야 한다. 이 모든 블록체인에 대한 관심은 업계에 참여하고 있는 플레이어가 상품 거래의 열악한 표준화, 투명성을 해결할 수 있는 더 나은 방법을 찾도록 유도할 수 있다. ¶블록체인에 대한 현실성 체크 상품 거래는 상품의 표준화, 효율성 그리고 추적을 향상 시켜야 한다. 그러나 블록체인이 이러한 혜택을 제공할 킬러 앱인지 여부는 여전히 물음표다. 업계에서는 이 기술을 완전히 채택하지 못했다. 블록체인에는 좋은 이점이 있지만 여러 측면에서 중요한 단점이 있기도 하다. ¶가격과 중재 블록체인 기반 솔루션이 수용되기 위해서는, 대부분의 거래를 공유 원장에 정확히 기록해야 한다. 원장에 거래가 기록되면 참가자는 위탁가격 간의 차이를 비교하여 불일치를 발견할 수 있다. 투명성이 높아지면 가격이 더욱 공정해질 것이다. 그러나 이는 돈을 벌기 위해 가격 비효율에 의존하는 상인의 이익에 영향을 미칠 수 있다. 가격을 보고하는 기관들은 또한 사업을 확장할 수 있는 새로운 방법을 찾아야 한다. ¶위험 현재 거래 청산 (상대방이 채무 불이행을 하는 경우) 및 상품의 물리적 이송 (사기 및 품질 저하) 에 상당한 위험이 있다. 거의 실시간으로 가능하게 함으로써, 블록체인은 위험을 제거한다. 금융 시장 참가자들은 거래날짜와 결제일 사이의 간격을 좁히기 위해 고민하고 있다. 그러나 이러한 실시간 문제는 일부 상대방이 담보를 조기로 공개해야 하기 때문에 좋지 않을 수 있다. 단 변경 불가능한 단계별 검증은 참가자가 검사와 인증을 추적할 수 있도록 하여 물리적인 전달 위험, 특히 사기에서 발생하는 위험을 줄일 수 있다. ¶규제 감독 블록체인은 규제 보고를 크게 개선할 수 있다. 오늘날, 다양한 참가자들은 컴플라이언스 보고서를 제출한다. 그러나 블록체인을 사용하면 규제 기관이 공유원장에 자동으로 접근할 수 있다. 그 결과, 규제 기관은 제출한 사실에 대해 조사하는 것이 아니라 실시간으로 거래를 검사하고 불일치에 대해 빠르게 후속조치를 취할 수 있었다. 마찬가지로 전력 또는 가스 공급과 전력시장의 수요 균형을 맞추는 에너지 네트워크 회사는, 개인으로부터 정보를 수집하지 않고 실시간으로 시장 참여자의 위치를 조사할 수 있다. 장부에 보다 정확하고 시의 적절하며 세분화된 정보를 사용함으로써, 정치에 입각하여 보다 획기적인 개입을 할 수 있다. 여기에서 문제는 다른 국가 및 상품 시장에서 규제 지침의 일관성을 보장하는 것이다. ¶새로운 자본조달 메커니즘 ICO를 통해 회사는 자산 또는 기타 권리의 소유권을 블록체인이 지원하는 가상 거래 가능 토큰으로 전환할 수 있다. 이는 투자 자금 조달을 위해 선불로 팔릴 수 있다. 예를 들어, 리투아니 기반 플랫폼 WePower는 개발자가 보유자에게 향후 생산량을 공유할 수 있는 토큰을 판매, 재생가능한 에너지 프로젝트를 위한 기금을 마련할 수 있었다. 하지만 ICO에는 단점이 있다. 국제 제재 대상 국가에 있는 기업들이 ICO를 사용하여 이러한 제한을 우회하고, 국제 기금을 활용할 수 있어 규제 당국의 분노를 샀다. 거래를 해결하기 위해 토큰과 기존 통화를 모두 인식하는 시스템을 만들어 운영하면 비용이 많이 들고 복잡해질 수 있다. 또한 ICO는 여전히 대규모 상품 프로젝트에 대해, 다른 자금 조달 옵션 보다 더 저렴하고 나은 선택임을 입증해야 한다. ¶IT 투자와 새로운 프로세스 상품 거래 관행은 수년에 걸쳐 개발되어 왔다. 그러나 상당한 변화를 겪고 있으며, 많은 기업들이 새로운 규제 요규를 충족시키기 위해 IT 시스템에 막대한 투자를 해왔다. 블록체인 솔루션을 사용하여 보다 투명하고 동기화된 시장으로 전환하면, 상품 회사가 운영하는 방식, 특히 물리적 상품 거래 방식이 근본적으로 바뀔 것이다. 그러나 추가적인 IT 인프라에 대한 투자가 필요하다. 또한 모든 당사자들이 블록체인에 참가해야 혜택이 실현될 수 있기 때문에 업계는 협력적으로 행동해야 할 것이다. ¶블록체인 vs 비트코인 상품, 에너지 제품, 전기 사업자들은 은행 산업의 선례를 따르고 있는데, 이는 분산 공공 원장으로서의 블록체인의 기능이 국가 간 결제, 해외 거래, 그리고 외환 거래에서 어떻게 거래를 추적하고 처리할 수 있는지 조사하고 있다. 하지만 많은 비즈니스 리더들은 블록체인을 오인하고 있다. 이들은 일반적으로 블록체인을 암호화폐와 연관지어 생각한다. 하지만 이 잠재적인 활용범위는 훨씬 더 광범위 하다. 본질적으로, 블록체인 플랫폼은 중앙 당사자가 제어할 필요가 없으며, 모든 참가자가 엑세스 할 수 있는 암호화된 불변의 데이터베이스로 작동한다. 블록체인 플랫폼은 상품 추적, 계약 기록, 무역 문서의 신뢰등 등록 기관의 역할을 할 수 있다. 블록체인은 배포되고, 보안이 유지되며, 정보를 디지털화하며 계약을 자동으로 실행하고 절차를 표준화 하는데 사용할 수 있으므로 참가자는 거래를 안정적으로 관리하고 해결할 수 있다. 그리고 허가된 플랫폼을 사용하면 실시간으로 합의가 이루어질 수 있다. 그러나 회의론자들은 블록체인은 엄청난 양의 전력을 필요로 하며, 거래가 추가됨에 따라 원장은 다루기 어려워진다고 주장한다. 이 기술이 아직 복잡한 응용 분야에 적합하다는 것을 보여주지 못했다고 주장한다. 블록체인을 널리 쓰게 되면 상품 거래의 전통적인 가격 설정 매커니즘이 위협 받을 수 있다고 말한다. 그러나 이 비판은 블록체인 자체와 블록체인이 적용된 비트코인간의 문제를 혼동하는 것이다. ¶다루기 힘든 원장 블록체인 플랫폼은 네트워크의 모든 사용자 트랜잭션을 기록하기 때문에 원장이 너무 커져 쉽게 작동할 수 없다고 비판한다. 사실 비트코인이 탄생한 2009년 이래 데이터 베이스의 크기는 150기가 바이트에 불과하다. 상품거래, 특히 금융 상품이 아닌 물리적인 상품이 거래되는 경우 거래건수는 비트코인 보다 적을 것이다. 단일 거래가 1000배럴의 원유를 포함하는지 여부와 관계 없이, 이는 쉽게 기록이 검증되고 제거 될 수 있다. ¶복잡함? 블록체인은 비트코인과 같은 암호화폐 응용 프로그램에서 상대적으로 직접적인 역할을 수행하면서, 가치 저장소와 함께 지불 수단으로 사용될 수 있다. 주요 기술적인 과제는 비트코인을 기존 통화로 교환하는 방법이다. 그러나 블록체인은 상품 거래에서 흔히 볼 수 있는 보다 복잡한 응용 프로그램과 함께 사용할 수도 있다. 이 기술을 통해 자산, 현금 포지션 및 증권에 대한 여러 원장이 서로 인터페이스 할 수 있다. 이로 인해 투명성과 가치 사슬에 대한 풍족함이 생길 수 있다. 또한 규제 기관 및 정부 기관이 블록체인 원장을 볼수는 있지만 변경할 수 없도록 엑세스 권한을 부여할 수도 있다. ¶가격 설정 위협 블록체인 기술은 사실상 원장에 국한되므로 시장가격을 자동으로 설정하지 않는다. 이를 위해서는 가격을 결정하기에 충분한 거래량이 발생하는 시장이 필요하다. 블록체인을 이용한 P2P 거래는 상품 거래의 가격을 정하는데 사용할 수 있다. 그러나 블록체인의 분산된 특징이 주어지면 사용자는 독자적으로 원장을 업데이트 한다음, 다른 사용자의 승인을 구할 수 있다. 가장 빠른 시스템임에도 불구하고 트랜잭션을 확인하고 기록하는데는 몇초가 걸린다. 이러한 시간 지연은 속도가 점점더 중요한 차별화 요인이 되는 상품거래에 중요한 단점이 ㅚㄹ 수도 있다. ¶블록체인이 상품 시장에 미치는 영향 블록체인을 채택하려면 상당한 투자가 필요하다는 것을 감안하면, 참여자들은 이것이 창출하는 가치와 성공 핵심 요인에 대해 분명히 이해 해야 한다. 블록체인의 상품 거래를 변화시키는 능력을 히해하기 위해서는, 가격 복잡성, 특히 현재의 가격 결정 매커니즘에 얼마나 많은 다양성이 존재하는지, 위탁 규모 변화를 포함하는 거래량, 원산지 인증에 대한 확실한 요구 사항, 현재 인프라가 어떻게 개발되었는지, 효율성이 개선된 채계적인 프로세스가 얼마나 유익한지, 효율적인 시장 인프라에 도달하기 위한 노력등에 대해 이해 해야 한다. 블록체인 솔루션은 모든 상품 시장 비즈니스에서 작동하는 방법을 개선할 수 있으며, 각 상품에 다양한 방식으로 영향을 미친다. ¶전력과 가스 이 시장에서는 이미 높은 수준의 표준화와 투명성으로 이익을 얻고 있으며, 동질적인 제품을 취급한다. 결과적으로 블록체인 기술이 기존 시스템에 영향을 미치는 범위가 제한적이다. 블록체인 플랫폼을 채택하는 이유는 거래량이 많은 전력 및 가스와 같은 시장에서 효율적인 결제를 강화하기 위한 것이다. 이 응용 프로그램에서 블록체인은 현재의 청산 및 조정과정이나 산업계약을 관리하는 시스템에서 단순한 부품에 불과할 것이다. 블록체인은 거래비용을 감소시킬 수도 있지만, 거래자의 운영방식에 직접적인 영향을 미치지는 않을 것이다. 도매 전력 및 가스 시장의 주요 업체들은 대부분 백오피스 프로세스 관리를 위해 IT 시스템에 상당한 투자를 해왔다. 그러므로, 블록체인 채택은 점진적으로 이루어질 것이다. 블록체인 솔루션은 전력시장의 소매업종에서 훨씬 더 많은 영향을 미칠 수 있다. 기존의 중앙집중식 전력망으로 돍립적으로 작동 가능한 분산형 전력발전과, 국소형 마이크로 그리드가 인기를 끓고 있다. 블록체인은 P2P 온라인 플랫폼을 개발하여 지역 생산자와 구매자가 에너지를 교환할 수 있도록 만들고 있다. 그러나 이러한 어플리케이션에도 블록체인 P2P 거래의 규모에 제한이 있는 세가지 기본적인 이유가 있다. 스타트업은 마이크로그리드의 부하 분산을 촉진하는 P2P 솔루션을 개발하고 있다. 대부분 가동 중에 용량을 생성할 수 있는 추가 소스를 제공하여, 수요 피크를 효과적으로 관리하는데 초점을 맞추고 있다. 그러나 마이크로 그리드가 생산자에게 용량을 정지할 동기를 부여하여, 잉여 공급에 대처할 수 있는 해결책을 모색하는 개발자는 거의 없다. 이러한 솔루션은 P2P 에너지 시스템이 폭넓게 수용되려면 필수적이다. P2P거래가 규모에 맞게 작동하고, 그리드 인프라를 활용하여 장거리에서 작동하려면, 개별고객이 선호하는 에너지 소스 (태양열, 풍력 등)를 선택하고 해당 소스를 보상할 능력이 필요하다. 이런 솔루션은 도매수준에서는 잘 정립된 방법이 있다. 그러나 소비자들이 도매시장에서 현재 에너지 회사가 하고 있는 것과 같은일을 하기 위해서는, 수십년간 그리드 디지털 기술에 막대한 투자가 필요하다. P2P 거래는 고객 경험에 중요하지만 원치 않는 복잡성을 가중 시킨다. 고객은 에너지 공급 회사로 부터 매월 청구서를 받는대신, 네트워크 내 선호나는 출처로 부터 에너지를 확보하기 위해 P2P 거래에 적극적으로 참여해야 할 것이다. 전력을 소비하고 전기를 발생시키는 '프로슈머’들이 얼마나 많은 애너지를 생산하고 있는지 제어해야 할 것이다. ¶석유, 철광석, 다이어몬드 이 시장은 일일 거래수가 적다는 특징이 있지만, 개별 상품의 가격이 품질 및 원산지와 같은 요소에 따라 좌우된다는 점이 다르다. 효과적이 품질 관리 및 원산지에서 최종 배달까지의 실시간으로 상품 추적, 투명성 증가, 사기 방지가 중요한 관심사다. 참가자들은 아직 거래를 표준화하고 효율성을 향상시키는 방법을 개발하지 못했다. 블록체인 솔루션을 사용하면 공급망의 투명성이 크게 향상되어 상품의 소유권 및 원산지를 확인하며 안전하고 신뢰할 수 있는 추적을 가능하게 한다. 또한 효율적이고 유동적인 시장을 창출하여 구매자와 판매자를 일치시키는 전자 플랫폼을 기반으로 한 거래를 만들어 양 당사자간에 직접적으로 상품 거래에 변화를 가져온다. 이를 성공적으로 채택하기 위해서는 업계의 선도적인 플레이어가 새롭고 파괴적인 블록체인 솔루션을 채택해야 한다. 이러한 솔루션으로 전환하기 위해서는 주요 참가자들이 필요하다. ¶앞으로의 블록체인 블록체인 기반 솔루션을 대규모로 채택하기 위해선 몇가지 조건을 충족해야 한다. 거래 속도와 전력 요구 사항이 개선되어야 하며, 인센티브를 잘 정렬할 필요가 있다. 또한 업계 참가자들이 이 기술을 동시에 채택해야 한다. 블록체인의 파괴적인 잠재력을 감안한다면, 기업은 블록체인 기반 솔루션이 어떻게 상품거래를 개선하여 미래의 기술 방향을 결정하는데 도움을 줄 수 있는지에 대한 논쟁에 뛰어들 때다. 또한 유사한 이점을 제공할 수 있으며 요구 사항이 더 간단하고 적합한 다른 기술들도 고려해 봐야 한다. 새로운 기술에 대한 논의는 참가자들이 낮은 투명성 및 표준화라는 근본적인 문제를 해결할 수 있는 대체방법을 찾도록 할 수 있다. 규제자들은 이러한 논쟁을 추진하는데 중요한 역할을 한다. 새로운 플랫폼을 만드는 과정은 복잡성과 비용 때문에 많은 사람들이 공동으로 진행한다. 신규 진입자들은 파트너를 신중하게 선택하고, 참가자가 잠재적인 사용 사례 뿐만 아니라 블록체인의 가치를 명확하게 이해할 수 있도록 해야 한다. 이들은 규제와 다른 장애물을 고려하고, 글로벌 솔루션을 창출할 수 있다고 믿기 보다는 지역적인 접근을 채택해야 한다. 간단히 말해, 블록체인은 모든 당사자들에게 올바른 해답이 아닐 수도 있다. 하지만 이 기술은 또다른, 똑같이 중요한 기능을 수행할 수 있다. 업계 전반에 걸친 토론을 가능하게 하고, 합의된 언어 및 표준화던 거래조건과 메커니즘을 중심으로 참가자들을 정렬함으로써 트로이목마 역할을 할 수 있다. 이러한 방식으로, 상품거래가 보다 투명하고 효율적인 시장으로 전환될 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"세계식량기구: 블록을 만들다","slug":"building-blocks","date":"2018-08-16T15:00:00.000Z","updated":"2018-08-16T18:43:19.000Z","comments":true,"path":"2018/08/17/building-blocks/","link":"","permalink":"https://www.yceffort.kr/2018/08/17/building-blocks/","excerpt":"Building Blocks / Blockchain ‘Crypto’ Assistance at WFP WFP에서의 블록체인 지원 원문 2017년 초, WFP는 굶주림과 의 싸움을 변화시킬 수 있는 기술을 활용하는 첫번째 단계를 밟았다. 암호 통화 비트코인과 관련이 있는 블록체인 기술은 인도주의자들이 우리가 봉사하는 사람들에게 효과적이고 효육적인 도움을 제공하고, 수백만 달러를 절약할 수 있는 능력을 향상시킬 수 있는 독특한 기회를 제공한다. ¶현금으로의 전환 최근 몇년 동안 WFP는 현금기반 이전(CBT: Cash-based T","text":"Building Blocks / Blockchain ‘Crypto’ Assistance at WFP WFP에서의 블록체인 지원 원문 2017년 초, WFP는 굶주림과 의 싸움을 변화시킬 수 있는 기술을 활용하는 첫번째 단계를 밟았다. 암호 통화 비트코인과 관련이 있는 블록체인 기술은 인도주의자들이 우리가 봉사하는 사람들에게 효과적이고 효육적인 도움을 제공하고, 수백만 달러를 절약할 수 있는 능력을 향상시킬 수 있는 독특한 기회를 제공한다. ¶현금으로의 전환 최근 몇년 동안 WFP는 현금기반 이전(CBT: Cash-based Transfer)에 맞춰 전환하고 있다. 2011년에는 전체 지원액의 5%에 불과했지만, 이는 작년 25%로 급증했다. WFP에서 혁신은 향후 몇년간 더욱 크게 증가할 것으로 예상됨에 따라서 CBT의 비용과 위험을 줄이고 수혜자의 데이터 보호및 기술 구현 속도를 향상시키는 핀테크를 포함한 혁신을 모색하고 있다. ¶블록체인 이해 간단히 말하자면, 블록체인은 데이터를 구성하는 최첨단 방법이다. 블록체인은 여러 참가자 네트워크를 통해 호스팅되는 분산 디지털 원장이다. ‘신뢰가 필요없는’ 구조 (네트워크에서 어떤 당사자도 서로를 신뢰할 필요가 없음)로서 정보를 공유하고, 디지털 자산을 빠르게 추척하고 안전한 방식으로 전송할 수 있는 방법을 제공한다. 불변의 안전한 블록에 데이터를 저장하고, 여러 당사자가 사본을 보유하면 사기, 절도, 조작의 위험이 거의 0로 줄어든다. 또한 P2P 특성은 은행이나 다른 기관과 같은 값비싼 중개자로부터 제3자의 검증 필요성ㅇ르 제거한다. 비용 절감, 정보 흐름의 추적가능성 및 거래에 소요되는 시간을 줄임으로써 WFP는 보다 효과적이고 효율적인 개입을 제공할 수 있다. ¶샌드박스에서 실제 필드로 2017년 1월, WFP는 현장에서 Building Blocks라는 초기단계 블록체인 프로젝트의 파일럿을 시작했다. 파키스탄에서 WFP는 핵심 가정과 블록체인이 현금 및 식량 지원 거래를 인증, 기록, 조정할 수 있는 능력을 테스트했다. 수혜자가 현물 식량 지원과 WFP의 현금을 받으면서 코드화된 거래가 공급업체에 의해 시스템에 기록되고, 기다리는 동안 스마트폰 어플리케이션을 통해 공개 블록체인에 인증되고 기록된다. 시스템에서 생성된 거래 보고서는 지출을 조정하고, 당사자간 의 신뢰를 보장하는데 사용된다. 블록체인 시스템의 기술적 타당성과 유용성을 확인한 WFP Building blocks는 CBT의 여러 측면을 지원하는 강력한 블록체인 엔진을 구축하고 있다. 이 시스템을 사용하는 파일럿은 2017년 봄에 이뤄질 것으로 보인다. ¶블록체인의 엄청난 잠재력 상대적으로 미성숙한 기술임에도 불구하고, 블록체인은 오버헤드를 줄이고 원조 제공 업체와 수혜자에 대한 보안을 강화하며, 궁극적으로 더 많은 자금이 기아를 종식시키는 방향으로 사용되도록 보장된다. 인터넷과 유사한 기초 기술로서, 블록체인은 인도주의적 운영의 많은 부분을 개선할 수 있는 잠재력이 있다. 이러한 사용하례는 현재 파일럿과 송금에만 국한되지 않는다. WFP는 신원 관리, 공급망의 운영을 가능케 하는 광범위한 블록체인 아키텍쳐를 구축하기 위해 적극적으로 노력하고 있다. 블록체인은 세계에서 가장 어려운 운영환경에서 빠르게 개입을 할 수 있도록 도와주고 있다. 금융인프라가 부족한 국가의 경우, 블록체인은 재난이 발생하면 인도주의 행위자가 생명을 구하는 현금 지원을 며칠만에 완료하는데 도움을 줄 수 있다. Building Blocks 원문 세계식량기구 (이하 WFP) 는 블록체인 기술을 활용하여 우리가 돕고 있는 사람들에게 효과적이고 효율적인 지원을 제공하고, 수백만 달러를 절약 시킬 수 있는 능력을 향상시키는 첫 걸음을 내딛고 있다. ¶송금 &amp; 블록체인 Building Blocks 파일럿의 일환으로 WFP는 송금을 보다 효율적이고 투명하며 안전하게 만드는 수단으로 블록체인을 테스트하고 있다. 송금은 바우처 또는 선불 직불 카드를 통해 사람들이 현지에서 자신의 음식을 구입할 수 있게 하며, 기아를 완화 하기 위하여 수혜자 스스로 구매결정을 내릴 수 있는 효과적이 방법이다. 2010년 3백만명에서 2015년 930만명으로 최근 몇년 간 꾸준히 증가하고 있는 이 수단은 수혜자의 숫자와 함께 점점 더 중요한 지원을 제공하는 수단이다. 블록체인은 중앙 기관 없이 자산 소유권을 추적할 수 있는 신뢰할 수 있는 방법으로 사용되는 디지털 원장기술로, 사기 또는 데이터 관리의 실수를 막아주면서도 거래를 가속화 할 수 있다. 결정적으로, P2P 특성은 은행이나 다른 기관과 같은 값 비싼 중개자로부터 검증 필요성을 제거한다. 블록체인의 힘을 잘 활용함으로써 WFP는 송금과 관련된 지불 비용을 줄이고, 수혜자의 개인정보를 잘 보호하며, 재정적인 위험을 통제하고, 비상 사태 발발시 신속하게 지원 작업을 설정하는 것을 목표로 한다. ¶요르단과 파키스탄에서의 파일럿 2017년 1월, WFP는 파키스탄의 한 지방에서 거래를 인증하고 등록하는 블록체인기능에 대한 기본 가정을 확인 하기 위해 PoC를 진행했다. 여기에서 교훈을 얻은 WFP는 요르단의 난민촌에서 보다 강력한 블록체인 시스템을 구축하고 구쳔했다. 2018년 1월 현재 캠프에 거주하는 10만명이 넘는 사람들이 블록체인 기반 시스템을 통해 WFP제공한 지원을 상환한다. 이 기술 덕분에 WFP는 해당 소매점에서 발생하는 모든 거래에 대한 사내 기록을 보유하고 있어, 시리아 난민에 대한 보안 및 개인정보를 강화한다. 또한 제3자 비용의 상당한 부분을 절약한다. 이프로젝트의 다음단계는 요르단의 50만명의 시리아 난민 모두가 WFP의 지원을 받는 것으로 확대될 것이다. 캠프에 거주하는 난민의 경우, 이 프로젝트는 난민이 눈 깜빡임으로 자신을 식별할 수 있게 해주는 생체인식인증기술 IrisGuard와 통합되었다. 중요한 것은 난민들 그 자체나, 난민들이 슈퍼마켓에서 겪는 경험에 변화가 없다는 것이다. 단지 변화는 데이터가 뒷단에서 어떻게 처리되는 가 이다. WFP는 전문 기술 지식을 갖춘 민간 부문 회사의 지원을 받아 이 시스템을 구축했다. WFP는 공급망 운영 및 디지털 신원 관리와 같은 추가 영역에 블록체인 기술을 적용하는 것에 관심이 있다. 중립적인 블록체인 협업 플랫폼이 인도주의 공동체 전체에 도움을 줄 수 있으므로, WFP는 관심있는 조직과 의 협업의 기회를 모색하고 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"가상 통화로 인한 규제 문제","slug":"regulatory-issues-and-challenges-presented-by-virtual-currencies","date":"2018-08-16T15:00:00.000Z","updated":"2018-08-16T18:43:19.000Z","comments":true,"path":"2018/08/17/regulatory-issues-and-challenges-presented-by-virtual-currencies/","link":"","permalink":"https://www.yceffort.kr/2018/08/17/regulatory-issues-and-challenges-presented-by-virtual-currencies/","excerpt":"Regulatory issues and challenges presented by virtual currencies 원문 가상 통화에 대한 공개적인 토론은, 익숙한 주제에 대한 우려를 중심으로 하는 경향이 있다. 새로운 금융 기술에 대한 이해가 부족하고, 분산된 형태로 규제하기가 어려우며, 익명성 및 정부 감독 부족으로 인해 현재 자금 세탁 및 테러를 포함한 목적으로 블랙마켓에서 가상 통화를 오용할 가능성도 있다. 이러한 우려는 전혀 근거가 없는 것이 아니다. 비트코인의 기원은 정부의 통제와 중앙 감시가 없는, 명시적으로 대체","text":"Regulatory issues and challenges presented by virtual currencies 원문 가상 통화에 대한 공개적인 토론은, 익숙한 주제에 대한 우려를 중심으로 하는 경향이 있다. 새로운 금융 기술에 대한 이해가 부족하고, 분산된 형태로 규제하기가 어려우며, 익명성 및 정부 감독 부족으로 인해 현재 자금 세탁 및 테러를 포함한 목적으로 블랙마켓에서 가상 통화를 오용할 가능성도 있다. 이러한 우려는 전혀 근거가 없는 것이 아니다. 비트코인의 기원은 정부의 통제와 중앙 감시가 없는, 명시적으로 대체 통화를 만들어내는 목적이었찌만 오히려 사용자들에 의해 ‘민주적으로’ 지배되었다. 따라서 해커와 무정부 주의자들 사이에서 등장한 비트코인은, 처음에는 비공식적인 가치 거래와 수익금에 사용되었지만, 마약, 불법 무기 및 도난 당한 물건에 대한 지불용도로서 명성을 얻기 시작했다. 최근 추세는 가상 통화 규제에 대한 로비 뿐만 아니라, 라이센스에 대한 정부의 승인을 요구하는 일부 비트코인 거래를 보여준다. 이러한 시도는 다소 오염된 개념을 주류로 끌어드리려는 노력이 반영되어 있다. 반면에 신생 블록체인 기업은 혁신을 저지하는 정부의 개입으로 보이는 규제에 대해 저항한다. 블록체인은 암호화된 트랜잭션 레코드 목록이 지속적으로 증가하는 분산 데이터베이스를 사용하여, 매우 저렴한 비용으로 사실상 변조 방지 기능을 제공한다. 비트코인과 같은 가상 통화는 블록체인 기술을 사용하여 거래 기록을 유지한다. 새로운 회사들은 비트코인의 개념과 거리를 두려고 노력한다. 비록 동일하거나 유사한 기술을 활용하더라도, 마케팅 포인트를 '블록체인’에 둠으로써 기존의 여러 형태 중 하나의 대체 통화를 훨씬 뛰어넘는 보다 합법적인 기술로, 그리고 훨씬더 광범위한 영역의 스마트 컨트랙트, 인증, 그리고 분산 원장 기록 보관에 초점을 맞춘다. 또한 가상 화폐는 규제 당국에 의해 더 많이 고려되고 이미 규제가 심한 금융 산업 영여게 속하는 것으로 인식되므로, ‘비트코인’ 이라는 레이블을 피하고 '블록체인’을 선택하면 과도한 규제주의를 피하면 더 많은 벤쳐 자금을 유치하는 새로운 도구를 개발하라 수도 있다. 다른 새로운 기술과 마찬가지로, 시장에 새로 진입한 사람들은 이 초기 단계에서 규제로 발생하는 부담을 피하고 시장점유율을 확보하기 위해 노력하는 반면, 기존 기업은 스타트업으로부터 명성을 보호하는데 더 많은 도움이 되는 규제를 위해 로비를 펼친다. 가상 통화 규제의 이해 관계자는 블록체인 경제에 관여하는 회사, 새로운 진입자, 그리고 이미 시장의 일부를 통제하는 회사다. 정부는 경제활동과 소비자 보호를 위해 규제한다. 이들 당사자들 사이의 이해관계는 자연스럽게 충돌하고, 정부의 규제 권한을 감안 할대, 포괄적인 규제 개념을 내놓는데 내재된 위험과 어려움에 직면한 정부는 사전 예방적인 입장을 취할 수 밖에 없고, 어떤 경우에는 가상 통화 자체를 금지하는 것은 이해할 만한 대목이다. 이러한 신중한 접근법은 비트코인을 포함한 블록체인 기술의 잠재적 기회와 위험을 연구하기 위한 여러 지역에서 다양한 태스크 포스를 설립하는데 반영된다. 델라웨어, 하노이, 일리노이, 버몬트 등 미국의 여러 주와 미국 연방 정부기관, 유럽 집행 위원회에 의해 도입되거나 연구가 시도되고 있다. 이 연구의 결론은 블록체인의 국가 차원 구현에 대한 불확실성과 제한된 이점을 강조하면서, 동시에 금융 시장에 대한 위험을 강조하고 있다. 가상 통화가 경제활동을 활성화 할 수 있다는 주장은 설득력이 없다. 어떤 통화든, 디지털이든 아니든 간에, 경제적 수익을 창출하는데 도움이 안되는 교환 수단에 불과하다. 비트코인은 이전의 어떤 결정에도 제한되지 않는다는 점에서는 예외일 수 있지만, 사용가능한 블록체인 길이에 대한 기술적인 제한은 사실상 비트코인의 공급을 제한하는데, 이는 곧 가상화폐의 수명을 끝낼 수도 있다. 결국 블록체인 정보를 처리하는 네트워크 노드인 마이너들은 서비스의 대가로 비트코인을 받는다. 기술적으로 지속가능한 비트코인의 공급이 고갈되면, 시스템은 이러한 비트코인 생성없이 그러한 결제를 제공하도록 재설계 되어야 할 것이다. 예를 들어 비트코인 사용자들의 수수료나 보유지분에 대한 이자를 부과함으로써 달성 될 수 있지만, 국가가 통제하는 상황에서 세무당국과 유사한 감독기관의 도입을 요구할 수 있다. 이러한 접근법은 그러나 개방적이고, 민주적이며, 분산적이고, 규제가 덜하나 가상 통화 시스템에 끌리는 비트코인 사용자들의 강력한 반대를 마주할 수 있다. 비트코인을 통화로 규제하기 위해서 필요한 기술적인 능력, 전문 지식으로 인해 대부분의 정부는 도전에 맞닥드리게 된다. 그러나 소비자 보호와 같은 금융 규제의 일부 요소는 구현 가능하다. 예를 들어, 뉴욕에서는 비트코인 거래 및 관련 서비스가 다른 유사한 금융 서비스와 마찬가지로 규제된다. 하지만 대중들의 당하는 리스크에 대한 깊은 이해 부족, 특히 중앙은행과 같은 규제 기관의 조치를 따르지 않는 가상통화의 극단적인 변동성과 관련된 리스크 때문에 가상통화 거래에 대한 요구사항은 정부에서 발행하는 기존 통화에 대해 서비스를 제공하는 기업에 부과되는 요구 사항보다 높아야 한다. 향후 블록체인 개발을 위해서는, 규제기관과 이해관계자가 기술과 한계의 위험성 뿐 만 아니라 이로 인한 기회를 잘 이해하는 것이 중요하다. 일단 국회의원들이 효과적인 감독 조치를 제공하고, 블록체인 기술을 일반적으로 규제할 수 있다고 확신한다면, 정부 지원은 투자자와 소비자가 자신들의 지분을 위험에 빠뜨리는 법적인 반대에 대해 걱정을 하지 않고 새로운 핀테크 개발 제품을 주류로 확산시키는데 중요한 역할 을 할 수 있다. 예측가능한 규제 환경은 자본 비용을 줄이고 혁신을 촉진 시킨다. 이런식으로 블록체인 기술은 보편적이고 분산되어 있고, 믿을만한 기록 보관과 제품 추적 뿐 만 아니라 스마트 컨트랙트, 네트워크화된 상호 연결된 스마트 도시까지의 중추역할을 할 야심 찬 잠재력에 도달할 수 있다. 변경할 수 없는 알고리즘 기록과 명령은 디지털 세계가 어떻게 작동하는지에 대한 새로운 미래를 보여주고, 인터넷의 대중화에 필적하는 혁명을 구축할수도 있다. 또한 공공 거버넌스가 작동하는 방식을 바꿀 수 있다. 중간자나 궁극적인 감독자가 필요없고 거래의 타당성이 수학적인 운영에 의해 결정되며, 합의에 의해 확인되는 분산된 시스템에서, 우리는 전에는 볼수 없었던 대중 민주주의의 보급을 상상할 수 있다. 모든지불, 거래 또는 투표가 사람들에게 공개되는 경우, 비록 개인의 신원이 모든 사람들에게 공개되지는 않지만, 말 그대로 숨길 곳이 없는 것과 마찬가지다. 어떤 면에서는 조지오웰의 비전이 실현 될 수도 있다. 이는 절대적인 감시 뿐만 아니라 절대적인 통제와도 같다. 왜냐하면 서비스 거부는 완전히 연결된 세계에서 사람을 좌초 시킬 것이기 때문이다. 하지만 정부가 가상 화폐 거래를 감시하고, 상대방을 신뢰성있게 식별하는 방식을 찾을 수 있다면 돈세탁과 테러 금융 문제는 해결하기 훨씬 쉬울 것이다. 그러므로 문제는 가상 통화를 통제하는 것이 불가능하다는 것이 아니라, 디지털 통화 네트워크를 해독하고 포함된 전체 정보에 접근할 수 있는 도구가 부족하다는 것이다. 그러나 이는 도청과 같은 기존의 감시 방법이 작동하지 않는, 암호 및 일반 컴퓨터 과학의 문제다. 전세계 정부가 최근 핀테크 개발에 주시하고 있는 반면, 많은 신흥 기술의 경우와 같이, 규제에 대한 접근법은 눈에 띄게 뒤쳐지고 있다. 새로운 디지털 경제는 기술 발전 속도에 발맞추어 규제 접근 방식의 근본적인 변화를 요구할 수 있다. 정부는 지속적으로 진화하고 가속화되는 도전을 충족시킬 수 있는 규제환경을 준비해야 한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"블록체인과 법은 양립할 수 없는가?","slug":"Blockchain-and-Law-incompatible-codes","date":"2018-08-15T15:00:00.000Z","updated":"2018-08-15T18:43:19.000Z","comments":true,"path":"2018/08/16/Blockchain-and-Law-incompatible-codes/","link":"","permalink":"https://www.yceffort.kr/2018/08/16/Blockchain-and-Law-incompatible-codes/","excerpt":"Blockchain and Law: Incompatible Codes? 원문 기술의 역사, 적어도 IT 기술의 역사를 보면 특정 기술 개발은 매우 '파괴적’이며 기존의 법적 규범과 체계를 없애버릴 것이라는 주장으로 가득차 있다. 그 중에서도 가장 극적이었던 모습은 1990년대 중반 인터넷이 등장하면서 사이버 자유주의자들이 보여준 열렬한 환영이다. 당시 일부 사람들은 법적 제도가 도전을 받을 뿐만 아니라 국가가 쓸모 없게 될 것이라는 예측 까지 했었다. 그 논쟁에서 가장 유명한 사례는 John Perry-Barlow’s 1996","text":"Blockchain and Law: Incompatible Codes? 원문 기술의 역사, 적어도 IT 기술의 역사를 보면 특정 기술 개발은 매우 '파괴적’이며 기존의 법적 규범과 체계를 없애버릴 것이라는 주장으로 가득차 있다. 그 중에서도 가장 극적이었던 모습은 1990년대 중반 인터넷이 등장하면서 사이버 자유주의자들이 보여준 열렬한 환영이다. 당시 일부 사람들은 법적 제도가 도전을 받을 뿐만 아니라 국가가 쓸모 없게 될 것이라는 예측 까지 했었다. 그 논쟁에서 가장 유명한 사례는 John Perry-Barlow’s 1996 ‘Declaration of the Independence of Cyberspace’ (존 페리-발로우의 사이버 스페이스 독립 선언)이다. 참고 이 선언은 정말 인기가 있었고, 그 당시 많은 초기 웹사이트가 전체 텍스트를 인용하거나, 링크를 달아 두었다. 그러나 이런 ‘주권의 죽음’ 에 대한 외침은 과장되었다. 2004년, 그에게 이 부분에 대해 그는 ‘우리는 모두 나이가 들고 똑똑해 집니다.’ 라고 답했다. 사실, 온라인 활동이 오프라인 활동보다 적어도 명목상으로는 더 많은 법적 규칙과 광범위한 규제 감독을 받을 가능성이 높다는 증거는 오래전 부터 있었다. 신기술이 기존의 입법 및 규제 패러다임에 항상 딱 들어맞지는 않고 시행도 어려울 수 있지만, 입법자, 국회의원, 법원 등이 지금까지 각 혁신의 물결에 적응하는데 시간이 걸리더라도 그럭저럭 해왔다. 최근 기술 발전의 격렬한 논쟁을 불러일으키고 많은 언론의 관심을 끌고 있는 기술은 블록체인이다. 블록체인에 대한 현재의 과대 광고는 대부분 암호통화, 특히 비트코인과 ICO와 같은 금융 상품과 관련이 있다. 초기 인터넷과 마찬가지로 블록체인 기반 금융 시스템이 규제되지 않고 심지어 ‘규제할 수 없는 성격의 것’ 이라는 우려를 낳고 있다. 눈에 띄지 않지만, 장기적으로 이보다 더 중요한 것은 자산등록 (토지) 부터 스스로 실행되는 스마트 컨트랙트에 이르기까지 다양한 블록체인 어플리케이션 개발에 많은 투자가 진행되고 있다는 것이다. 블록체인의 정체와 이에 대한 혼란이 널리 퍼져있음에도 불구하고, 블록체인과 분산 원장 기술 (DLT)는 정부, 기업, 민간 투자자들의 상상력을 사로잡았고 전세계 입법자들과 규제기관들이 점점더 관심을 갖게 되었다. 다루기 어려운 법적인 도전 중 하나는 데이터 보호 개념과 이를 위한 규칙이 블록체인에 어떻게 적용 될 지에 관한 것이다. 개인 데이터 처리와 관련된 범위내에서 호환되는 블록체인 플랫폼을 구축하고 배치할 수 있는가? EU의 GDPR의 개발과 마무리를 한 담당자는 그렇지 않다고 이야기 했다. 원문 데이터 주체의 권리를 행사할 수 있는 기능을 제공하지 않는 기능은 GDPR에 호환되지 않을 것이다. 이것은 일반적으로 블록체인 기술이 GDPR에 적응해야 한다는 것이 아니라, 단지 개인 데이터 처리에 사용될 수 없다는 것을 의미한다. 개인 정보를 처리하는 기술로서 블록체인에 대한 그의 견해는 시기상조적이며, 단순해 보인다. 다른 많은 기술과 마찬가지로, 개인데이터가 GDPR과 호환되는 방식으로 블록체인 기술을 활용할 수 있을지는 특정 블록체인 응용 프로그램을 뒷받침하는 기술과 모델에 따라 달라진다. 그러나 이 문제를 더 깊이 탐구하기전에 블록체인이라는 용어에 대한 더 분명한 설명이 필요해보인다. 클라우드 컴퓨팅과 같은 최근에 소개된 많은 다른 기술과는 다르게, 블록체인에 대한 정의는 아직 널리 받아드려지지 않았다. 이는 아마도 최초의 인기 있는 블록체인 응용프로그램의 비정통적인 기원, 기술이 진화하는 빠른 속도, 그용어가 광범위한 거래를 설립하고 관리하기 위해 사용된다는 사실을 고려할 때 별로 놀랄 일이 아니다. 이 블록체인 개념을 세가지 기본요소로 축소하는 것이 도움이 될 수 있다. 가장 기본적인 블록체인은 다음과 같은 시스템으로 이해할 수 있다. 일련의 데이터 항목 (예: 당사자 간의 거래)을 기록하기 위한 것 암호를 사용하여 과거 원장항목을 조작하기 어렵게 만들고 원장 하나 이상의 사본을 저장하고 새로운 항목을 추가하는데 동의하는 프로세스가 존재 첫 번째 요소는 블록체인이 일종의 원장이라고 말하는 방법이다. 두번째 요소와 관련하여 종종 블록이 형성되고 체인이 되는 방식이 블록체인을 변조불가능하게 한다고 가정한다. 보다 정확하게 말하면 블록체인은 블록의 연속체다. 블록마다 다양한 트랜잭션에 대한 데이터와 이전 블록에 대한 '해시값’이 포함된 헤더가 들어가 있고, 여기에는 블록의 해시가 포함된 헤더가 있다. 이 블록들은 해시를 통해 연결된 체인을 형성한다. 즉, 데이터의 해시가 더 이상 다음 블록에 포함된 해시값과 일치하지 않으면 체인의 특정 블록에서 데이터를 변경하려는 시도를 확인할 수 있으므로, 이에 따라 체인을 끊을 수 있다. 따라서, 엄밀히 말하자면, 블록체인 내의 블록은 특정 레코드가 변경 될 수 있지만, 변경이 발생했음을 분명하게 알수는 있다. (즉, 증명이 아니고 증거인 셈이다) 세번째 요소는 합의라고 부른다. 다시 말하지만, 블록체인과 분산원장 기술(DLT)라는 용어를 상호 통용되는 단어로 쓴다면 혼란이 발생할 수 있다. DLT는 블록체인 기술을 사용하여 구현할 수 있는 프로그램의 하나로, '원장’을 많은 '노드’들에게 분산하여 저장하는 기술이다. 분산 시스템에서 원장의 다양한 사본간의 일관성을 보장하기 위한 메커니즘이 필요하다. 이러한 합의는 여러가지 방법을 통해 일궈낼 수 있다. 여기에는 비트코인이 사용하는 성가신 에너지 집약적인 '작업증명’모델이 포함되어 있다. 이 모델에서는 마이너가 점점 더 어려운 계산 퍼즐을 풀기 위해 경쟁하며, 이는 비트코인을 통해 보상받는다. 비트코인의 또 다른 핵심적인 특징은 ‘개방’ 과 ‘허가가 없음’ 이다. 이는 특별한 허가 없이 비트코인을 사용할 수 있고, 실제로 네트워크에 노드로 참여할 수 있다는 뜻이다. 원장을 관리하기 위해 중앙 집중식 중개자가 필요하지 않은 합의 과정과 함께 원장 사본을 광범위 하게 유지한다는 사실은, 비트코인과 유사한 분산원장을 다수의 사용자가 사용할 수 있는 플랫폼으로서 매력적으로 만들 수 있다. 그러나 비트코인과 같은 공공 블록체인 시스템이 법적 및 규제적 관점에서 문제가 되는 것은 개방적이고, 허가가 부족하며, 익명성이라는 사실이다. 이러한 사실은 존 페리 발로우와 같은 초기 사이버 자유주의자들의 이상과 열망을 반영한다. 예를 들면 비트코인 거래가 AML과 KYC 규칙을 알고 있는가? 금융 서비스 규제 당국은 규제 및 감사를 받을 수 잇는 중앙 기관이나 다른 중개자 없이 토큰 이전이 이루어지는지를 어떻게 확인할 수 있는가? 데이터 보호법은 4개의 영역과 관련해서 더 어려운 질문들을 제기한다. 데이터 컨트롤러 및 프로세서 식별: 분산 원장 사본을 보유한 각 노드는 원장 내의 모든 개인 데이터와 관련하여 컨트롤러인가? 개방형 블록체인 어플리케이션에서 사용자는 어떤 상태인가? 블록체인에 개인정보를 저장한다면, 이들 또한 컨트롤러 일까? 그렇다면 순전히 개인적 또는 가정적인 활동에서만 데이터를 처리하는 경우 (단순 노드로 활동하는 경우) 규제를 피해갈 수 있는가? 컨트롤러 및 프로세서 관계: 당사자가 상대방에 대해 모른다면, 개인정보 처리에 관한 프로세서에 대한 지침을 어떻게 제공할 수 있는가? 수천개의 노드가 수백만명의 거래와 관련된 데이터 사본을 보유하고 있다면, 어떻게 서로 계약을 맺을 수 있는가? 국가 간 데이터 전송: 노드가 사용자가 어느 곳에나 있을 수 있다는 점을 감안할때, 원장의 개인 데이터가 전세계적으로 전송 될 수 있다고 가정해야 하는가? 데이터 최소화 및 데이터 주체의 권리: DLT에서 데이터 복사본의 확산이 데이터 최소화의 원칙과 호환이 되는가? 만약 데이터 주체가 데이터 수정, 삭제와 같은 개인의 권리를 행사하고자하면, 관련데이터가 수정불가능한 블록체인에 저장되면 어떻게 될까? 이러한 어려운 문제가 확산 됨에 따라 많은 논평가들은 블록체인은 기존 법률 규제 모델과 근본적으로 양립할 수 없다고 주장하고 있으며, 이는 놀랄만한 일은 아니다. 그리고 그러한 예로 앞서 언급한 데이터 보호 문제가 인용되고 있다. 그렇다면 GDPR담당자의 입장을 받아들여서 블록체인을 개인 데이터 처리에 사용할 수 없다고 결론지어야 할까? 꼭 그렇지는 않다. 비트코인 모델에서 벗어나 블록체인의 핵심 요소로 돌아가서, 일종의 합의 프로토콜에 따라 확정되고 유지되는 변조되지 않는 원장으로 돌아가자. 이러한 기본 요소를 기반으로 설계 원칙에 의한, 데이터 보호화 호환되는 블록체인 플랫폼을 개발하고 배치하는 것이 가능할까? 아마도 그럴 것이다. 예를 들어, 블록체인은 공개되고 허가되지 않는 대신 각 당사자가 블록체인에 포함된 개인 데이터를 처리하는 기준으로 설정된 규칙에 의해 관리되는 컨소시엄을 설정할 수 있다. 더욱이, 작업 증명과 같은 분산 합의 메커니즘 대신, 당사자들은 한명이상의 참가자가 각 차례에 따라 체인에 블록을 추가하는 권한을 갖는, 일종의 '권한에 의한 합의’를 사용하기로 합의할 수 있다. 실제로 이 역할은 신뢰할 수 있는 타사, 즉 서비스형 블록체인 (BaaS)을 제공하는 클라우드 서비스 제공업체로 아웃소싱 될 수 있다. 이로 인해 컨트롤러와 프로세스를 식별하고 관계를 훨씬 더 쉽게 구성할 수 있다. 또한 편집가능한 블록체인을 설계할 수 있으며, 변경 가능성 입증 책임자의 핵심 특성을 훼손하지 않을 수도 있다. 이를 통해 데이터 수정 또는 삭제에 대한 데이터 주체의 요청을 보다 쉽게 준수 할 수 있다. 따라서, 데이터 보호 법률에서 발생하는 많은 문제와 마찬가지로, 블록체인을 사용하여 개인 정보를 처리할 수 있는지에 대한 질문에 대한 대답은 예 아니오가 아니고 ‘경우에 따라 다르다’ 이다. 물론, 블록체인의 다른 법적 영향과 관련해서 해야할일은 많이 남아 있다. 암호화폐와 ICO는 국회의원과 금융 서비스 규제 기관으로 부터 지속적으로 관심을 받고 있으며, 금지부터 건설적인 참여에 이르기까지 다양한 접근 방식을 취하고 있다. 확립된 법적 규범과 규제체계의 측면에서, 블록체인은 얼마나 파괴적일까? 이단계에서 블록체인은 기존 규칙의 해석, 적용 및 시행 측면에서 복잡한 문제를 야기하는 또다른 기술처럼 보인다. 그러나 초기 사이버 자유주의자들이 예측한 유형의 '패러다임의 전환’을 촉발시키는 블록체인 기술에 대해서는 아직 사례가 없다. 그러나, 장기적으로 본다면 블록체인은 법률 규칙이 작용하는 방식에 변화를 일으킬 수 있다. 블록체인 기술의 흥미로운 특징 중 하나는 많은 정보 기술과 마찬가지로 규칙을 기반으로 하는 프로세스의 작동을 자동화하여 새로운 방식으로, 그리고 많은 양을 트리거하고 문서화 할 수 있다는 것이다. . 블록체인 기술을 기반으로 구축된 '스마트 컨트랙트’는 '자가 실행, 사용자 정의 규칙’의 가장 중요한 예가 될 수 있다. 이러한 맥락에서 블록체인 플랫폼의 추가 개발 및 배치가 국회의원, 법원 및 규제기관이 상업 거래 및 기타 법적 조치를 다루는 방식에 처음에는 미묘한 그러나 유익한 변화를 촉진할 수 있을지 여부는 두고 보아야 한다. 만약 여기에서 결과가 나온다면, 블록체인과 법사이의 긴장감은 혁신을 위한 냉각요소가 아닌, 긍정적인 발전의 촉매제가 될 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인: 분산 거버넌스와 지역 제조업을 위한 글로벌 인프라","slug":"a-global-infrastructure-for-distributed-governance-and-local-manufacturing","date":"2018-08-15T15:00:00.000Z","updated":"2018-08-15T18:43:19.000Z","comments":true,"path":"2018/08/16/a-global-infrastructure-for-distributed-governance-and-local-manufacturing/","link":"","permalink":"https://www.yceffort.kr/2018/08/16/a-global-infrastructure-for-distributed-governance-and-local-manufacturing/","excerpt":"Blockchain : a global infrastructure for distributed governance and local manufacturing 원문 인터넷과 디지털 커뮤니케이션 도구가 등장하면서 사무실, 일정, 직원 없이도 운영되는 새로운 '종이 없는 조직’이 태너았다. 인터넷을 통해 한장소에서 다른 장소로 이동하지 않고 원격으로 동기화되고, 비동기적으로 일할 수 있다. 더이상 같은 장소에서 살 필요가 없으며, 공동의 노력으로 협력하기 위해 얼굴을 마주볼 필요가 없다. 단순히 동료, 파트너, 고객을 찾기 위해 인터","text":"Blockchain : a global infrastructure for distributed governance and local manufacturing 원문 인터넷과 디지털 커뮤니케이션 도구가 등장하면서 사무실, 일정, 직원 없이도 운영되는 새로운 '종이 없는 조직’이 태너았다. 인터넷을 통해 한장소에서 다른 장소로 이동하지 않고 원격으로 동기화되고, 비동기적으로 일할 수 있다. 더이상 같은 장소에서 살 필요가 없으며, 공동의 노력으로 협력하기 위해 얼굴을 마주볼 필요가 없다. 단순히 동료, 파트너, 고객을 찾기 위해 인터넷 네트워크에 연결하기만 하면 된다. 이 글로벌 커뮤니케이션 네트워크가 결국 전세계 사람들이 세계 경제에 참여할 수 있는 참여와 더 큰 기회를 증가시킬 것이라는 희망이 있었다. 그리고 어느 정도는 그랬다. 하지만 이러한 변화는 부분적인 것이었다. 지난 20년동안 중앙집권조직의 전통적인 모델에서 점차 멀어져갔다. 중앙 집권 조직에서는 대규모 운영자가 수동적 소비자 집단에게 서비스를 제공하는 책임을 맡았다. 오늘날 디지털 영역에서 새로운 조직구조가 출현하는 것을 목격하고 있으며, 이는 실질적으로 더욱 분산되어 있다. 이른바 '크라우드 소싱 조직’은 훨씬 더 액티브한 소비집단에 서비스를 모으기 위해 여러 사람의 자원을 모으는 역할을 하고 있다. 구글, 페이스북, 트위터, 우버, 에어비엔비와 같은 인터넷 거인들의 방식을 살펴보면, 이들은 모두 한가지 공통점을 갖고 있다는 것을 알 수 있다. 그리고 이 모델의 문제점은 대부분의 경우 대중이 생성한 가치가 가치창출에 기여한 모든 사람들에게 똑같이 배분되지 않는 다는 것이다. 이윤의 대부분은 대신 이러한 플랫폼을 운영하는 대규모 중개인이 가져간다. 반대로, 물리적인 영역에서 지난 수십년간 새로운 오프소스 하드웨어 / 소프트웨어 도구의 개발은 가치 창출 및 개방된 생태계에 개인의 참여를 실제로 촉진시킬 수 있는 새로운 학습, 설계, 제조 및 협력 방식을 육성하고 있다. 소프트웨어의 오픈 소스 운동에서 영감을 받은 개발자 커뮤니티는 새로운 공간에 새로운 하드웨어 기반 기술과 도구를 구축해왔다. 오늘날 수백만명의 사람들이 오픈 소스 소프트웨어를 사용하여 인터넷에 연결되고, 디지털 제작 도구 (3D프린터 포함)를 사용하여 세계에서 가장 큰 분산 및 제조 생태계를 구축한다. 이는 디지털 및 물리적으로 생산 수단의 동등한 재분배를 위한 새로운 잠재력을 열어준다. 하지만 수십년 전 인터넷에서 그랬던 처럼, 제조사들이 창출한 가치는 곧 출시될 제조업과 유통업계에 의해 가져갈 가능성이 높다. 어떻게 이런 공동체들이 공유 경제의 맥락에서 널리 퍼져나간 중앙집권회의 패러다임에 빠지지 않고 스스로를 지배할 수 있을까? 최근 이 질문에 답할 수 있는 새로운 기술이 등장했다. 비트코인을 뒷받침하는 기술인 블록체인 기술은 중개자가 필요없이 안전하고 분산된 방식으로 가치 교환을 용이하게 한다. 따라서 금융 부문의 기존 중개자를 혼란에 빠뜨리기 쉬운 가상 화폐 및 기타 분산 원장 기술의 출현을 가능하게 했다. 블록체인 기술의 가장 혁신적인 측면은 개인이 공통의 활동을 조정하고, 서로 직접 상호 작용하며, 보다 안전하고 분산된 방식으로 스스로를 통치하는 수단이기도 하다. 실제로 최근 블록체인 기반 네트워크는 사람들이 서로 가치를 거래할 수 있을 뿐만 아니라 안전하고 분산된 방식으로 소프트웨어를 실행 할 수 있게 해준다. 블록체인을 사용하면 소프트웨어 응용 프로그램을 더이상 중앙 집중식 서버에 배포할 필요가 없다. 단일 파티에서 제어하지 않는 P2P 네트워크에서 실행할 수 있다. 이러한 블록체인 기반 응용 프로그램은 제 3자의 도움 없이 스스로 조직할 수 있는 많은 개인의 활동을 조정하는데 사용할 수 있다. 이미 블록체인에서 구동되는 여러가지 응용 프로그램이 있다. Steemit, Sapien, Akasha는 중앙 집중식 권한 없이 작동하는 분산 소셜 네트워크 미디어 플랫폼이다. 대중에게 표시되는 콘텐츠를 제어하고 관리할 수 있는 중앙 집중식 조직이 운영하는, 중앙집중식 서버에 저장되는 콘텐츠 대신에 블록체인 기술을 활용하여 개인을 조정하고, 일련의 코드기반 프로토콜 및 규칙을 통해 플랫폼에 기여하는 콘텐츠를 관리하여 분산된 네트워크에 콘텐츠를 저장한다. 마찬가지로 OpenBazzar는 eBay또는 Amazon와 같은 분산된 마켓플레이스로, 중간 운영자와 독립적으로 운영된다. 이 플랫폼은 비트코이니 블록체인을 사용하여 구매자와 판매자가 중앙 집중식 중개인을 통과하지 않고 서로 직접 상호작용 할 수 있도록 한다. 누구나 주어진 가격으로 플랫폼에서 판매할 제품을 무료로 광고할 수 있다. 구매자가 해당 제품의 가격에 동의하면 블록체인에 에스크로 계쩡이 만들어져 3명 중 2명 (구매자 , 판매자, 잠재적인 제 3자 중개자)이 자금 출시에 동의한다. (다중 서명 계정) 구매자가 에스크로 계정에 지불을 보내면 판매자는 제품을 배송하고, 제품을 받은 후 구매자는 에스크로 계정에서 자금을 공개한다. 문제가 발생할 경우에만 시스템은 판매자에게 지불을 공개할지 또는 구매자에게 돈을 반환할 지 여부를 결정하기 위해 제 3자 (중개인)의 개입을 필요로 한다. DAOStack Aragon과 같이 중앙 집중식 운영자 없이 관리되는 분산 크라우드 소싱 조직을 구축하기 위한 기본 요소를 재공하는 인프라를 만드려는 시도가 있었다. 이러한 조직은 블록체인 기반 인프라에 배포된 코드에 의해 관리되며 여러 액터간의 P2P 상효작용을 관리하도록 설계되었다. 따라서 블록체인 기술은 이사나 CEO가 없는 새로운 형태의 분산 조직이나 일종의 layer 구조의 조직 출현을 용이하게 한다. 이러한 좆기은 블록 체인에서 상호작용하는 모든 개인에 의해 총체적으로 관리된다. 따라서, 사람들이 플랫폼에 기여하지만 플랫폼의 성공으로 이익을 얻지 못하는 전통적인 모델인 '크라우드 소싱’과 혼동하지 않는 것이 중요하다. 반대로 블록체인 기술은 크라우드 소싱의 훨씬보다 더 협력적인 형태를 지원할 수 있다. 이를 '플랫폼 협력주의’라고 한다. 그리고 중간 운영자가 없기 때문에 이러한 플랫폼 내에서 생성된 가치는 가치 창출에 기여한 사람들 사이에서 보다 똑같이 나눠 가질 수 있다. '협력주의’를 강화할 새로운 기회를 갖게 되면서 진정하나 공유나 협력 경제로 나아가고 있다. 이는 몇몇 큰 중개자가 통제하지 않고, 국민이 지배하게 된다. 블록체인 기술은 하향식 계층적 조직의 모델을 분산하고, 상향 협력 시스템으로 대체할 수 있게 해준다. 궁극적으로, 이러한 변화는 부가 분배되는 방식을 변화시켜 사람들이 공동의 이익을 창출하기 위해 협력할 수 있게 하고, 모든 사람들이 그들의 노력과 기여에 대해 정당한 보상을 받을 수 있도록 한다. 이러한 블록체인 기반 조직의 대부분은 디지털 세계에서 개인의 조정을 용이하게 하기 위해서 개발하였지만, 이러한 새로운 조직 구조가 제공하는 가능성은 몰리적인 세계에서도 발견될 수 있다. 도시, 지역 사회는 블록체인 기술의 힘을 이용하여 많은 분야에서 투명성과 책임을 높이고 누구나 지역 경제에 참여할 수 있는 새로운 기회를 제공할 수 있다. 이와 같은 사례로 블록체인 기술은 이웃간의 P2P 거래를 통해 지역 에너지 마이크로 그리드를 지원하는 방법, 분산원장에 암호화 기록 형태로 정보를 저장하여 식품 공급망에서 투명성을 제고하는 방법으로 연구되고 있다. 디지털 기술은 도시 농업 기술, 태양 전지판, 풍력 터빈 및 디지털 제조도구를 활용하여 지역사회, 이웃 및 도시내에서 현지 생산능력을 향상시킬 수 있는 많은 새로운 기회를 창출한다. 이러한 기술은 생산비용을 줄이고, 전세계 제조업체의 새로운 비즈니스 기회를 열어 운영 효율성 향상에 기여할 수 있다. 그러나 거버너스 문제는 여전히 제대로 다루어져야 하는 중요한 문제로 남아 있다. 실제로 물리적 세계에서는 공유지의 비극이 있다.적절한 거버넌스 구조, 또는 인센티브 제도가 없으면 사람들은 무임 승차할 가능성도 존재한다. 이러한 신기술이 지역 제조업에 건전한 생태계 번영에 기여하기 위해서는, 중앙 집중식 권위 업시 사람들이 자원을 기여하도록 장려하는 적절한 인센티브 메커니즘이 필요하다. 현재 산업 세계화의 영향을 줄이기 위해 현지 생산 공정을 활성화 하는 것이 중요하지만, 이 프로세스를 인센티브 가속화 및 확장하는 메커니즘을 가능하게 하는 것이 중요하다. 여러 이해 관계자간에 표현할 수 있는 개방형 플랫폼, 분산된 인센티브 제도를 만들어 블록체인 기술이 손에 들어갈 수 있게 해야 한다. 지역 사회는 오랫동안 현지 통화를 실험에 왔지만, 제한된 범위 때문에 글로벌하게 도달하지는 못했다. 그러나 블록체인을 활용하여 전세계 여러 도시들은 지역 공동체가 공동체에 기여하도록 장려할 수 있고, 글로벌 소셜 임팩트 화폐로 이러한 행동을 보상함으로써 생산적이고 협력적인 활동을 만들어 나갈 수 있다. 이를 통해 지역 사회는 글로벌 레벨에서 공급망의 재활용, 재사용, 재분배 및 선형 경제의 영향을 줄이는 기타 관행의 패러다임 변화를 촉진할 수 있다. 기회는 엄청나지만, 당연한 것으로 받아드려질 수는 없다. 블록체인 기술의 분산된 잠재력이 반드시 분산된 방식으로 사용될 것을 의미하지 않는다. 인터넷이 고도로 분산된 인프라에서 소수의 대형 온라인 운영자가 제어하는 점점 더 중앙 집중식 시스템으로 진화한 것처럼, 거대한 기업이 거대한 블록체인 공간에서 형성될 위험은 항상 존재한다. 사회에서 진정한 공유 경제의 개념을 정말로 중요하게 여기고, 이질적인 집단이 스스로를 조정하고, 비슷한 집단과 협력하며, 가치를 창출하는 사람들이 그들의 노력에 대한 보상을 받는다면, 이새로운 기술에 참여하여 실험해볼 가치가 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인을 활용하여 디지털 비용 낭비를 막는 대형 광고주","slug":"big-advertisers-embrace-blockchain-to-root-out-digital-spending-waste","date":"2018-08-13T15:00:00.000Z","updated":"2018-08-14T00:54:33.000Z","comments":true,"path":"2018/08/14/big-advertisers-embrace-blockchain-to-root-out-digital-spending-waste/","link":"","permalink":"https://www.yceffort.kr/2018/08/14/big-advertisers-embrace-blockchain-to-root-out-digital-spending-waste/","excerpt":"Big Advertisers Embrace Blockchain to Root Out Digital Spending Waste 원문 블록체인 기술은 물류에서 의료에 이르기까지 다양한 산업에 진출했다. 이제 마케팅 담당자들이 온라인 광고의 함정에 대한 답으로 블록체인을 인시가고 있다. Anheuser-Busch InBev, BUD, AT&T, Kellogg 등은 블록체인 초기 기술을 활용하여 컴퓨터로 생성된 봇이 아닌 실제 사람들이 광고를 보는지, 중개자가 얼마나 지출하고 있는지를 파악하기 위해 노력하고 있다. 블록체인은 여러","text":"Big Advertisers Embrace Blockchain to Root Out Digital Spending Waste 원문 블록체인 기술은 물류에서 의료에 이르기까지 다양한 산업에 진출했다. 이제 마케팅 담당자들이 온라인 광고의 함정에 대한 답으로 블록체인을 인시가고 있다. Anheuser-Busch InBev, BUD, AT&amp;T, Kellogg 등은 블록체인 초기 기술을 활용하여 컴퓨터로 생성된 봇이 아닌 실제 사람들이 광고를 보는지, 중개자가 얼마나 지출하고 있는지를 파악하기 위해 노력하고 있다. 블록체인은 여러 컴퓨터에 분산된 트랜잭션 원장을 수용할 수 있는 보안된 디지털 데이터베이스다. 비즈니스 파트너는 당사자간 합의에 따라 블록으로 저장하고, 실시간으로 업데이트 된 거래 기록을 유지할 수 있다. 그리고 블록은 변경할 수 없다. 블록체인을 둘러싼 기술은 호황을 누리고 있다. 이제 이 기술의 안전하고 투명한 특성은 광고계에서도 관심을 갖게 되었다. 마케팅 담당자, 광고 대행사, 기술 벤더 사이의 거래가 투명하지 않아 광고주들 사이에 돈을 낭비하고 있다는 불신과 두려움이 자리잡고 있는 경우가 많다. 1. 광고주가 광고를 시작한다: 블록체인에 기록된 비즈니스는 광고주의 거래 조건에 동의 한다. 2. 각 거래 내용은 공유된 데이터베이스에 저장된다: 이 데이터에는 수수료 삭감 정도와 게시자가 받는 금액이 포함되어 있다. 3. 데이터가 블록에 저장된다: 블록에는 또한 각 광고 단가와 현재 볼 수 있는지 여부도 저장한다. 4. 광고주는 비즈니스 파트너에 금액을 지불한다: 지불은 블록체인의 컨텐츠를 기반으로 이루어진다. ¶돈의 흐름을 좇아라 작년에 전세계적으로 프로그래밍된 광고(자동 소프트웨어를 사용하여 구입된 광고)에 지출된 1달러당 평균 40센트 만이 광고 공간을 대여 해준 웹사이트 퍼블리셔에게 갔다는 연구결과가 나온바 있다. 광고주들은 결국 마케팅 담당자와 광고를 운영하는 웹사이트 사이의 복잡한 공급업체 공급망에 '기술세’를 내는 결과가 나타나게 된다. 마케팅 담당자는 종종 디지털 광고 캠페인을 수동으로 볼수 있지만, 블록체인 지지자들은 이 기술이 지출을 추적하고 공급업체와의 불일치를 조정하는 보다 빠르고 신회할 수 있는 방법을 제공한다고 밝혔다. 이 기술은 실제 트래픽이 있는 웹사이트와 일반 사용자가 볼 수 있는 영역에서 광고가 실행되는지 여부를 추적하는데 도움이 될 수 있다. 이러하나 정보는 가격 정보와 함께 블록에 저장될 수 있다. 세계 최대 광고주인 Anheuser-Busch의 글로벌 마케팅 부사장은 이 기술의 목적이 비용 절감이 아니라, 가장 적절한 방식으로 소비자에게 다가가는 투명성을 부여하는 것이라고 밝혔다. 광고 캠페인 데이터르르 블록체인에 기록하는 모바일 광고회사인 Kiip에서 이 기술을 테스트 한바 있다. 또한 앞으로 2, 3년 간 대부분의 프로그램 광고가 블록체인 기반으로 운영될 것이라고 믿는다고 하였다. 이는 광고주들이 투명성을 원하고, 블록체인은 이것을 제공할 수 잇기 때문이다. 물론 블록체인에는 단점이 있다. 공동 합의에 서명하는데 동의하는 많은 플레이어가 필요하고 비용도 든다. 수백개 이상의 웹사이트에 걸쳐 하는 대형 온라인 광고는 수십개의 다양한 광고 기술 중개인을 활용할 수 있으며, 그 중 많은 사람들이 블로겣인 컨소시엄에 관심이 없을 수도 있다. 온라인 광고 생태계에서 가장 큰 플레이어인 구글은 블록체인을 활용한 광고 프로젝트에 참여하지 않는 다고 발표했다. (구글 애드센스) 구글 광고 및 상업 담당 부사장은 블록체인을 연구하는 소규모 연구팀을 보유하고는 있지만, 핵심적인 기술이 거래 횟수 제한이 많아 확장이 어렵다고 밝혔다. 디지털 광고 거래는 매초 수백만건의 광고 거래를 처리하지만, 블록체인 및 지불로 거래가 인정되는데에는 몇분이 걸릴 수 있다. 하지만 여전히, 일부 업계 전문가들은 블록체인의 혜택에 더 주목하고 있다. 이 기술이 익숙한 문제를 해결하기 위해 어떻게 적용될 수 있는지를 알면, 블록체인에서 중개자들을 제거하고 모든 사람이 삶의 질의 향상에 집중할 수 있을 것이라고 밝혔다. IBM은 6월에 광고 소프트웨어 제공업체인 Mediaocean과 제휴하여 블록체인 제품을 발표했다. 디지털 광고 지출을 추적하기 위해 이 기술을 사용하는 많은 회사들이 있으며, 그 회사들에는 유니레버, 켈로그 등이 있다. 네슬레가 기술 스타트업 Amino로 부터 제품을 테스트 하기 시작했다. 이제품을 통해 모든 광고 공급업체는 미리 준비된 약속을 충족시키는 구매자에게만 직접 지불을 할 수 있다. 이 회사는 전통적인 방식으로는 프로세스에서 지연과 불일치가 발생한다고 밝혔다. 네슬레는 또한 파트너 모두가 블록체인 솔루션을 사용해야 한다는 규정사항을 광고 계약에 넣을 것이라고 밝히기도 했다. 광고 업계의 다른 신기술과 마찬가지로, 블록체인은 저명한 광고주가 요구하기 시작할때 비로소 널리 채택될 수 있을 것이다. 그리고 충분한 근거가 마련되는데에는 몇년이 걸릴 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인과 머스크: 최근 거래에서 무엇을 배울 수 있는가?","slug":"what-can-we-learn-from-the-recent-deals","date":"2018-08-13T15:00:00.000Z","updated":"2018-08-14T00:54:33.000Z","comments":true,"path":"2018/08/14/what-can-we-learn-from-the-recent-deals/","link":"","permalink":"https://www.yceffort.kr/2018/08/14/what-can-we-learn-from-the-recent-deals/","excerpt":"Blockchain, Digital Transformation and the Law: What Can We Learn from the Recent Deals? 원문 최근 몇 년 동안 블록체인 기술의 사용이 급증했다. 특히 비트코인과 같은 암호 통화의 상용이 급증 했기 때문이다. 이러한 관심의 일부는 단순한 과장 광고로 치부할 수도 있지만, 블록체인이 특정 법류 분야에 혁명으르 일으킬 수 있는 기술이라는 것은 의심의 여지가 없다. 최근 덴마크 기업인 머스크가 블록체인 기술과 관련한 세가지 이상의 거래에 관여하고 있다는 사실에 주목","text":"Blockchain, Digital Transformation and the Law: What Can We Learn from the Recent Deals? 원문 최근 몇 년 동안 블록체인 기술의 사용이 급증했다. 특히 비트코인과 같은 암호 통화의 상용이 급증 했기 때문이다. 이러한 관심의 일부는 단순한 과장 광고로 치부할 수도 있지만, 블록체인이 특정 법류 분야에 혁명으르 일으킬 수 있는 기술이라는 것은 의심의 여지가 없다. 최근 덴마크 기업인 머스크가 블록체인 기술과 관련한 세가지 이상의 거래에 관여하고 있다는 사실에 주목할 필요가 있다. ¶머스크와 블록체인 머스크는 덴마크의 운송, 에너지 회사로 세계 최대의 컨테이너선 운용회사이자 보급선 운용회사 입니다. 2017년 덴마크 해운 대기업인 머스크와 관련된 3가지 계약에 대한 세부사항이 드러났다. 2017년 4월 마이크로소프트와 머스크는 마이크로소프트의 클라우드 플랫폼인 Azure와 관련된 거래를 발표했다. 2017년 9월 마이크로소프트와 머스크는 해상 보험에 사용될 블록체인 플랫폼에 대한 내용을 발표했다. 마지막으로 2018년 1월, IBM과 머스크는 해운분야에서 블록체인 서비스를 제공하는 합작회사 설립과 관련된 세부사항을 발표했다. ¶머스크 마이크로소프트 머스크가 마이크로소프트의 Azure Cloud 솔루션과 IoT를 디지털 트랜스포메이션에 사용할 것을 동의했다. 디지털 트랜스포메이션은 디지털 방식으로 수동 프로세스를 자동화 하는 것으로 정의 할 수 있다. 클라우드 거래는 일반적으로 비즈니스 고객을 위해 거대한 컴퓨터 Pool을 임대하여 용량에 대한 자체적인 투자를 피할 수 있다. 머스크가 소프트웨어를 설계하고 이를 위한 공급망은 마이크로소프트 Azure 플랫폼을 사용하도록 의무화했다. IoT솔루션은 머스크가 이러한 솔루션을 통해 컨테이너를 연결, 추적 및 관리하는데 도움이 된다. 따라서, 이거래는 본질적으로 블록체인 거래가 아니지만, 블록체인이 활용될 수도 있다. ¶머스크, 마이크로소프트, 회계법인 EY 이 세 회사의 거래는, 이전 보험과는 다르게 블록체인을 기반으로 한다. 데이터 수집을 단순화 하고 업데이트르 자동화하며, 비용을 절감하고 실시간으로 청구를 자동화하는 것이다. 이 계약은 해양 보험에 적용 되며, 모든 당사자가 동일한 데이터베이스에 엑세스하도록 보장한다. 이 는 해야야 보험 준수 과정을 훨씬 쉽게 만들 것이다. 서명 당시 거래가 다른 사업라인으로도 확장될 수 있음을 시사했다. ¶머스크 IBM 블록체인 기술을 통해 화물 시스템을 관리하는데 도움이 되는 계약이었다. 머스크가 51%의 소유권을 가진 새로운 뉴욕 기반의 회사에서, 다른 사람들이 화물을 추적하고 디지털 원장을 통해 서류작업을 대체 할 수 있도록 설립되었다. 해양 산업에 블록체인 서비스를 제공하는 이 회사는, 소규모 스타트업보다 유리한 위치에서 모든 거래에 대한 단일한 뷰를 제공하는데 도움이 될 수 있다. ¶블록체인 사용에 있어 법적인 문제 블록 체인 기술이 초기단계에 있지만, 세가지 법적인 문제를 맞닥드리고 있다. 보편적인 정의가 존재하지 않으며, 거의 모든 것에 대하여 광범위한 의견 차이가 있다는 것이다. 일부 대중들은 암호 화폐가 블록체인을 기술로 사용한다는 한가지 용도일 뿐이며, 블록체인과 암호화폐를 동일시 하고 있다는 사실이다. 더 복잡한 사실은, 블록체인이 공개적으로 기록되거나 분산될 필요가 없다는 것이다. (프라이빗 블록체인) 이러한 명확한 인식의 부족은 반드시 그 자체로 문제는 아니지만, 결국 부과될 규제의 범위에 대한 큰 어려움을 지적한다. 블록체인에 부과될 수 있는 규제 감독 범위다. 블록체인 거래에서 거래 당사자가 실제로 누구인지를 찾는 것은 매우 어렵다. 블록체인에서 거래가 자동으로 실행 되기 때문에 실행을 명령하는 것도 똑같은 이유에서 어렵다. 법원 명령이 단순히 체인에 새로운 거래를 추가함으로써 시행되는 상황을 상상하는 것은 이론적으로 불가능하지 않지만, 권한 있는 당사자를 제외하고는 아무도 이 명령을 수행할 수 없다.긍정적인 점은 블록체인이 중개자를 최소화 하도록 설계되어 있기 때문에 위반 가능성이 적다. 특히 어려운 문제는 사생활 보호법 적용에 있다. 2018년 5월, EU에서 새롭고 엄격한 개인 정보 보호 규칙을 채택하고 발효한 이후, 블록체인 아키텍쳐가 GDPR을 준수하지 못할 수도 있다는 사실이 점차 분명해지고 있다. 이 논란의 시작은, 원장에 저장된 암호화 데이터가 익명이 아닐 경우 GDPR의 영향을 받을 수 있다는 것이다. 주요 문제는 GDPR 의무를 가진 대상자가 누구인지 결정하는 것이 어렵다는 것이다. (불가능할 수도 있다) 문제는 여러 컨트롤러와 프로세서가 있을 뿐만 아니라, 자신이 누구인지, 전부 또는 일부만 다루어지는지 여부가 즉시 투명하게 조회할 수 없다는 것이다. 또한 블록체인에서 시행하기 어려울 수도 있는 의무사항도 있다. 블록체인이 개인 데이터를 잘 처리하는지 (그리고 GDPR을 잘 처리하는지)에 관한 질문은 쉽게 대답할 수 있다. 공개키는 개인을 쉽게 추적할 수 있으므로 개인데이터가 될 수 있다. 29조에 따르면, 해시가 개인데이터라고 판단을 내렸다. GDPR에서는 잊혀질 권리와 지울수 없는 원장의 속성과 충돌로 이루어지다. 스마트 컨트랙트는 액세스 권한을 구축하여 적어도 일부 상황에서는 동일한 목표에 효과적으로 달성할 수 있으므로, 이를 벗어날 수도 있다. 블록체인 거버넌스 모델은 GDPR이 문제가 될 정도를 결정하는데 결정적인 역할을 할 것이다. 대부분 현재 블록체인은 거의 확실하게 준수하지 못하는 상황일 것이다. 반면 블록체인 기술은 GDPR 을 촉진하거나 목표를 달성하는데 도움이 될 수 있다. 마지막으로, 블록체인 기술의 도움을 받아 분쟁을 해결하거나, 이 기술로 발생하는 문제를 해결하려면 문제가 발생한다. 이들은 비용, 기간, 관할권 및 해당 법류 집행에 관한 문제로 이어질 수 있다. 분쟁을 해결하는데 블록체인 기술을 사용하는 측면에서는 a) 이 기술을 통해 증거 수집과정을 가속화하는 방법이 있지만, 아직 성숙기에 도달하지 못했고 b) 명확한 블록체인 기반 솔루션이 현재 제시 되지 않았다는 것이다. 분쟁해결은 온라인 매커니즘을 통해 사용자와 '배심원’을 연결하는 별도의 계층으로 스마트 컨트랙트에 구축할 수도 있다. 그러나 이 용도는 해상 분쟁에서는 적합하지 않을 것이다. 블록체인의 분쟁 발생 가능성에서 볼때, 블록체인은 조건이 충족되면 거래를 자동으로 실행하는 능력이 있으므로 신뢰와 집행의 문제가 제거 될 수 있다고 말할 수 있다. 동시에 블록체인은 지금까지 법원에 알려지지 않은 새로운 문제를 제시할 것이다. ¶결론 요악하자면, 위에 설명된 여러가지 방법으로 블록체인 기술을 활용하고자 하는 머스크의 바람은, 전통적인 기술 투자 산업에서 새로운 영역으로 이동하는 것을 의미한다. 이는 해상 운송의 일부 측면에 혁명을 일으킬 수 있는 기술의 잠재력을 의미한다. 특히 흥미로운 것은 두가지 사례 (블록체인 기반 해상보험, 블록체인 기반의 해운 합작 투자)에서 비교적 목표와 초점이 좁다는 것이다. 이는 업계가 신중하고 매우 실질적인 접근 방식을 취하고 있다는 신호다. 블록체인은 혼란을 야기할 수 있는 능력을 가지고 있지만, 동시에 알려지지않은 기술이기도 하다. 역사는 우리에게 이러한 기술의 작동과 함의가 완전히 투명해 지기전에 규제하지 않는 것이 최선의 선택이라고 가르친다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"에스토니아가 다른 나라의 블록체인 모델이 될 수 있을까","slug":"Estonia-a-blockchain-model-for-other-countries","date":"2018-08-12T15:00:00.000Z","updated":"2018-08-13T00:54:33.000Z","comments":true,"path":"2018/08/13/Estonia-a-blockchain-model-for-other-countries/","link":"","permalink":"https://www.yceffort.kr/2018/08/13/Estonia-a-blockchain-model-for-other-countries/","excerpt":"Estonia, A Blockchain Model For Other Countries? 원문 1991년 소련이 붕괴되면서, 발트해 연안의 작은 국가 에스토니아는 독립하게 되었다. 당시 에스토니아 인구의 절반은 전화조차 사용할 수 없었으며, 외부 세계와 접촉할 수 있는 유일한 수단은 총리가 소유한 비밀 휴대전화 였다. 20년이 넘는 시간이 흐른 지금, 에스토니아는 다른 어떤 사회보다도 디지털화되어 있다. 와이어드에서 ‘세계에서 가장 발전된 디지털 사회’ 로 명명한 이 나라는 창업허브이자 블록체인 기술의 얼리어답터가 되었다. 또한","text":"Estonia, A Blockchain Model For Other Countries? 원문 1991년 소련이 붕괴되면서, 발트해 연안의 작은 국가 에스토니아는 독립하게 되었다. 당시 에스토니아 인구의 절반은 전화조차 사용할 수 없었으며, 외부 세계와 접촉할 수 있는 유일한 수단은 총리가 소유한 비밀 휴대전화 였다. 20년이 넘는 시간이 흐른 지금, 에스토니아는 다른 어떤 사회보다도 디지털화되어 있다. 와이어드에서 ‘세계에서 가장 발전된 디지털 사회’ 로 명명한 이 나라는 창업허브이자 블록체인 기술의 얼리어답터가 되었다. 또한 에스토니아는 'estcoin’이라고 불리우는 자체 암호 토큰을 출시하려 하고 있다. 하지만 estcoin 출시는 단순 해프닝으로 끝날 것 같다. 공식홈페이지 링크를 들어가보면 404에러 (페이지 없음)이 뜨고 있고, 지난 6월 보도에 따르면, 에스토니아는 국가 단위 암호화폐를 내놓으려 한적도 없으며 계획도 없다고 하였다. 국가 차원에서 암호화폐를 만들 이유는 지난 여러 연구 결과로 봤을 때 별로 없다. 그리고 유로에서도 유로화대신 암호화폐 (혹은 공용으로)를 사용하는 것을 고깝게 보지 않을 것이다. 소련의 붕괴는 에스토니아에게 가능성을 제공했다. 결과적으로, 에스토니아 인들은 오래된 아날로그 시스템을 버리고 세계에서 가장 빠른 속도로 디지털 미래로 도약하고 있다. ¶디지털 사회 현재의 에스토니아를 만든 중요한 사건 중 하나는 2007년 사이버 공격이다. 돌이켜보면, 이 공격은 어느정도 다소 불가피한 면 이 있었다. 1990년대 에스토니아는 NATO와 EU에 가입하기 위해 서둘렀으며 이 과정에서 어느정도 러시아 지도부에 대항하였다. 탈린 공원에서 소련 동상을 제거하겠다는 결정이 논란을 일으켰고, 이후 에스토니아 의화외 여러 공공 서비스가 DDoS공격으로 마비되었다. 대부분의 사람들은 그 공격이 러시아에서 왔다고 결론지었다. 이는 디지털 인프라를 구축하고 사용하는데 많은 투자를 하게 되는 계기가 되었고, 구현 중인 기술의 보안요소를 신중하게 고려하게 만들었다. 또한 블록체인을 활용할 수 있는 길을 만들었다. 2008년 에스토니아 정부는 사토시가 비트코인 백서를 출시하기 전에 이미 새로운 기술을 실험하고 테스트 하기 시작했다. 블록채인이라는 용어 조차 만들어 지지 않아, 그들은 ‘hash-linked time-stamping’ (해시로 연결된 타임스탬핑)이라고 불렀다. 2012년 부터 블록체인은 국가 의료, 사법, 입법 과 같은 에스토니아 전반에서 운영되었다. 사이버 공격에 대한 에스토니아의 또다른 반응은 룩셈부르크에 건설된 세계 최초의 '데이터 대사관’을 창설하는 것이었다. 만약 다른 공격이 에스토니아에 가해지면, 물리적인 사본이 존재하지 않는 대신 하나이상의 백업이 존재하게 되는 것이다. 오늘날까지 빠르게 나아가는 에스토니아는 모든 디지털 접근 방식을 근본적으로 두 배이상 늘렸다. 에스토니아의 거의 모든 공공 서비스는 모든 시민과 거주자에게 제공되는 보안 디지털 신원을 통해 액세스된다. 2012년 창립이래 블록체인은 에스토니아 개인 의료 및 사이버 보안에도 사용되고 있다. ¶에스토니아 스타일의 블록체인 X-Road는 국가 전체의 디지털 인프라가 운영되는 오픈소스 백본이다. 2001년에 처음으로 실행된 이래 (여러번 업그레이드 되고 변경되었다.) X-Road는 세계에서 가장 큰 블록체인 회사 중 하나인 Guardtime에서 개발한 KSI라는 블록체인을 바탕으로 한다. 이 블록체인은 나토와 미 국방부에서도 사용되고 있다. X-Road의 주요 혁신은 결코 지우거나 다시 쓸 수 없는 분산원장을 활용하는 것이다. 이 말은 비트코인 처럼 암호화폐를 가능하게 하는 블록체인의 원리와 같다. 에스토니아에서는 분산 원장이 사람들이 데이터를 잘 제어할 수 있게 도와주며, 해당 데이터를 제어할 수 있는 중앙 권한을 박탈하게 할 수도 있다. 예를 들어, 교사는 학업성적을 기록할 수 있지만 병력은 기록할 수없다. 이를 가능하게 하는 엄격한 필터링과 제한시키는 프로세스가 있다. 누군가가 허가 없이 다른 사람의 데이터를 보거나 액세스를 하면 기소될 수 있다. X-Road는 세금, 의료 기록, 푸툐, 디지털 신원, 거주 정보와 관련된 데이터를 보유하고 있다. 블록체인에 공공 자료를 안전하게 저장하면, 에스토니아는 아이티와 같은 운명을 겪지 않을 것이다. (아이티에서는 2010년 지진으로 토지 기록을 완전히 유실하여 누가 무엇을 소유했는지 알 수 없게 되었다.) 다른 나라들이 에스토니아의 접근방식을 모방하기 원하는 이유에는 여러가지가 있지만, 에스토니아의 지리학적 위치로 인한 독특한 요인들이 있다는 것을 상기해야 한다. 더 큰 나라들이 블록체인 솔루션을 원활하게 구현하는 것은 쉽지 않을 수 있다. 하지만 만약 그렇다면 두가지 중요한 요소가 필요할 것이다. ¶진보적인 프레임워크 ‘Wild West’ (미국 개척시대의 황량한 서부)라는 문구는 이따금씩 현재의 블록체인 / 크립토 환경을 설명하는데 사용된다. 말 그대로 새롭고, 탐험되지도 않았고, 통제 불능이며, 위험할 수 있다. 이는 기업가와 소비자가 종봉 종 법망의 주변에서 운영되고 있음을 말한다. 때로는 기존의 법적 틀에 의해 실행하지 못하고, 때로는 모호한 규칙을 위반할 가능성 때문에 물러서게 된다. 진보적이고 상황을 앞서는 법률들은 블록체인 개발이 더 발전할 수 있는 기회를 걷어 참과 동시에 소비자 보호를 강화할 수 있는 여지를 제공한다. 완전히 분산된 미래는 아직까지 없으며, 국회의원들이 해야할 진정한 역할이 남아 있다. 일부 자유주의자들이 꿈꾸는 수준의 혁명은 아니지만, 당국과 공생관계를 맺어야 이 기술이 현실을 벗어날 수 있다. 부적절한 데이터 액세스를 처벌하고, 전자투표가 개표되며 전자서명계약이 법적으로 구속력이 있음을 확인하는 힘이 있어야 한다. ¶디지털 신원 에스토이나에서 삶의 많은 부분을 '블록체인’에서 수행할 수 있게 해주는 또다른 것은 검증된 디지털 신원을 사용하는 것이다. 130만명에 가까운 시민들은 신분증을 가지고 있는데, 이는 단순히 운전면허증이나 여권보다 훨씬 더 많은 기능을 한다. 이 ID는 2048 공개키 암호화를 사용하며, 온라인 환경에서 사람의 신원을 확인할 수 있게 해준다. 이는 투표시스템과 의약품 처방전을 작성하는 기능에 디지털 액세스를 허용해준다. 블록체인 개척자와 스타트업에게 있어 pain point는 KYC(Know Your Customer) 프로세스 이다. KYC는 당국이 절도, 테러, 돈세탁에 대처할 수 있도록 은행 및 돈을 송금하는 기기를 대상으로 한다. 많은 경우, 법적 규정을 충족시키기 위해 기업 자신이 서비스하는 고객을 확인하기 위한 번거로운 절차를 거쳐야 하며, 실수할 경우 높은 위험에 직면하게 된다. 암호 화폐 거래에 경험이 있는 사람이라면 누구나 이 괴로움에 동의할 것이다. 모든 사람이 이미 확인된 디지털 신원을 가지고 있다면, 비즈니스를 위한 길은 열려 있고, 정부는 나쁜 활동에 대처할 수 있는 도구를 얻게 되는 것이다. 검증된 디지털 신원이 표준인 환경을 조성하면 블록체인이 성장하고 번성하기 더 쉽다. 이러한 정체성을 위조하거나 오용할 가능성이 없는지 궁금해 하는 사람들에게는 그 답이 100% '아니오’가 ‘거의 아니다’ 라고 말하고 싶다. 에스토니아에는 이런 문제를 모니터링하는 보안 연구팀이 있으며, 최근에는 ID를 elliptic-curve cryptography (타원곡선 암호)로 보호하고 있다. 이 암호화는 SSL 인증서보다 빠르고, 안전하다. 그리고 현재까지 디지털 신원이 오용됐다는 기록은 발견되지 않았다. ¶가상 시민권 에스토니아의 블록체인 모델 활용을 보는 사람들에게는 한가지 문제를 맞닥드리게 된다. 모든 것이 규모가 너무 작다는 것이다. 에스토니아 인구 130만명은 글로벌 서비스를 목표로 하는 기업가들에게는 너무나도 작은 숫자다. 에스토니아 시스템이 더 많은 수의 운영 능력을 가지고 있다고 주장하기 위해서는, 더 많은 참가자들이 필요했다. 그리고 EU 평균보다 적은 인구와 출생률을 가진 이들은 더 많은 주민이 필요했다. 이 두가지 문제에 대한 해결책은 현재 널리 알려진 전자 거주 프로그램이다. 유기적으로 인구를 증가시키는 것과는 다르게, 에스토니아는 자신들의 서비스를 세계에 오픈했다. 미국의 델라웨어에 기반을 둔 기업과 마찬가지로, 에스토니아 전자 거주자들은 여러가지 혜택을 누리고 있다. 신뢰할 수 있는 EU환경에서 글로벌 비즈니스를 쉽게 시작하고 운영할 수 있는 자유가 그것이다. 조세 피난처나 이민 과 같은 해결방법은 아니지만, 이 제안은 소수의 사람들을 끌어들였다. (지금까지 143개국에서 약 27,000명) 에스토니아 최초의 전자 시민권 카드는 2014년 12월에 출시되었다. 그 안에 있는 마이크로 칩은 에스토니아인의 디지털 ID카드와 동일하지만, 실제 에스토니아 국민의 것과는 약간 다르다. 정부는 이후 천만명 디지털 거주자를 목표로 전자 거주 관련 예산을 두배이상 늘리고 2018년에는 더 많은 노력을 기울일 것이다. 딜로이트가 실시한 연구에 따르면 3년전에 이 프로그램이 시작한 이래로 1720만달러의 매출을 올렸다. 이 프로그램은 에스토니아 블록체인에 대한 베타 테스트 일 수 있다. 이것이 원활하게 확장될지는 미지수지만, 이는 그 와 관계없이 에스토니아가 ‘경계가 없는 국가’ 까 되는 또다른 독특한 실험적인 측면을 나타낸다. ¶에스토니아 디지털 토큰 앞서 말했듯, estcoin의 계획은 현재 없는 것으로 밝혀졌습니다. estcoin은 현재 전자 거주 프로그램을 위한 토큰으로만 사용되고 있습니다. 참고 암호화폐가 인기를 끌면서 에스토니아가 자체버전의 암호화폐를 출시할 예정이라는 사실은 그리 놀라운 일은 아니다. 지난 2017년 8월 estcoin에 대한 아이디어가 이더리움 창립자 비탈릭 부테린의 의견으로 검토되고 있다고 밝힌 바 있다. 에스토니아는 2018년에 전자 거주 프로그렘으로 돈을 모으며, 에스토니아를 ICO의 천국을 만든다는 전략의 일부다. 이들은 토큰을 구조화하여 전자 거주 커뮤니티를 구축하고, e-Residency를 통해 에스토니아에서 시작된 회사의 수를 늘리는 것이 주요 목표다. 부테린 또한 이 아이디어에 긍정적이었다. 뒤이어 유로화에 위협이 되지 않는 더 상세한 계획을 내놓기 시작했다. 그러나 EU중앙은행은 당연히도. 회원국 중 한 나라가 새로운 통화를 내놓는 것을 반가워하지 않았다. 중국, 일본, 스웨덴, 그리고 아마 베네수엘라 정부는 자신 만의 암호 통화를 도입하기 위해 움직이고 있다. 이러한 토큰에 대한 여론은 분열 된 것으로보인다. 이러한 노력이 어떻게 이루어지는지 확인하기 위해서는, 시간이 필요하지만, estcoin이 성공하면 '디지털 국가’를 유지하는데 필요한 금전적인 접착제가 될 수 있다. ¶마지막으로 에스토니아의 기술과 블록체인의 사용은 대부분의 국가 보다 몇걸음 더 앞서 있다. 하지만 에스토니아와 같은 작은 크기와 특별한 동기가 없는 나라들은 이 모델을 어떻게 따를 수 있을까? 에스토니아의 공식을 단순히 다른 나라에서 채용하기는 어렵다. 그러나 많은 훌륭한 아이디어가 실험되고 있으며, 에스토니아에서 성공은 구식 기술을 버리는 것이 아니라, 오래된 사고방식을 버리는 것이다. 에스토니아 국가 디지털 고문은 최근 인터뷰에서 이와 같이 언급했다. “기술을 둘러싼 열정과 낙관주의는 그 자체만으로 가치를 지니지만, 종종 요점을 놓치기도 한다. 이것은 모두 마음가짐에 관한 것이다. 문화에 관한 것이다. 그리고 인간관계에 관한 것이다. 이는 우리가 무엇을 할 수 있도록 해준다.”","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 국가에 오신 것을 환영합니다","slug":"welcome-to-the-blockchain-nation","date":"2018-08-12T15:00:00.000Z","updated":"2018-08-13T00:54:33.000Z","comments":true,"path":"2018/08/13/welcome-to-the-blockchain-nation/","link":"","permalink":"https://www.yceffort.kr/2018/08/13/welcome-to-the-blockchain-nation/","excerpt":"Welcome to the blockchain nation 원문 해당 글은 에스토니아 e-Residency 매니저인 Kaspar Korjus 가 공식 블로그에 올린 글 입니다. 에스토니아의 관점으로 번역되어 있습니다. 블록체인 국가에 오신 것을 환영합니다. 세계에서 가장 진보된 디지털 국가 에스토니아가 기업가들이 블록체인 기술의 잠재력을 발휘하도록 돕습니다. 블록체인의 미래 가능성을 엿보고 싶다면 에스토니아를 방문하세요. 10년전, 우리나라는 전국적인 사이버 공격을 경험한 세계 최초의 국가라는 부끄러운 칭호를 얻었습니다.","text":"Welcome to the blockchain nation 원문 해당 글은 에스토니아 e-Residency 매니저인 Kaspar Korjus 가 공식 블로그에 올린 글 입니다. 에스토니아의 관점으로 번역되어 있습니다. 블록체인 국가에 오신 것을 환영합니다. 세계에서 가장 진보된 디지털 국가 에스토니아가 기업가들이 블록체인 기술의 잠재력을 발휘하도록 돕습니다. 블록체인의 미래 가능성을 엿보고 싶다면 에스토니아를 방문하세요. 10년전, 우리나라는 전국적인 사이버 공격을 경험한 세계 최초의 국가라는 부끄러운 칭호를 얻었습니다. 데이터가 손상된 것은 아니지만, 공격자는 시스템을 오프라인으로 만들기 위하여 많은 양의 트래픽을 송출했습니다. 이로 인해 디지털 거버넌스에 많은 투자를 하고 있으며, 특히 디지털 서비스를 위한 허브로 떠오르고 있는 국가에 일시적인 혼란을 야기하였습니다. Skype는 불과 5년전 이곳에서 태어났습니다. 그 결과, 이 공격으로 인해 국가의 디지털 인프라가 어떻게 더욱 강화될 수 있는지에 대한 꺠우치게 되는 계기가 되었습니다. 이 공격은, 장기적으로 에스토니아가 현재 세계에서 가장 발전된 디지털 국가로 널리 인식되고 발전하는데 도움이 되었다는 것입니다. 오늘날 에스토니아의 거의 모든 공공 서비스는 모든 시민과 거주자에게 제공되는 안전한 디지털 신원을 통해 디지털화 되고 액세스 됩니다. 이 디지털 인프라 기술은 놀라울 정도로 인상적입니다. PKI(Public Key Infrastructure)및 eID 시스템은 고급 암호화 기술을 기반으로 하며 2단계 인증을 거치고 있습니다. 데이터는 분산되어 있지만 중복되어 있지 않고, X-Road덕분에 안전하게 공유됩니다. 아래 비디오에서 더 많은 것을 확인할 수 있습니다. 이러한 서비스 중 몇가지에 통합된 혁신 중 하나는 지우거나 다시 쓸 수 없는 분산 원장입니다. 이러한 종류의 원장 기술은 이제 '블록체인’이라고 알려져 있으며, 비트코인 및 이더리움과 같은 암호 통화과 중앙에서 별도의 권한 없이도 작동할 수 있게 하는 역할로도 유명합니다. 에스토니아에서는 이 분산 원장이 시민과 거주자에게 자신의 데이터를 잘 제어할 수 있게 도와줍니다. 의료 등록 시스템을 예로 들어봅시다. 세계 어느 누구도 자신의 의료 기록이 어디에 있는지, 누가 그 정보를 보았는지 정확히 이야기 할 수 없습니다. 반면 에스토니아인은 디지털 신원을 사용하여 자신의 기록에 로그인 한 다음, 정확히 어떤 의료 전문가가 언제 이러한 일을 했는지 확인할 수 있습니다. 적절한 이유 없이 데이터에 엑세스한 정부 공무원은 추궁당하며 기소될 수 있습니다. 최근 이코노미스트에서 지적했듯이, 더 작은 정부를 원하는 사람들이 사랑하는 기술을 정부에서 점점더 사용하고 있다는 것은 아이러니한 일입니다. 하지만, 그 목적은 사람들의 손에 더 많은 힘을 실어준다는 점에서 비슷합니다. 사실 블록체인은 우리 삶의 거의 모든 측면을 변화시킬 수 있는 힘을 가지고 있습니다. 민주주의를 개선하고, 더 큰 기회를 제공하는 것입니다. 하지만 이는 정부의 지원과 협력이 있어야만 잠재력을 최대한으로 발휘할 수 있습니다. ¶정부가 블록체인 기술의 잠재력을 최대한으로 발휘하는데 어떤 도움을 주는가 정부가 제공할 수 있는 블록체인 산업의 미래 발전에 필요한 두가지 구성요소가 있습니다. ¶1. 스마트 정책 프레임워크 블록체인은 여전히 비교적 새로운 기술이므로, 기업가와 고객은 법적으로 회색인 영역에서 운영할 불확실성에 직면하거나, 혹은 기존 법률에 의해 제약을 받고 있습니다. 블록체인 기술의 발전을 방해하는 것과는 거리가 먼 스마트 정책 프레임 워크는, 기업가의 활동을 장려하고 소비자 보호를 강화할 수 있습니다. 예를 들어, 우리는 누가 데이터에 엑세스하고, 전자 투표 또는 디지털로 서명된 문서를 수행하는지 모니터링할 수 있는 기술을 보유하고 있지만, 부적절한 데이터 액세스를 막기 위한 정책적인 프레임워크가 없으면 쓸모가 없습니다. 전자투표를 개표하고, 디지털 서명된 계약은 법적으로 구속력이 있어야 합니다. 다행히도, 에스토니아는 새로운 산업을 지원하기 위하여 새로운 법률이 필요할 때, 신속하게 대응할 수 있다는 이점이 있습니다. 예를 들어, 자동차 공유 어플 또는 ‘귀여운 배달 로봇’ 이 거리를 돌아다닐 수 있도록 도와주는 것과 같습니다. 공공 부문과 민간 부문의 긴밀한 협력을 바탕으로 에스토니아는 선도적인 신생 허브로 떠올랐습니다. 세계 최대의 블록체인 기업인 GuardTime 뿐만 아니라 수많은 스타트업이 창의적인 방법으로 전통산업을 파괴하기 위하여 활동하기 시작했습니다. 위험을 줄이고, 돈세탁과 같은 도전으로 부터 공공의 이익을 보호하기 위하여 더 강력한 KYC (Know Your Customer) 절차를 요구하는 규정을 포함해, 블록체인 주변의 보다더 명확한 정책 프레임 워크가 전세계적으로 확산되고 있습니다. 불행히도 이는 블록체인 스사트업의 비용을 증가 시키거나, 제품 및 서비스를 특정 시장으로 한정 할 수 있습니다. 그래서, 바로 공공 부문이 제공할 수 있는 두번째 핵심요소가 있습니다. ¶2. 온라인 신원 확인 더욱 강한 KYC에 대한 법적인 요구 사항이 없더라도, 블록체인을 개척하는 사람들은 온라인에서 누구를 다루는지 확인하는데 많은 비용을 들고, 잘못 이해하면 위험을 수반할 수도 있습니다. 정부가 지원하는 안전한 디지털 신원은 스사트업을 위한 KYC 프로세스를 단순화 하는데 도움이 될 것입니다. 우리는 이미 에스토니아에 이런 것을 보유하고 있지만, 블록체인 기업가들은 에스토니아 국내 시장 규모에 크게 관심이 동하지 않을 것이라는 것도 이해 합니다. 고작 130만명의 사람이죠. 다행히도, 정부가 발행한 디지털 신원은 이제 전자 시민권을 통해 전세계적으로 이용 가능합니다. e-Residency는 에스토니아가 세계에 선물한 것으로, 현재 가장 큰 이점은 ‘신뢰할 수 있는 위치에 독립적인 회사를 온라인으로 완벽하게 설립하고 관리하는 능력’ 입니다. 그러나 이 프로그램은 디지털 ID를 제품 및 서비스에 통합할 수 있는 방법으로, 블록체인 기업가들 사이에서 상당한 관심을 얻었습니다. e-Residency는 반드시 고객에게 의무적으로 적용될 필요는 없지만, 옵션으로 통합할 경우 회사가 더 빠르고 저렴한 비용으로 고객을 서비스에 탑승시킬 수 있습니다. 그 다음 기존 전자 거주자에게 제품과 서비스를 쉽게 제공할 수 있으며, 미래의 고객이 양측의 장기적인 이점을 고려할 수 있도록 유도할 수 있습니다. e-Residency를 얻으면, 에스토니아 경찰 및 국경 수비대에서 배경조사를 받아야 합니다. 확인이 된다면, 신분증이 들어 있는 e-Residency 키트, 컴퓨터 usb슬롯에 꽂는 카드 및 온라인 디지털 서명 문서 인증을 위한 핀 코드 세트를 발급받을 수 있습니다. 현재 전세계 2만명이 넘는 전자 거주자가 있으며, e-Residency 팬과 블록체인 솔루션 팬 사이에는 이미 이 두개에 큰 교차점이 있음을 알고 있습니다. 이 프로그램은 현재 베타 테스트 중이지만, 최근 개발된 개선사항으로 인해 커뮤니티가 급속도로 성장할 수 있는 잠재력을 갖게 되었습니다. 가장 중요 한 것은, Holvi라는 회사는 최근 에스토니아로 여행가거나 에스토니아와 연결할 필요 없이 전세계적으로 전자 거주자를 위한 EU 비즈니스 뱅킹을 제공한 최초의 회사가 되었다는 점입니다. 즉, 전세계적으로 블록체인 개발을 지원하기 위해 세가지 구성요소가 모두 신속하게 등장하고 있다는 것을 의미합니다. ¶블록체인 회사들은 이미 e-Residency의 혜택을 보고 있습니다 이 글에는 이론적인 내용은 아무것도 없다는 점에 주목해야 합니다. 전 세계의 블록체인 기업가들은 이미 고객이 e-Residency를 통해 제품과 서비스에 액세스 할수 있게 만들고 있습니다. 심지어 e-Residency를 통해 회사를 설립하는 사람들도 있습니다. 다음은 주목할 만한 예 입니다. 나스닥은 에스토니아의 e-Residency 플랫폼이 나스닥의 탈리니 증권 거래소에 상장된 회사의 주주들이 주주회의에서 투표할 수 있도록 블록체인 기반 전자 투표 서비스를 촉진할 것이라고 밝혔다. BitNation은 전자 거주자를 위한 공증인 서비스를 소개하기 위해, e-Residency와 파트너십을 발표 했습니다.BitNation의 창립자는 에스토니아 정부가 다른 어떤 정부보다 세계화 시대의 역동성을 훨씬 잘 이해하고 있다고 믿는다고 밝혔습니다. Wallet.Serivces는 소프트웨어 개발자가 블록체인 기술을 사용하여 응용 프로그램을 구축할 수 있는 간단한 도구를 제공합니다. 스코틀랜드 정부와 공동으로 만들어진 SICCAR 플랫폼은 시민과 정부 사이에 사이버 보안 정보 공유를 제공합니다. 전자 거주자이고 한 Ferry는 “e-Residency는 디지털 공공 서비스에서 글로벌 리더십을 대표합니다. 이 강력한 ID를 활용하고 프로그램과 함께 성장할 수 있습니다” 라고 언급했습니다. Oraclize는 전자 거주자가 이더리움을 거래 할 수 있는 전자 지갑과, 전자 거주자가 자신의 디지털 ID를 이더리움 주소에 연결할 수 있는 신분 증명 웹사이트를 개셜했습니다. Oracalize에서 e-Residency에 대해 어떻게 생각하고 있는지 여기에서 확인할 수 있습니다. 대만에 있는 WageCan은 e-Residency ID를 통해 액세스 할 수 있는 웹, 모바일 앱 용 블록체인 자산 지갑을 제공합니다. Funderbeam은 블록체인을 사용하여 사람들이 전통적인 주식시장에서 필요한 수많은 중개자 없이 초기단계 스타트업에 투자할 수 있게 합니다. 이들은 투자자를 위한 e-Residency ID를 통합하기 위해 노력하고 있으며, 이는 다른 KYC옵션을 보완하게 됩니다. MotherShip은 e-Residency를 기반으로 새로운 디지털 자산 거래를 계획하고 현재 크라우드 펀딩 캠페인을 시작했습니다. 이들의 목표는 에스토니아를 블록체인 회사를 위한 최고의 국가로 만드는 것입니다. 에스토니아를 선진 디지털 국가로 설립하는데 도움이 된 전 에스토니아 대통령 Toomas Hendrik Ilves 은 에스토니아가 더 많은 블록체인 기업가를 지원하는 방법에 대해 설명했습니다. “에스토니아는 이제 블록체인 국가가 되었습니다. 우리의 디지털 사회은 블록체인 기술을 토대로 하고 있고, 안전한 디지털 신원은 온라인 신원을 검증해야 하는 블록체인 기업에게 상당한 이점을 제공합니다. 에스토니아는 e-Residency를 통해 세계 어느 곳에서나 블록체인 개척자를 지원할 준비가 되어 있으므로, 에스토니아에 발을 들이지 않고도 디지털 인프라를 통해 미래를 건설할 수 있습니다.” e-Residency를 통해 창업을 선택하거나, 제품 및 서비스에 투자하는 모든 회사와 마찬가지로, 이 프로그램은 모든 성공을 기원하며 가치를 추가할 수 있는 지원을 제공할 준비가 되어 있습니다. 여기에서 e-Residency 를 신청하고, 블록체인 국가에 가입하면 미래를 함께 만들 수 있습니다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"중앙 은행이 디지털 화폐를 발행할 경우의 통화정책","slug":"monetary-policy-implcations-of-central-bank-issued-digital-currency","date":"2018-08-09T15:00:00.000Z","updated":"2018-08-10T01:42:36.000Z","comments":true,"path":"2018/08/10/monetary-policy-implcations-of-central-bank-issued-digital-currency/","link":"","permalink":"https://www.yceffort.kr/2018/08/10/monetary-policy-implcations-of-central-bank-issued-digital-currency/","excerpt":"MONETARY POLICY IMPLICATIONS OF CENTRAL BANK-ISSUED DIGITAL CURRENCY 원문 디지털 지불 수단 (카드, 모바일 결제 등)의 증가로 인한 현금 사용의 감소와 더불어 소위 '암호화폐’라고 불리우는 디지털 기술의 혁신과 발전으로 인해 중앙은행이 디지털 화폐를 발행해야 하는지에 대한 논의가 활발해지고 있다. 영국은행, 중국 인민은행, 스웨덴 은행과 같은 일부 중앙은행은 이론적인 관점에서 그 가능성을 고려 했다. 디지털 화폐를 발행한다는 것은 중앙 은행의 예금을 다른 모든 경제 주체,","text":"MONETARY POLICY IMPLICATIONS OF CENTRAL BANK-ISSUED DIGITAL CURRENCY 원문 디지털 지불 수단 (카드, 모바일 결제 등)의 증가로 인한 현금 사용의 감소와 더불어 소위 '암호화폐’라고 불리우는 디지털 기술의 혁신과 발전으로 인해 중앙은행이 디지털 화폐를 발행해야 하는지에 대한 논의가 활발해지고 있다. 영국은행, 중국 인민은행, 스웨덴 은행과 같은 일부 중앙은행은 이론적인 관점에서 그 가능성을 고려 했다. 디지털 화폐를 발행한다는 것은 중앙 은행의 예금을 다른 모든 경제 주체, 즉 비은행, 비 금융 회사 및 일반 가구에게 까지 확대한다는 것을 의미한다. 이 가능성은 다음과 같은 몇가지 기술적 대안을 제시한다. 디지털 화폐에 대해 예금 처럼 이자를 통해 보상을 해야하는가? 디지털 화폐가 은행 예금과 같은 등록된 형태를 유지하거나 혹은 익명성을 유지해야 하는가? 중앙 은행 디지털 통화 (CDBC) 옹호자들은 지불 시스템의 기능과 잠재적으로 통화 정책의 일부 측면을 개선할 것이라고 주장한다. 그러나 비판론자들은 CDBC와 관련된 통화정책 전달방식에서 이점이 적으며, 기술적 위험이 있으며 재정적인 안정성에 있어서도 위험성이 있어 주의를 요한다고 말한다. CDBC의 가능한 이점과 단점은 앞서 언급한 두 가지 측면, 잠재적인 익명성과 보상에 측면에서 좌우 된다. ¶CDBC (Central Bank Digital Currency) 란 무엇인가? 중앙은행의 지급준비금과 은행권(지폐)는 아래 표와 같이 '돈’으로 분류될 수 있는 두가지 주요 유형의 책임을 발행하게 된다. 은행 준비금은 규제및 통화 정책상의 이유, 또는 유동성 관리 목적을 위해 금융기관에서 의무적으로 중앙은행에 예치하는 것을 의미한다. 여기에는 물리적인 형태가 없지만, 이는 중앙은행과 상업은행간의 회계항목으로 남아 있다. 이는 제한된 엑세스와 등록, 잠재적으로 보상을 받을 수 있는 디지털 자산이다. 유로 시스템에서 은행 보유금은 예금 금리가 지급되며, 이는 유럽 중앙은행의 주요 통화정책 수단 중 하나다. 지급 준비금 지폐 CDBC 형태 디지털 물리 디지털 접근 제한적 유니버셜 유니버셜 익명성 익명성없음 익명성보장 둘다 가능 보상 지불 없음 둘다 가능 지폐는 물리적인 자산으로, 등록을 필요로 하지 않으며 합법적으로 간주되는 지역에서 시민의 여부와 관계없이 익명으로 지불을 할 수 있다. 당연히 지폐는 보상을 받지 않는다. 따라서 지폐는 물리적, 보편적, 익명, 비보상 자산이다. CDBC는 일반적으로 가계와 기업이 이용할 수 있는 중앙은행에서 예금으로 간주된다. 결과적으로 CDBC는 지폐와 은행 준비금의 특성을 공유한다. 익명성과 보수에 대해서는 다양한 가능성이 예상된다. 익명일수도, 아닐수도, 보상을 줄수도, 아닐 수도 있다. CDBC는 또한 은행 송금이나 직불 카드를 통해 지폐를 사용할 필요 없이 동원 될 수 있는 개인의 디지털 화폐와 특징을 공유한다. 가장 큰 차이점은 CDBC는 중앙은행에서 발행한 공개 디지털 통화라는 점이다. ¶왜 CDBC를 발행하려 하는가? 최근 문헌에서는 일부 중앙 은행이 CDBC의 향후 도입을 고려할 수 있는 세가지 이유를 제시했다. 일부 지역에서 현금 수요가 줄어들고 있다. 지불 시스템의 일부 측면에서 가능한 개선 통화정책 전달 측면에서의 개선 또한 CDBC 도입이 고려되고 있는 많은 국가에서 세금 사기, 돈세탁 퇴치 등 경제정책의 보다 일반적인 측면도 고려하고 있다. CDBC를 발행할 수 있는 이유 중 하나는 현금이 디지털 방식으로 대체될 가능성이 있는 경우, 즉 중앙은행이 발행하는데 드는 작은 금액인 지폐 발행에 대해 얻는 이익과 같은 작은 금액에 대한 영향일 수 있다. 중앙은행의 이익이 재무부로 이전되는 한, 공공부문 수입 감소로 인해 잠재적으로 조세인상이나 공공지출의 감소를 초래할 수 있다. 그러나 유로지역을 포함하여 대부분 국가에서 유통중인 지폐의 양은 증가하고 있다.따라서 이러한 이유, 즉 지폐 발행 비용을 절약한다는 이유는 타당해 보이지 않는다. 각 국가별 현금 발행량. 파란색 유로, 빨간색 미국, 노란색 영국, 초록색 일본, 그리고 우하향하는 유일한 국가는 스웨덴 두번째로, CDBC의 도입이 지불 시스템의 특정 측면을 향상 시킬 수 있다고 결론 지었다. 최근 분석에서는 CDBC를 도입할 경우 생산성과 관련하여 상당한 이익이 있을 것이라고 추정한다. 그러나 이러한 개선이 공공 디지털 통화의 도입과 현재 사용되는 개인 디지털 통화의 확장및 개선이 아닌 공공 디지털 통화의 도입이 반드시 발생해야 하는 이유와 연관관계는 불분명하다. 세번째 이유는 통화정책을 전달하는데 있어서의 개선이다. 첫번째로, CDBC가 보상을 주게 되면 이자율은 가계 및 기업 저축과 투자 결정에 직접적인 영향을 미치기 때문에 기존 통화정책을 이행하는데 중요한 도구가 될 수 있다. 이는 통화 정책 전달을 부분적으로 은행의 재정상황과 분리시킬 수 있을 것이고, 특히 금융 위기 동안에 중요하게 작용할 수도 있다. 더욱이 현금이 없어지면, Zero-lower-bound 문제를 해결할 수 있다. 물리적 지폐가 사라지게 되면, CDBC는 이자율을 바닥으로 나타낼 수 있다. Zero Lower Bound의 존재를 통해 존재하는 통화정책의 현재의 비대칭을 꺠고, 원칙적으로 필요한 경우 명목금리를 더 내릴 수 있다. 또한 CDBC는 금융을 이용하지 못하는 문제, 세금 사기 해결과 같은 다른 경제 정책 목표에 도움이 될 수 있다. 세금 사기와 돈세탁 문제는 CDBC가 익명이 아닌 경우에만 역할을 할 수 있다는 점을 명시해야 한다. 이는 중앙은행이 경제의 모든 거래에 대해 적극적으로 기록을 유지할 때만 가능하다. 또한 목표를 달성하기 위해서는 현금 사용 또한 없애 야 한다. 그렇다고 해서 익명의 CDBC가 이러한 활동들을 완전히 없앨 수 잇는 것은 아니다. 여전히, 다른 나라 통화, 금, 또는 암호 화폐와 같은 것을 사용하여 대체자산을 보유하려 할 것이다. 암호 화폐의 출현으로 인해 디지털 화폐가 받아들여지면서 애널리스트 사이에서는 여러가지 우려가 나타났다. 이 경우 중앙은행은 통화정책이 실물 경제를 통제할 수가 없어질 수도 있으므로 물가안정과 관련하여 문제가 발생할 수도 있다. 현재 암호화폐 시장 가치가 유로나 미국 통화에 비해 상당히 작기 때문에 공공 디지털 통화 발행을 정당화하기에는 많인 부족하다. 또한 교환수단으로서의 사용도 제한적이다. 암호화폐는 완래 교환을 하기 위한 수단으로 고려되었지만, 암호화폐 시장에 만연한 강력한 변동성은 통화 단위 또는 가치 저장용도로 사용하기에 부적절하게 만든다. ¶익명 혹은 기명의 돈 기명으로 CDBC를 활용할 경우 사회에 특정 이점 (돈 세탁, 세금 회피등)에서 이점을 제공 할 수 있지만, 개인의 사생활을 침여할 것이다. 이러한 사회학적인 고려외에도, 공공의 익명 디지털 통화를 도입하기로 한다면, 중앙은행이 현재 전자 지불 운영자가 돌리고 있는 인프라보다 최소한 동등하거나 더 나은 인프라를 만들 수 있도록 투자해야 한다는 사실을 명심해야 한다. 특히 중앙은행은 거래를 검증해야 하며, 다각적인 위협에 대비하여 시스템의 안전을 보장해야 한다. 익명의 공적통화의 경우 인프라에 대한 투자가 적을 수 있지만 다른 기술적 문제가 발생한다. 익명의 CDBC는 암호통화에서 사용되는 현재 분산 유효성 검사 기술을 법적 통화에 사용할 수 있어야 한다. 이는 두가지 문제가 있다. 첫째, 보정이 불확실한 이 시스템 (블록에 한번 작성이 되고나면 수정이 불가능한)과 관련된 비용을 추가해야 하고, 둘째 , 사이버 공격과 같은 사기를 막을 수 있어야 한다. 이는 암호통화화 같이 상대적으로 통합되지 않은 기을 근거했을 때 매우 복잡할 수 있다. ¶통화정책과 금융 안정 관점에서 시사점 앞서 언급했듯이, CBDC의 도입은 통화정책을 전송한다는 관점에서 중요한 영향을 미칠 수 있다. 이런 점에서 현재 설계와 가장 밀접한 시나리오는 보상이 없는 CDBC다. 여기서 중앙은행의 상업은행 준비금은 단기 통화 정책 결정을 전달 할 수 있는 핵심 변수인 은행간 시장의 단기 금리를 지속적으로 높여줄 수 있을 것이다. CDBC가 현재 계좌에 대한 가치 창고 및 지불 수다으로 사용하는대신, CDBC에 대한 접근 권한을 가진 다른 경제 주체가 은행에 자금을 빌려주는 비율에 대한 보상으로 사용하는 것은 유요할 수 있다. 예를 들어, 비은행 금융 기관이 CBDC를 접근 하게 하면, 폭넓게 정의 된 화폐시장의 금리를 결정할 수 있게 된다. 마찬가지로, CBDC에 대한 보상은 가계 및 기업 예금 금리의 하한선을 설정하게 된다. 따라서 CDBC 비율의 변화는 중앙은행에 예금된 보상금을 통해 직접 또는 상업은행의 예금 보수에 대해 간접적인 영향을 미치며, 이는 대리인 지출 및 저죽을 결정하는데 영향을 미친다. 은행의 자금 조달 비용이 변화하게 되면, 실물경제에 빌려주는 은행의 이자율에 영향을 미친다. 간단히 말해서, 보상이 가능한 CBDC 시나리오에서는 중앙은행이 경제 전반의 재정 상태에 대한 통제권을 행사할 수 있게 해주며, 총 수요량에 대한 중앙은행의 통제력을 높일 수 있다. 또한 은행 부문의 수익성과 규모에 영향을 미칠 수 있다. 은행 준비금 금리에 비해 CBDC 금리가 충분히 낮은 경우, 은행은 CDBC 금리보다 높은 예끔 금리를 제공하여 예금 손실을 피할 수 있으며, 자금의 수익성 또한 동시에 유지 할 수 있다. 반대로 동일한 수준이라면, 은행이 CDBC 금리 보다 더 높은 금리를 인상하도록 강요할 것이다. 이는 순이자 마진을 줄이는 것 외에도 신용 공급 및 비용 상승으로 이어지고, 나아가 은행 부문의 중개능력 축소로 이어질 수 있다. 마지막으로, 보수가 없는 경우에도 CDBC를 도입하면 금융 안정에 영향을 미칠 수 있다. 금융 위기에 직면하여 중앙은행의 예금이 상업은행의 예금보다 안전하다고 인식 될 수 있기 때문이다. 따라서 예금자, 특히 보증금이 국가 보증을 받지 않는 경우에는 CBDC로 은행 계좌로 자금을 인출하여 잠재적인 은행 공황 상태에 빠지게 하고 금융 위기를 악화 시킬 수 있다. ¶결론 CDBC의 도입을 논의 할때 고려할 수 있는 한가지 주장은, 예금자와 차용자가 직면하는 시장 수익률을 보다 잘 통제함으로써 통화정책을 개선할 수도 있다는 것이다. 또한 제로 금리 바운드와 관련한 제한을 제거할 수 있는 가능성은 이론적으로 매력적이며, 특히 현재의 저금리 환경에서는 특히 그렇다. 그러나 불확실성과 위험성 또한 존재하며 중앙은행은 이점에 신중해야 한다. CDBC 도입과 관련된 위험중 하나는 기술에 관련된 것이다. 현재 전자지불 수단과 유사한 기술을 기반으로 하는 익명의 CDBC의 경우 인프라 및 운영 요구 사항 및 요구 사항 측면에서 상당한 비용이 소요된다. 익명의 CDBC의 경우 암호 통화 기술을 상대적으로 다른 환경에 적용할 수 있어야한다. 우발적이든 사이버 공격이든 두 시나리오에서 하나라도 실패하면 경제해 상당한 해를 끼칠 수 있다. 두 번째 위험성은 재정적 안정성의 위험이다. 새로운 무위험 자산 (특히 보상이 포함되어 있다면)의 도입은 은행 부문의 수익성에 영향을 미치고 예금 자들이 특히 은행 공황 발발시 자금을 인출하여 중앙은행에 입금하도록 장려할 수도 있다. 그러나 이러한 고려사항이 금융 부문 안정성과 은행 대출에 미치는 영향을 추정하기 어렵다. 이전에 이런 경험이 없었기 때문이다. 결과적으로, 중앙은행이 추구할 수 있는 가장 합리적인 방법은 지켜보고 기다리는 것이다. 각 중앙은행의 소관 지역에서 기술진보와 잠재적인 응용을 분석하고, 이들의 운영과 통화체계에 대한 잠재적인 위험을 피하는 것이다.","categories":[],"tags":[{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"환자 정보를 안전하게 저장하기 위한 블록체인","slug":"a-blockchain-based-method-for-the-secure-storage-of-patient-records","date":"2018-08-08T15:00:00.000Z","updated":"2018-08-09T00:26:32.000Z","comments":true,"path":"2018/08/09/a-blockchain-based-method-for-the-secure-storage-of-patient-records/","link":"","permalink":"https://www.yceffort.kr/2018/08/09/a-blockchain-based-method-for-the-secure-storage-of-patient-records/","excerpt":"Moving Toward a Blockchain-based Method for the Secure Storage of Patient Records 원문 ¶오늘날의 환경 과거 2008년에는 10% 미만의 의료정보만 전자 형태로 저장되었다. 종이 기반 기록은 다른 서비스 혹은 환자에게 직접 데이터를 제공하거나 복사하기가 어렵다. 그러나 오늘날 거의 모든 의료 기록은 EHR (Electronic Health Record) 시스템에 저장된다. 그러나 여전히 대부분의 데이터는 휴대 불가능한 형태로 남아 있다. 의료 데이터에 대한 엑세스","text":"Moving Toward a Blockchain-based Method for the Secure Storage of Patient Records 원문 ¶오늘날의 환경 과거 2008년에는 10% 미만의 의료정보만 전자 형태로 저장되었다. 종이 기반 기록은 다른 서비스 혹은 환자에게 직접 데이터를 제공하거나 복사하기가 어렵다. 그러나 오늘날 거의 모든 의료 기록은 EHR (Electronic Health Record) 시스템에 저장된다. 그러나 여전히 대부분의 데이터는 휴대 불가능한 형태로 남아 있다. 의료 데이터에 대한 엑세스를 제공하고 제어하는데 어려움을 겪고 있다. 많은 의료 서비스 제공업체들은 HIPAA (미국 의료정보보호법) 을 해석하는데 있어 오류를 겪고 있고, 또 절대적으로 필요한 경우에만 데이터를 공유하고 있다. 이는 환자가 자신의 데이터에 액세스 하는 것을 제한 한다. 일부 기관에서는 데이터 관리 능력을 경쟁우위로 인식하기도 한다. 환자의 데이터를 공유하면 다른 기관에서 치료 받을 수 있지만, 이를 보유하면 그 기관에서만 치료 받을 수 있다. 이는 의료사업자가 환자 의료 기록을 의료 기록이 아니라 '의료 자산’으로 인식하게 한다. 이는 의료 기록을 다른 곳으로 옮기거나 필요한 환자들에게 제공하는데 있서 불필요하며 또한 비용이 많이 든다. 지난 7년 동안 EHR이 빠르게 확산 되면서, 이러한 서비스 제공자는 환자에게 해당레코드를 다운로드하고, 다른 위치로 데이터를 제공할 수 있는 기능을 제공할 것을 요구한다. 그러나 오늘날 대부분의 업체는 외부 시스템과 최소한의 일부 데이터만 공유하고 있어 이 분야에서 진전이 더디다. 일반적으로 정보가 생성된 시스템에 그냥 머물러 있다는 것을 의미한다. 이는 미국에서 '정보차단’의 사례를 확인하고 바로잡기 위한 절차를 채택할 만큼 중요한 문제다. 적시에 의료 데이터를 안전하게 전송하고 공유하지 못한다면, 환자 치료에 어려움을 미치게 된다. 2008년 한 에세이에서는 환자가 의료기록 관리를 포함한 자신의 의료 정보를 통제할 필요가 있다고 주장했다. 환자는 건강관리를 위한 플랫폼을 얻어야 하며, 환자가 플랫폼이 되기 위해서는 더 환자가 원하는 더 많은 도구와 기능이 필요하다고 주장했다. 이는 의료 데이터를 쉽게 공유할 수 있다는 기능 이상의 것을 요구하는 것이다. 환자들에게 자신의 의료데이터의 관리자가 되어야 하며, 궁극적으로 그것이 어디서 사용할 수 있는지 통제되어야 한다는 것이다. 출처 EHR 보급이 증가함에 따라 발생하는 문제에는 다른 것도 있다. 전자적로 데이터를 저장하면서, 의료 정보를 유출하는 사건도 빈번하게 발생하고 있다. 대다수의 환자들은 의료 기록의 사생활 침해와 보안에 대해 우려 하고 있으며, 정보를 제공하지 않는 경우 도 더러 있다. 데이터 유출 현황 ¶블록체인 솔루션 적용 블록체인 기반의 의료 기록 시스템을 구현하기 위해 EHR 및 기록 보관 시스템은 환자의 의료 정보를 암호화 하고 블록체인에 전송한다. 트랜잭션에는 출처를 추적할 수 있는 서비스 제공자의 전자 서명과, 트랜잭션 수신자의 환자 블록체인 ID가 포함된다. 문서가 블록체인에 기록된 뒤에는, 환자는 웹 또는 모바일 어플리케이션을 사용하여 블록체인에서 내용을 조회하고 특정 당사자에게 해당 정보를 엑세스를 허용하거나 취소한다. 이런 시스템은 현재 기록 유지 방법에 비해 여러가지 장점이 있다. 환자는 의료 데이터에 대한 엑세스를 소유하고 제어하는 플랫폼이 될 수 있다. 이것은 환자가 의료기록 사본을 획득하거나 다른 의료 제공자에게 데이터를 제공하는데 발생하는 장애물을 제거한다. 데이터가 분산 네트워크에 저장되므로, 환자기록을 얻기 위해 해킹할 수 있는 단일 지점이 없다. 데이터는 블록체인에 암호화되어 있으며, 환자의 개인키로만 해독할 수 있다. 네트워크가 악의적인 해커에 의해 침투되더라도, 데이터를 읽을 수 잇는 실질적인 방법이 없다. 인프라만으로 감사 및 비거부 기능을 제공할 수 있다. 블록체인에 데이터를 추가하는데에는 변조 방지 스탬프, 계정 ID 및 콘텐츠의 변경여부를 확인하는 방법도 포함된다. 의료 데이터를 저장하는 블록체인 기반 방법론은 의료 기록 보관시스템의 모든 기준을 포함하며, 환자의 기록에 대한 엑세스를 향상시키고 데이터 위협에 대한 보안을 강화하기 때문에 전통적인 중앙 집중식 시스템이 할 수 있는 것 이상을 해낼 수 있다. ¶의료 기록용 블록체인을 위한 첫번째 단계 의료 산업이 현재의 솔루션을 폐기하고 블록체인 아키텍쳐로 넘어갈 것이라는 생각은 순진한 생각이다. 의료산업은 전형적인 위험 기피 산업으로, 입증되지 않는 새로운 기술로 전환하는데 필요한 시간과 비용을 들이지 않을 것이다. 게다가 현 상황에 대한 관성과 투자도 이미 많이 이루어져 있다. EHR을 보급하기 위해 CMS (Centers for Medicare &amp; Medicaid Services (CMS), 미국 심평원 느낌)은 2011년까지 약 300억달러 이상을 지출했다. 때문에 기록 정보를 위한 방식은 이 투자를 존중하고 기존 EHR 인프라와 함께 운영되는 방향으로 가야할 것이다. 중앙 집중식 시스템에서 의료 데이터를 유지하고 있는 기관은 환자데이터를 자산으로 인식하고 있으며, 이러한 사고방식을 바꾸기란 쉽지 않다. 블록체인 기반 솔루션은 향후 어느 시점에서는 의미있는 옵션일 수 있지만, 단기간에는 발판을 삼을 수 있는 솔루션이 필요하다. 블록체인 기술을 기반으로 한 임상 데이터 저장을 위한 인프라를 만들고 동시에 EHR시스템을 활용하여 환자 데이터를 수집하고 저장한다. 이는 현재 의료 IT 투자를 존중하고 블록체인 솔루션의 많은 장점을 활용할 수 있다. 기존 표준 및 정책은 기존 시스템의 데이터를 새로운 블록체인 기반 시스템에 복제하기 위한 프레임워크를 제공한다. 새로운 시스템은 결과적으로 효과적인 블록체인 기반 개인 의료 기록 시스템이 될 것이다. 이 솔루션에는 EHR 에서 시작하여, 실험실 정보 시스템, 방사선 시스템, 지불 데이터베이스, 의료 기기 및 소비자의 디바이스 를 포함할 수 있다. 이 시스템은 하나의 데이터베이스에 데이터를 저장하고, 데이터 사본을 저장하는 것 외에도 각 시스템은 블록체인 기반 의료 기록 시스템에 사본을 전송한다. 이러한 시스템을 만드는 데는 세가지 옵션이 있다. EHR 공급업체가 의료 정보를 블록체인 기반 의료 기록 시스템에 직접 자동으로 전달하는 클라이언트를 개발한다. 이는 가장 선호되는 옵션이지만, EHR공급업체의 노력과 협력이 필요하며 규제나 인센티브가 있지 않는 한 발생하지 않을 것이다. (아래 그림 참조) EHR 공급업체가 REST, SOAP와 같이 데이터를 보낼 수 있는 기존 프로토콜을 사용하여, 여기에서 제정한 표준에 따라 데이터를 블록체인에 보내는 것이다. 블록체인 기반 의료 기록 시스템이 이러한 통신 프로토콜을 처리하고 다양한 소스에서 데이터를 수신할 수 있도록 구성해야 한다. 환자가 기존 환자 포털을 통해 개인 의료 정보를 받은 다음, 블록체인에 직접 업로드 한다. 이 방법은 모든 경우에 작동할 수 있지만, 환자라는 중개자에 의존하는 방법이다. 최악의 경우 환자가 제대로 하지 않을 경우 불완전한 기록이 된다. 옵션 3는 가장 간단한 시나리오며 구현하기 쉽다. 그리고 다른 두가지 옵션은 EHR 공급업체에 달려 있다. 1. EHR은 데이터를 로컬에서 저장하고, 데이터를 C-CDA (의료데이터용 XML)로 준비하며, 내장된 블록체인 클라이언트로 전송 2. 내장된 블록체인 네트워크는 환자의 공개키를 사용하여 문서를 암호화하고, 블록체인에 연결하여 문서를 전송 3. 데이터의 출처, 메타데이터와 함께 블록체인에 트랜잭션에 사용된다. 블록체인 네트워크 노드는 합의 알고리즘을 사용하여 트랜잭션의 유효성을 결정하고, 이 과정이 긑나면 공개 원장에 영구적으로 기록한다. 4. 블록체인은 모든 문서를 체인으로 묶어 저장한다. 5. 블록체인에 연결하여 환자를 위해 모든 데이터를 다운로드 할 수 있다. 해당 데이터는 환자의 개인키를 사용하여 해독된다. 6. 환자가 데이터를 보고 다른 사용자와 공유할 수 있다. ¶고려사항 블록체인 기반 시스템이 가까운 시일내에 가능한 것은 아니다. 극복해야 할 많은 과제가 남았다. 첫 번째로는, 의료용으로 적절한 블록체인 인프라가 현재 존재하지 않다는 것이다. 더 중요한 것은, 이것을 만드려고 하는 동기를 가진 명확한 이해 관계자가 없다는 것이다. 노드를 구축하고 유지하기 위해서는, 컴퓨팅 능력을 필요로 한다. 비트코이니 블록체인을 유지하는 노드는, 비트코인을 '마이닝’하게 함으로써 보상을 받는다. 만약 의료 블록체인을 유지하기 위해 처리능력을 사용하도록 동기를 부여하는 것은 무엇일까? 한가지 제안은 시스템 데이터를 제공하는 노드가 의료 블록체인을 유지하기 위한 컴퓨팅 파워를 제공한다는 것이다. 간으하지만, 이러한 기여자가 병원 및 의료 시스템인 경우 네트워크의 총 노드수가 적을 수 있다. 강력한 블록체인은 수많은 독립노드에 의존한다. 또한 현재 데이터 사일로를 통제하는 중앙 당국이 인프라를 책임지고 있으며, 데이터를 안전하게 유지하기 위해 중앙 당국이 아닌 네트워크에 신뢰를 부여해야한다는 것이다. 또다른 사항은 데이터를 저장하는 블록체인 인프라가 최종사용자에게는 아무런 형태로도 보이지 않아야 한다는 것이다. 즉, 블록체인에 데이터를 추가하기위해 많은 시간이 소요 될 경우, 광범위하게 채택되기 어려울 수 있다. 성능은 블록체인 기반 솔루션의 주요 기술적인 고려 사항이다. 구현에 따라 블록체인에서 많은 수의 트랜잭션을 수행하는 것은 시간과 처리 능력 면에서 비쌀 수 있다. 즉, 처음부터 솔루션의 성능과 확장성을 고려해야 한다. ¶결론 최근 몇년 동안 EHR 기술을 급속히 채택했지만, 안전하고 쉽게 환자 의료 정보 데이터를 이전할 수 있는 것에 대해서는 의구심으로 남아 있다. 블록체인 기술은 모든 환자의 의료 데이터를 단일의, 안전하고 분산된 저장소를 제공하여 문제를 해결할 수 있는 잠재력을 지니고 있다. 기존에 의미있게 사용되고 있는 표준을 사용하여 공인된 주체가 환자 데이터 사본을 수신한다. 이러한 접근법을 통해 환자는 자신의 기록에 기여하거나 이를 원하는 모든 환경에 데이터를 보내는 등 의료 데이터를 더 효과적으로 액세스 하고 제어할 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"healthcare","slug":"healthcare","permalink":"https://www.yceffort.kr/tags/healthcare/"}]},{"title":"블록체인을 활용한 안전하고 신뢰할 수 있는 전자 의료 기록 정보 공유","slug":"secure-and-trustable-electronic-medical-records-sharing-using-blockchain","date":"2018-08-08T15:00:00.000Z","updated":"2018-08-09T02:39:01.000Z","comments":true,"path":"2018/08/09/secure-and-trustable-electronic-medical-records-sharing-using-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/08/09/secure-and-trustable-electronic-medical-records-sharing-using-blockchain/","excerpt":"Secure and Trustable Electronic Medical Records Sharing using Blockchain 원문 전자 의료 기록 (EHR, EMR) 은 의료 제공자, 보험 회사, 약국, 연구원, 환자 가족 등에게 의료 진단 및 치료를 목적으로 공유되어야 하는 의료 데이터이지만 동시에 매우 민감한 개인정보다. 여러 개체간에 데이터를 저장하고, 공유하며, 수많은 동의를 통해 액세스 제어를 유지하면 환자의 치료과정이 매우 복잡해진다. 암이나 HIV같은 심각한 질병으로 고통받는 환자는 치료과정과 재활 및 모니터링","text":"Secure and Trustable Electronic Medical Records Sharing using Blockchain 원문 전자 의료 기록 (EHR, EMR) 은 의료 제공자, 보험 회사, 약국, 연구원, 환자 가족 등에게 의료 진단 및 치료를 목적으로 공유되어야 하는 의료 데이터이지만 동시에 매우 민감한 개인정보다. 여러 개체간에 데이터를 저장하고, 공유하며, 수많은 동의를 통해 액세스 제어를 유지하면 환자의 치료과정이 매우 복잡해진다. 암이나 HIV같은 심각한 질병으로 고통받는 환자는 치료과정과 재활 및 모니터링의 기록을 유지해야 한다. 완전한 기록을 볼 수 있는 것은 치료에 결정적인 역할을 할 수 있다. 환자는 치료를 위해 여러 기관을 방문하거나 서로 다른 병원을 오갈 수 있다. 그러나 환자가 연구목적으로 임상데이터를 공유하거나, 병원에서 다른 병원으로 전송해야 하는 경우 어떤 유형의 데이터가 공유될지, 수신자의 정보 및 데이터에 액세스 할 수 잇는 기간을 지정하는 동의서에 서여명해야 한다. 그리고 이는 환자가 다른 도시, 지역, 국가로 이사하고 병원에 대해서 미리 알지 못할 때 조정하기 매우 어렵다. 동의가 제공되더라도 데이터를 전송하는 과정은 시간이 많이 소요된다. 대부분의 ㅇ병원에서 환자 의료 기록을 이메일로 공유하는 것을 고려하지 않는다. Common Well Health Alliance 와 같은 의료 정보 교환을 위한 생태계는, 데이터 형식의 환자 의료 기록이 미국내에서 전국적으로 안전하고 효율적으로, 그리고 정확하게 공유되도록 하는 것을 목표로 한다. 이는 제공자가 환자의 의료 정보에 대한 액세스를 받으면, 환자가 다른 의료 제공자로 부터 독립적인 의견을 받는 것을 보장하기 어렵다. 또한 이러한 생태계는 국가간 데이터 이동에서는 요구사항을 만족하지 못한다. 연구 목적으로 데이터를 수집하기 위해서는 익명성이 수반되어야 한다. 그러나 동일한 환자가 여러 의료기관을 방문하여 데이터가 독립적으로 여러곳에서 생성됐을 경우, 환자의 신원을 추적할 수 있으므로 프라이버시를 위반할 가능성이 있다. 환자의 데이터와 액세스 제어 정책을 중앙 집중식으로 관리하는 것은 단일 실패지점을 만들고 나아가 전체 프레임워크에 병목현상이 일어날 수 있다. 또한 암호화된 데이터를 통해 작업을 수행하거나, 환자의 민감한 정보에 액세스 할 수 있는 완전히 신뢰할 수 있는 주체가 존재해야 한다. 전자의 경우 많은 양의 메모리를 관리해야하므로 병원에 적합하지 못하다. 후자의 경우에는 실제로 실현되기가 굉장히 어렵다. 구글의 건강 지갑의 예는 환자들이 자신의 사생활에 대해 우려하고 있으며, 민감한 데이터가 오용될 수 있는 잠재적인 위험을 알고 있음을 보여준다. 네트워크의 모든 참가자에게서 발생한 액션 (환자 정보 수정, 의사, 새로운 데이터 액세스, 업로드 또는 연구용 공유)에 대한 공유를 불변하고 투명한 기록위에 액세스 하면 이러한 문제를 해결할 수 있다. 블록체인 기술은 단일의 신뢰할 수 있는 당사자에 의존하지 않고, 분산된 개체간에 합의를 달성할 수 있는 도구를 제공함으로써, 데이터 보안을 보장하고 민감한 데이터를 제어하며, 환자 및 의료영역의 다른 행위자에 대한 의료 데이터 관리가 용이해진다. 의료 환경에서 우리는 연결된 peer에서 수행되는 EMR 데이터 생성, 업로드 또는 전송하는 프로세스로 트랜잭션을 정의할 수 있다. 특정시간에 그룹화된 일련의 트랜잭션이 원장에 추가되어 모든 트랜잭션을 기록하므로 네트워크의 상태를 나타낼 수 있다.의료 분야에서 블록체인 기술을 사용한다면, 위/변조에 저항하고 투명성 및 민감한 의료 데이터에 무결성을 보장해 줄 수 있다. 이는 해싱 및 디지털 서명과 같은 합의 프로토콜 및 암호화를 사용하여 달성된다. ¶의료 산업에서 블록체인의 잠재력 ¶시나리오1) 1차 환자 진료 환자는 종종 서로다른 여러개의 병원을 방문한다. 이 모든 데이터의 이력을 유지하고 업데이트도 반영되어야 한다. 그렇지 않으면 원하는 때에 원하는 정보를 이용할 수 없다. 데이터가 제공되지 않아 환자는 실험실 결과에 대한 몇가지 검사를 반복적으로 수행해야 한다. 이는 결과가 다른 병원에 저장되어 액세스 할 수 없는 상황에서 일반적으로 발생한다. 의료 데이터는 민감하고 관리하기 번거롭다. 환자가 효율적으로 액세스 제어 정책을 유지할 수 있게 해주는 개인정보보호시스템이 존재하지 않는다. 서로 다른 의료 서비스 제공자간에 데이터를 공유하려면 큰 수고가 들고 시간도 많이 소요된다. 다음으로, 환자 치료를 개선하기 위해 별도로 시행하거나 결합할 수 있는 두가지 블록체인 활용방안이다. 기관기반: 네트워킄 신뢰할 수 있는 의료기관, 또는 실무자 (간호사) 사이에 형성될 것이다. 피어는 합의 프로토콜을 실행하고 분산 원장을 유지한다. 환자는 응용프로그램을 통해 자신의 데이터에 액세스 하고 관리 할 수 있다. 주요 관리 프로세스와 액세스 제어 쩡책은 블록체인에 인코딩되어 데이터 보안 및 환자의 개인정보를 보호한다. 케이스 기반: 치료, 재활, 검사, 수술을 위해 병원에 입원하는 동안 케이스별로 원장을 만들 수 있다. 네트워크는 의사, 간호사, 가족을 연결하여 치료의 효율성과 투명성을 달성한다. 이는 치료 단계에서 합의를 보장하기 위해 만드는 것으로, 인간이 실수를 저지르는 것을 줄일 수 있다. ¶시나리오2) 연구 목적을 위한 데이터 집계 데이터의 출처가 신뢰할 수 있는 의료기관이므로, 데이터가 확실하다는 것을 보장하는 것이 매우 중요하다. 공유 분산 원장을 사용하면 추적성을 제공하며, 환자의 개인정보보호와 데이터 집계 프로세스의 투명성을 보장한다. 현재 적절한 매커니즘이 부족하기 때문에 환자는 데이터 공유에 망설이고 있다. 연구자, 바이오 뱅크 및 의료 기관 네트워크 내에서 블록체인 기술을 사용하면 연구목적으로 환자의 데이터를 수집하는 과정을 용이하게 할 수 있다. ¶시나리오 3) 환자 치료 개선을 위한 의료 관계자 연결 의료 정보를 연결하면 자원을 극대화 하고 소비자가 간병인과 소통하고 건강 상태의 자세 관리를 개선할 수 있는 기회를 제공하는 것을 목표로 하는 모델이다. 보험회사, 약국과 같은 기관 간 원장을 공유하면, 만성질환관리 같은 환자의 약물 치료 및 비용관리가 용이해진다. 처방전에 대한 정확한 업데이트 된 데이터를 약국에 제공하는 것은 물류를 향상시킬 것이다. 공통된 원장에 접근하면 환자가 처방된 처치를 정확히 따르는지 감시하는 것 부터 치료 및 의약품 비용과 관련하여 보험회사와 의사소통을 용이하게 하는 것에 이르기 까지 모든 처치 과정에 투명성을 부여한다. ¶시나리오 구현 이와 같은 시나리오 구현을 위해 프라이빗 블록체인을 활용해야 한다. 사용자의 익명성 및 계정 소유자의 신원을 확인할 수 없으면, 데이터가 오용될 수 있다. 또한 환자의 데이터는 민감한 성격을 띄고 있으므로, 개인정보 침해의 소지가 있을 수 있다. 환자와 관련된 정보를 업데이트하는 것이 환자에게 중요할 수 있으므로 시스템이 신속하게 응답해야 한다. 그러므로 허가가 필요없는 퍼블릭 블록체인 보다는, 프라이빗 블록체인에서 구현하는 것이 용이하다. ¶방사성 종양학과에서 사용하는 블록체인 어플리케이션: 의료 제공자간의 임상 데이터 공유 시나리오 1을 위한 전자 의료 기록 공유를 지원하는 시스템의 프로토타입 설계 및 구현을 제시한다. ¶1. 유즈케이스 시나리오 암은 장기간 치료와 환자 평생 모니터링이 필요한 심각한 의학적 상태다. 따라서 환자가 의료 병력을 유지하고 치료 및 치료 후 모니커링 중에 의료 데이터에 액세스 하거나 공유할 수 있어야 한다. 환자의 이동성으로 인해 모든 환자의 방문중에 생성된 데이터는 의료정보의 민감한 특성과 결합되어 관리가 어려울 수 있다. 여기에 블록체인 기술을 사용하여 임상데이터 공유 시스템을 만들어 문제를 해결한다. 종양학관련한 정보 및 이미지 관리를 위해 사용중인 ARIA 시스템을 예로 들어본다. 이 프로그램은 방사선, 의학 및 외과 종양 정보를 결합하고 임상의가 다양한 의료 데이터를 관리하고 치료계획을 개발하며 환자의 방사선량을 모니터링 할 수 있도록 돕는다. 이 시스템에 저장된 다양한 유형의 데이터는 임상의의 요청에 따라 구조화되고 PDF 형식으로 보낼 수 있다. 현재 이 데이터를 다른 병원으로 옮겨야 하는 경우 아래와 같은 절차로 이루어진다. 환자는 전송할 데이터를 지정하고 데이터 수신자에 대한 정보를 포함하는 동의서에 서명 인쇄하여 수신자에게 우편으로 전송 이 경우 도으이 관리 및 데이터 전송은 복잡하고 불편해 질 수 있다. 환자는 간병인에게 연락하여 더이상 치료 받지 않는 병원에서 동의서에 서명해야 할 수 있다. 데이터 전송은 시간이 걸리고, 환자의 데이터 사본을 받으면 다시 업로드 해야한다. 그리고 환자가 데이터에 대한 엑셋 제어를 유지하고 데이터를 완전히 보는 것도 어렵다. 블록체인을 활용하여, 이러한 동의 절차를 용이하게 하고 데이터 전송 속도를 높일 수 있다. 환자가 자신의 데이터에 대한 세밀한 접근 제어 정책을 관리하고 임상의들 사이에서 효율적인 데이터 공유를 가능하게 할 수 있다. ¶2. 시스템 아키텍쳐 이 프레임워크는 회원서비스, 의료 데이터 저장을 위한 데이터 베이스, 합의 프로세스를 관리하는 노드, 유저 별 API등으로 구성되어 있다. 현재는 의사와 환자에 초점을 맞추고 있지만, 시나리오에 따라 역할과 기능이 확장될 수 있다. 회원 서비스의 주요 기능은 다른 역할을 가진 사용자를 등록하는 것이다. 여기서 역할이랑 사용자가 사용할 수 있는 기능을 의미한다. 의사로서 사용자를 등록하는 동안에는 사용자가 자격을 갖춘 의사라는 사실을 보장하는 것이 중요하다. 이를 확인하기 위해 의사를 관리하는 서비스 (여기에서는 National Practitioner Data Bank) 와 연동 될 수 있다. 환자는 환자에 해당하는 데이터를 암호화/해독하는데 사용되는 대칭 암호화키를 생성한다. 이 키는 허가받은 사용자만 환자에 대한 정보를 저장하는지 확인할 수 있도록 하는 데 사용된다. 환자가 의사와 데이터를 공유해야 할때 환자는 의사의 암호화 공개키를 사용하여 환자의 암호화키를 공유할 수 있다. 키가 손상되면 새롭게 키를 생성하여 암호화 한다음, 원하는 정책에 따라 새로운 키를 공유할 수 있다. 그 다음 환자의 데이터는 다음 데이터베이스에 오프체인으로 저장된다. 첫째 종양과 관련된 데이터를 저장하는 데이터베이스 관리 시스템. 두번째, 데이터 카테고리에 따라 환자의 데이터를 저장하고 해당 환자 키로 암호화된 클라우드 기바 플랫폼. 등록된 임상의는 환자가 정의하고 체인에 구련된 액세스 제어 정책에 따라 클라우드 저장소의 데이터를 보거나, 업로드 할 수 있다. ¶3. 데이터 구조와 기능 위 그림은 환자의 데이터와 메타데이터가 어떻게 연결되는지 보여준다. 황자의 데이터는 로컬 데이터베이스와 클라우드에서 제시된 범주에 따라서 외부 체인에 저장된다. 이 외부 체인에 저장할 데이터로는 일단 이력과 신체검사, 실험 결과, 노출된 방사선량만 제한 한다. 앞으로 데이터의 민감도와 의미를 기준으로 체인에 저장되는 데이터가 확대될 수 있다. 환자와 관련이 있고 다른 임상의가 업로드한 데이터 파일은 해당 범주에 저장된다. 환자는 선택적으로 개인 공개 데이터 또는 환자 공개키로 암호화시켜 저장할 수 있다. 위 그림은 권한, 임상 메타 데이터, 개인정보 (선택) 블록으로 구성된 환자의 메타 데이터 구조를 나타낸다. 권한 블록은 다음과 같이 구성된다. 모든 권한은 시스템에 등록된 의사와 매칭된다. 그리고 임상의가 특정 데이터 카테고리에 속하는 환자의 데이터를 읽거나, 클라우드 저장소에 업로드하거나, 프레임워크 내에서 환자의 데이터를 공유할 수 있는 기간을 지정한다. 타임 스탬프는 모든 권한을 고유하게 만들어 동일한 의사 ID에 해당하는 액세스 제저 변경 사항을 업데이트하고 추적할 수 있게 한다. 임상 메타 데이터는 다른 임상의가 클라우드에 업로드한 모든 데이터 파일에 대한 정보를 포함하는 블록이다. 메타데이터 항목은 해당 데이터 파일의 의미에 따라서 분류된다. 이 해당 항목에는 임상의 ID, 클라우드에 저장된 파일의 포인터, 경로, 데이터 파일의 해시가 포함되어 있어 클라우드에 저장된 데이터의 위조 가능성을 막고, 이벤트의 타임스탬프를 제공한다. 개인정보 데이터와 마찬가지로 일부 개인 데이터를 추가로 환자에게 저앙할 수 있다. ¶결론 네트워크 전체에서 일어나는 모든 사건을 추적하는 불변의 투명한 원장을 유지하는 것이 의료 데이터 관리를 개선하고 촉진할 수 있다. 나아가 방사선 이미지를 포함하여 환자 기록 및 메타 데이터의 구조가 확장 될 수도 있으며, 이는 훨씬더 도전적인 과제가 될 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"healthcare","slug":"healthcare","permalink":"https://www.yceffort.kr/tags/healthcare/"}]},{"title":"의료 산업에서의 블록체인","slug":"blockchain-technology-applications-in-health-care","date":"2018-08-07T15:00:00.000Z","updated":"2018-08-08T00:01:31.000Z","comments":true,"path":"2018/08/08/blockchain-technology-applications-in-health-care/","link":"","permalink":"https://www.yceffort.kr/2018/08/08/blockchain-technology-applications-in-health-care/","excerpt":"Blockchain Technology Applications in Health Care 원문 ¶블록체인 어플리케이션 분산 데이터 관리를 위한 블록체인은 금융 서비스를 넘어 다양한 응용프로그램에서 사용할 수 있는 잠재력을 가지고 있다. 블록체인은 잠재적으로 많은 가능성을 가지고 있기 때문에, IBM, 마이크로소프트, 액센츄어등 여러 회사가 블록체인 기반 기술을 개발하고 있는 상황이다. 향후 블록체인 소프트웨어가 제공하는 기능으로 5년내에 금융 서비스 산업에 연간 150억에서 200억 달러를 아낄 수 있다는 예측도 나오고 있다.","text":"Blockchain Technology Applications in Health Care 원문 ¶블록체인 어플리케이션 분산 데이터 관리를 위한 블록체인은 금융 서비스를 넘어 다양한 응용프로그램에서 사용할 수 있는 잠재력을 가지고 있다. 블록체인은 잠재적으로 많은 가능성을 가지고 있기 때문에, IBM, 마이크로소프트, 액센츄어등 여러 회사가 블록체인 기반 기술을 개발하고 있는 상황이다. 향후 블록체인 소프트웨어가 제공하는 기능으로 5년내에 금융 서비스 산업에 연간 150억에서 200억 달러를 아낄 수 있다는 예측도 나오고 있다. ¶의료 산업에서 블록체인 이러한 관심과 추진력은 이제 의료 산업 분야로 까지 확대 되었다. 의료 산업에서 블록체인의 잠재적인 관련성과 중요성을 깨달은 미국 ONC (Office of the National Coordinator for Health Information Technology)는 지난 2016년 부터 블록체인의 잠재적인 사용에 관한 백서를 만들기 위하여 아이디어 과제를 마련했다. 이를 바탕으로 블록체인을 바탕으로 한 여러가지 의료 응용 프로그램이 제안되었다. 블록체인 내에 모든 의료 정보를 기록하는 것은, 건강관리의 사용사례로 이용될 수 있지만 개인정보보보에 대한 우려, 규제 요구사항 준수 및 몇가지 잠재적인 장벽이 있는 것으로 확인되었다. 이 때문에 대부분의 단기적인 제안은 데이터 검증, 감사 및 승인에 중점들 두고 있는 상태다. 일례로 네덜란드에 있는 데이터 보안회사인 Gurdtime이라는 회사가 있다. 이 회사는 에스토니아 정부와 제휴하여 환자의 신원을 확인하기 위한 블록체인 기반 프레임워크를 만들었다. 모든 시민들의 자신의 EHR 데이터와 블록체인 기반 신원을 연결하는 스마트 카드를 발급받았다. EHR 정보가 업데이트 되면 해시가 지정되고 블록체인에 등록된다. 이러한 방식은 EHR 데이터에 레코드를 악의적으로 수정할 수없도록 한다. 불변의 타임스탬프 로그는 또한 존재하는 의료 데이터베이스에서 정보의 현재 상태를 확인할 수 있다. 그리고 이는 암호화 서명 된다. 의료기기의 데이터 조작에 대한 우려로 인해 데이터 무결성에 대한 최긘의 관심을 감안하면, 이러한 시스템은 의료 기록의 수정이 안전하다는 것을 보장 할 수 있는 이점이 있다. 두 번째 예로는 IT Media Lab과 Beth Israel Deaconess Medical Center 사이에서 시작된 프로젝트인 MedRec 이 있다. 이 플랫폼은 의료 시스템 간의 허가, 승인 및 데이터 공유를 하는데 있어 분산된 접근 방식을 제공한다. 이 응용 프로그램에서 블록체인을 사용하면 환자는 특정 기관에게 자신의 의료 정보를 액세스 할 수 있는 권한을 부여할 수 있다. 이러한 권한은 블록체인에서 공유되어 실제 의료 데이터가 블록체인에 저장되지 않더라도 임상 및 연구를 위한 데이터 공유가 자동화 될 수 있다. 블록체인에 허가, 데이터 저장 위치, 감사 기록이 유지되면 모든 의료 정보는 EHR시스템으로 유지되며 상호 운용성을 가능하기 위해 추가 소프트웨어가 필요하다. MedRec 프로젝트는 약물데이터를 기초로 테스트 되었고, 이 프로젝트의 범위를 넓히려 하고 있다. PoC에 따르면,종단 연구 데이터에 신속하고 안전한 액세스를 제공하기 위해 블록체인을 사용했고, 그 결과 큰 이익을 얻을 수 있었다. 현재까지 설명된 사용 사례와는 다르게, 현재까지 개발된 소프트웨어, PoC 프로그램이 대부분 블록체인의 대부분 예제는 아직 컨셉 단계에서만 남아 있다. 그 중 하나가 공급망 관리다. 블록체인을 사용하여 모든 프로세스 단계에서 제품 및 구성요소를 추적하는 프로그램을 만들어, 관리를 간소화 하고 효율성을 높일 수 있다. 의료 산업에서는 약물 제조, 판매, 추적 및 처방의 진위성 등에 투명성을 보장하기 위해 개발 될 수 있다. 특히, 의약품 공급망 보안 범 준수를 위해 제품 추척과 제조내역을 제공해야 하는 현재 상황에서 이미 많은 관심을 받고 있다. 거래 합의 처리와 마찬가지로 블록체인은 청구의 자동화 검증에 사용될 가능성이 있으며, 이는 프로세스의 효율성과 보안을 높일 수 있다. 이 소프트웨어에는 암호화된 환자의 식별자, 의료 계획 정보 및 청구 정보를 지불자와 제공자가 공유하는 블록체인 ㅐ에 저장할 수 있다. 이를 통해 실시간 자동 처리, 자격 검증 및 사전 승인이 현실화 될 수 있다. 적절한 허가가 내려진다면, 연구자들은 생물 의학 연구에 사용하기 위해 이러한 데이터의 하위 집합에 액세스 할 수도 있다. ¶블록체인의 기술적인 한계 블록체인 내 데이터는 암호화 할 수 있지만, 전체 데이터에 대해 분산 액세스는 잠재적인 위험이 있을 수 있다. (데이터의 위치는 고정시키고, 데이터 접근 권한만 블록체인에서 처리하면 위험이 있을 수 있다는 뜻) 분산된 시스템의 속도와 확장성 또한 해결되어야 한다. 예로 비트코인 네트워크에서 마이너가 참여하기 위해서는 2016년 말 기준 총 101기가 바이트 상당의 원장 데이터를 다운로드 해야 한다. 그리고 또한 거래 속도는 초당 7회로, 대규모 블록체인 네트워크의 처리량을 제한 하고 있다. 아직 상당한 양의 데이터를 보유하고 있는 플랫폼에서의 비용 효율성이 입증되지 않았다. 하드웨어 , 구현 및 지원 에 대한 총 지출을 평가 하여 이 기술에 대한 투자 수익을 실현할 수 있는지 여부를 결정해야 한다. ¶결론 블록체인 기술은 다양한 의료 분야에서 사용될 수 있는 플랫폼을 제공한다. 설계 및 개발 초기 단계에서는 많은 조직이 의료 데이터 투명성 및 운영 효율성을 높일 수 있는 솔루션을 제안했다. 의료 및 기타 산업 분야에서 이 기술은 여전히 연구 중이며, 아직 이렇다할 응용 프로그램이 나온 것이 아니다. 그러나 블록체인 기술의 확장성, 보안 및 비용 효율성은 대규모 생산 배치 이전에 추가로 연구가 필요하다. 중개자를 제거하는 이러한 분산 시스템은 의료 분야 연구에서 현재의 프로세스에 혼란을 가중시킬 상당한 잠재력을 지니고 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"healthcare","slug":"healthcare","permalink":"https://www.yceffort.kr/tags/healthcare/"}]},{"title":"의료 서비스 공급망 관리 향상을 위한 블록체인 기술 활용","slug":"blockchain-health-supply-chain","date":"2018-08-06T15:00:00.000Z","updated":"2018-08-07T01:01:33.000Z","comments":true,"path":"2018/08/07/blockchain-health-supply-chain/","link":"","permalink":"https://www.yceffort.kr/2018/08/07/blockchain-health-supply-chain/","excerpt":"Leveraging Blockchain Technology to Enhance Supply Chain Management in Healthcare: An Exploration of Challenges and Opportunities in the Health Supply Chain 원문 ¶Pharma-chain, 의약품 공급망을 위한 블록체인? 표준 기준 이하의 의약품과 가짜 의약품은 의약품 공급망에 대한 위협이다. 이러한 것들은 위조약 이라고 불리지만, 종종 다른 법적인 의미를 지닌다. 종합적으로 볼때, 이러한 서로 다른 형태의","text":"Leveraging Blockchain Technology to Enhance Supply Chain Management in Healthcare: An Exploration of Challenges and Opportunities in the Health Supply Chain 원문 ¶Pharma-chain, 의약품 공급망을 위한 블록체인? 표준 기준 이하의 의약품과 가짜 의약품은 의약품 공급망에 대한 위협이다. 이러한 것들은 위조약 이라고 불리지만, 종종 다른 법적인 의미를 지닌다. 종합적으로 볼때, 이러한 서로 다른 형태의 가짜 의약품들은 지역 내에서 승인, 불량 제조 관행, 부적절한 보관, 표준 이하의 약 수입, 마약 및 절도를 통한 그레이 마켓 침투하는 등의 결과로 나타날 수도 있다. WHO는 이 같은 시장을 연간 750억 달러로 추정하고 있지만, 추정치는 최대 2000억 달러다. 제약 공급망 및 의료 시스템은 특히 베트남과 같은 국가에서 취약하다. 베트남과 같은 국가는 대다수 마약이 수입되어 들어온다. 그러나 이러한 공급망의 취약성은 저소득층 시장이나 마약 수입에 크게 의존하는 시장ㅇ만 국한되는 것이 아니다. 얘를 들어, 2012년 FDA는 가짜 항암제를 구입하고 관리할 가능성이 있는 48개 주 1000개의 의료시설에 해당 사실을 통보한 바 있다. 미국에서 이러한 위협에 대해서 약물 공급망 보안법 (DSCSA)을 입법하면 서 대응했다. 지난 10년 동안 DSCSA는 의약 품 추적, 의심스러운 제픔 검증, 약품 도매 업체 라이센스 및 보고에 대한 엄격한 지침을 제공했다. 미국 이외의 지역 EU에서는 위조 의약품 지침과 유럽의 MEDICRIME 협약, 그리고 여러 국가의 현지 위조 방지법 등과 관련된 노력이 진행 중이다. 과연 제약 제품 제조, 유통, 분배를 위한 공급망 관리를 확보하고 최적화 하는데 블록체인이 필요할까? 블록체인 기술은 기존 공급망 및 반 위조 시스템 및 데이터베이스보다 더 개선 될 수 있는가? 중앙 집중식 데이터베이스 및 레거시 시스템에서 사용할 수 없는 기능이나 프로세스를 제공하는가? 블록체인이 기존 공급망 데이터와 어떻게 상호작용할 수 있는가? 마지막으로, 위험을 완화할 수 있는 솔루션을 제공하면서 제조업체와 소비자 모두에게 도움이 될 수 있는 환자의 안전을 보장할 수 있는가? 이러한 질문에 대한 답변은 블록체인 설계 및 실행 가능성 연구에 대한 초기 평가의 기초가 되어야하며, 다양한 관할 구역에서 공급망이 직면한 다양한 도전과제의 맥락에 기초하여 현지화 해야 한다. DCSCSA의 예를 통해, 각 규제 구성요소는 블록체인이 실행가능한 솔루션이 되기 위해 올바르게 매핑되어야 한다. 주요 요구 사항 블록체인 적용 가능성 제품 식별 사이드 체인을 활용하여 제공된 제품의 고유한 제품 식별자를 확인할 수 있다. 제품 추적 제조업체, 유통 업체가 중요한 정보를 자동으로 확인하여 공유 원장의 추적정보를 알 수 있다. 제품 인증 개방형 솔루션을 만들어 제품 식별자 및 기타 정보를 제공한다. 탐지 및 응답 위조, 승인되지 않거나 위험한 것으로 의심되는 약물을 보고하고 탐지할 수 있다. 통지 불법약물이 발견되면 FDA 및 기타 이해 관계자에게 통보되는 공유 시스템을 만들 수 있다. 정보 요구 라이센스 정보의 확인을 포함하여 제품 및 트랜잭션 정보의 공유 원장을 작성할 수 있다. 몇몇 조직은 블록체인 솔루션을 개발하여 제약 공급망 관리를 위한 블록 체인 사용을 적극적으로 탐구하고 있다. 이러한 것을 선도하는 것은 공급망 관리연구센터다. https://www.c4scs.org/ 이 비영리 단체는 제약 공급망 전체의 다양한 이해 관계자가 참여하여 파일럿 연구를 통해 블록체인의 타당성을 연구하고 있다. 또한 DSCSA 및 블록체인 호환성을 시뮬레이션 하는데 지속적으로 연구하고 있다. 또한 IEEE와 같은 단체는 워크샵 등을 통해 현재 블록체인기술과 기존 레거시 시스템 간의 상호 운용성을 탐구하기 위해 공급망, 임상 시험 산업 연결 프로그램을 운영하고 있다. 이는 제약 공급 및 임상시험 분야에서 환자의 안전을 향상시킨다. 동시에 많은 기업들이 이와 같은 목표를 향해 노력하고 있으며 사용사례 개발, 제조업체와의 프로젝트 연구, 다른 산업에서 의약품 및 의료용도에 사용되는 블록체인 모델 확장 등 다양한 관점에서 작업하고 있다. ¶의약품 공급망 블록체인을 넘어서: 의료산업에서의 블록체인에 대한 가능성 제약 및 의약품 공급망을 넘어서 블록체인 응용 프로그램은 다른 의료 산업, 특히 기술 중심적이고 규제가 많은 분야에서 성숙하기 시작했다. 임상시험 이해 관계자, 의료 기록 및 데이터 관리제공 업체, 제약 공급망 등에서 블록체인 채택이 논의되고 있다. ¶의료 기기 및 의료 공급 분야 최근 이식 가능한 심장박동기를 가진 50만명 가량의 환자가 해커의 잠재적인 장치 조작에 노출되는 보안 결함으로 인해 중요한 펌웨어 업데이트의 필요성이 대두되었다. 또한 허가 받지 않는 사용자가 환자의 복용량을 변경하기 위해 병원 네트워크에 액세스 하고 제어 할 수 있다는 사실도 과거 밝혀진 바 있다. 디지털로 연결되고 지원되는 의료기기의 사용이 더욱 보급됨에 다라서, 그들의 취약성 뿐만 아니라 적절한 사용성에 대한 논란이 두드러지고 있다. FDA와 EU가 의료기기에 고유 장치 식별자 (UDI)를 장착해야 한다는 요구에 부응하여, 블록체인은 비용을 줄이고 환자의 안전을 개선하며 신뢰에 대한 효율성과, 의료기기 위조에 대처할 수 있는 잠재력을 가지고 있다. 블록체인을 사용하면 자동화된 스마트 컨트랙트를 통해 장치의 예방적 유지보수를 향상 시킬 수 있다. 스코틀랜드에서는 현재 블록체인 기술을 활용해 의료기기 공급망에 도움을 주려는 노력이 진행 중이다. 블록체인 활용은 또한 향상된 공급망 관리 및 상호 연결된 임상 공동체를 통해 치료의 가치를 향상 시키고 비용을 절감할 수도 있다. 존스 홉킨스 의학대는 최근 척수, 관절, 혈액 관리에 초점을 맞춘 공급망 이니셔티블르 만들었다. ¶의료용 사물 인터넷 의료용 사물 인터넷은 의료에 초점을 맞춘 사물인터넷이다. 여기에는 활동, 수면, 심장, 질병에 관한 조건을 탐지하는 웨어러블, 센서, 독립형 장치가 포함된다. 이 분야의 취약성은 기존 의료기기에서 볼 수 있는 취약성과 비슷하고, 나아가 데이터 보안 시스템에 대한 더 큰 위협이 있다. 여러 IOT 이해 관계자가 구성한 Trusted IoT Alliance https://www.trusted-iot.org/는 차세대 IoT 제품의 연결 및 보안을 위한 블록체인을 중심으로 표준 설계 및 장애물 극복을 노력하고 있다. 이러한 의료용 사물 인터넷의 최초 시도는 Bowhead Health가 있을 것이다. 의료 데이터와 습관에 대해 환자가 입력하면, 익명의 건강 토큰 (AHT)를 지급 받게 된다. 이와 비슷한 일을 하는 곳으로 BurstIQ, Healthcoin, ScriptDrop, Solaster 등이 있다. 일단 초기 모델에서 성공을 거두면, 이를 다양한 의료기기로 확대할 수도 있을 것이다. ¶공공 보건 공공 보건의 공급망 과제에는 비상 사태시 의료 종사자 보호를 위한 보호물품 공급 및 필수약물, 백신 예방 접종에 대한 접근 과 재난 및 비상 관리가 포함되어 있다. 필수 의약품 접근의 맥락에서 블록체인은 솔루션은 의약품 공급망 사용사례와 비슷한 면이 있지만, 의약품 및 의료 서비스의 효과적인 전달 및 대외 원조와 자선을 더 잘 실현하고 보건 시장에서 사기와 부패를 줄일 수 있는 수단으로 사용될 수 있는 암호화폐 또한 연구되고 있다. ¶결론 공급망 관리를 향상 시키기 위한 블록체인의 장점은 아래와 같다. 사기와 오류 방지 서류 작업 지연 감소 재고관리 개선 문제를 신속하게 식별 이전 비용 최소화 소비자와 파트너 신뢰의 증가 그러나 이러한 잠재적인 이익을 의료 공급망에서 확대하는 것은 아직 섣부른 판단이다. 앞으로 환자의 안전 및 의료 결과에 대한 실제 영향에 대해 엄격하게 평가할 수 있는 솔루션에 대한 더 큰 연구와 투자가 필요하다. 물론 보건 분야에서도 수많은 사용 사례가 나타날 수 있다. 블록체인 공급망이 제공할 수 있는 특정 이점을 보여주는 두가지 추가적인 예로는 약물 리콜 관리 및 처방 약물 남용이다. 스마트 컨트랙트를 활용하여 프로세스를 자동화하고 비용을 절감할 수 있는 능력은 블록 체인 기술이 공급망 성능 향상을 달성하는데 도움이 될 수 있는 메커니즘이기도 하다. 마찬가지로 HIPAA (미국 건강 보험 양도 및 책임에 관한 법 Health Insurance Portability and Accountability Act)과 EU의 데이터 보호규정 (GDPR)과 같은 정책 프레임워크를 준수할 필요성이 있으므로 의료 부문 고유의 개인정보 보호및 데이터 보호 고려 사항을 해결해야할 필요성이 있다. 의료 공급망에 대한 블록체인의 노력이 현재 PoC나 시범단계에 머물러 있지만, 의료 부문에 채택할 수 있고 국가 정부가 제공하는 정책 인센티브를 바탕으로 현지화 될 수 있는 다른 산업 부문 전반에 걸쳐 배치되는 방안이 논의 중이다. 의료 공급망 에 대한 가능성과 기회는 많지만, 규제가 엄격하고 복잡한 의료분야에 블록체인 기술이 제공하는 모든 가능성을 최대로 활용할 수 있는지는 두고 볼 일이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"healthcare","slug":"healthcare","permalink":"https://www.yceffort.kr/tags/healthcare/"}]},{"title":"의료산업을 바꿀 수 있는 의료용 블록체인","slug":"healthcare-blockchain-leads-to-transform-healthcare-industry","date":"2018-08-06T15:00:00.000Z","updated":"2018-08-07T01:01:33.000Z","comments":true,"path":"2018/08/07/healthcare-blockchain-leads-to-transform-healthcare-industry/","link":"","permalink":"https://www.yceffort.kr/2018/08/07/healthcare-blockchain-leads-to-transform-healthcare-industry/","excerpt":"Healthcare Blockchain leads to Transform Healthcare Industry 원문 ¶1. 병원간 네트워크 병원은 분산된 원장 네트워크를 사용하여 다른 병원과 연결할 수 있다. 정보와 데이터는 블록에 저장된다. 요즘의 시나리오에 따르면, 병원 간의 건강기록과 운영은 서로 얽혀 있다. 블록체인을 통해 개별 사용자에 대한 레코드를 저장하는 전국적인 공통 플랫폼을 만들 수 있다. 블록체인은 서로 다른 당사자들 간의 정보 공유라는, 신뢰가 필요없고 협력적인 생태계를 제공할 것이다. * 병원들은 정보를","text":"Healthcare Blockchain leads to Transform Healthcare Industry 원문 ¶1. 병원간 네트워크 병원은 분산된 원장 네트워크를 사용하여 다른 병원과 연결할 수 있다. 정보와 데이터는 블록에 저장된다. 요즘의 시나리오에 따르면, 병원 간의 건강기록과 운영은 서로 얽혀 있다. 블록체인을 통해 개별 사용자에 대한 레코드를 저장하는 전국적인 공통 플랫폼을 만들 수 있다. 블록체인은 서로 다른 당사자들 간의 정보 공유라는, 신뢰가 필요없고 협력적인 생태계를 제공할 것이다. 병원들은 정보를 블록체인에 저장할 수 있다. 트랜잭션은 고유하게 식별되고 블록에 저장된다. 병원들은 블록에 직접 질의를 할 수 있다. 환자는 자신의 신원을 공유할 수 있다. ¶2. 혈액 은행간 네트워크 분산 원장 네트워크를 통해서 서로 다른 혈액은행간에서도 연결 할 수 있다. 정보와 데이터를 블록에 저장한다. 이를 바탕으로 혈액은행은 혈액을 효율적으로 조절할 수 있다. 잉여 혈액은 혈액이 가장 부족한 은행으로 쉽게 은행할 수 있으며, 기증자와 수혜자를 쉽게 관리할 수 있다. 혈액은행은 실시간으로 블록체인에 질의를 던저 혈액의 상황을 알 수 있다. 기증자와 환자 모두 블록체인 시스템에 로그인 후 고유한 아이디값을 가지고 블록체인에 질의할 수 있다. ¶3. 실험실 간 네트워크 실험실 간에 분산 네트워크를 통하여 블록체인 기술에 연결할 수 있다. 의료 실험실 기록은 개인 블록체인에 저장되므로, 실험실 기록은 블록의 형태로 분산 원장에 유지된다. 사용자는 고유 식별번호를 사용하여 보고서를 볼수 있다. ¶4. 약국간 네트워크 약사와 화확연구자 사이에 블록체인 기술을 사용하여 연결할 수 있다. 블록체인 기술은 제조업체, 도매업체, 약사 및 환자간의 거래가 분산원장으로 유지되므로 약물을 추적할 수 있게 된다. ¶5. 보험 파트너 네트워크 보험 회사는 블록체인 네트워크에 연결 될 수 있으므로, 의료보험과 관련된 사기를 예방할 수 있다. ¶의료 블록체인의 형태 의료 블록체인과 데이터분석, 인공지능, 기계학습은 의료기술의 새로운 문을 열 수 있다. 개인이 건강기록을 효율적으로 유지할 수 있도록 도와주며, 기록의 사본을 가지고 다닐 필요가 없다. 약국은 매우 효율적인 공급망 관리를 할 수 있게 된다. 의사들은 그들의 환자를 빠르고 효율적으로 분석할 수 있다. 실시간 데이터 모니터링을 통해 사고를 방지하고 병원 기관 및 조직 데이터를 효과적으로 관리할 수 있게 된다. 아래 그림에서 볼 수 있듯, 블록체인은 모든 정보를 저장할 것이다. ¶헬스케어 블록체인의 구조 UI, API, Business Logic, 신원 관리, 데이터, 블록체인 네트워크 를 포함하여 총 6개의 레벨로 아키텍쳐를 나눠볼 수 있다. 아래 그림에서 보듯, 상호 레이어간에는 느슨한 결합이 유지된다. 이 아키텍처는 다른 블록체인 네트워크에 적용할 수 있을 정도로 유연하게 되어야 한다. 이더리움, Hyperledger, Hydrachain, Multichain등 여러 프로토콜에 연결할 수 있다. 아키텍처는 모든 데이터 저장소에 연결할 수 있는 가능성을 가지고 있다. 네트워크 전체의 사용자 및 시스템은 키를 기반으로 인증을 하게 된다. 블록체인 네트워크는 나머지 API가 관리할 것이다. ¶구현 상의 도전 블록체인은 의료영역에서 기존의 많은 문제를 제거 할 수 있지만, 완전히 성숙하지 못했으며 큰 범위에서 직접 구현하기란 어렵다. 또한 의료 블록체인을 구현하기 전에 제도적 &amp; 조직적 문제를 해결해야 한다. ¶결론 블록체인은 의료 정보 생태계를 변화시키는데 중요한 역할을 할수 있다. 블록체인은 데이터 분석 및 인공지능과 함께 Web 3.0 생태계를 만들 수 있다. 우리는 이러한 분야를 연결하고 표준화하여 시스템을 성숙시켜야 한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"healthcare","slug":"healthcare","permalink":"https://www.yceffort.kr/tags/healthcare/"}]},{"title":"미국 블록체인 프로젝트 90%는 운영되지 못할 것","slug":"blockchain-suffers-slow-down","date":"2018-08-05T15:00:00.000Z","updated":"2018-08-06T01:01:33.000Z","comments":true,"path":"2018/08/06/blockchain-suffers-slow-down/","link":"","permalink":"https://www.yceffort.kr/2018/08/06/blockchain-suffers-slow-down/","excerpt":"Blockchain, Once Seen as a Corporate Cure-All, Suffers Slowdown 원문 포레스트 리서치에 따르면 올해 분산 원장 기술을 기반으로 한 많은 소프트웨어 프로젝트가 중단 될 것이라고 내다보았다. (원문을 보고 싶었지만 500달러나 했다. ㅠㅠ 참고) 일부 회사에서는 파일럿 테스트 하고 있으며, 기존의 야망과 타임라인을 축소하고 있다. 90% 가량의 프로젝트가 기업의 운영에 포함되지 못할 것으로 내다보았다. 블록체인과 암호통화를 잘 아는 나스닥 조차도 기대만큼 빨리 움직이지 않았다. 2","text":"Blockchain, Once Seen as a Corporate Cure-All, Suffers Slowdown 원문 포레스트 리서치에 따르면 올해 분산 원장 기술을 기반으로 한 많은 소프트웨어 프로젝트가 중단 될 것이라고 내다보았다. (원문을 보고 싶었지만 500달러나 했다. ㅠㅠ 참고) 일부 회사에서는 파일럿 테스트 하고 있으며, 기존의 야망과 타임라인을 축소하고 있다. 90% 가량의 프로젝트가 기업의 운영에 포함되지 못할 것으로 내다보았다. 블록체인과 암호통화를 잘 아는 나스닥 조차도 기대만큼 빨리 움직이지 않았다. 2016년 주주통회와 민간 기업 주식 발행에 블록체인을 배치하는 것을 논의 했지만, 아직 까지도 이 기술을 사용하지 못하고 있다. 이 와 관련하여 나스닥의 수석 부사장 겸 시장 기술 제품 관리자는 인터뷰에서 ‘신기술을 도입하려면 업계 참가자들과 광범위한 협력이 많이 필요하며, 시간이 많이 소요된다’ 라고 이야기 했다. ¶블록체인에 베팅 출처: WinterGreen Research Inc. 올초 리포트 지금까지 IBM과 마이크로소프트는 전ㅊ체 블록체인 지출의 절반이상을 차지해왔다. 블록체인은 변조 방지 디지털 원장을 제공하기 위하여 고안되었다. 그러나 이 기술은 실제 상황에서 채택하기가 어려운 것으로 입증된 경우가 더 많다. ¶과대광고와 현실 사이 블록체인을 연구하는 1500명 이상의 연구원을 보유한 IBM은 여전히 많은 수요를 내다보았다. 마이크로소프트도 낙관적인 모습을 유지하고 있다. 지금까지 두 회사는 51억달러가 넘는 블록체인 제품 및 서비스 관련 시장의 51%를 점유했다. 그러나 많은 기업들에게 블록체인은 아직까지 이국적인 과일로 남아있다. 가트너의 연구에 따르면, 전체 CEO 중 1% 만이 조직에서 블록체인을 채택했다고 말했고, 8%만이 단기 계획이나 기술에 대한 적극적인 연구를 하고 있다고 응답했다. 그러나 80% 가량은 아직 이 기술에 관심이 없다고 말했다. ¶No Delay 이전에 블록체인에 대한 롤아웃을 발표한 많은 회사들이 계획을 변경했다. 호주의 국가 증권 거래소를 운영하는 한 회사는 2020년 말 2021년 총 블록체인 기반 청산 및 결제 시스템을 보유할 것으로 예상된다. 2년전, 이 회사는 18개월 이내에 상업용 블록체인 플랫폼을 출시하는 것을 목표로 하고 있었다. 하지만 최근까지 정확한 출시일을 발표하지 않았기 때문에 지연이 없었다고 대변인은 말했다. 호주의 한 거대 광업회사는, 2016년에 암석과 샘플을 추적하기 위해 2017년 초까지 블록체인 플랫폼을 배치할 것이라고 밝혔지만, 현재는 ‘어떤 블록체인 프로젝트나 실험도 진행중이지 않다’ 고 밝혔다. 하지만 블록체인 지원 단체들에 따르면, 내년에는 더 많은 사례를 볼 수 있을 것이라고 내다보았다. 시스코, 인텔, JP 모건 등 600여명의 회원으로 이루어진 Enterprise Ethereum Alliance에서는 올해 많은 일이 일어날 것으로 기대하고 있다고 언급하기도 했다. ¶표준 추구 지연이 일어나는 이유 중 하나는, 대부분의 블록체인 공급업체가 호환되는 소프트웨어를 제공하지 않든 다는 것에 있다. 기업들은 하나의 벤더만 존재하는 상황에 대해 우려 하고 있다. 그리고 이는 앞선 EEA에서 블록체인과 관련한 표준을 제정해 해결하고자 하는 문제다. EEA에서는 2019년 중반에 블록체인 소프트웨어 인증 테스트 프로그램을 시작할 것이라고 말했다. 라이벌 격인 HyperLedger에서도 Kubernotes라고 불리우는 블록체인 소프트웨어를 연결할 수 있는 플랫폼을 준비 중이다. 대부분의 블록체인은 아직 대규모 거래를 처리 할 수 없다. 그리고 특정 유형의 사례에서만 빛을 발한다. 그러나 다른 기업들이 동일한 블록체인을 공유해야하기 때문에, 기술과 그것을 채택하는 방법에 대한 동의를 하는 것이 어려울 수 있다. 그리고 많은 회사들이 새로운 기술을 처음 도입하는 것에 대해 걱정하고 있다. Hyperlegdger의 Excutive director는 이렇게 얘기했다. “사람들은 누군가 먼저 실패하는 것을 보고 싶어 한다. 먼저 매를 맞고 싶어 하지 않는다, 그리고 이는 단지 기업용 소프트웨어의 속성일 뿐이다”","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"중앙은행의 디지털화폐와 암호화폐","slug":"central-bank-electronic-money-and-cryptocurrency","date":"2018-08-02T15:00:00.000Z","updated":"2018-08-03T01:01:33.000Z","comments":true,"path":"2018/08/03/central-bank-electronic-money-and-cryptocurrency/","link":"","permalink":"https://www.yceffort.kr/2018/08/03/central-bank-electronic-money-and-cryptocurrency/","excerpt":"The Case for Central Bank Electronic Money and the Non-case for Central Bank Cryptocurrencies 원문 비트코인은 여러 기술 요소들을 연결하여 가치가 경쟁적인 환경하에서 발행되고, 가상화된 형태와 분산된 거래를 모두 가지고 있다고 이야기 된 바 있다. 이와 같은 방식으로, 비트코인 시스템은 상품, 현금, 전자화폐와는 다른 상당히 다른 형태의 돈을 만들어 냈다. ¶1. 인트로 비트코인의 독특한 특성을 이해하기 위해서는, 위 그림에서 나타난 것 처럼 그 통제","text":"The Case for Central Bank Electronic Money and the Non-case for Central Bank Cryptocurrencies 원문 비트코인은 여러 기술 요소들을 연결하여 가치가 경쟁적인 환경하에서 발행되고, 가상화된 형태와 분산된 거래를 모두 가지고 있다고 이야기 된 바 있다. 이와 같은 방식으로, 비트코인 시스템은 상품, 현금, 전자화폐와는 다른 상당히 다른 형태의 돈을 만들어 냈다. ¶1. 인트로 비트코인의 독특한 특성을 이해하기 위해서는, 위 그림에서 나타난 것 처럼 그 통제 구조에 따라 돈을 각각 특성화 하는 것이 유용하다. 첫번째 디멘션은 표현방식이다. 돈은 가상형태나 물리적인 형태로 표현될 수 있다. 두번째 디멘션은 처리방식이다. 돈은 중앙집중식 또는 분산형 지불 시스템에서 처리 될 수 있다. 세번째 디멘션은 발행이다. 일부 돈은 독점 하에서 만들어지며, 다른 돈은 경쟁하에서 만들어진다. 현금은 물리적인 대상, 일반적으로 동전이나 지폐로 표시되며 그 값은 대상과 분리될 수 없음을 의미한다. 현금 단위 소유자는 자동으로 해당 가치의 소유자가 된다. 결과적으로 경제에서 자유롭게 순솬하는 현금 단위에 대한 소유권은 항상 기록할 필요가 없이 명확하게 정의된다. 그 기능을 사용하면 제 3자의 개입없이 현금이 주 당사자 간에 바로 바꿀 수 있는 분산 지불 시스템을 사용할 수 있다. 대부분의 국가에서 중앙 은행 또는 재무부가 현금 발행을 독점적으로 주도한다. 금과 같은 상품은 물리적인 대상으로 표현된다. 현재 단위의 보유자는 기본적으로 가치 단위의 소유권이 할당되어 있어 지불수단으로 사용하기 위해 기록 관리가 필요하지 않다. 금은 금을 채굴하는 사업으로 진입할 수 있기 때문에 경쟁적인 창조과정을 가져 현금과 다른 성격을 띈다. 상업은행의 예금은 일종의 ‘가상의 돈’ 이다. 가상의 돈에는 물리적인 표현이 없다. 이는 회계 시스템의 기록으로만 존재한다. 지불이 이루어지면 구매자의 지불 금액을 공제하고 판매자에게 보냄으로써 계좌가 조정된다. 대부분의 국가에서 가정과 회사는 전자 지불을 위해 상업용 은행 예금을 사용한다. 지불을 하는데는 여러 방법이 있다. 일반적인 것은 싱요카드, 직불카드, 수표 및 온라인 뱅킹이다. 상업은행은 예금을 놓고 경쟁하게 된다. 은행은 기록을 보관할 책임이 있으므로 구매자와 판매자 간 거래는 상업은행이나 여러 상업은행이 각각의 계좌를 업데이트 하도록 요구한다. 이러한 이유로 상업은행 예끔은 중앙 집중식 지불 시스템에서 거래된다. 비트코인은 분산된 네트워크에서 다양한 통화 단위에 대한 소유권을 관리하는 최초의 가상화폐다. 중앙 관리체계는 없지만, 여전히 잘 작동하고 있다. 비트코인 블록체인은 분산된 회계 시스템이며, 소위 마이너들이 회계사 역할을 하고 있다. 디지털 자산의 분산관리가 근본적인 혁신이다. 현재 지불 인프라와 금융 시스템에 혼란을 가져올 수 있는 가능성이 있다. 일반적으로 기록을 보관하는 모든 기업, 정부 기관에 영향을 줄 수 있다. 암호 화폐의 특별한 특징은 가상 화폐의 거래상 이점과 거래 처리의 체계적인 독립성을 결합한다는 것이다. 금과 마찬가지로, 새로운 비트코인 단위의 생성은 경쟁력이 있다. 누구나 각 소프트웨어를 다운로드하고 시스템에 기여함으로써 새로운 비트코인을 만들 수 있다. 그러나 실제로는 몇 몇 마이너들이 채광 과정을 지배한다. 경쟁이 치열해졌고, 고도로 전문화된 하드웨어를 갖춘 대규모 마이닝 풀과 저렴한 전기료를 가지고 있는 사람만이 마이닝에서 이익을 얻을 수 있기 때문이다. ¶2. 중앙은행의 디지털화폐 돈의 형태에는 장단이 있다. 이것이 많은 형태로 돈이 존재하는 이유다. 현금은 사용자를 익명으로 만들어주고, 현금 지불 시스템에 대한 허가받지 않는 액세스를 할 수 있다는 장점이 있다. 특히 사용자들은 현금을 사용하기 위해 은행계좌를 열 필요가 없다. 또한 현금거래의 분산된 특성으로 인해 현금 지불 시스템이 매우 견고해진다. 지불 인프라를 공격하여 파괴할 수도 없고, 사람들의 참여 전제 조건을 만들 필요도 없다. 반면 중앙집중형 지불 시스템은 취약하다. 이 프로세스가 공격당하면, 전체 시스템이 정지할 수 있다. 현금의 또다른 이점 중 하나는 신용관계다. 모든 빚은 즉시 해결된다. 따라서 위험이 없으며, 거래는 최종적이고 사람들은 서로를 신뢰하지 않아도 거래에 참여할 수 있다. 반면 오늘날 전자 화폐 (상업은행이 발행한 예금)은 상대적으로 위험을 수반한다. 상업은행 예금은 물리적 통화단위(현금)에 대한 청구 원장 기반의 가상화폐이다. 이는 단순히 은행 예금이 발행자의 책임이며, 은행예금을 보유한 은행 고객이 각 은행에 신용을 제공하고 있음을 의미한다. 현금은 구매자와 판매자가 동일한 위치에 물리적으로 있어야 한다는 단점이 있어 온라인 상거래에 실용적이지 못하다. 그러나 상업 은행 예금과 같은 가상 돈은 물리적으로 분리된 사용자간의 지불이 가능하다는 것이다. 따라서 가상화폐는 새로운 비즈니스 기회를 가능하게 한다. 현금은 또한 개인 금융 시스템 외부에서 저축이 가능한 유일한 유동자산이다. 유동성이란 상품과 서비스로 직접 교환할 수 있는 자산을 의미한다. 예를들어, 금은 개인 금융 시스템 외부에서 저축할 수 있는 수단이지만, 상품과 서비스에 직접 교환할 수 없으므로(대부분의 경우) 유동성이 있다고 말할 수 없다. 개인 금융 시스템 외부에서 저축하는데 사용할 수 있는 신뢰할 수 있는 당사자가 발급한 가상자산에 대한 큰 수요가 있다고 생각한다. 이 주장을 뒷받침 하기 위해 1980년 부터 2017년 까지 GDP의 일부분으로 유통중인 스위스 프랑(현금)의 1980~2017년 데이터를 추적했다. 1980~1995년 사이에는 금융혁신으로 인해 현금 대신 거래를 위해 다른 수단을 사용하기 시작했다. 스위스 국민들은 지불을 위해 직불카드와 신용카드를 사용하기 시작했다. 두번째 단계에서는, 1995~2008년에는 카드 결제와 온라인 뱅킹이 더욱 확대되었지만 현금 사용은 더 줄어들지 않았다. 2008년부터 2017년 까지, 유통되는 현금이 급증하기 시작했다. 이 증가의 이유중 하나는 아마 금융위기와 유로의 위기에서 비롯되었을 것이라 믿는다. 2007~8년 사이 금융붕괴와 유로화의 위기는 중앙 은행의 대규모 개입을 야기했고, 많은 국가에서 부채대비 GDP 비율을 급격히 증가시켰다. 이러한 사건은 금융 시스템에 대한 신뢰, 최후의 대출기관으로서 기능하는 중앙은행의 능력, 그리고 강제 징수세와 같은 대대적인 조치에 의지하지 않고 다른 재정적인 위기를 방지할 수 있는 정부의 능력을 약화시켰다. 2008년 이후, 현금 수요는 상대적으로 위험에 직면하지 않고 스위스 프랑을 보유할 수 있는 유일한 수요 수단이었기 때문에 수요가 급속히 증가했다. 현금은 금융 기관의 파산에 대한 보험으로 사용되었다. 예를 들어 금융 위기 때 스위스의 가장 큰 은해인 UBS는 정부와 스위스 국립 은행에 의해 구제되어야 했다. 우리는 중앙 은행의 돈이 전자 형태로 부각될 수 있다고 믿으며, 구현 또한 쉬울 것이다. 중앙 은행은 가계와 회사가 계좌를 개설할 수 있도록 허용해야 하므로, 상업은행예금 대신 중앙 은행 전자 화폐로 지불 할 수 있다. 앞서 설명했듯, 중앙은행의 전자화폐는 상대적으로 위험에 직면하지 않고도 가상화폐를 필요로 하는 인구를 만족 시킬 수 있고, 추가적인 혜택도 있을 수 있다. ¶현금은 장점이 많지만 그 끝이 가까워 질 수도 있다. 현금 사용이 감소하는 정치적, 기술적인 이유가 있다. 현금은 정치가들과 경제학자들에 의해 비난 받고 있다. 현금 비평가들의 주요 주정은 아래와 같다. 전자 지불 보다 비효율적이며 비싸다 범죄를 조장하고 돈세탁과 탈세를 촉진한다 중앙은행이 명목 이자율을 마이너스로 하는 정책을 제한함으로써 (Zero Lower Bound) 통화정책을 방해한다. 기술적인 이유도 있다. 가가운 장래에 현금을 대신할 무언가가 개발되어 현금을 지불수단에서 몰아낼 것이다. 이러한 경쟁자느 비트코인 또는 또다른 암호 통화다. 암호통화에는 여전히 높은 지불 비용, 스케일링 문제 등이 산재하고 있지만, 대규모 오프체인 지불 네트워크 및 기타 스케일링 솔루션의 출현으로 이러한 문제가 빠르게 사라질 수 있다. 정치적인 이유로 현금을 사용하는 것이 제한되거나 기술 혁신으로 인해 사라지면, 가계와 회사는 법적 통화에 접근할 수 없는 다소 이상한 상황이 발생한다. 오늘날 대부분의 국가에서는 현금을 법적통화로 사용함으로써 지불 할 수 있다. 현금이 없어지면, 거래계좌를 중앙은행에서 쩨공함으로써 일반 대중이 직접 법정통화를 전자 형태로 소유할 수 있게 해준다. 그렇게되면 인구의 대부분이 현금을 대체할 수 있다고 생각할 것이고, 이는 현금과 작별하기 더 쉬워지게 할 것이다. ¶모든 사람을 위한 중앙은행의 전자화폐는 금융 시스템을 안정화 시킨다. 상업은행이 예금을 유치하기 위해서는, 사용자에게 추가 위험을 보상하기 위해 비즈니스 모델을 변경하거나, 예금에 대한 이자율을 증가시켜야 한다. 시중은행이 신뢰를 상실하게 되면 고객의 돈을 중앙은행 전자화폐 계좌로 신속하게 이전할 수 있다는 사실이 강조되면, 시중은행에 대한 징계 효과가 강조될 것이다. 이를 피하기 위해 은행은 위험을 줄이거나, 더많은 준비금과 자본을 보유하여 비즈니스 모델을 보다 안전하게 만들거나, 높은 이자율을 제공해야 한다. 중앙 은행계좌로 자금을 옮기는 이러한 단순한 방식은 추가적인 변동성을 만들어 낼 수 있다. 예를 들어, 상업은행 예금에서 실질적인 이유 없이 중앙은행으로 돈이 빠르게 이동할 수 있다. (펀더멘탈과 관련이 없는 단순 은행의 패닉) 이 경우 중앙 은행은 시중 은행이 담보물에 대해 중앙 은행 자금을 빠르고 간단하게 얻을 수 있는 상설 시설을 제공함으로써 상업 은행에 필요한 임시 유동성을 제공해야 한다. ¶모든 사람을 위한 중앙은행의 전자화폐는 통화정책을 단순하고 투명하게 만든다. 중앙은행은 이러한 계좌에 지불된 이자율을 주요 정책적인 도구로 사용할 수 있다. 시장이 분리되지 않으면 모든 사람이 중앙은행 전자화폐에 액세스 할 수 있다며, 이 계좌의 이자율은 경제에서 가장 낮은 이자율이 될 것이다. 왜냐하면 중앙 은행 전자 화폐가 경제체계에서 가장 유동성 있는 자산이 될 것이고, 중앙은행이 비유동화 될 수 없기 때문에 자금 보유자는 상대적으로 위험에 직면하지 않을 것이기 때문이다. 많은 중앙은행이 현재 금리를 정상화 하는 방안을 논의하고 있다. 금융 위기에 대응하기 위하여 대량의 유동성을 창출했기 때문에, 공개 시장 개입과 같은 일반적인 수단은 효과가 없으며, 현재 논의되고 있는 몯든 수단들은 중앙은행이 어떤형태로든 준비금에 대한 이자를 지불하고자 하는 특징이 있다. 오늘날 중아 은행 전자 화폐에 액세스 할 수 있는 금융 중개인에게만 제공되기 때문에 형평성에 대한 정치 경제적 논란이 있다. 일반 대중은 이러한 지불금을 공평하거나 유익하다고 생각하지 않을 수 있으며 중앙은행 독립에 영향을 미칠 가능성이 있는 정치적 논쟁을 촉발 시킬 수 있다. 중앙은행 전자화폐는 전체 인구가 소규모 상업은행이 아닌 이러한 형태의 이자 지급에 접근할 수 있게 함으로써 가능한 정치적 혼란을 피할 수 있다. ¶모든 사람을 위한 중앙은행의 전자화폐는 적은 행정적인 수고를 필요로 한다. 전반적으로 중앙은행의 전자화폐를 구현하는 것이 믿는다. 왜냐하면 이 계좌는 오로지 지불에만 사용되기 때문이다. 신용을 필요로 하지 않으므로 모니터링이 필요하지 않다. (물론 일부 표준 규정은 적용되어야 한다) 모든 거래는 전자적인 방식으로 시작되어야 할 것이다. 게다가, 많은 중앙은행들은 이미 지불을 위한 인프라를 운영하고 있다. 예를 들어, 스위스 국립은행은 이미 직원을 위해서 만ㄷ르어 운영하고 있다. 이는 즉 기존 인프라를 확장하면 된다는 것을 의미하다. 중앙은행이 자체 인프라를 제공할 필요는 없다. 상업은행이 각고객에 대해 적어도 하나의 중앙은행계좌를 개설하도록 요구할 수 있다. 이를 통해 고객은 기존 온랑니 뱅킹 액세스를 사용하여 중앙은행 계좌에서 거래를 시작할 수 있다. 이 계좌의 대차대조표는 외부 상업은행에서 유지해야 한다. 결과적으로, 이들이 파산해도 이는 자산의 일부로 간주되지 않는다. 이 아이디어는 시카고 계획과는 다르다. 시카고 계획의 핵심요소는 상업은행 예금에 100%의 준비금을 부과함으로써 준비은행 제도를 제거하는 것이었다. 그러나 여기에서는 그럴 필요가 없다. 다만 모든 사용자가 중앙은행 전자화폐에 액세스 할 것을 요구하는 정도만 수정된다. 상업은행은 은행예금을 계속 제공할 수 있으며, 아무도 중앙은행 전자화폐를 사용하도록 강요 받지 않는다. 이 제안을 구현하기 전에 신중하게 논의해야할 사안이 있다. 예를 들어, 스위스의 경우 스위스 국립은행에서 누가 계좌를 보유하고 있을 수 있는지 결정해야 한다. 스위스 인구만? 아님 해외에 있는 사람도? 첫번째 단계로서 사용자 그룹을 좁게 정의하는 것이 합리적이다. 추가로 이 계좌에 보관할 수 있는 금액에 제한을 두기 위해 한도를 두는 것이 바람직하다. 이러한 상한선은 스위스 국립 은행이 대규모 은행 운영시 개인 은행 시스템 융자를 위해 필요한 도구를 사용하며 경험을 쌓을 수 있게 해준다. ¶3. 중앙은행 암호통화의 사례? 암호화폐의 특징은 사용자가 익명으로 남아 무허가로 액세스를 허용하는, 분산형 트랜잭션 처리다. 결론 부터 말하면, 중앙은행 관점에서 암호통화를 발해하는 것은 거의 의미가 없다. 이론적으로 중앙은행은 암호통화를 쉽게 도입할 수 있다. 이더리움 블록체인의 인프라와 호환되는 토큰을 만드는 데 사용하는 ERC20, ERC223 과 같은 토큰 표준을 만드는 구성이 있다. 또는 비트코인과 같은 기존 암호화폐에 추가적으로 구성요소를 추가하는, 컬러코인 방식도 있다. 또 중앙은행은 새로운 블록체인을 개발할 수도 있다. 모든 접근 법은 구현이 간단하며, 퍼블릭 블록체인에 중앙 은행 암호 화폐를 발행할 수 있다. 암호화폐와 중앙은행 준비금 사이의 동등성을 보장하기 위해, 중앙은행은 이러한 토큰을 구매하고 판매할 용의가 있어야 한다. 밸류에이션은 중앙은행의 신뢰성에 달려 있다. 그러나 암호통화의 중요한 특징은 중앙은행에 대한 적기(red flag)라는 것이다. 즉, 평판이 좋은 중앙은행은 익명의 가상화폐를 발행할 인센티브가 전혀 없다. 단순히 이를 감내하기엔 위험성이 너무 높다. 마약 카르텔이 돈을 세탁하거나 무기를 획득하기 위해 사용하는 가상의 'FedCoin’을 생각해보자. 게다가 시중은행은 KYC와 AML을 준수해야하는 이유를 묻기 시작할 것이다. 반면 암호화폐를 사용하는 중앙은행은 규제의 효과를 훼손하고 있다. 전반적으로, 우리는 FedCoin또는 다른 중앙은행 암호통화에 대한 요구가 순진무구하다고 믿는다. 암호화폐에서 분산된 특성을 제거하면, 남아있는 것이 별로 없다. 중앙은행이 독점적으로 중앙은행에 의해 발행하는 가상의 돈은 그냥 중앙은행의 전자화폐다. 이러한 기술은 블록체인이 발명되기 전부터 존재했다. 그러나 가상화폐를 '중앙집중식 형태로’만드는 것은 암호화폐라고 부르기엔 무리다. ¶4. 결론 암호화폐의 특징은 사용자가 익명인 상태에서 분산화된 특성의 트랜잭션을 사용할 수 있으며, 이러한 과정이 허가가 없이 진행된다는 것에 있다. 이러한 특징은 중앙은행에게 있어 적기(사용하지 말하야할 이유)이며, 평판이 좋은 중앙 은행은 사용자가 익명으로 남을 수 있는 분산 가상화폐를 발행하지 않을 것으로 예측한다. 평판이 좋은 중앙은행이 발행하기엔 위험이 너무 높다. 오히려 중앙은행은 중앙은행의 전자화폐를 발행할 수 있다. 이 돈은 중앙은행에 의해 엄격하게 통제하고, KYC, AML 절차를 받을 것이다. 일부 중앙은행은 중앙은행 암호화폐 발행 여부를 평가하고 있을 것으로 보인다. 그러나 이러한 프로젝트는 정확히 말하면 암호화폐는 아니다. 이 프로젝트들은 대게 매우 중앙집중화 되어 있다. 익명의 지불에 대한 수요를 충족시키기 위해, 중앙은행이 ㅅ이러한 사업을 할 필요는 없다고 본다. 이러한 요구가 민간 부분, 특히 암호화폐를 통해 완벽하게 충족될 수 있다고 생각한다. 역사와 현재 정치의 현실이 한편으로는 정부가 나쁜 행위자가 될 수 있고, 다른 한편으로는 시민이 나쁜 행위자가 될 수도 있음을 보여준다. 전자는 나쁜 정부로 부터 시민들을 보호하기위해 익명 화폐의 사용을 정당화하고, 후자는 모든 지불금의 투명성을 요구한다. 그 사이에 우리의 현실이 있으며, 그 이유때문에 암호화폐를 환영하지만, 정부가 그것을 제공해야 한다는 사실에는 동의하지 않는다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"총기 규제를 위한 블록체인","slug":"a-blockchain-solution-to-control","date":"2018-08-01T15:00:00.000Z","updated":"2018-08-02T09:22:32.000Z","comments":true,"path":"2018/08/02/a-blockchain-solution-to-control/","link":"","permalink":"https://www.yceffort.kr/2018/08/02/a-blockchain-solution-to-control/","excerpt":"A BLOCKCHAIN SOLUTION TO GUN CONTROL 원문 ¶총기 규제법의 실효성 총기 규제법은 미국 총기 관련 사망률을 줄이는데 제한적인 성공만 거두었다. 1999~2013년 미국 총기 사망률은 변하지 않았다. 또한 미국 주에서 시행한 25종류의 총기 규제법을 살펴보면 9개는 실효성을 거두고, 9가지는 전혀 실효성을 거두지 못했다. 그렇다고 총기 규제법이 아무런 영향을 미치지 않았다는 것은 아니다. 1999년 이래로 미국의 전반적인 총기 사망률은 변하지 않았지만, 일부 개별 주에서는 총기 관련 사망자를 줄이는데","text":"A BLOCKCHAIN SOLUTION TO GUN CONTROL 원문 ¶총기 규제법의 실효성 총기 규제법은 미국 총기 관련 사망률을 줄이는데 제한적인 성공만 거두었다. 1999~2013년 미국 총기 사망률은 변하지 않았다. 또한 미국 주에서 시행한 25종류의 총기 규제법을 살펴보면 9개는 실효성을 거두고, 9가지는 전혀 실효성을 거두지 못했다. 그렇다고 총기 규제법이 아무런 영향을 미치지 않았다는 것은 아니다. 1999년 이래로 미국의 전반적인 총기 사망률은 변하지 않았지만, 일부 개별 주에서는 총기 관련 사망자를 줄이는데 성곡했다. 일반적으로 보다 제한적인 총기 법을 가진 주에서 사망률이 더 낮다. 또한 모든 미국인들에게 가장 효과적인 통제법 3가지가 균일하게 적용되면, 사망률이 10만명당 10.35명에서 1명까지 감소할 수 있음이 밝혀졌다. 이 3가지는 총기 구입에 대한 배경조사 탄약 구매에 대한 배경조사 탄도 지문 채취 및 마이크로 스탬핑을 통한 총기식별 이다. ¶총기 규제를 위한 블록체인 총기 통제를 위한 블록체인 응용 프로그램은 이런 배경조사를 용이하게 하고, 총의 흐름을 추적하며 안정적인 경제 환경을 조성하는데 도움을 줄 가능성이 크다. 블록체인은 정확하고 해킹에 안전하며, 액세스하기 쉬운 데이터베이스를 만들고 유지 관리함으로써 이러한 배경조사를 도울 수 있다. 제조업체에서 딜러, 최종사용자에게 총을 이전하는 것을 추적하는 것은 블록체인 기술을 통해 쉽게 개선될 수 있다. 이는 안전을 보장하기 위해 정확한 추적이 필요한 다른 시장에서 수행되는 것과 유사하다. 현재 배경 조사는 일반적으로 NICS에 쿼리하여 수행한다. NICS는 연방수사국(FBI)가 관리하는 일련의 데이터베이스다. 일반적으로 유해하지 않은 배경을 가진 사람의 쿼리는 수분내에 승인이 된다. 그러나 총기를 구입하려는 사람이 NICS에 존재하게 되면, 판매를 허용하기 전에 3일간 더 조사할 수 있다. NICS 시스템은 중앙 집중식 데이터베이스다. 모든 쿼리는 단일 조직에서 관리하는 중앙 데이터베이스에서 수행된다. 이런 데이터베이스 구조는 해커에게 단일 공격지점을 허용하며, 데이터 입력 및 관리에서 인적오류에 취약하다. NCIS의 불완전한 성격은 FBI에서도 인정한 바 있다. FBI는 주 또는 연방법에 의해 총기를 구매하는 것이 금지되어 있음에도 불구하고 매년 약 3천명에 가까운 사람들이 NICS 배경조사를 통과한다고 보고한 바 있다. 분산 원장과 같이 완전히 분산된 데이터 베이슨느 공격에 대해 보다 견고하며 업데이트하기 쉽고, 유지관리가 용이하며 제조업체에서 부터 최종 사용자에게 이르기까지 총기의 흐름을 추적하기 쉽다. 정확한 원장을 유지하는데 있어 블록체인 프로토콜은 제품 추적을 하는데 중요한 개선을 해줄 수 있다. 예를 들어 Walmart는 IBM과 제휴 하여 식품 및 공급망 추적 블록체인 시스템을 만들었다. 블록체인 시스템은 또한 원자력을 수출하고 마리화나 유통을 통제하는 더 나은 방법으로 제안되고 있다. 블록체인 분야가 금융 프로그램에 사용된다면, 전세계적으로 경제 안정성을 크게 향상 시킬 수 잇으며, 결과적으로 높은 실업, 경기 침체와 같은 잠재적으로 폭력을 증가시키는 조건을 줄임으로써 안전 및 총기 위협에 긍정적인 영향을 미친다. (???) 블록체인 프로토콜을 사용하는 암호화폐는 은행을 늘리거나 정기예금을 줄임으로서 중앙은행의 안정을 도울 수 있다. 비록 중앙은행이 암호화폐에 대한 단일화된 정책을 가지고 있지 않지만, 비트코인과 암호화폐의 존재감이 점점 더 커지고 있다. 금융분야에서 블록체인의 공중 보건 혜택을 극대화 하기 위하여, 이 기술을 기존 시스템에 통합하는 적극적인 접근 방식이 권장되고 있다. ¶구현 총기 제어를 위한 블록체인 솔루션은 현재 블록체인 기술의 암호화폐 구현과 유사하게 작동한다. 첫째, 현재 총을 소유하거나 구입하려고하는 개인은 비트코인 지갑과 유사한 전자 총기 지갑을 얻을 수 있다. 이 지갑은 망막 스캔이나 지문 같은 생체 인식 데이터에 묶여 있다. 총을 만들거나 구입하거나 판매할때 마다 이러한 거래 과정이 블록체인에 기록된다. 모든 거래는 판매자와 허가된 총기딜러가 판매를 승인해야 한다. 멀티시그 지갑과 마찬가지로 양당사자는 이런 양도에 서명을 해야 한다. 마찬가지로, 총을 받으려는 수신인은 배경 조사를 통과해야 한다. 이 작업이 끝날 때까지 소유권을 양도 할 수 없다. 이는 이더리움 기반 스마트 컨트랙트와 유사하게 작동한다. 신원조회를 통과하면 거래가 허용되며, 그렇지 않으면 거래가 거절되어 이러한 내용이 기록되게 된다. 이상적으로 이러한 전자 총기 지갑에는 탄도 지문이나 마이크로 스탬핑에 의한 총기 식별자가 포함될 뿐만 아니라, 개인에 관련된 데이터도 포함된다. 예를 들어 해당 지갑에는 불법활동이력, 가석방상태, 가정폭력 유죄 판결 및 정신건강 문제와 같은 광범위한 데이터가 포함될 수 있다. 이 데이터는 기존 데이터 베이스가 달성할 수 잇는 것보다 훨씬 더 사생활을 호하는 방식으로 장치에 내장될 수 있다. 프라이버시 문제로 인해 이러한 데이터가 보관되지 않을 수 있지만, 일부국가에서 페이스북, 구글, 아마존이 현재 수집하고 있는 것과 마찬가지로 인터넷 브라우징 데이터도 포함할 수 있다.이러한 정보는 학교에서 사후에 발견된 총기 폭력에 대한 집착과 같은 정신 건강 문제를 잠재적으로 식별할 수 있다. No-Fly List(비행기 탑승 금지자 목록)도 블록체인에 통합될 수 있다. 총기 또는 폭력에 대한 집착은 자동으로 소유권 거부를 유발하지는 않지만, 판매되기전에 잠재적인 구매자에 대해 철저하게 조사를 하게 만들 수 있다. 그리고 소요된 총도 안정적으로 추적할 수 있다. 이는 잠재적으로 33개의 총을 구입한 라스베이거스 사건과 같은 고위험 개인을 식별 할 수도 있다. 단순히 블록체인 거래기록을 작성하면 총기 추적을 수행하는데 필요한 노동량을 줄임으로써 많은 돈을 절약할 수 있다. 기본 기술이 잘 개발되어 있기 때문에 구현은 간단하다. Zcash, monero, dash등에서 구현한 익명의 기술을 활용하여 개인정보보호 문제를 달성할 수도 있다. 더 많은 법률 뿐만 아니라 기술을 구현하는 것은 총기 통제를 향상시키고 총기관련 폭력을 줄이는데 중요하다. 컬러 코인을 활용하여, 비트코인에 메타데이터를 작성하는 방식으로도 활용할 수 있다. 컬러 코인은 메타 데이터를 비트코인 트랜잭션에 결합시켜 '색칠’함으로써 비트코인을 토큰으로 바꾼다. 이 메타데이터에 총과같은 자산에 대한 정보와 소유자를 설명하는 데이터를 추가할 수 있다. 마지막으로 배경조사정보, 총기이전 정보 및 소유자 정보를 블록체인 시스템에 넣으면 미국에서 총 소유권을 확인할 수 잇는 능력이 훨씬 더 커진다. 총기 규제 위원회는 총 소유권에 대한 법적 권리를 결정하고 균형을 맞출 수 있다. 따라서 위원회는 중앙은행과 같이 매우 느슨하게 작동할 수 있어, 총포수가 일정 수준을 초과할때 이 새로운 총기의 수입이나 제조를 제한 할 수 있다. 총 소유권은 헌법에서 정한 권리이지만, 총기는 또한 공중 안전을 위협하는 전염병이기도 하다. 블록체인 프로토콜을 사용하면 사회 총체적인 총기 관련 부담을 줄이는데 도움이 되므로 합당한 총기 제어 조치를 구현할 수 있다. ¶결론 미국에서 효과적인 총기 통제는 사회에서 사용할 수 있는 총의 수를 헌법과 공중 안전이 양립할 수 있는 방식으로 제한 해야 한다. 보건 전문가는 총기 통제 문제와 이 분야의 공중 안전을 개선하는데 도움이 될 수 있는 기술 발전에 대해 알고 있어야 한다. 블록체인 프로토콜은 제조업체에서 최종 사용자까지 총기의 흐름을 추적하고 총 소유자에서 다른 총 소유자로 판매를 추적하는 가장 정확한 시스템이다. 기존 배경 검사 시스템 보다 더 나은 프라이버시를 제공하고, 동시에 특정 총기의 소유권을 불변의 방식으로 특정 개인에게 연결한다. 블록체인 기반 디지털 총기 지갑은 기존 총기 관련 법의 구현을 개선하고 프라이버시를 유지하며 총기 제어를 개선한다. 총기 규제는 더 많은 법률을 제정함으로써 해결할 수 있는 법적인 문제로 만 봐서는 안된다. 블록체인 기술이 금융 시스템 및 비느지스에 적용될때, 잠재적으로 자살률 및 폭력이 최소화되는 환경을 조성하는데 도움이 될 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"디지털 통화, 분산 원장, 그리고 중앙 은행의 미래","slug":"digital-currencies-decentralized-ledgers-and-the-future-of-central-banking","date":"2018-08-01T15:00:00.000Z","updated":"2018-08-02T01:42:11.000Z","comments":true,"path":"2018/08/02/digital-currencies-decentralized-ledgers-and-the-future-of-central-banking/","link":"","permalink":"https://www.yceffort.kr/2018/08/02/digital-currencies-decentralized-ledgers-and-the-future-of-central-banking/","excerpt":"DIGITAL CURRENCIES, DECENTRALIZED LEDGERS, AND THE FUTURE OF CENTRAL BANKING 원문 ¶중앙 은행과 디지털 통화와의 경쟁 만약 자율 디지털 통화가 유통되면, 중앙은행이 발행한 공식 통화와 경쟁할 것이다. 공식 통화와 개인의 돈 사이에서의 경쟁은 새로운 것은 아니며, 여러 사회에서 금과 은을 비롯한 물건들이 돈을 대신하고 있으며, 여기에는 또한 사품 뿐 만 아니라 가치와 교환 매체로 사용되는 다양한 것들 (포인트, 도장 등)이 포함된다. 그러나 대부분의 국가에서 현지 통화는","text":"DIGITAL CURRENCIES, DECENTRALIZED LEDGERS, AND THE FUTURE OF CENTRAL BANKING 원문 ¶중앙 은행과 디지털 통화와의 경쟁 만약 자율 디지털 통화가 유통되면, 중앙은행이 발행한 공식 통화와 경쟁할 것이다. 공식 통화와 개인의 돈 사이에서의 경쟁은 새로운 것은 아니며, 여러 사회에서 금과 은을 비롯한 물건들이 돈을 대신하고 있으며, 여기에는 또한 사품 뿐 만 아니라 가치와 교환 매체로 사용되는 다양한 것들 (포인트, 도장 등)이 포함된다. 그러나 대부분의 국가에서 현지 통화는 외국 정부의 통화, 특히 미국 달러와 가장 큰 경쟁을 하고 있다. 이와 비슷한 맥락에서, 중앙 은행의 경우 디지털 통화가 제기하는 도전은 기본적으로 경쟁 외화의 존재로 인한 도전과 동일하다. 경제에 있어서, 통화 간의 경쟁으로 인해 공급자로 하여금 유용성을 반영하는 적절한 균형으로 가격과 품질을 유도하게 한다. 역사적으로 이러한 공급 업체는 대부분 중앙 은행이었지만, 비 중앙은행의 통화가 사용된 경우도 많았다. 서로 다른 돈 사이의 경쟁에서 얻은 한가지 이점은, 계약 당사자가 합의 조건을 선택하는 유연성이 생김으로써 안정성이 나타나게 됐다는 것이다. 개인 채권자와 채무자는 자유로운 선택이 주어지면 중립적인 통화를 사용하는 경향이 있다. 채무자는 계약 후 가치가 떨어질 통화를 사용하길 원치 않을 것이며, 채권자는 반대의 경우를 원치 않을 것이다. 따라서 돈을 소비자 관점으로 보았을때, 화폐의 제공에 경쟁자가 있다는 것은 공급자의 일방적인 행동에 대한 견제다. 구체적으로 말하면, 디지털 통화는 잘 관리되고 있지 못한 통화공급으로 어려움을 겪고 있는 국가에 안정성을 제공해 줄 수도 있다. 아르헨티나는 외국 통화와 비슷한 성격을 가진 디지털 통화가 어떻게 중앙 은행의 정책에 대해 어떻게 체크할 수 있는지에 대한 좋은 예가 될 수 있다. 세계 은행에 따르면 아르헨티나는 20002년 이후 한자릿수 인플레이션을 제외하고 매년 두자릿수 인플레이션을 겪고 있다. 이런 상황은 자본을 할당하는 결정에 원치 않는 위험을 부과함으로써 국가 경제에 혼란을 초래한다. 2015년 마우리시오 대통령이 당선되기 전에, 뉴욕타임즈는 비트코인을 사용하여 금융이 불안정한 상황속에서 외환 통제를 피할 수 있다고 보도했다. 아르헨티나 페소와 중앙은행이 국민에게 영향력 있는 통화를 제공할 수 없을때 (인플래이션 상황) 상대적으로 디지털통화나 미국 달러와 같은 다른 외화로 전환할 수 있는 옵션을 선택할 수 있다. 글로벌 금융시장에 참여하기엔 너무 위험성이 많은 국가는, 암시장이나 회색시장을 용인할 가능성이 높아진다. 그가 대통령이 되기전에 부아노스 아이레스 시장을 역임하면서 비트코인 포럼을 조직했다. 그가 취임 직후 한 첫번째 행동은, 환율 통제를 폐기하는 것이었다. 2014년 공식적으로 비트코인을 금지한 에콰도르는 'Sistema de Dinero Electrónico’라고 하는 자체 디지털 통화 프로젝트를 도입했다. 모바일 머니를 민간 제공업체로 모델로 한 이 시스템은, 개인에게 중앙은행이 승인한 통화로 표시된 모바일 신용계좌에 액세스 할 수 있게 해준다. 에콰도르는, 수년간 자국 통화가 불안정하여 미국달러를 공식통화로 채택하였다. 에콰도르 정부는 이전에 밝힌 바와 같이 이런 디지털 시스템은 달러를 대체하기 위해 고안 된 것이 아니라 점점 상황이 나빠지고 있는 물리적인 지폐를 대체하기 위해 설계되었다. 그러나 일부는 이 프로젝트를 '탈 달러화’를 위한 움직임으로 보았으며, 정부가 경제를 더 강력하게 통제하려는 시도라고 보았다. 비트코인과 다른 디지털 통화 금지는 앞서 언급한 경쟁의 이점이 에콰도르 당국이 새로운 통화 시스템을 구축할때 원하던 것이 아니라는 사실을 보여준다. 결국 현재는 총 인구의 2.5% 만이 이를 사용하고 있는 것으로 보인다. 출처 위의 이점을 염두해 두고, 중앙은행이 통화정책을 독점적으로 수행하는 능력을 약화시키는데 기여하는 디지털 통화의 비용을 고려해본다. 중앙은행이 다른 중앙은행 및 민간 행위자와 경쟁해야 하는 세계에서, 단순히 공급 및 수요 만으로 일반적으로 받아들여지는 교환 수단으로 어떤 돈을 사용되는지를 결정하게 될 것이다. 중앙은행은 그들의 지폐의 수락을 강요하는 기능을 법적으로 제정한 상태에서 운영하게 된다. 이러한 법안은 중앙은행 통화로 계약할 것을 요구하지는 않지만, 그러나 다른 교환 수단으로 계약된 채무에 대한 법적인 책임은 거부한다. 즉 그레샴의 법칙, 악화가 양화를 구축하는 것이다. 같은 환율에서, 채무자는 감가상각 통화로 지불 할 수 있는 옵션이 있다면, 공인된 통화로 지불할 가능성이 적다. 따라서 정부에 독점 특권을 부여하여 화폐를 인쇄할 수 있도록 한다. 그런 법이 없다면, 단순히 중앙은행은 은행으로 남게 될 것이다. 소비자가 민간 및 공공 부채에 대한 중앙 은행 통화의 수락을 거부할 수 있다면, 자유 은행 체제가 나타날 것이고, 중앙은행은 소비자의 요구에 따라 통화정책을 운영해야 하며, 정치적 / 정책적 목표에 따라 시장이 정해질 것이다. 미국 통화 정책의 역사는 이에 대한 중요한 예시를 제시한다. 1861~1865년 미국 남북전쟁 기간 동안 미국의 통화는 미국의 First Bank를 포함한 의회에 허가된 민간은행에 의해 발행되었다. 세금을 인상하지 않고 남북전쟁에 대한 자금을 지원하기 위해 의회는 1862년 Legal Tender Act (재정적 의무를 이행하기 위해 유효하다고 법적으로 인정된 ‘정부에 의해 발행된’ 지불수단)를 발효했다. 이 법안은 ‘수입에 대한 의무와 공적인 부채에 대한 이자를 제외하고, 미국내 모든 부채, 공공 및 민간 채무를 지불하는데 쓰일 수 있는 합법적인 지폐’ 라고 명시된 미국 지폐 1억 5천만 달러의 발행을 승인했다. (그린백) 그러나 미국 대법원에서는 평가 절하된 통화를 받아드리게 하는 것이 형평성에 어긋난다며 논란에 불을 지폈다. 하지만 결국 5-4의 결정으로 그린백의 합헌이 결정되었고, 미국은 연방정부가 통화 특권이 법적인 안정망 없이 운영된다는 정치적 합의에 도달하게 되었다. 19세기 미국에 이 사건은 2014년 아이슬란드의 정치적 토론을 이해하기 위한 흥미로운 맥락을 제공한다. 아이슬란드는 자국의 화폐 크로나에 대한 대안으로 ‘오로라 코인’ 이라는 민간 자율 디지털 통화를 대안으로 맞닥드리게 된다. 'Baldur Friggjar Óðinsson’라고 불리우는 익명이 소개한 이 코인은 2014년 3월 오로라코인의 50%가 아이슬란드의 국민들에게 에어드랍했다. 이 사건은 아이슬란드가 세계 금융 위기 여파로 인해 엄격한 자본 통제를 실시할 때 발생했다. 오로라코인의 도입으로 정부는 이와 관련하여 회의를 개최하게 되었다. 위원장은 '이것이 사기와 불법이 라는 증거가 있었지만, 궁극적으로 아무런 조치도 취하지 않았다 고 언급했다. 어쨌든, 결과적으로 오로라코인은 실패했으며 아이슬란드의 크로나를 대체하지도 못했다. 정부는 송금에 대한 요구사항을 이용하여 경쟁 통화의 위협을 간접적으로 규제할 수 있다. 이러한 법률은 정부가 비트코인과 같은 디지털 화폐로 이루어지는 자금 세탁, 세금 회피등을 쉽게 대처할 수 있게 한다. 많은 국가들은 모호하거나, 적대적으로, 혹은 자유 방임에 이르기까지 디지털 통화에 대해 다양한 방식으로 대처했다. 이러한 태도와, 외화를 취급하는 방식에는 종종 겹치는 부분이 있다. 예를 들어, 중국 정부는 중앙은행의 적극적인 시장개입과, 자본통제를 활용하여 위안화 가치에 영향을 미치거나, 민간 행위자가 환율 가치를 설정하는 것을 철저하게 막고 있다. 마찬가지로 비트코인과 다른 디지털 통화에 대해서도 민간 부문의 손을 묶어버렸다. 중국에서 개인이 비트코인을 소유하는 것까지는 가능하지만, 은행과 금융기관은 그럴 수 없다. 2014년 4월 중국 인민은행은 상업은행과 무역회사에서 비트코인을 다루는 모든 계좌를 폐쇄하도록 명력했다. 중국 정부는 시민의 재정적 복지에 대한 우려 외에도, 비트코인 및 기타 디지털 통화가 국경을 넘어 쉽게 전송할 수 있기 때문에 이들은 자본통제에 위협이 될 수 있다. 반면에 영국은 비트코인의 사적인 사용과 통화로 거래되는 사업을 허용한다. 미국 정부내 많은 관리들은 디지털 통화에 대해 비슷한 태도를 보였다. 반-돈세탁법이 양국 모두 적용되고 있지만, 비트코인을 금지하거나 확산을 막으려고 하지는 않았다. 실제로 잉글랜드의 수석 이코노미스트는 디지털 통화가 통화정책의 Zero Lower Bound 문제 (단기 명목 이자율이 0에 가까워 유동성의 함정을 야기하고, 중앙은행이 경제성장을 촉진하는 능력이 제한될 때 발생하는 거시경제 관점에서의 문제) 에 대한 해결책이 될 수 있다고 보았다. ¶중앙 정부는 디지털 통화를 발행해야 하는가? 중앙은행의 통제를 우회하기 위해 비트코인을 비롯한 기타 디지털 통화가 만들어졌지만, 중앙은행이 지폐를 디지털 통화로 교체할 가능성은 통화경제학자들 사이에서 논쟁거리가 되고 있다. 만약 그렇다면, 이는 미국 연방 준비 은행과 경쟁하기 위해 만들어진 ‘암호화폐’ 기술을 채택하는 결과를 낳을 것이다. FedCoin 이라고 하는, 중앙 은행 디지털 통화에 대한 가장 신중하고 널리 논의된 제안도 있다. 최근 공개연설에서 FedCoin의 아이디어 채택에 관하여 논의하면서, 영국이 국가 단위 디지털 통화를 출시하는 최초의 국가가 될 수 있다고 추측했다. 디지털 파운드가 만약 시장에 진입한다면, 현대기술에 익숙하지 않는 , 그리고 디지털 장비가 없는 소비자들을 수용하기 위해 적어도 한동안은 전통적인 동전 &amp; 지폐와 함께 유통되어야 할 것이다. FedCoin의 제안에 따라, 시민과 기업은 오늘날 상업은행에 자금을 입금하는 대신 중앙은행 자체에 계좌를 개설할 수 있게 된다. 중앙은행은 역사적으로 기록 보관과 고객 접촉이 엄청나게 많기 때문에, 대중으로 부터 예금을 받을 수 없었다. 디지털 기술은 클라우드 기반 서버 및 스토리지가 매우 많은 양의 금융 거래를 쉽게 수용할 수 있기 때문에 이러한 우려를 극복하고, 휴대전화 장치를 통해 화폐에 액세스 할 수 있다면 은행 지점과 ATM을 유지 관리할 필요가 없다. 중앙은행의 디지털 계정은 예금자가 기존 통화를 1:1로 교환하게 허용함으로써 자금을 조달할 수 있으며, 새로운 디지털 통화는 중앙은행이 운영하는 블록체인에 정보를 저장하게 될 것이다. 예금주가 디지털 통화를 사용하기를 원할때, 블록체인을 통해 상대방 계정으로 전송하고 중앙은행은 각 거래를 블록체인으로 저장해 놓는다. 서로 경쟁하면서 마이너들에 의해 업데이트 되기 보다는, 블록체인은 신뢰할 수 있는 제 3자에 의해 감독 될 것이며, 중앙은행은 항목을 추가하거나 수정할 수 있는 독점권을 갖는다. 추가로 시민의 사생활과 기업의 영업 미밀을 지키기 위해 중앙은행의 블록체인은 최소한 어느정도는 숨겨져 있을 것이다. 이 두가지 차이 때문에 중앙 은행의 블록체인은 네트워크 합의를 위해 강력한 게이트 키퍼에 의존하지 않는 기존 디지털 통화의 특징과는 현저하게 다를 것이다. 그러나 중앙 은행이 블록체인이 될 수 있는지에 대한 의문도 있다. 이러한 중앙 집중화는 전체 금융 시스템을 해킹하거나 방해할 수 있는 단일 실패지점을 만들어 낸다. 중앙 은행에 예금을 집중함으로써 FedCoin은 기존 은행의 관행을 암묵적으로 종식시키고, 은행 시스템을 작게 만들어 예금자들이 중간 민간은행이 아닌 중앙은행을 통해 직접 처리할 수 있게 한다. 여러면에서 FedCoin은 대공황때 대중의 신뢰를 회복하기 위해 제안된 1933년 ‘시카고 계획’(그 고전 도서 100권 읽기 그런 것이 아닙니다.) 의 부활을 나타내고 있다. 디지털 통화시스템이 생긴다면, 통화정책을 구현하기 더 쉬워질 것이다. 은행은 알고리즘적인 화폐 창출 비율을 약속할 수 있고, 고객 예금에 대한 이자를 정확하게 통제할 수 있다. 원칙적인 면으로 봤을 때, 이자율은 낮아질 수 있다. 이러한 정책은 경제가 특정 로드맵을 따를 경우 자금 창출 속도를 바꿀 수 있는 스마트 컨트랙트에 의해 수정될 수 있다. 대안으로, 중앙은행은 안정화 정책의 일환으로 전략적인 기준에 따라 통화공급을 조정하는 재량권을 보유할 수 도 있다. 두 경우 모두, 개방형 시장의 운영의 개념이 지리적/인구학적/경제적인 예금자를 대상으로 정교하게 고안해 낼 수 있는 방법으로 대체될 것이다. 대체로 말하자면, 시민과 중앙은행간의 직접적인 관계로 인한 은행시스템의 축소는 금융 사회주의를 대표할 것이다. 중앙은행에 계좌를 허용하게 되면, 현재 은행 시스템에 내재된 많은 문제를 해결할 수 있다. 중앙 은행은 은행 운영에 취약하지 않으며, 정부는 예금 보험을 제공하는 사업 (계좌당 5천만원까지 보장해주는 그런)을 중단하고, 부적절하게 자금을 지원하여 시중은행이 위기에 처할경우 제공하는 구제 금융 사업을 종료할 수 있다. 상업은행은 더이상 단기 수요 예금에서 자금을 조달하고, 장기 모기지나 다른 대출로 대출해주는 것에 관여할 필요가 없다. 은행의 위험 변동 등 도덕적 해이 문제로 인해 정부로부터 무상예금보험을 받는 상황이 없어질 수도 있다. 거시 경제학에서 중앙은행이 디지털 통화를 갖는 주된 이점은 정부가 금융 시스템에 대한 보다 많은 통제와 이해를 제공한다는 것에서 비록된다. 이러한 통제는 경기 순환에 대해서 더 원활하게 개입함과 동시에 세금 징수 및 돈세탁 방지 규제를 보다 더 잘 준수할 수 있도록 보장한다. 중앙은행 디지털 통화는 중앙은행이 지출과 투자를 장려하는 전략으로 금리를 0 이하로 낮추도록 하용함으로써, Zero Lower Bound 문제를 해결할 수 있게 해준다. 지폐 형태로 돈이 유통될때, 시민들은 통화를 축적하고, 0의 이자율인 은행 예금을 거절 할 수 있기 때문에 - 이자율을 적용하기 어려울 수 있다. 20세기의 대부분 동안에는 전세계가 상대적으로 실질 금리가 높았으므로 굳이 마이너스 이자율을 구현할 필요가 없었다. 그러나 최근 몇년간 실질 금리가 지속적으로 하락하면서 다시 중요하게 떠오르고 있다. 이는 세계 금융 위기의 경기 침체와, 선진국의 저축 패턴에 영향을 미치는 통계학적 패턴의 변화등 다양한 이유로 발생하였다. 디지털 통화의 주요혁신이 중앙은행이 금리를 0이하로 낮추도록 허용하는 것이라면, 대중은 기술에 대해 화를 내거나 도입을 막을 수도 있다. 2013년 키프로스 은행은, 특정 고객 계좌의 잔액을 줄임으로써 은행의 지분을 늘리자고 제안한 바 있는데, 이는 정치적으로 논란이 많았고 시행하기 어려웠다. 참고 은행이 예금자에게 마이너스 이자를 제공하는 것은 이와 비슷한 의미이며, 시민들은 정부가 컴퓨터 메모리에서 현금의 일부를 마이너스 금리고 지우도록 유도한 금리 정책의 광범위한 혜택을 보는데 어려움을 겪을 수 있다. 키프로스 금융위기는 비트코인 가격 상승을 이끌었고, 비트코인당 1216달러라는 최고기록을 세우게 했다. 중앙은행의 디지털 통화가 상업은행의 기능을 제한하게 된다면, 이는 상업은행의 위험으로 곧 이어질 것이다. 상업은행은 주요 자금 원천에 대한 접근이 어려워 질 것이고, 투자자들에게 증권을 발행함으로써 대출을 줄이거나, 새로운 자본을 마련해야 할 것이다. 새로운 자금 조달은 예금보다 훨씬 더 비싸고 덜 안정적일 것이다. 결론적으로 상업은행은 모기지 대출이나 신용거래와 같이 기업 과 시민 모두에 대한 대출 활동이 크게 위축될 것이다.이 신용 수축의 효과를 상쇄하기 위해 경제가 어떻게 보상할 수 잇는지는 분명하지 않다. 그러나 아마도 민간 개혁을 통해 수행된다면, 경기 순환 주기가 완만해질 것이다. 이와 관련된 문제는 규제영역에서 발생할 가능성이 크다. 대중으로부터 예끔을 받는 중앙은행은, 같은 기관의 감독자 역할을 했더라도 결국 시중은행과 정면으로 대결하게 될 것이다. 은행의 이러한 사회하는 비판이 없는 것이 아니다. 국가가 디지털 통화를 통제하고 추적할 수 있는 중앙은행은 개인 재정을 관찰하고 통제할 수 있는 엄청난 힘을 갖게 될 것이다. 정부는 독립적인 사법부를 소환할 필요 없이, 각 개인이 얼마나 많은 통화를 소유하고 어디다 썼는지 볼 수 있다. 많은 사람들이 이러한 이유로 경화 (달러와 같이 널리 사용되는 통화)를 사용하는 것을 선호한다. 정부가 디지털 통화를 발행한다면, 디지털 통화가 남용에 대한 위험한 유혹을 불러 일으킬 수도 있다는 우려에서 벗어날 가능성이 높다. 또한 달러를 인쇄하지 않아도 단순히 0을 추가하여 던 많은 돈을 유통할 수 있다. 자유 경제와 마찬가지로, 자유은행은 중앙 계획 경제보다 통제하고 이해하기가 더 어렺지만, 현대 경제는 인센티브, 잘 정리된 재산권 및 이익의 채널을 통해 이러한 혼란보다 강력하고 생산적인 시스템을 만들어낸다는 결론에 이르렀다. ¶블록체인을 사용하는 중앙은행 중앙은행은 FedCoin처럼 디지털 통화를 발행하지 않을 수도 있다. 그러나 다른 금융 기관과 마찬가지로 중앙은행은 비트코인 및 기타 알고리즘 통화의 기초에 있는 블록체인에 더 매력을 느끼며, 중앙은행은 지불 처리 및 거래 청산에 사용하기 위하여 블록체인을 사용할 수 있다. 디지털 통화 블록체인의 원래 목표는 은행간 청산 프로세스를 우회할 수 있는 P2P 프로세스 였지만, 이 기술은 아이러니하게도 중앙 은행이 예금자간에 안정적이고 저렴하게 돈을 이동할 수 있다는 것에 가장 큰 용도를 느낄 수 있다. 중앙은행 통화는 과거 금이 제공하는 기능과 비슷한 결제 통화가 될 것이다. 은행은 이러한 부기 및 결제 작업을 자체적으로 상업은행을 대신하여 수행한다. 블록체인 기술은 초기 단계에 있지만, 처리 및 부기 비용의 잠재적인 절감을 가져올 수 있으며, 이는 50~80% 정도를 절감할 것으로 내다 봤다. 중앙은행이 엄청난 양의 거래를 처리할 때, 이러한 절감은 상당한 수준이다. 중앙 은행이 전체 금융 시스템을 대신하여 지불 및 결제 기능을 감독할때, 은행 시스템에 대해 대중의 신뢰를 창출하기 위해 안전하고 효율적인 시스템을 제고앟려고 할 것이다. 중앙은행은 기업, 소비자, 은행 및 국제 업체를 대신하여 처리하며, 효율성을 약간만 개선해도 엄청난 돈을 절약할 수 있었다. 규모의 경제를 통해 효율성을 달성할 잠재력에도 불구하고, 국제 송금과 같은 송금 시장은 사용자에게 너무 비싸다. 세계 은행에 따르면 2015년 말 국제 통화 이체비용은 전세계적으로 봤을 때 7.37%, G8에서는 6.89% 였다. 이러한 이체는 대게 청산과정에서 여러번 검증을 거치므로 완료되는데 며칠이 걸린다. 중앙은행이 예금자의 행동을 더욱 직접적으로 감시할 수 있게 해 돈세탁이나 탈세같은 문제를 무마하는데 도움이 되는 유익한 부작용이 있을 수 있다. ¶결론 디지털 통화는 중앙은행에 도전과 기회를 제공한다. 일부 경제 상황에서는 비트코인이 중앙은행을 약하게 하거나 신뢰할 수 없는 것으로 인식하게 하고, 이에 비트코인이 화폐에 대한 경쟁력 있는 대상으로 떠올랐지만, 이는 어디까지나 자본 통제에 문제를 겪고 있는 환경에서의 가정으로 제한되었다. 흥미로운 점은, 디지털 통화의 블록체인 기술이 중앙은행의 지불 및 청산 운영을 개선하고 중앙은행이 자체 디지털 총화를 출시할 수 있는 플랫폼 역할을 할 수 있는 가능성이 있다는 점이다. 국가 주도 디지털 통화는 은행시스템에 심오한 영향을 미치고, 시민과 중앙은행 간의 관계를 좁히며 대중이 상업은행에 예금을 유지할 필요성을 제거할 수 있다. 이것은 상업 은행 부문에 심각한 자금 조달 부족을 초래할 수 있다. 이러한 정책에 대한 토론은 고전 통화 경제학에 대한 관심의 부활로 이어졌다. 명목통화와 디지털 통화간의 경쟁 19세기 ‘자유은행’ 시대를 불러일으키고 중앙 은행이 디지털 통화를 발행할 가능성은 상업은행을 제거하여 금융시스템을 좁히는 1930년대 시카고 계획을 상기 시킨다. 디지털 통화는 파괴적인 신기술로서, 정부와 중앙은행으로 하여금 이것의 혁신을 금지하거나, 허용하거나, 공동으로 개방하는 것중 하나늘 선택하는 것을 강요한다. 대부분의 성숙한 경제상황에서 중앙은행은 국가주도 디지털 통화를 운영에 통합할 가능성을 공개적으로 검토하고 있다. 디지털 통화와 블록체인의 가능성에 대해 여전히 많은 것을 알아야 하는 가운데, 중앙 은행의 디지털 통화 발행은 나머지 금융제도를 위해 상당한 위험을 수반하는 급진적인 제안으로 보인다. 더욱이, 법적인 보호를 받는 의무적인 중앙 은행 디지털 통화는 현대 디지털 통화의 창시자가 구상한 경쟁, 분산화 및 개방성에 대한 비전을 좌절 시킬 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인이 어떻게 은행 산업을 뒤바꿔 놓는가","slug":"Why-Blockchain-will-revolutionize-the-banking-industry","date":"2018-07-31T15:00:00.000Z","updated":"2018-08-01T05:38:31.000Z","comments":true,"path":"2018/08/01/Why-Blockchain-will-revolutionize-the-banking-industry/","link":"","permalink":"https://www.yceffort.kr/2018/08/01/Why-Blockchain-will-revolutionize-the-banking-industry/","excerpt":"Why Blockchain will revolutionize the banking industry 원문 ¶블록체인은 어떻게 작동하고, 은행 업무에는 어떻게 적용될까? 하버드 비즈니스 리뷰는 인터넷이 미디어에 한일을, 블록체인이 은행에 할 것이라고 주장한다. 그리고 2016년 현재 금융기관의 60%는 국제 송금에 블록체인을 사용하고 청산 및 결제에는 23%, 돈세탁 방지 서비스에는 20%를 사용할 계획이다. 결국 블록체인 기술이 향 후 10년 안에 은행 산업에 혁명을 일으킬 두 가지 주요 이유가 있다. * 저렴하다 * 거래가","text":"Why Blockchain will revolutionize the banking industry 원문 ¶블록체인은 어떻게 작동하고, 은행 업무에는 어떻게 적용될까? 하버드 비즈니스 리뷰는 인터넷이 미디어에 한일을, 블록체인이 은행에 할 것이라고 주장한다. 그리고 2016년 현재 금융기관의 60%는 국제 송금에 블록체인을 사용하고 청산 및 결제에는 23%, 돈세탁 방지 서비스에는 20%를 사용할 계획이다. 결국 블록체인 기술이 향 후 10년 안에 은행 산업에 혁명을 일으킬 두 가지 주요 이유가 있다. 저렴하다 거래가 훨씬 빠르다 미국인구의 절반이 전화를 사용하는데에는 76년이 걸렸고, 스마트폰은 약 10년이 걸렸다. 인터넷은 첫번째 웹사이트가 발표된 이후로 거의 즉시 발판을 마련했다. 블록체인도 마찬가지로 시간의 문제다. ¶블록체인은 저렴하다 돈을 덜 쓰는 것은 은행의 주요 관심사다. 어떤 사업과 마찬가지로 은행업의 ROI도 주요 관심사다. 혹자는 은행에 효율성을 떨어뜨리고 그들의 비용을 높이는 세가지 요소가 있다고 주장한다. 불확실한 규제 환경 역사적으로 봤을 때 낮은 이자율 디지털 혁명 사실, 이 3가지 요인은 2021년 까지 전세계 금융 회사들에게 3천억달러가 넘는 비용이 들게 만든다. 하지만 이는 은행 산업에 엄청난 양의 현금이 필요한 환경만을 이야기 하는 것이 아니다. 이는 또한 국제 지불과 미국 연방 정부 규정을 준수하기 위한 엄청난 과정이다. 매년 기업들은 국가간 송금을 위해 약 150~300조 달러를 지출한다. 이러한 거래에 대한 수수료는 평균 약 10% 이며, 송금에는 약 2~5일이 걸린다. 그정도 많은 수수료를 지불하고 송금이 오기를 기다리는 셈이 된다. 마찬가지로, 금융기관들은 현재 KYC 규정 (Know your customer)을 준수하기 위해 6천만달러에서 많게는 5억달러까지 지출한다. 물론, 이는 은행산업이 직면한 시간과 돈 문제의 몇가지 예시일 뿐이다. 그렇다면 블록체인이 더 나은 기술이 될 수 있는가? 은행에게는 그럴수도 있다. 예를 들어, 블록체인 기술은 고객 식별을 위한 간접비를 잠재적으로 제거할 수 있다. PWC 보고에서는 아래와 같이 언급했다. 블록체인은 기존 플랫폼 보다 훨씬 더 저렴할 수 있다. 왜냐하면 블록체인은 신원을 확인하는데 필요한 단계를 제거할 수 있기 때문이다. 분산 원장 시스템에서 확인은 네트워크의 모든 참가자들이 동시에 수행한다. 이른바 ‘합의’ 프로세스는 거래에 손을 대고 그 과정에서 통행료를 가져가는 기존 중개자의 필요성을 감소 시킨다. 금융 서비스에는 돈을 옮기고, 계약을 만들고, 세금 거래를 하고, 정보를 저장하는 사람만 포함한다. 신원 사기는 이미 2017년에 160억달러 이상의 피해를 가져왔다. 따라서 블록체인 기술이 매년 200억달러의 인프라 비용을 절감할 수 있다고 주장하는 사실은 쉽게 믿을 수 있다. 블록체인 기술에 대한 은행의 지출은 2019년 까지 4억달러로 급증할 것으로 보인다. 물론, 지난 20년 동안 신뢰해온 시스템을 이용하는 것이 더 쉬울 수도 있다. ¶거래가 훨씬 빠르다 싱가포르에서 말레이시아로 석유를 운송하고 있다 가정하자. 운송작업은 하루면 되지만, 서류 작업은 최소 일주일이 걸리는게 현실이다. 이런 예로 보았을때, 블록체인 기술이 은행업의 또다른 측면을 붕괴시킬 수도 있다. 개인은행 업무에도 예금 대기 시간은 몹시 오래 걸린다. 무역 금융에는 더 많은 돈이 있기 때문에, 그 과정은 훨씬 오래 걸린다. 블록체인은 어떤가? 디지털리스 매거진에 따르면 결과는 아래와 같이 나왔다. 일반적으로 2~6일간이 걸리는 업무는 블록체인 상에서 20초만에 완료되었다. 그리고 조금더 향상 시킨 결과, 10초만에 거래를 완성할 수 있었다. 따라서 블록체인 기술은 은행들이 수백만달러를 절약할 수 있는 잠재력을 가지고 있을 뿐만 아니라, 해외와 현지에서 거래 프로세스를 대폭 가속화 할 수 있다. 이러한 이유로 전세계 40대 거대 은행이 현재 블록체인에 막대한 자산을 투자하고 있다. 뱅크오브아메리카는 블록체인 특허를 갖고 있으며, 골드만삭스, JP 모건, 씨티뱅크 등은 모두 자신 만의 암호화폐를 만들어 냈다. 블록체인은 단지 저축같은 서비스를 제공하는 것이 아니라, 더 빠른 거래를 제공한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인을 활용한 중앙은행 암호통화, Fedcoin","slug":"fedcoin-A-Blockchain-Backed-Central-Bank-Cryptocurrency","date":"2018-07-30T15:00:00.000Z","updated":"2018-07-31T05:38:31.000Z","comments":true,"path":"2018/07/31/fedcoin-A-Blockchain-Backed-Central-Bank-Cryptocurrency/","link":"","permalink":"https://www.yceffort.kr/2018/07/31/fedcoin-A-Blockchain-Backed-Central-Bank-Cryptocurrency/","excerpt":"FedCoin - A Blockchain-Backed Central Bank Cryptocurrency 원문 편의상 페드코인이라고 간단하게 하겠습니다. 페드코인에 대한 논의는 아이러니하게도 비트코인의 결점에 대한 설명으로 시작되어야 한다. 비트코인에서 가장 큰 문제중 하나는 변동성이며, 이는 주류 통화가 되는데 있어 심각한 장애물로 작용한다. 이 과정에서 투기꾼들은 가장 많은 이익과 손해를 볼 수 있다. 세계에 가난한 사람들이 가치 변동이 두자리 수로 출렁거리는 통화에 투자하는 것은 현명하지 못한 선택이다. 이런 변동성은 많은","text":"FedCoin - A Blockchain-Backed Central Bank Cryptocurrency 원문 편의상 페드코인이라고 간단하게 하겠습니다. 페드코인에 대한 논의는 아이러니하게도 비트코인의 결점에 대한 설명으로 시작되어야 한다. 비트코인에서 가장 큰 문제중 하나는 변동성이며, 이는 주류 통화가 되는데 있어 심각한 장애물로 작용한다. 이 과정에서 투기꾼들은 가장 많은 이익과 손해를 볼 수 있다. 세계에 가난한 사람들이 가치 변동이 두자리 수로 출렁거리는 통화에 투자하는 것은 현명하지 못한 선택이다. 이런 변동성은 많은 것을 요구한다. 암시장 거래 또한 예고 없이 일어날 수 있기 때문에, 익명성은 또 다른 위험이다. 블록체인은 주소와 금액만 공개되어 있을 뿐, 신원에 대해서는 공개되어 있지 않다. 자금의 흐름을 추적할 수는 있지만, 출처나 목적지는 확실히 알 수 없다. 또한 지불은 구조적으로 돌이킬 수 없다. 비트코인의 중앙집중화는 또다른 문제다. 가장 빠른 마이닝 하드웨어를 갖춘 몇 명의 주요 플레이어가 거래를 확인해버리면, 노드를 검증할 인센티브가 거의 없다. 이러한 추세에 비추어 보았을때, 비트코인은 가장 가치 있는 선언인 '자산의 분산 아키텍처’의 성격을 잃을 수 있다. 게다가 기하 급수적으로 더 어려운 암호화 퍼즐을 해결하는 마이닝 과정은 많은 양의 전기를 낭비하고 있다. 비트코인 마이닝은 초당 거래 7번을 처리하는 것이 최선이며, 이는 Visa에서 50,000개를 처리하는 것과는 대조적이다. 비트코인 블록 생성 속도에서는, 거래를 확인하는데 최소 10분이 소요되고 심지어 일부는 삭제 될 수 있다. (메인 체인에 연결되지 못 했을 경우 뒤로 밀릴 수 있다는 이야기) 전세계는 규모에 맞춰 돈을 처리하는 시스템이 필요하며 비트코인은 여전히 이것을 처리하는데 힘이 부족하다. 현재 거래 확인 수수료는 마이너들에게 새로운 화폐를 주는 네트워크에 의해 보조금 형태로 지급이 때문에, 장기적으론 훨씬 더 비싸질 것이며, 화폐 공급이 제한되어 마이너들이 독점하는 시스템으로 변모할 것이다. 마지막으로, 2천1백만개의 고정 통화 공급은 심각한 위험을 초래한다. 현실적인 조치로, 2025년 부터 통화공급은 평탄해져서 금과 같은 형태로 변모하게 된다. 역사적으로 알 수 있듯이, 고정된 양의 화폐 공급은 결코 효과가 없다. 수요가 치솟으면 예기치 않는 디플레이션을 야기하며, 금융 위기 상황에서 돈 공급을 늘리는 탄력적인 통화정책을 수행할 수 없게 된다. 간단히 말해서, 비트코인은 변동성 및 유동성의 제한, 마이닝 과점 및 비효율, 빈약한 확장성, 네트워크 대기시간, 소액 지불 처리 능력 및 통화정책 부재로 고통 받고 있다. 페드코인은 연방 준비 제도 이사회가 만든 블록체인으로 시작한다. 연방 준비제도 이사회는 통화 생산과 정책 수립을 통제하는 공공 통화 당국이다. 연준은 이 원장에 특정 속성을 부여한다. 연준만이 원장에 항목을 만들고 삭제할 수 있다. (그래서 FedCoin이다) 즉, Fed는 FedCoin과 부채(통화) 사이에 전환을 제공하기 위해, 1:1 비율로 모든 Fedcoin거래가 노드의 분산 네트워크에 공개된다. 비 Fed node는 원장의 무결성을 책임지고, Fed는 Fedcoin 가치의 무결성에 대한 책임을 지며 이는 달러에 고정되어 있을 것이다. 정부발행증권이 파괴되거나 사라지게되면, FedCoin도 마찬가지로 생성되거나 사라질 것이다. 이 암호화폐는 중앙은행으로부터 구조적인 이익을 얻을 수 있다. 일상적인 사용 사례에서, FedCoin은 모든사람들에게 일종의 자금결제 시스템이다. (Fedwire) Fedwire는 은행간의 실시간 총 결제 시스템으로서, 서로의 매장량을 이전한다. 이것은 연방 준비 제도가 제공하는 유틸리티이지만, 이와 동등한 서비스가 시민들에게 열려있다면 중앙은행에 직접 계좌를 가질 수 있게 된다. 자넷 옐런(연준의장)과 회사는 연방 준비 은행 통화정책을 저해할 수도 있는 블록체인에 대해 걱정할 필요가 없다. 왜냐하면 이들은 유보금의 양을 조절하거나 이자를 지불하지 않기 때문이다. 여전히 연준은 양적완화, 유보율 변경, 이자율 갱신 등을 할 수 있는 능력이 있지만, 시장은 필요한 현금 또는 Fedcoin을 요구할 수 있다. 또한 디지털화폐는 중앙은행이 직면하고 있는 Zero Lower Bound 문제 (단기 명목 이자율이 0에 가까워 유동성의 함정을 야기하고, 중앙은행이 경제성장을 촉진하는 능력이 제한될 때 발생하는 거시경제 관점에서의 문제) 를 없앨 수 있다. 이 문제는 지폐의 존제에서 비롯된다. 단기 금리가 0에 가까워 지면 중앙 은행이 금리를 인하하여 통화 부양을 하고자 하는 중앙은행의 능력이 무력화된다. 사람들은 은행 시스템에서 현금을 인출하고 지폐를 보유하는 것이 마이너스 이자율을 받는 것보다 더 선호하게 된다. 이는 중앙 은행의 힘을 제한하지만, Fedcoin과 같은 디지털 화폐의 광범위한 사용은 이를 극복할 수 있게 해준다. 국가 일련의 거래에 대한 불변의 영구 기록은 통화 정책에 대한 실시간 정보를 제공할 것이다. 현금 흐름에 대한 투명성은 연방 준비제도 이사회와 세계가 지금 까지 본 분석 중에서 가장 확실한 데이터로 보일 것이다. 분산된 시스템을 무너뜨리는 어려움 때문에 DDoS공격이 더 어려울 것이다. 달러의 P2P거래는 현재 발생하는 비용의 극히 일부만으로도 이루어질 수 있다. 나아가 대중은 대중들은 상업적인 은행에서 연방은행이 제공하는 블록체인 계좌로 직접 이동하거나 개인 지갑으로 옮길 수 있다. 인터넷에 연결된 장치를 가진 사람은 누구나 디지털 방식으로 가치를 전송할 수 있다. 영국 은행의 보고서에 다르면 중앙은행의 디지털 통화발행을 GDP의 30%정도만 한다면, 실질금리 및 왜곡된 세금 및 통화 거래 비용의 감소로 인해 GDP의 최대 3%가 성장하는 효과를 누릴 수 있다고 밝혀졋다. 중앙은행은 또한 경기 순환의 붐과 침체를 안정화 시킬 수 있다. 그러나 여기서 신원의 문제는 크게 작용할 것이다. KYC(‘Know Your Customer’)와 돈 세탁 방지 규정은 페드코인 거래에 제한을 가할 것이다. 경제제재가 가해진 나라에 페드코인을 보내는 사용자를 상상해보자. 페드코인은 적어도 현금 처럼 자유롭게 국경을 넘어갈 수 없기 때문에 현금으로 취급될 수 없다. 또한 현재 미국 달러를 사실상의 통화로 사용하는 많은 외국 국가들은 페드코인을 채택하고 싶어할 수 있다. 비트코인을 사용하면 주소만 공개되며, 거래를 하는 당사자의 신원은 비공개로 남아 있다. 또한 주소를 수요에 따라 만들어 줄 수 있으므로 주소를 식별하는 법 집행 기관이 반드시 개인을 추적하라 수 있는 것은 아니다. 페드코인을 사용하는 경우, 모든 거래자가 중앙은행에 계좌를 가지고 있어야 완전한 익명성을 방지할 수 있다. 페드코인은 중앙은행의 암호 통화로, 연방 준비제도 이사회의 대차대조표에 대한 보편적이고, 전자적인 책임이 될 것이다. 블록체인을 사용하기 위해 시스템의 탄력성을 유지하는 것이 필수적이다. 블록체인의 핵심은 데이터 구조이며, 분산원장일 필요는 없다. 페드코인은 중앙 은행의 기관에 대한 기존의 신뢰를 의존하기 때문에 합의를 위해 블록체인을 필요로 하지 않는다. 이러한 시스템은 블록체인을 유지하는 중앙은행, 원장 사본을 유지하는 공공기관 또는 민간 기관으로 구현될 수 있다. 여기서는 중앙은행이 통화공급을 통제하는 하이브리드 모델을 제안하고, 거래를 확인하고 이중 지출을 막기 위해 분산된 권한을 가진 노드에 의존한다. 이러한 노드는 상업 은행이 될 것이다. 이러한 시스템 하에서, 비트코인과 같은 암호화폐에 요구되는 값비싼 증명을 피하고, 대기 시간을 크게 줄일 수 있다. 따라서 페드코인은 높은 처리량을 제공하고 중앙은행의 통제하에 통화정책을 남겨두는 RSCoin을 기반으로 구축할 것이다. 궁극적으로 페드코인은 속도, 안정성, 확장성 및 보안을 제공하고 이 기술이 국가 재정의 중추가 될 가능성을 입증한다. 연준이 분산 원장에 대해 지침을 내린 바와 같이 페드코인은 자산의 종단 처리 속도 및 가용성 개선 많은 기록 보관 인프라에서 신뢰의 필요성 감소 트랜잭션 기록 및 관리에서 투명성과 불변성 향상 분산 데이터 관리에 의한 네트워크 탄력도 개선 운영 및 재정적 위험 감소 를 가져올 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"Breaking the bank","slug":"breaking-the-bank","date":"2018-07-30T15:00:00.000Z","updated":"2018-07-31T00:57:25.000Z","comments":true,"path":"2018/07/31/breaking-the-bank/","link":"","permalink":"https://www.yceffort.kr/2018/07/31/breaking-the-bank/","excerpt":"Breaking the Bank 원문 5000년전 봄날, 메소포타미아에서는 한 외국인 상인이 대량의 은과 교환하여 물건을 팔았다. 그는 그 꾸러미를 집으로 가져가고 싶지 않았다. 왜냐하면 그는 추수가 끝날 무렵 다시 곡물을 사기 위해 돌아올 것을 알아씩 때문이다. 대신에 상인은 귀중품이 보관되어 있는 지역의 사원으로 돌아가서 제사장에게 은을 맡아달라고 부탁하였다. 얼마 지나지 않아 제사장의 조카가 나타나 대출을 요청했다. 그는 자신의 작물을 재배하기 위해 씨앗을 사고 싶었는데, 이는 제사장의 마음을 움직였다. 그래서 제사장은","text":"Breaking the Bank 원문 5000년전 봄날, 메소포타미아에서는 한 외국인 상인이 대량의 은과 교환하여 물건을 팔았다. 그는 그 꾸러미를 집으로 가져가고 싶지 않았다. 왜냐하면 그는 추수가 끝날 무렵 다시 곡물을 사기 위해 돌아올 것을 알아씩 때문이다. 대신에 상인은 귀중품이 보관되어 있는 지역의 사원으로 돌아가서 제사장에게 은을 맡아달라고 부탁하였다. 얼마 지나지 않아 제사장의 조카가 나타나 대출을 요청했다. 그는 자신의 작물을 재배하기 위해 씨앗을 사고 싶었는데, 이는 제사장의 마음을 움직였다. 그래서 제사장은 은화를 빌려주었는데, 그 상인이 은화를 도로 찾으로 올 때 까지 조카가 갚지 못하면 개인 돈으로 이 금액을 매꾸거나 친구들로 부터 빌려야겠다고 생각했다. 제사장은 조카의 단기 대출을 지원하기 위해 외국 상인과 장기 계약을 맺음으로써, 같은 돈을 두번 사용하여 상업 거래의 숫자를 두배로 늘렸다. 다시말해, 그는 Fractional Banking(지불 가능한 금액의 일부만 보관(reserve)하고 나머지는 대출등으로 사용하는 일반적인 은행업의 형태)를 발명한 것이다. 고고학적인 증거에 따르면, 실제로 이러한 사례가 메소포타미아에서 발생했으며, 이는 두가지 방향으로 금융 환경을 크게 변화시켰다. 첫번째, 조카가 씨앗을 살수 있게 되면서 전반적인 경제의 생산성을 높였다. 두번째, 조카가 제 때 돈을 갚을 수 없을 수도 있는 위험을 초래 했다. 몇 천년 후, 17세기 유럽에서 정부가 지원하는 중앙은행이 출현은 ‘이중지출’ 과세와 연관되었다. 왕은 전쟁에 맞서거나 도로를 건설하기 위해 상인들로 부터 돈을 빌리 것이고, 무기 제조업체, 남품업자 및 군대에 지출하기 위해 이 돈을 사용할 것이다. 이러한 돈은 순환하기 시작했고, 경제활동과 이익을 창출했으며, 각 단계에서 돈의 양은 두 배 이상으로 증가했다. 왕은 일반적으로 이익에 부과된 세금으로 대출금을 상환했고, 이는 오늘날 우리가 사용하는 은행시스템의 시작을 나타냈다. 첫째, 기업들은 JP모건이나 HSBC와 같은 민간 은행에서 돈을 빌려 노동자의 급여와 기타비용을 지불한다. 이 단계가 돈이 만들어 지는 단계다. 둘째, 소비자는 회사에서 생산된 제품을 구입하거나 은행에서 저축으로 돈을 입금한다. 마지막으로, 회사는 은행에 상환하기 위해 돈을 은행에 입금하면서, 이 순환은 마무리 된다. 이단계에서 원래 빌려준 돈은 사라졌지만, 이자는 시스템에 남아 있다. 이것이 바로 민간은행이 아무데도 없는 돈을 만들어내서 경제를 도약시키는 방법이다. 이렇게 할 수 있는 권한은 부분적으로 중앙은행에 의해 규제되며, 이는 민간 은행이 대출활동을 통해 되돌려줘야하는 자본 및 유동성의 양에 제한을 둔다. 간단해 보이지만, 이 과정은 사회에 몇가지 근본적인 문제를 야기한다. 그 중 하나는, 이러한 과정은 필연적으로 엄청난 양의 부를 통제하는 소수의 억만장자를 만들어 낸다는 것이다. 또한 이에 따른 위험을 충분히 이해하지 않고 돈을 레버리지하여 이익을 창출하는 것이 일반화 되었다는 것이다. 은행가와 정치가들이 모기지에 대한 탐욕적인 수요를 만들어 냈을때, 이는 창출된 돈의 양을 증가시켰으며, 이는 위험에 대한 더 많은 신호를 만들어 냈다. 하지만 문제의 근원은 이것이 아니다. 오늘 날에는 인구 증가, 세계 무역 및 강력한 컴퓨터와 같은 얽히고설킨 요인들로 인해 시스템을 관리하고 규제하는 것이 매우 복잡해졌다는데 있다. 더욱이 우리가 거시 경제 활동을 위해 사용하는 지배적인 프레임워크가 구식 패러다임에 기반을 두고 있다는 것이다. 예를 들어 돈을 창출하고 금리를 관리하는데 사용하는 모델은 여전히 민간은행을 크고, 활동적이며, 돈을 창출하는 요소라는 사실을 무시하고 단순한 중개자 취급을 한다는 것이다. 은행들은 그들만의 동기를 가지고 있으며, 이들의 수익 창출 전략은 시스템에 큰 불투명성을 야기한다. 2008년 모기지 위기를 아무도 예측하지 못 했던 것은 놀라운일이 아니다. 오늘날의 매우 복잡한 통화 순환은 우리가 실제로 이것을 이해하기 위해서는 전례 없는 세부적인 모델을 만들어야한다. 기술적인 한계는 오랫동안 이 거대한 과제를 막고 있었다. 그러나 빅데이터와 디지털 통화, 디지털 계약의 출현은 이를 완전히 바꾸고 있다. 경제 시스템에서 일어날 수 있는 일을 추정하기 위해, 과거 평균 데이터를 사용하는 대신 모든 개별 거래 및 거래를 시뮬레이션하여 모든 잠재적인 결과를 분석하는 것이 불가능해지고 있다. 이는 글로벌 금융의 기능과 이데올로기를 흔들어 놓고 있으며, 경제적 안전성을 좋게 만들거나 - 악화시킬 수도 있다. ¶디지털 화폐의 등장 이 새로운 기술은 지난 10년간 금융시스템을 재창조하는 것을 실행가능하게 해주었다. 대부분의 사람들이 비트코인에 대해 들어본적이 있지만, 이는 유행과 추측을 특징으로 하는 금융 기술 산업의 한 부분일 뿐이다. 여기에서 핵심은 여러 참여자가 공유하고 관리하는 데이터베이스인 '분산원장’이라는 사실이다. 공용 디지털 부기 시스템으로 생각하면 된다. 이는 비트코인과 같은 암호화폐를 가능하게 하는 기초 기술이다. 블록체인의 기본 데이터 구조는 일련의 순차적으로 암호화된 블록이다. 이러한 블록을 안정적이고 안전하게 만들기 위해 다양한 ‘증명’ 메커니즘에 의해 합의되어 업데이트 된다. 개념적으로 봤을때, 블록체인과 분산원장은 새로운 개념이 아니다. 예를 들어, 권력, 토지, 재산의 소유주가 바뀔 때마다 자연스럽게 발생한다. 여기에서 새로운 것은 다양한 실용적인 문제에 적용될 수 있는 위/변조 방지 컴퓨터 시스템과의 결합이다. 블록체인 기반의 분산원장을 위한 새로운 기술은 미국 달러보다 훨씬 효율적이고 비트코인보다 더 효율적인 디지털 화폐를 만들 수 있게 해준다. 이러한 기술을 통해 우리는 화폐 순환을 이해할 수 있는 세분화된 수준에서 거래를 모니터링하고 분석할 수 있다. 완전히 새로운 수준의 명확성을 통해 원장에서 기록된 수조건의 거래에서 발생하는 조기 경보 시그널을 인식하여 행동하는 법을 배울 수 있고, 이에 따라서 시스템과 안전성이 더 향상 될 수 있다. 이런종류의 공개 원장, 실시간 모니터링은 지역 사회 전체에 걸쳐서 더 안정성을 제공할 수 있다. 예를 들어, 2008년 위기에는 수천만명 시민들의 개별 손실을 처리할 수 있는 능력이 없었다. 결과적으로 규제 당국은 훨씬 적은 수의 은행을 선별하고, 다수의 일반인들에게는 큰 고통을 줄 수 밖에 없었다. 빠르게 발전하는 이 기술은 점점 더 많은 분야에서 사용되면서 혼란이 빚어지고 있다. 비트코인은 현재 가장 잘 알려진 (또한 악명 높은) 형태의 디지털 통화이기 때문에, 그 기원과 약점, 그리고 현재 추구 되고 있는 더 유망한 형태의 코인들과 어떤 차이가 있는지 탐구해볼 필요가 있다. 비트코인은 중앙 권한 없이도 운영되는 P2P 디지털 지불 시스템으로 설계되었다. 누구나 참여할 수 있다는 것은 강점이자 약점이다. 이러한 거래는 모든 참가자가 이론적으로 볼 수 있도록 공개적으로 배포된 블록체인 원장에 기록된다. 2009년 비트코인이 시작된 이후로, 그 가격은 몇배나 올라 투기꾼들의 사랑을 받고 있다. Fractional Banking: 은행은 회사에 자금을 대출해주면서 돈을 만들어 낸다. 기업은 급여와 배당금을 지급하고, 개인은 금융회사로 부터 상품과 서비스를 구매한다. 대출금을 상환하면 앞서 '창출된 돈’은 사라지지만, 이자는 시스템에 남게 된다. Bitcoin Network: 거래는 두 당사자 사이에서 직접적으로 만들어지며, 이 과정에서 어떠한 중개자의 도움도 필요로 하지 않는다. 이 거래들은 공개적으로 전송되어 블록체인에 기록된다. 합의는 랜덤하게 선택된 검증자에 의해 유지된다. 비트코인 그 자체는 가치가 없기 때문에, 본질적으로 가격이 불안정할 수 밖에 없다. P2P Trade Coin Network: 비트코인과 마찬가지로 직접적으로 거래가 이루어지며, 블록체인에 공개적으로 기록된다. 그러나 합의는 지정된 검증자에 의해 유지된다. TradeCoin의 가치는 스폰서가 제공하는 실질 자산의 지원을 받는 다는 것으로, 상대적으로 안정적이다. 비트코인이 주는 약속은 거대하다. 비트코인의 지지자들 - 주로 기술에 정통한 이상주의자나 범죄자 - 은 결국 국가통화를 대체하는 세계 통화가 될 것이라고 생각한다. 일부는 비트코인이 '금’의 디지털 버전이라고도 이야기 한다. 이들은 금의 물리적인 속성과 수십억명의 이해관계자로부터 안정성에 대해 잊었으며, 좋은 기술은 금새 또 다른 좋은 기술에 의해 따라잡힌다는 사실을 간과 했을 것이다. 비트코인은 실제로 최초의 디지털 화폐가 아니며, 마지막 주요 디지털 통화도 아닐 것이다. 그리고 여기에는 심각한 제약이 있다. 예를 들어 초당 처리할 수 있는 트랜잭션의 수는 Visa가 평균 2000개인 것에 비해 7개 밖에 되지 않는다. 암호 화폐 네트워크 노드가 블록체인에 거래를 안전하게 추가하기 위해 거치는 과정인 마이닝은 엄청난 전기를 소모한다. 고에너지 비용 국가에서 마이너들은 전력 비용을 감당할 수 없다면 파산하게 된다. 정확한 숫자는 알려진 바 없지만, eBay, Facebook, Google을 합친 만큼의 전력을 소모하고 있다. 이 시스템은 많은 마이너들에게 권한을 분배하기 위해 설계 되었지만, 거대 마이닝 풀이 등장하면서 소수의 그룹이 비트코인 시스템을 제어할 수 있을 만큼 강력해지기도 했다. 비트코인의 사용도 제한적이다. '돈’이라는 용어는 거래, 가치, 회계 단위로 정의 된다. 비트코인의 가격대 미국 달러는 극도로 불안정하기 때문에 일상적으로 사용하는 것은 어렵다. 비트코인과 이더리움은 실제 자산이나 정부의 보증에 의해 뒷받침 되지 않는다. 결과적으로, 이들은 순전히 투기적이다. 다시말해, 이는 진짜 돈이 아니라는 것을 의미한다. 가치가 없는 것은 즉, 어떤 가격도 될 수 있다. 비트코인 애호가들은 가치 없는 본성을 미덕으로 삼고, 미래에는 모든 돈이 비트코인처럼 될 것이라고 주장한다. 이것은 기술적, 정치적인 이유에서 모두 희박하다. 그러나 최초의 성공적인 분산 디지털 화폐로서 비트코인은 인상적이다. 규제되지 않는 P2P 금융 시스템의 기본 기술과 철학은 혁신적이며, 비트코인은 큰 문제에 대한 실질적인 해결책을 제시한다. 물론 블록체인 기반 분산원장을 적용한 한가지 사례일 뿐이다. 블록체인은 결국 이념이 아니고 하나의 기술이다. 블록체인이 비트코인의 기본 원리 , 도는 현재/미래의 응용프로그램에 대한 동기와 관련되어서는 안된다. 금융 시스템의 기존 문제를 해결할 수 있는 잠재력이 있는 것처럼, 대신 금융 시스템을 억누르는데도 사용할 수 있다. 그리고 권력의 핵심요소가 돈의 통제, 즉 기존 돈과 미래 돈 창출이라고 생각할때, 우리는 이미 이 기술이 열어버린 판도라의 도덕적으로 위험한 상자를 들여다 볼 수 있다. 미국 연방준비제도이사회와 영국 은행과 같은 주요 기축통화의 중앙은행을 예로 들자. 신뢰는 종종 그 대상의 크기와 관련이 있다고 생각한다. (더 클 수록, 더 믿을 만하다.) 하지만 이들은 스스로 이런것이 중대한 실수 임을 입증했다. 이들은 인플레이션을 통해 재정적인 의무를 희석시키고, 금리와 다른 정책을 억제함으로써 '소수 약자’를 더 가난하게 만들었다. 최근 그들은 마이너스 금리를 시험하고 현금을 없애는 방법을 고민하고 있다. 더욱 놀라운 것은 일부 중앙은행이 모든 통화를 디지털화하고 구매 기록을 장부에 직접 올릴 가능성을 논의하고 있다는 것이다. 이는 민간은행에 의견을 피룍하고 정부가 경제를 절대적으로 통제할 수있게 해준다. 또한 정부가 당신이 구매하는 모든 것을 기록해두는 것을 의미할 수도 있다. 이는 점점더 가능한 계획처럼 보이고 있으며, 중국, 영국, 싱가폴, 스웨덴과 같은 국가는 이런 전략을 연구하고 잠재적으로 구현할 계획을 발표하기도 했다. 여기서 중요한 것은 기술자체가 설계적으로는 분산되어 있지만, 중앙에서 제어되는 시스템을 만드는데 사용될 수도 있다는 것이다. ¶보다 안정된 금융 시스템을 위해 블록체인과 분산원장의 발명이 금융위기나 인플레이션과 같은 문제를 근절하지 못한다는 것ㅇㄴ 사실이다. 하지만 이는 크고 강력한 주체들에게 합법적인 대안을 만들어 줄 수 있다. 이제 기술은 이전에는 경쟁할 수 없었던 규모, 신뢰 또는 정치적 안정성을 갖춘 특수화된 글로벌 통화 시스템을 형성할 수 있게 해준다. 그래서 신흥국이나 다수의 시민등 작은 플레이어들이 중앙은행에 대안을 만드는 것이 자연스러운 다음 단계가 될 수 있다. 이러한 가능성을 염두에 두고, MIT는 대규모 거래 목적에 적합한 디지털 통화를 개발하고 있다. TradeCoin은 블록체인에 영구적으로 기록되어 작물, 에너지, 광물 등 현실세계의 자산에 항상 고정되어 있을 것이다. 그렇게하면 그 가치를 안정시킬 수 있을 뿐만 아니라 대중들이 이를 쉽게 믿을 수 있게 될 것이다. 핵심 아이디어는 광범위하게 유용한 통화가 인간의 신뢰와 효율적인 무역시스템을 위해 필요로 한다는 것이다. 분산원장을 기반으로한 디지털 TradeCoin은 소규모 국가, 기업, 상인, 신용 조합, 심지어 농부들이 제휴하여 세계은행과 국제통화기금이 사용하는 국가통화만큼 신뢰할 수 있고, 대규모 유동성을 뒷받침하는 충분한 자산을 모을 수 있도록 한다. 이는 TradeCoin 회원들이 큰 플레이어들의 이기적인 정책으로 부터 약간의 보호장치를 제공할 것이다. 암호화 구조는 국제 무역에 참가하는 것 보다 더 안전하고, 쉽고, 저렴하다. 이러한 동맹이 지리적으로나 정치적으로 다양하다면, 단일기업의 지원을 받는 것보다 디폴트의 위험으로부터 더 큰 면역력을 가질 수 있다. 실제로, 이것은 1964년 상인들의 동맹으로서 영국은행에서 실시한 방법이다. TradeCoin은 비트코인을 비롯한 다른 암호화폐처럼 실제 자산에 의해 뒷받침되지 않는 성격과는 다르다. TradeCoin은 또한 사전 승인된 다양한 신뢰받는 ‘검증자’ 네트워크를 이용하여 에너지 집약적인 마이닝 과정을 피할 수 있다. 참가자들은 검증자가 51%를 지배할 수없도록 다양한 검증 노드를 선택할 수 있다. 그 결과, 빠르고 확장가능하며 신뢰할 수 있는 환경을 만드는 금융상품을 만들어 낼 수 있다. 이는 가장 최근의 기술과 고유한 가치를 지닌 금화라는 아주 오래된 아이디어를 결합하여, 멀리 떨어진 곳에서 사용해야할 '신뢰’를 부여할 수 있다. TradeCoin과 같은 통화는 오늘날의 통화보다 더욱 안전할 수 있다. 통화 순환의 과정을 감독을 위해 표시하도록 설계할 수 있기 때문이다. 아이칸(ICANN) [Internet Corporation for Assigned Names and Numbers]이 인터넷 시스템을 감독하거나, 연방준비제도이사회와 같은 규제 기관이 미국의 은행시스템을 감독하는 것 처럼, 이해관계자의 감독은 여전히 필요하다. 그러나 이들은 금융거래와 계약의 세부사항이 엄격하게 제한되어 있기 때문에 지금 당장 이런 투명성을 만드는 것이 불가능하다. 만약 2008년에 이러한 시스템이 시행되었다면, 일부 트레이더들이 주택담보대출을 통한 신용불량에 극단적으로 집중하는 것을 감시하고 주택가치의 변화를 상세하게 시뮬레이션 할 수 있었을 것이다. 나쁜 모기지 거래 패키지가 만들어지는 대신, 경고를 위한 빨간색 깃발이 있을 수 있었다. 이러한 투명성 문제를 해결하고 있다. 예를 들어, EU와 미국 주요 금융회사가 시범 프ㄱ로그램으로 사용할 수 있는 신뢰 네트워크 소프트웨어 시스템을 구축하고 있다. 그들은 독점적인 데이터를 노출하거나, 프라이버시를 침해하지 않고 서로 다른 당사자간의 거래계약을 기록할 수 있고 추적할 수도 있다. 이 소프트웨어는 또한 TradeCoin의 핵심 시스템이다. 우리는 이 코인을 두가지 방법으로 조종하는 것을 모색하고 있다. 하나는 국제 상거래를 위한 것이고 이는 작은 국가들이 동맹으로 사용하며, 다른 하나는 상품시장에서 사용하기 위해 농부들의 연합으로 구축되어 있다. 우리는 그 아이디어를 시험하기 위해 대상을 찾고 있다. 많은 돈을 통제하는 부유한 중앙은행의 이기적인 정책들에 거의 영향을 받지 않는 전세계적인 디지털 통화의 가능성을 발견한 것은 흥미로운 일이다. 실제로 새로운 대안이 등장할 가능성이 높으며, 궁극적으로는 가장 큰 기축통화와 경쟁하기 위해 일부 대안이 등장할 수 있다. 진정으로 이해할 수 있는 통화시스템을 만든다는 것은 위험을 최소화하고, 충돌을 피하며, 정부와 지나치게 강력한 기업으로 부터 자유를 유지할 수 있는 도구를 구축한다는 것을 의미한다. 그리고 그들은 전통적인 자산을 바탕으로 진정한 가치를 지니고 있다. 이는 투기 공격의 대상이 될 가능성이 적고, 단일 국가 문제로 인한 정치적인 조작 또는 인플레이션에 강력하게 대응할 수 있다. TradeCoin과 같은 차세대 암호 화폐는 현재 정치 및 경제 환경의 혼란 속에서도 세계 무역의 마찰을 극적으로 줄일 수 있다. 결과적으로 달러와 같은 주요 통화가 지배력을 어느정도 잃거나, 미국 금융 시스템이 더 잘 동작할 수 있다. 다양한 참가자들의 광범위한 동맹에 의해 뒷받침되는 이러한 분산 시스템은 세계에 더 많은 투명성, 책임성, 그리고 형평성을 가져오기를 희망한다. 2018년 2월에 등장한, MIT에서 개발중인 TradeCoin입니다. 현재 기존의 강력한 중앙은행의 무능력함으로부터 시민과 신흥국이 위험에서 벗어나고자 만든 코인으로, 특정 이해집단이 가지고 있는 실제자산을 기반을로 TradeCoin을 만들어 거래될때 사용할 수 있게끔 한다는 것을 목표로 하고 있습니다. 이제 갓 백서가 나오고, 아직 프로토타입할 대상을 찾고 있는 과정에 있지만 눈여겨 볼만 한 것 같습니다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인 사용 여부를 결정하기 위한 프레임워크","slug":"whether-blockchain","date":"2018-07-29T15:00:00.000Z","updated":"2018-07-30T05:02:21.000Z","comments":true,"path":"2018/07/30/whether-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/07/30/whether-blockchain/","excerpt":"Blockchain Beyond the Hype, A Practical Framework for Business Leaders 원문 ¶분산 원장 기술의 종류 분산원 장기술에는 세가지 종류가 있다. public, private, 그리고 두가지를 조합한 hyprid. 각각은 다른 목적을 달성하기 위해 다른 요소를 필요로 한다. 아래 그림과 같이 각각 고유한 속성을 가지고 있으며, 블록체인 정보를 읽고 편집하기 위해 다양한 형태로 액세스를 제어하고 있다. 오른쪽에서 왼쪽으로 갈수록 분산 수준이 증가하고, 트랜잭션 속도는 감소한다.","text":"Blockchain Beyond the Hype, A Practical Framework for Business Leaders 원문 ¶분산 원장 기술의 종류 분산원 장기술에는 세가지 종류가 있다. public, private, 그리고 두가지를 조합한 hyprid. 각각은 다른 목적을 달성하기 위해 다른 요소를 필요로 한다. 아래 그림과 같이 각각 고유한 속성을 가지고 있으며, 블록체인 정보를 읽고 편집하기 위해 다양한 형태로 액세스를 제어하고 있다. 오른쪽에서 왼쪽으로 갈수록 분산 수준이 증가하고, 트랜잭션 속도는 감소한다. ¶Permissionless, public, shared systems 이 시스템에서는 누구나 네트워크에 가입하고, 원장을 쓰고, 거래를 읽을 수 있다. 이 시스템에는 단일 소유자가 없다. 네트워크의 모든 사용자는 '장부’와 동일한 사본을 같고 있다. 흔히들 이야기하는 비트코인을 비롯한 것이 이에 속한다. 중앙 집중식 신뢰 포인트가 없는 이 시스템은 완전히 열린환경에서 작동하는 설계와 잠재적으로 악의적인 사용자의 행위를 방지하기 위한 구성요소가 추가되어 있다. 가장 일반적인 방법은 작업증명이지만, 이외에도 지분증명, 권한 증명과 같은 다양한 모델이 있다. 작업 증명은 계산 비용이 많이 들고 상당한 양의 전기를 사용되며, 많은 수의 네트워크 참가자가 '신뢰’를 생성할 수 있어야 한다. 그러나 이 방법을 활용하면 많은 수의 참가자가 분산되어 있는 방식으로 코드 기반 공동작업을 수행할 수 있다. ¶Permissioned, public, shared systems 이 시스템에 접근하기 위해서는 whitelist 가 필요하지만, 모든 트랜잭션을 공개적으로 볼수는 있는 환경을 제공하는 하이브리드 시스템이다. 예를 들어 특정한 사람만이 네트워크에 기록을 할 수 있지만, 모든 거래를 공개적으로 확인할 수 있는 정부 프로그램을 들 수 있다. ¶Permissioned, private, shared systems 이 시스템에 접근하고, 기록하고, 쓰기는 것은 접근권한을 가진 사람만이 가능하다. 이는 즈로 컨소시엄이 소유권을 관리하기 위해 사용한다. ¶Decision Tree A. 블록체인이 적절한 해결책이 되기 위해서는, 비즈니스 컨텍스트를 이해하는 것이 중요하다. 비즈니스에서 중개자를 제거해야하는가? 중개자를 사하는 대신에 공급업체와 직접 협력하는 것이 더 저렴한가? 예를들어 은행업계는 CORDA같은 자체 솔루션을 이용하여 송금을 관리한다. 이를 통해 기존 기술보다 빠르고 안전하게 저렴한 서비스를 제공할 수 있다. 비즈니스 프로스세스가 어떻게 수행되는지 잘 정의한다면, 블록체인이 적절한 해결책인지 파악할 수 있다. B. 블록체인을 성공적으로 적용하려면, 디지털 형식으로 자산을 표현할 수 있는 디지털화된 자산을 이용해야 한다. 예를 들어 자산이 물리적으로 형태가 변하는 경우, 블록체인에서 해당 자산을 효과적으로 관리하기가 어렵다. 예를 들어 블록체인에서 밀을 추적하고자 한다면, 블록체인을 사용해서 밀가루에서 빵이 변화는 과정을 추적하는 것은 굉장히 어렵다. C. 디지털 자산에 대해 영구적인 기록을 남길 수 있는가? 블록체인 자체가 신뢰의 원천이 되어야 하기 때문에 가장 중요한 질문이 될 수 있다. 어떤 물건의 상태에 대해 알 수 있는 신뢰 소스가 여러가지 인 경우, 이 물건을 블록체인에 효과적으로 저장할 수 없다. 영구 기록이 작성될 수 있는 경우, 디지털 자산 상태에 대한 책임 있는 모든 당사자가 블록체인 개발 이전에 새로운 비즈니스 프로세스에서 해당 상태가 어떻게 관리 되고 처리 될지에 동의하는 것이 중요하다. 이와 별도로 영구적인 기록이 남는 것이 바람직한가도 살펴 보아야 한다. 이런 영구적인 기록이 불필요하거나 비생산적인 경우, 블록체인은 적절한 솔루션이 아니다. D. 비즈니스 프로세스에 대한 속도를 판단하는 것이 적절하다. 거래가 밀리 초 이내의 성능이 필요한 경우, 블록체인은 이를 효과적으로 처리 할 수 없으므로 기존 기술로 작업하거나 블록체인이 이러한 속도를 처리할 기술이 나올 때까지 기다리는 것이 좋다. E. 블록체인에 비 거래 데이터를 저장하는 것은 바람직하지 않다. 특정 유즈 케이스에만 필요한 경우, 블록체인을 적용하는 것은 바람직하지 못하다. 그러나 거래기록의 신뢰에 의구심이 있는 경우, 블록체인이 적용될 수 있다. 개인 정보 또는 GDPR과 같은 글로벌 데이터 보호 규정과 충돌할 수 있는 데이터는 블록체인에 저장해서는 안된다. F. 업계에서 중개자 또는 신뢰 할 수 있는 파트너의 사용에 대한 특정한 요구 사항을 가지고 있다면, 블록체인을 배치하는 것이 복잡해 질 수 있다. 규제가 큰 역할을 하는 경우, 프로젝트에 규제 담당 기관을 포함하고 독점 금지 및 경쟁법과 같은 법률 준수를 보장할 수 있는 수단을 제공해야 할 수도 있다. G. 블록체인은 비용을 줄이고 실제 비즈니스 가치를 제공하는데 도움을 주기 위해, 블록체인은 디지털 자산을 둘러싼 트랜잭션 관리에 관심을 갖는 것이 중요하다. 비즈니스 문제가 계약 관계와 가치 교환을 관리하는 것이 아니라면, 블록체인을 필요로 할 이유가 거의 없다. H. 유즈 케이스내에서 정말로 공유 작업 액세스가 필요한가? 다시 말해, 네트워크 내의 구성원 중 일부/전체가 트랜잭션을 작성할 수 있어야 한다. 이러한 공유 작업 액세스가 필요하지 않은 경우 다른 기술이 더 나은 솔루션을 제공할 수 있다. I. 이용자간에 서로를 알고 신뢰한다면, 블록체인이 필요하지 않는다. 이들이 서로 잘 알지 못하거나, 신뢰가 없거나 이해관계가 잘못되어 있다면 블록체인을 사용할 만한 충분한 이유가 있다. J. 블록체인의 기능을 변경하고자 할때, 대규모 오픈소스 포럼과 같은 곳에서 논의가 필요로 하지 않는다면, 프라이빗 블록체인을 사용해야 한다. K. 거래를 비공개로 유지해야하는 경우, 프라이빗 블록체인이 적절하다. ¶Decision Tree 활용 사례 ¶분산된 GPU에 접근하기 위한 블록체인 활용 이 사용 사례는 블록체인이 분산 유휴 컴퓨팅 자원에 액세스 할 수 있도록 한다. 이 회사는 영화 특수효과에 제공하는 소프트웨어를 보유하고 있으며, 7백만명이 넘는 게임 개발자와 산업 디자이너가 사용한다. 여기에서 주요 문제 중 하나는 고객 프로젝트를 렌더링 하기 위해 대규모 그래픽 처리장치 (GPU)를 공급하는 것이다. 지금까지 중앙 집중식 클라우드 제공 업체는 충분한 처리 능력을 제공할 수 없었다. 만성적인 GPU 부족과 규모의 경제 부족으로 인해 GPU클라우드는 대다수 사용자에게 저렴한 가격으로 제공된다. 이 사례는 유휴 GPU에서 가치를 발견하고, 회사의 장기적인 문제를 해결할 수 있도록 토큰 생태계를 사용한 사례다. 이 솔루션은 블록체인을 적용하여 분산 GPU를 전세계에 공유하고, 비용을 절감하고 활용도가 낮은 GPU 낭비를 줄이고 분산된 연산 능력을 효율적으로 사용할 수 있도록 한다. A. 이 사례에서 중개자는 이미지 렌더링을 위한 GPU를 보유하고 있는 회사다. 이 중개자는 렌더링을 위한 GPU사용을 비효율적으로 만든다. 블록체인을 적용하면 기업이 비효율적인 중앙 집중식 GPU서비스를 대체하기 위해 컴퓨터의 유휴 GPU에 액세스 할 수 있는 인센티브가 만들어진다. 대략적인 추정에 다르며, 회사가 전세계에서 주소를 할다앟ㄹ 수 있는 GPU의 1%에 액세스 하기위해 토큰을 사용한다면, 이는 210억달러 이상의 인프라 구축비용과 맞먹는다. 이러한 분산 네트워크를 활용하고 현재 사용되는 중개자를 제거하는데 상당한 경제적인 유인이 있다. B. 자산은 본질적으로 디지털 자산이다. 즉 전세계 GPU 처리 용량이다. C. 이 사례에서는 자산을 관리하고 있는 엔티티가 존재하지 않는다. 회사는 거래에 대한 기록을 작성할 수 있으며, 분산된 네트워크 상태를 유지할 수 있다. D. 밀리 초 이내의 트랜잭션 성능이 필요하지 않다. E. 많은 양의 데이터를 저장할 필요가 없으며, GPU가 작업에 기여하기로 동의하고, 해당 액세스에 동의함으로써 지불하기로한 금액만 저장하면 된다. F. 스마트폰 과 컴퓨터에 설치된 GPU는 표준화되어 있다. 따라서 분산 GPU 네트워크에 참여할 수 있는지 인증하기 위해 신뢰할 수 있는 당사자에 의존할 필요가 없다. 또한 이러한 거래 매커니즘은 개방적이며 규제 준수를 위한 제 3자가 필요하지 않는다. G. 이 솔루션은 계약 관계를 관리하는 것이므로, 블록체인과 잘 어울린다. H. 공유 쓰기 액세스는 모든 당사자가 투명한 기록을 가질 수 있도록 하기 위해 필요하다. 이는 거래가 발생하고 지불이 이루어졌다는 반박할 수없는 증거를 제공한다. I. 이 사례에서는 사용자간에 누구인지 정확히 알지 못한다. J. 네트워크 업그레이드등을 위해 분산 네트워크의 기능을 제어할 수 있어야 한다. K. 이거래는 공개되어야 한다. 결과적으로 이 응용 프러그램은 Public 블록체인을 활용해야 한다. ¶의료 보험 이 솔루션은 블록체인에 대한 사용자의 의료보험 청구를 추적할 수 있게 해준다. 의료 보험 청구의 투명성을 높이고, 최종 사용자에 대한 청구르 ㄹ빠르게 해결하고, 사기를 줄이며 이러한 서비스 비용의 감소를 만들수 있다. 그리고 프라이버시 보호를 위해 프라이빗 블록체인이 사용될 것으로 보인다. A. 일반적으로 보험회사와 사용자 관계를 관리하는 취급기관의 형태로, 최종사용자와 서비스 제공업체간의 중개자를 제거하고자 한다. B. 자산은 기본적으로 디지털 방식이다. 즉, 처음부터 디지털 형식으로 만들어지며, 지불해야하는 의료서비스 거래와 관려이 있다. C. 보험회사가 블록체인을 제공하기로 결정하면, 자산을 완전히 통제할 수 있으며, 해당 자산의 상태를 디지털 방식으로 관리하고 유지하는 책임을 담당한다. D. 밀리 초 단위의 트랜잭션이 필요하지 않다. E. 의료정보과 관련된 트랜잭션만 지원하기로 되어 있기 때문에, 개인데이터가 블록체인에 직접 저장되지 않고 블록체인을 고려해볼만 하다. F. 신뢰할 수 있는 출처와 규제 준수가 필요하다는 관점에서 볼 때, 솔루션은 어려움을 겪게 된다. 의료산업은 각종 규제가 존재하며,보험 제공 업체는 특히 최종 사용자 데이터 관리와 관련해 상세한 감독을 받아야 한다. 따라서 분산원장에서 설명된 개념에 대한 최선의 선택이 아니며 다른 기술을 찾아야 한다. 그러나 규제기관이 처음부터 이 분산원장 설계 프로세스에 관여하는 경우, 성공적인 솔루션을 만들 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인은 새로운 경제가 아니고, 재난이 될 것이다.","slug":"bitcoin-would-be-a-calamity-not-an-economy","date":"2018-07-26T15:00:00.000Z","updated":"2018-07-27T00:48:35.000Z","comments":true,"path":"2018/07/27/bitcoin-would-be-a-calamity-not-an-economy/","link":"","permalink":"https://www.yceffort.kr/2018/07/27/bitcoin-would-be-a-calamity-not-an-economy/","excerpt":"Bitcoin would be a calamity, not an economy 원문 올해 초, 트위터의 CEO 잭 도시는 비트코인이 10년 안에 세계 단일 통화가 될 것이라고 선언헀다. 띠용띠용~~~ 이 발언에서 놀라운 점은 이런 대담한 예측 뿐만 아니라 비트코인이 투기성 투자 외에 다른일에도 유용할 수 있다는 개념이었다. 금융계가 작년에 암호화폐 광풍에 사로잡혀 있는 와중에도 암호화폐에서 ‘화폐’ 의 부분은 대중들의 시선에서 중요하게 인식되고 있었다. 골드만삭스의 임원이 작년에 언급했듯이, 비트코인은 현재 ‘화폐’ 라기 보다는","text":"Bitcoin would be a calamity, not an economy 원문 올해 초, 트위터의 CEO 잭 도시는 비트코인이 10년 안에 세계 단일 통화가 될 것이라고 선언헀다. 띠용띠용~~~ 이 발언에서 놀라운 점은 이런 대담한 예측 뿐만 아니라 비트코인이 투기성 투자 외에 다른일에도 유용할 수 있다는 개념이었다. 금융계가 작년에 암호화폐 광풍에 사로잡혀 있는 와중에도 암호화폐에서 ‘화폐’ 의 부분은 대중들의 시선에서 중요하게 인식되고 있었다. 골드만삭스의 임원이 작년에 언급했듯이, 비트코인은 현재 ‘화폐’ 라기 보다는 ‘자산’ 에 가깝다. 사람들이 상품이나 서비스에 대해 비트코인을 교환하는 것이 아니라, 주식이나 채권처럼 ‘투자’ 목적으로 거래하는 것이다. 이러한 인식은 현실을 크게 반영한다. 지난 몇 년 동안 비트코인 트랜잭션의 수는 크게 증가하지 않았으며, 학술 연구에 따르면 이러한 거래의 절반이 불법적인 활동과 관련이 있다고 한다. 주: 일별 트랜잭션 수. 그리고 해당 학술 연구는 나중에 다뤄 보도록 하겠습니다. 교환 매개체로서의 비트코인은 2010년에 있었던 것과 거의 비슷하다. 기존 통화 시스템에 대한 흥미로운 보환책 정도로, 법 당국을 피하거나 인플레이션에 시달리는 사회에 관심이 있는 사람들에게 주료 유용하다. (베네수엘라, 짐바브웨) 하지만 암호화폐가 정부가 운영하는 중앙은행이 통화공급을 통제하는 기존 화폐 시스템을 대체할 수 있다는 꿈은 비트코인의 핵심요소로 남아 있다. 정부는 통화 공급을 조작할 수 없고, 시장 경쟁을 바탕으로 사람들이 사용하는 통화를 결정하게 되는 그런 꿈. 하지만 그 꿈이 실현된다면 어떻게 될까? 달러와 유로가 비트코인으로 대체된다면, 그 시스템은 어떻게 적응할 것인가? 기존 경제와 금융 시스템은 어떻게 기능하게 될까? 답은 간단하다. 글쎄요. 경제와 금융 시스템은 명목화폐를 중심으로 구축되어 있으며, 중앙은행이 통화를 통제하고 ( 정부가 통화로 부채를 발행할 수 있는 능력 ) 경기 순환을 관리하고 실업과 싸우며 금융 위기를 처리하는데 도움을 준다. 비트코인이 지배적인 통화인 경제라면, 정부가 경기 침체에 대처할 수 있는 도구를 제한하고, 금융 공황이 시작된 고에서 멈추기가 어려운, 보다 불안정하며 가혹한 경제가 될 것이다. ¶당신이 원하는 것과 정반대가 될 수 있다 왜 그런지 알아보려면, 중앙은행 (미 연방준비제도이사회)이 ‘유동성’ 이라고 부르는 것을 제공하기 위해 수행하는 역할을 인식하는 것이 중요하다. 중앙은행이 돈을 찍어내서 은행에 빌려주거나 (그 돈을 경제 시스템에 투입할 것이라는 생각으로) 자산 자체를 구매하여 경제 시스템에 돈을 퍼붓는다는 생각은 아주 멋진 방법이다. 금융 위기의 시기에 유동성을 제공하는 것이 특히 중요하다. 왜냐하면 금융 위기로 인하여 은행이 대출을 줄이고, 저축하는 사람들을 줄이기 때문이다. 중앙은행은 최후의 수단을 제공하는 대부업자로, 은행폐쇄가 일어나지 않도록 막는다. 비트코인 경제에서 이런 일들을 중앙은행이 해낸다는 것은 불가능하다. (애초에 중앙은행도 없겠지만) 비트코인 프로토콜의 핵심은 총 비트코인수가 2100만개로 제한되어 더이상 발행되지 않는 다는 것이다. 이것은 공급이 결코 증가하지 않는 다는 것을 의미하기에, 그 가치를 유지할 가능성이 더 높으므로 많은 사람들이 비트코인에 매력을 느낀다. 문제는 위기가 발생하면 시스템에 유동성을 추가할 방법이 없다는 것이다. 더 많은 비트코인을 찍어낼 수 없기 때문이다. 중앙은행은 비트코인을 쌓아서 시스템에 유입시킬 수 있지만, 사람들은 이 비트코인이 제한적인지 너도나도 다 알기 때문에 별로 도움이 되지 않을 것이다. 그리고 중앙은행이 비트코인에 대한 수요를 증가시켜 사람들이 그 가격에 더욱 집착하고 소비는 덜하게 만들 것이다. 이는 금융위기에서 사람들이 원하는 것과 정반대의 행보다. 비트코인은 또한 정부가 경기 침체에 맞서기 어렵게 될 것이다. 경기침체기에는 통화정책과 재정정책을 사용하는 것이 일반적이다. 중앙은행이 금리를 낮추고, 2008년 금융위기 이후 연방준비제도이사회가 그럤듯이 자산을 매입함으로써 (이른바 양적 완화) 돈을 시스템에 쏟아붓는다. 그리고 정부는 세금을 줄이고 지출을 늘리면서 경제를 다시 움직이게 한다. 오바마 시대의 경기 부양책과 같은 방식으로 돈을 빌려서 돈을 지불하게 된다. 다시한번, 비트코인 경제는 정부의 선택을 제한할 것이다. 중앙은행은 통화를 통제할 수 없기 때문에 금리를 통제할 수 없으며, 경제에 돈을 쏟아부을 수 있는 제한된 능력만 있을 것이다. 재정 정책 역시 거의 힘을 못쓰는 것에 가깝다. 오늘날의 정부가 적자를 낸다면, 연방준비제도이사회는 그 돈을 발행해서 정부에 빌려줄 수 있다. 그것은 시스템에 유동성을 더한다. 비트코인 세계에서 정부는 비트코인을 빌려야 한다. 이는 비트코인을 더욱 가치있게 만들어 사람들이 비트코인을 더욱 소비하지 않게 될 것이다. ¶하지만 걱정하지 말라 좋은 소식은, 이런 미래가 일어날 가능성은 정말 희박하다는 것이다. 비트코인을 보편적인 통화로 만드는 아이디어는 디지털 시대의 유토피아에 완벽한 논리를 가질 수는 있지만, 실제로는 거의 의미가 없다. 비트코인 공급이 제한되어 있기 때문에 수요가 증가하면 그 가치도 상승한다. 하지만 비트코인을 소유하고 있고, 비트코인을 더 인기있게 만들 수 있다고 생각한다면 비트코인을 가지고 있는 것이 현명한 방법이다. 그래서 사람들은 비트코인을 통해 물건을 사는데 관심을 갖지않고, 투기적인 투자로 취급하는데 더 관심을 갖게 된다. 경제가 금본위제도에서 운영될때, 공급에 대한 동일한 제한이 금에도 적용된다고 생각할 수 있다. 그러나 금의 공급은 고정되어 있지 않다. 사람들이 금을 더 많이 채굴하면, 공급이 확대 되었다. 경제 성장이 금에 대한 수요를 증가 시켜 더 가치있게 만들었기 때문에, 금 가격이 상승하면 사람들이 그것을 채굴하도록 장려하여 시스템에 더 많은 금을 가져왔고, 궁극적으로는 금의 달러 가치를 상대적으로 유지할 수 있었다. 1800~1900년 사이에 금의 달러가치는 점차 작은 상승폭으로 증가했다. 반면 비트코인은 하루 동안 상승과 하락을 반복한다. 이는 순전히 투기적인 감정의 변화 때문이다. 이러한 변동성은 가치 저장소로서의 유용성을 약화시키고, 두시간후 10% 씩 가겪이 떨어지면 아무도 통화로 받아드리고 싶어하지 않기 때문에 일상적인 교환 매체로서 사용하기에는 부적합하다. 다시 말해, 비트코인에서 운영되는 금융 시스템은 금본위제의 모든 안좋은 점을 가지고 있다. 또한 비트코인을 사람들이 쉽게 사용할 수 있는 통화로 만드는데에는 장애물이 있다. 비트코인에 대한 수요가 높을 때, 광부들이 거래 처리가격을 올리면서 거래수수료가 급등한다. 지난 가을 비트코인 광란이 절정일 때, 거래당 55달러의 비용이 들기도 했다. 사람들이 비트코인을 은닉해서 가치가 오른다고 생각한다면 괜찮다. 사람들이 비트코인을 이용해 피자나 새 TV를 사고 싶어한다면? 마찬가지로 거래수수료가 폭등할 것이다. 더욱 중요한 것은 비트코인은 현대 경제가 필요로 하는 거래의 수를 감당하기 위해 규모를 확장할 수 없다는 점이다. 이 시스템은 분당 420건, 초당 7건의 거래만 처리할 수 있다는 젷나이 있다. 마지막으로 소수의 사람들이 전세계 비트코인의 너무 많은 비율을 통제하고 있다는데 있다. 이는 그들에게 가격을 조작할 할 수 있는 레버리지를 제공하고, 비트코인이 실제 통화가 되기 어렵게 한다. ¶당신 만의 화폐를 고르세요 물론 비트코인이 유일한 암호화폐는 아니다. 전세계에 수백, 수천개의 암호화폐가 있다. 비트코인처럼 블록체인에 모든 것이 구축되어 있는 것이 있고, 어떤 것은 잠재적인 세계 통화로서 매력적으로 보일 수 있는 특징을 가진 것들이 있다. 예를 들어 Litecoin은 초당 더 많은 거래를 처리할 수 있고, Monero나 Zcash처럼 익명성을 강화한 코인도 있다. 모든 암호화폐가 총 발행량 제한을 가지고 있는 것은 아니다. 다시말해 다른 암호 화폐가 달러나 유로, 위안화를 대체할 수 있고, 더 설득력있게 말하자면, 단지 하나의 교환 수단에 의존하기 보다는 여러가지 개인 화폐로 이루어진 시스템을 갖게 될 수 도 있다. 모든 사람이 자신에게 적합한 화폐를 선택하고, 소비자와 기업의 충성심을 얻기 위해 서로 경쟁하는 암호화폐를 선택한다는 아이디어는 그럴듯해 보인다. 하지만 사실 지난 몇 년 동안 우리가 목격한 암호화폐의 확산은 화폐를 대체할 가능성을 줄어들게 하였으며, 그 이상으로는 작동하기 어려울 것이다. 다양한 개인화폐가 존재하는 세계의 문제는 거래비용이 엄청나게 증가한다는 것이다. 법적으로 정부 발행 통화가 하나만 있으면 상품과 서비스에 대한 대가로 그것을 받아들일지 말지 고민할 필요가 없다. 당신이 원하는 것을 사는데 그 돈을 사용할 수 있다는 것을 알기 때문에 당신은 그 돈을 받아 들인다. 모든 사람이 암묵적으로 달러 사용을 동의했기 때문에 상업이 원활해진다. 경젱화폐가 많은 경제 (그리고 상품에 의해 뒷받침 되지 않는 암호화폐)에서는 매우 다르게 동작한다. 누군가 LiteCoin으로 지불하고 싶다면, 당신은 이 코인이 진짜 암호화폐인지, 지금 당장 문닫을지도 모르는 스캠인지 확인해야 한다. Litecoin을 원한다면 누가 그것을 받아줄지, 누가 사려고 돈을 교환할지, 환율과 거래 수수료는 어떻게 될지 고려 해야 한다. 기본적으로 통화의 확산은 거래의 효율성을 떨어드리고 비용이 많이 든다. 그리고 사용하기 어려운 통화는 교환의 매개체로서 가치가 적다. ¶여전히 돈 세탁용으로는 좋다 사실 우리는 이러한 일이 어떻게 작동하는지에 대한 역사적인 예시를 가지고 있다. 남북전쟁 수십년 동안 미국에서는 국가 화폐가 없었다. 대신 '자유은행’의 시대였다. 개별 은행은 이론적으로 '금’으로 뒷받침 되는 은행어음을 발행했다. 문제는 은행에서 멀리 떨어져 있을 수록 사람들의 은행어음에 대한 인식이 떨어질 수 있다는 것이다. 그리고 거래를 할 때 마다 그 어음을 확인해야 했다. 당신의 거래 파트너가 가치있다고 말한 가치가 있는지 확인해야 했다. 소위 살쾡이 은행 (어음을 남발한 뒤에 먹튀하던 은행) 이 우후죽순으로 생겨나서 사람들의 돈(금, 다른 어음)을 가져가서 어음을 발행한다음, 문을 닫고, 어음을 쓸모 없게 만들었다. 이에 사람들은 은행에 대한 일종의 Yelp (각종 상점에 대한 평가를 하는 사이트) 같은 시스템을 만들어, 은행에 대한 신뢰성과 가치를 평가하기 시작했다. 하지만 이런 중앙화폐가 없음으로써 사업을 하는 것이 굉장히 느려지게 진행되었다. 이더리움, 라이트코인, 리플을 사용하는 사회도 마찬가지 일 것이다. 그렇다고 암호화폐까 쓸모없다는 것은 아니다. 반대로 정부로 부터 숨기고 싶은 거래의 경우에는 유용하게 쓰일 수 있다. 마약을 사고, 돈세탁을 하고, 자본 통제를 피하고, 초 인플레이션이 있는 환경에서 말이다. 이들은 암호 화폐가 편리할 수 있는 모든 상황이다. 그러나 암호화폐가 곧 일상 거래에 쓰이는 돈에 대한 의미있는 경쟁자가 될 수 있다는 개념은 꿈에 불과하다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"ICO라 불리우는 ICO의 문제","slug":"the-problem-with-icos-is-that-theyre-called-icos","date":"2018-07-26T15:00:00.000Z","updated":"2018-07-27T05:02:21.000Z","comments":true,"path":"2018/07/27/the-problem-with-icos-is-that-theyre-called-icos/","link":"","permalink":"https://www.yceffort.kr/2018/07/27/the-problem-with-icos-is-that-theyre-called-icos/","excerpt":"The problem with ICOs is that they’re called ICOs 원문 MIT Technology reveiw에서 전 Bank of England Crypto Sepcialist Robleh Ali와 ICO에 대해서 인터뷰한 내용 입니다. CoinDesk에서 나타난 정보에 따르면 2016년에는 2억 5천 6백만 달러를, 2017년에는 55억달러를, 그리고 2018년 1, 2월에만 30억달러 이상이 ICO에 투자된 것으로 나타났다. 참고 IPO 느낌이 나는 ICO는 투자자에게 회사의 주식이 아니라 암호통","text":"The problem with ICOs is that they’re called ICOs 원문 MIT Technology reveiw에서 전 Bank of England Crypto Sepcialist Robleh Ali와 ICO에 대해서 인터뷰한 내용 입니다. CoinDesk에서 나타난 정보에 따르면 2016년에는 2억 5천 6백만 달러를, 2017년에는 55억달러를, 그리고 2018년 1, 2월에만 30억달러 이상이 ICO에 투자된 것으로 나타났다. 참고 IPO 느낌이 나는 ICO는 투자자에게 회사의 주식이 아니라 암호통화의 토큰을 제공한다. 일반적으로 토큰은 회사가 (아마도) 미래에 (불확실함) 일구축할 일부/특정 제품 또는 서비스를 구매할 수 있는 방법을 제공한다. 이러한 엄청난 자금의 흐름은 ICO 발행자와 초기 구매자들이 그들의 토큰 가치를 높이면서 풍성하게 유지했다. 그러나 몇몇 국가에서는 투자자들이 도피하는 것을 막기 위해 규제 당국이 나서기도 했다. 다음은 영국은행의 디지털 통화 연구 책임자였던 Robleh Ali와 ICO 광풍에 대해 논의한 대담이다. ¶ICO에 대한 오해에는 무엇이 있을까? ICO의 문제는 사람들이 두마리 토끼를 모두 잡으려 한다는 것이다. '코인’이라는 단어를 사용하면 판매되는 토큰이 돈이라는 것을 알수 있다. 'Initial Coin Offering’이라는 문구는 주식을 대중에게 판매하는 기업의 IPO (Initial Public Offering)을 연상시킨다. 그들은 ‘우리는 이것이 유가 증권이 아니라, 돈이다’ 라고 말하고 싶어하지만, 그들은 또한 주식 매각에 내재된 '이 주식에 있는 돈의 가치가 미래의 기업을 사들이고 있다’는 개념 또한 어필하고자 한다. 이것이 ICO에서 가장 주된 문제 다. 명확성이 결여된 것이고, 이는 바로 고쳐야 한다. 주식을 판매한다는 개념과, 돈이라는 개념 두가지가 모두 혼용되어 있어 투자자들에게 혼란을 준다는 것을 의미한다. ¶왜 이렇게 믿을 수 없을 정도로 투기적인 투자가 빨리 인기를 얻은것인가? 사람들은 비트코인을 단돈 몇푼에 산 사람들에 대한 이야기를 들어본적이 있고, 몇천달러를 투자해서, 이제는 백만장자가 되었다. 구매자 들의 심리는 이런 것일 것이다. 공급자 쪽에서는 백서를쓰고, 웹사이트르 만들고, 비트코인 주소를 붙이면 수백만달러가 들어올 것이라는 걸 알게되면 이는 큰 유혹이 된다. 제품을 만들기 전에 도망칠 수도 있다. 이는 어떤 사람들에게는 매우 매력 적이다. 그리고 누가 이런 돈에 이끌리는 지는, 인센티브에 관한 문제다. 일부는 공인된 투자자 (미국의 경우 일정 수입이 넘는 사람들) 에게만 판매하거나, SAFT(Simple Agreement for Future Token의 준말로, 암호화폐 개발자가 공인 투자자에게 제공하는 투자계약이다. 이는 유가증권으로 간주되어 유가 증권 규정을 준수해야 한다. 토큰이 완성되고 분배하는 ICO와는 다르게, 토큰 개발에 필요한 비용을 투자받는 것이다.) 를 사용하는 경우도 있다. 그러나 많은 사람들이 ‘여기 내 웹사이트 를 봐라. 여기 내 백서도 있고, 여기서 이렇게 해서 가져가면 된다.’ 식으로 사람들을 끌어들인다. 그리고 2017년 말 실제로 많은 수의 토큰이 100배이상 뛰었고, 이것이 사람들을 유혹하고 있다. 이러한 많은 백서들이 사람들을 속이고 있다. 실제로 논문을 읽고, 어떤 기술적 주장이 옳고 그른지 식별할 수 있는 사람의 수는 상대적으로 매우 적다. 모든 사람들은 다른 사람이나 시장에 있는 신호에 의존하여 다른 이들에게 전한다. 그리고 가격이 오르는 것을 보면 쉽게 빨려들어간다. ¶앞서 언급했듯이 ICO는 공인된 투자자에게만 제한을 두고 있다. 공인 투자자들은 앞서 말한 정의를 따르면 돈을 잃을 여유가 있는 사람들이다. 그렇다면 실제로 어떤 위험이 따르는가? 모두가 돈을 잃을 수도 있고, 잃을 수도 있는 돈이라는 사실을 잘알고 있다, 라고 말하면 문제가 없다. 하짐나 공인된 투자자만 존재하는 것이 아니며, 많은 사람들이 ICO를 '100배이상 벌수 있으며 절대 떨어질리가 없다’라고 생각하고 있다. 돈을 잃을 여유가 없는 사람들은 이런 이야기에 솔깃하여 투자하고 그 돈을 잃는다. 이들은 절망적인 상황에 처에 있는 사람들이며, 이것이 나를 구해줄 수 있는 길이라고 생각한다. 또한 이런 방식으로 돈을 모으고 싶어 하는 사람들은 전체 생태계를 오염시키고 있다는 것을 인식하는 것이 중요하다. 사람들이 이것이 단지 그냥 사기꾼 무리라고 생각하면, 암호화폐에 업계에 존재하는 모든 사람들에게 좋지 못하다. ¶이전에는 불가능한 일에 대해서 ICO가 해결책이 되었던 사례는 없을까? 중소기업에 대한 주식이나 채권발행이 훨씬 쉬워졌다는 주장이 있다. 역사적으로 봤을때, 전국에 걸쳐 지역 증권 거래소가 있었던 적이 있었고, 그 개념으로 이해하는 것이 도움이 된다. S&amp;P 500에 모든 돈을 투자하는 대신, 지역 거래소가 있다면 그 중 일부를 지역 사업체 펀드에 넣을 수 있다. 토큰이 주식이고 지역 기업의 활력을 불어넣는데 도움이 된다면, 도움이 될 수 있다. 하지만 이는 기술적인 문제가 아니라, 공인투자 규제를 어떻게 개혁해야 하는지에 대한 문제다. 이는 정말로 IPO 다. 언젠가 토큰이 주식을 대표할 수 있고, 주식을 더 쉽게 팔 수 있으며, 이 기술이 그 역할을 하기를 희망한다. 그러나 이는 ICO와는 매우 다르다. ¶ICO가 단지 소수 부유한 투자자들에게만 혜택이 주어진다면 어떻게 될까? 이런식으로 주식을 발행하는 것이 매우 고성장의 기술기업에만 국한된다면, 이는 비슷한 일을 하는 다른 방법일 뿐이다. 더 넓은 기반으로 자리잡기 위해서는 지역 이발사, 차고, 정육 점 또는 그 밖의 곳에더 더 쉽게 접근 할 수 있어야 한다. 독립적인 중소기업도 활용할 수 있어야하며, 지역 고객은 주식을 구입할 수 있어야 한다. 당신이 투자한 피자가게가 유명한 프랜차이지 피자가게가 되지 않을 수 있지만, 여전히 좋은 사업이며 (암호화폐로) 투자 할 수 있다. 문제는 모두가 구글 다음의 '엄청난 기업’을 찾고 있다는 것이다. 당신이 지역사회의 사업에 지원하고 싶어서 투자하는 사업체가 많아지고, 꾸준한 성장을 하지만 10배, 100배까지는 기대하지 않는다면, 이 기술이 더 많은 사람들에게 훨씬더 유용하게 쓰일 수 있을 것이다. ¶이론상으로는, 기술에 빠삭한 이발사가 ICO를 할 수도 있지 않을까? 하지만 그럴수 있을 것 같지는 않다. 다시 문제는 ‘코인이 무엇인가’ 로 돌아간다. 이것이 ICO라는 문구가 나쁘다는 것이다. 만약 이발사가 주식을 토큰화하여 주식을 팔고 있다면, 그리고 주식을 누구에게 제공할 수 있는지, 그리고 어떤 유형의 주식을 사야하는지 규정이 세워져 그가 합법적으로 그리고 상대적으로 저렴한 비용으로 이것을 할 수 있다면, 그리고 구매자들이 주식을 사고 있다는 것을 이해 하면서 그것이 100배 이상으로 성장하지 않는다면, 이러한 모델은 괜찮다. 하지만 ‘여기 내 코인이 있다는 것을 알리고, 사람들에게 이를 구매하라고 뽐뿌질을 할거야’ 라고 한다면, 이는 좋은 결과가 아니다. 우리는 여전히 ICO에 대한 개념에 대해 이야기 하고 있으며, 이는 좀 벗어날 필요가 있다. '코인’이라는 말에는 돈을 의미하고 있기 때문에 문제가 된다. ICO의 개념은 본질적으로 결함이 있으며, 두가지 뜻을 생략하려고 하기 때문에 변경이 필요하다. ¶ICO는 뭐라고 바뀌어야 할까? 미래에 이 기술이 더 나은 시스템을 만들기 위해서 생각해 보기 위해선, 먼저 주식에 대해 생각해볼 필요가 있다. IPO라는 용어는 괜찮아 보인다. 하지만 지금의 IPO는 아주 큰 회사들을 위한 것이다. 문제는 IPO의 장벽을 낮추는 것이다. 회사의 주식을 대중에게 판매하는 개념은 괜찮다. 공유를 기록하기 위해 사용하는 데이터베이스 되신 블록체인과 토큰을 사용하는 개념도 - 만약 그런것이 필요하다면 괜찮다. 블록체인이 그 거래에서 일어나는 뒷단의 일을 간소화하고 유연하게 하는 측면에서도, 괜찮을 수 있다. 하지만 이러한 규정을 수용하기 위해 어떻게 규정이 바뀌어야 할지는 생각해 보아야 한다. 우리가 목표로 해야 할 것은 과거 지역마다 거래소가 있었던 시절이다. ICO의 열풍은, 긍정적으로 보자면 일종의 촉매제고,최악으로 보자면 의도적으로 오해를 만들고 있는 개념이자 문구다. ¶사람들이 ICO를 통해, 어떻게 이 것이 올바른 일을 하려고 하는 사람들이 운영하고 있는지를 알 수 있을까? SAFT를 이용하고 있다면, 이는 좋은 징조일 것이다. 이는 토큰 판매에 관한 법률을 공식화 하는 방법이다. 그러나 이는 공인된 투자자들에게만 팔고 있다. 그리고 당신이 이런 공인 투자자가 아니라면, 이는 매우 위험하다. 공인투자자 금융 규제법에 따라 특별한 지위를 가진 투자자다. 이에 대한 정의는 국가마다 다르다. 일반적인 공인 투자자는 벤처 캐피털, 헤지 펀드, 엔젤 투자와 같은 복잡하고 고위험의 투자를 할 수 있는 고액 자산, 금융기관, 은행, 기타 대기업을 의미한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"ICO","slug":"ICO","permalink":"https://www.yceffort.kr/tags/ICO/"}]},{"title":"In blockchain we trust","slug":"in-blockchain-we-trust","date":"2018-07-25T15:00:00.000Z","updated":"2018-07-25T23:44:31.000Z","comments":true,"path":"2018/07/26/in-blockchain-we-trust/","link":"","permalink":"https://www.yceffort.kr/2018/07/26/in-blockchain-we-trust/","excerpt":"In Blockchain We trust 원문 1990년대, 닷컴 버블은 수천억 달라의 부가 파괴되어 끝난 미쳐버린 과잉의 시기로 널려 알려져 있다. 이에 비해 덜 논의 되는 것 중 하나는, 호황기의 모든 거품이 터진 후, 가장 중요한 인터넷 혁신의 밑바탕이 될 인프라에 어떻게 자금을 지원했는지에 대한 것이다. 광섬유 케이블 출시, 3G 네트워크의 R&D, 거대한 서버팜 등에 그 자금이 투자되었다. 이 모든 것이 알고리즘 검색, 소셜미디어, 모바일 컴퓨팅, 클라우드 서비스, 빅데이터 분석, AI등 세계에서 가장 강력한 기업의 기","text":"In Blockchain We trust 원문 1990년대, 닷컴 버블은 수천억 달라의 부가 파괴되어 끝난 미쳐버린 과잉의 시기로 널려 알려져 있다. 이에 비해 덜 논의 되는 것 중 하나는, 호황기의 모든 거품이 터진 후, 가장 중요한 인터넷 혁신의 밑바탕이 될 인프라에 어떻게 자금을 지원했는지에 대한 것이다. 광섬유 케이블 출시, 3G 네트워크의 R&amp;D, 거대한 서버팜 등에 그 자금이 투자되었다. 이 모든 것이 알고리즘 검색, 소셜미디어, 모바일 컴퓨팅, 클라우드 서비스, 빅데이터 분석, AI등 세계에서 가장 강력한 기업의 기반이 된 기술을 가능하게 했다. 우리는 암호화폐와 블록체인의 붐에서 이와 비슷한 일이 일어나고 있다고 생각한다. 블록체인 회의론자들은 작년의 최고치에서 암호화폐 가격이 떨어지면서 기뻐했지만, 그들이 조롱하는 암호화폐 광신도들과 같은 실수를 한다. 그 두 부류는 가격을 암호화폐의 고유 가치라고 생각한다. 블록체인 기술을 기반으로 구축된 블루칩 산업이 어떤 것인지 아직 예측할 수 없지만, 우리는 그것이 존재할 것이라고 확신한다. 기술자체가 하나의 귀중한 자산을 창춫출하는 것이기 때문이다. 이유를 이해하기 위해, 우리는 14세기로 돌아가야 한다. 이 당시는 이탈리아 상인들과 은행가들이 복식 부기를 사용하기 시작하던 때였다. 아라비안 숫자를 채택하여 가능했던 이 방법은 상인들에게 신뢰할 수 있는 기록 보관 도구를 제공했고, 은행가들이 국제 지불 시스템에서 중개인으로서 새로운 강력한 역할을 맡게 해주었다. 하지만 현대 금융을 위한 길을 만든 것은 그 도구 자체만은 아니었다. 그것은 바로 이러한 행위가 그날의 문화에 어떻게 녹아들었는지에 대한 것이다. 1494년 프란체스코 수도자이자 수학자인 루카 파치올리는 회계를 추적하는 법 뿐만 아니라 도덕적인 의무로 복식부기를 제시한 수학 및 회계 메뉴얼을 출판함으로써 이러한 관행을 성문화했다. 파치올리가 말한 것처럼, 상인이나 은행가들이 가져간 모든 가치에 대해 그들은 무언가를 고객들에게 돌려주어야 했다. 그래서 별도의 가치를 기록하기 위해 오프셋 항목을 사용하기 시작했는데, 그것은 신용과 부채가 있는 자산, 즉 복식부기다. 파치올리의 도적적으로 올바른 회계는 이전에 불명예스러웠던 이 직업에 일종의 종교적인 축복을 주었다. 한세기에 걸쳐, 이렇게 깨끗한 회계짱부는 정직과 경건의 표시로 간주되어, 은행가를 지불의 매개자로 만들고 돈의 유통을 가속화시켰다. 이는 르네상스에 자금줄이 되었고, 세상을 바꿀 자본주의적 폭발의 길을 닦았다. 그러나 그 시스템은 사기에 영향을 주진 못했다. 은행가들과 다른 금융 관계자들은 정직한 회계장부를 보관하는데 도덕적 의무를 위반하는 경우가 많았다. 더욱이 정직한 사람들이라 할지라도, 그들은 정직에 대한 대가를 치르게 된다. 우리는 은행, 증권거래소, 기타 금융 중개인과 같은 중앙집권적 관리자들을 필수불가결한 존재로 만들어놓았고, 그리고 이들은 중개인에서 게이트키퍼로 변모했다. 그들은 수수료를 부과하고 접근을 제한하며 마찰을 일으키고 혁신을 줄이며, 시장 지배력을 강화했다. 블록체인 기술의 진정한 약속은, 당신이 밤새 억만장자가 될 수 있다는 것이아니라, 당신의 재정활동을 참견하기 좋아하는 정부로부터 보호할 수 있는 방법을 제공한다는 것이다. 이는 회계에 대한 급진적이고 분산된 접근을 통해 신뢰비용을 대폭 줄일 수 있으며, 확장을 통해 경제 조직을 구성하는 새로운 방법을 창출할 수 있다는 것이다. 신뢰와 중간자라는 필요성 때문에 구글, 페이스북, 아마존 과 같은 거대 기업들은 규모의 경제와 네트워크 효과의 경제를 사실성 독점할 수 있었다. 새로운 형태의 부기는 지루하고 고루한 성취처럼 보일 수 있다. 하지만 수천년 동안 함무라비의 바빌론으로 거슬러올라가, 원장은 문명의 기반이 되었다. 사회가 형성한 가치의 교환은 우리가 소유한 것, 빚진 것, 그리고 빚진것에 대한 서로의 주장을 신뢰가 필요하도록 요구하기 때문이다. 그리고 이러한 신뢰를 얻기 위해서, 우리는 우리의 거래를 추적하기 위한 공통의 시스템이 필요하다. 그렇지 않다면, 제프 베조스가 세계에서 제일 가는 부자이고, 아르엔티나의 GDP가 6200억 달러이고, 세계 인구 71% 가 하루 10달러도 안되는 돈으로 살아가고, 애플주식이 주당 이익에 따라 거래 된다는 사실을 어떻게 알 수 있을까? 블록체인은 전자 원장이다. 이 거래는 원칙적으로 거의 모든 것을 나타낼 수 있다. 비트코인과 같은 암호화폐의 기초가 되는 블록체인 이 있기 때문에, 실제로 돈을 교환할 수도 있다. 또 디지털 주식 인증서와 같은 다른 자산의 교환을 표시할 수도 있다. 주식을 사거나 팔라는 명령과 같은 지시도 내릴 수 있다. 무언가 전산화된 지시를 하는, 소위 스마트컨트랙트가 포함될 수 있다. 블록체인을 특별한 종류의 원장으로 만드는 것은 은행이나 정부 기관 과같은 단일 중앙 집중식 기관에서 관리하는 대신, 분산 네트워크 내의 여러 독립 컴퓨터의 사본에 저장된 다는 것이다. 원장을 제어하는 단일 요소가 없다. 네트워크에 있는 컴퓨터는 모두 원장을 추가할 수 있지만, 네트워크에 있는 다른 컴퓨터의 대다수가 변경에 동의해야 하는 수학 알고리즘인 ‘합의 프로토콜’ 에 의해 지시된 규칙을 따라야 한다. 해당 알고리즘에 의해 생성된 합의가 달성되면, 네트워크의 모든 컴퓨터가 원장 사본을 동시에 업데이트 한다. 이들 중 하나가 합의 없이 원장에 항목을 추가하거나 소급하여 변경하려고 하면, 나머지 네트워크는 자동으로 항목을 무효로 거부하게 된다. 일반적으로 트랜잭션은 암호화 장치에 의해 함께 묶인 특정 크기의 블록으로 함께 묶이며, 그 자체는 합의 알고리즘의 산물이다. 이것은 진리에 대한 불변의 공유 기록을 만들어 낸다. 즉 일이 한번 설정되면, 조작할 수 없는 것이다. 이 일반적인 틀 안에는 많은 변형이 있다. 예를 들어 합의 프로토콜에는 여러가지 종류가 이으며 어떤 종류가 가장 안전한지에 대한 의견 차이가 종종 있다. 허가가 필요없이 누구나 네트워크의 일부가 될 수 있는 퍼블릭 블록체인 원장이 있으며, 비트코인 등 대부분의 암호화폐가 이에 속한다. 디지털화폐가 없는 프라이빗형태의 ‘허가가 필요한’ 원장 시스템도 있다. 이러한 방식은 공통 기록 관리 시스템이 필요하지만 서로 독립적이며, 제조업체와 공급업체를 전적으로 신뢰하지 않는 조직에서 사용할 수 있다. 그들 사이의 공통된 실마리는 오류가 있는 인간이나 기관을 신뢰하는 것이 아니라, 수학규칙과 난공불락의 암호 원장이 완전성을 보장한다는 것이다. 이것은 마치 '삼중 입력 부기’라고 불리울 수도 있다. 차변, 대변, 그리고 세번째 항목은 불변의 확실한 공유 원장으로 사용된다. 이 분산형 모델은 현제 경제 시스템의 신뢰비용으로 비추어 볼 대 이점을 가질 수 있다. 2007년 리먼 브라더스는 회계감사관 Ernst &amp; Young이 승인한 기록적인 수익을 보고 했다. 그로부터 9년 후, 같은 자산구조로 158년을 이어온 비즈니스가 파산했으며, 이는 80년만에 가장 큰 금융 위기를 촉발 시켰다. 지난 몇년 동안 회계장부에서 인용된 평가는 확실히 빗나갔다. 그리고 나중에 리먼의 장부가 의심스러운 데이터를 가진 유일한 장부가 아니라는 사실을 알게 되었다. 미국과 유럽의 은행들은 부풀린 대차 대조표로 인한 손실을 충당하기 위해 수천억 달러의 벌금과 합의금을 지불했다. 중앙 집권화된 기업에서 내부적으로 만든 수치를 신뢰하는데 우리가 종종 높은 가격을 지불해야 한다는 것을 상기시키는 강력한 신호였다. 이러한 위기는 신뢰의 대가를 보여주는 극단적인 예였다. 하지만 우리는 또한 그 비용이 경제의 다른 대부분의 영역에서 뿌리 내리고 있었음을 알 수 있다. 세계 고층 빌딩을 가득 채우는 회계사들을 생각해보라. 그들의 업무는 회사의 장보와 비즈니스 상대방의 장부를 조화시키는 것인데, 이는 어느쪽도 상대방의 기록을 신뢰하지 않기 때문이다. 그것은 시간이 많이 걸리고, 비싸지만, 필요한 과정이다. 신뢰의 비용에 대한 다른 징후들은 우리가 하는 일이 아니라 우리가 할 수 없는 일에서 느껴진다. 20억 명의 은행계좌가 거부하고, 은행들은 자산과 신분의 기록을 신뢰하지 않기 때문에 세계 경제에서 다양한 은행계좌를 잠근다. 한 편 새로운 효율성을 구축하는 수십억개의 상호작용하는 사물인터넷의 경우에는 마이크로 트랜잭션이 중앙에서 엄청나게 비싼 중개자가 필요할 경우 불가능할 것이다. 이 문제가 혁신을 제한하능 방법에 대한 많은 다른 예가 있다. 이러한 비용은 경제 전문가가 거의 분석하거나 인식하지 않는다. 아마도 계정 조정과 같은 관행이 비즈니스의 필수불가결한 피할 수 없는 특징으로 가정하기 때문일 것이다. (인터넷이 있기전에는, 청구서를 월마다 발송하기 위해 큰 우편 비용을 지불하는 것을 당연하게 여겼다.) 이 맹점이 왜 몇몇 유명한 경제학자들이 왜 블록체인 기술을 무시하는지 설명할 수 있지 않을까? 많은 사람들은 이 비용의 정당성을 모르겠다고 말한다. 그러나 그들의 분석은 전형적으로 새로운 모델이 극복하고자 하는 광범위한 사회적 신뢰의 비용에 영향을 미치지 않는다. 하지만 점점 더 많은 사람들이 이에 대해 인식하기 시작했다. 2009년 1월 비트코인의 최초 릴리즈 이후로, 옹호론자들은 점차 월스트리트 전문가, 실리콘 밸리 기술 저문가, 세계 은행과 같은 기관의 개발 및 원조 전문가 등 자유주의 지향적인 급진주의자들로 확장되었다. 많은 사람들은 이 기술의 부상이 인터넷 경제에 중요한 새로운 단계로 인식하고 있다. 신뢰의 필요성, 비용, 중간자에게 의존하는 것은 구글, 페이스북, 아마존과 같은 거대 기업이 규모의 경제와 네트워크 효과를 사실상 독점으로 전환하는 이유 중 하나다. 이 거인들은 사실상 중앙 집중식 원장의 보관인으로, 세계에서 가장 중요한 ‘통화’ 인 '디지털 데이터’의 ‘거래’ 에 대한 방대한 기록을 작성한다. 그 기록을 통제할때, 그들은 우리를 통제한다. 이 중앙 집중식 시스템을 뒤집을 수 있는 잠재적인 약속은, 상승하지만 엄청난 변동성이 있는 가격을 보이고 있는 암호퐈폐 시장의 뒷면에 있는 중요한 요소다. 많은 투자자들은 단지 부자가 되기를 바라고 있으며, 기술이 왜 중요한지 생각하 않고 있다. 하지만 이러한 광기는 아무리 비합리적이라도 아무데서나 튀어나오지 않는다. 철도와 전기 처럼, 이 기술이 임박했을 때 추측하는 것은 불가능하다. 이는 새로운 아이디어가 등장할때 투자자들이 얼마나 많은 가치를 창출하거나 파괴할지, 어떤 기업이 이길지, 잃을지 결정할 틀이 없기 때문이다. 블록체인이 객관적인 진리를 기록하고 저장하기 위한 강력한 시스템의 약속을 이행하기 전에 극복해야할 주요 장애물이 있지만, 이 개념은 벌써 현장에서 테스트 되고 있다. IBM, Foxconn 등은 무역 금융의 장벽을 해제하고 공급망이 투명해지도록 하는 프로젝트에 대해서 블록체인의 불변성에 대한 아이디어를 활용하고 있다. 이러한 투명성은 또한 소비자가 구매하는 것의 출처에 대한 정보를 제공할 수 있다. 또 다른 아이디어는 디지털 자산에 대한 아이디어다. 비트코인 이전에는 디지털 영역에서 자산을 소유할 수 있는 사람이 아무도 없었다. 디지털 콘텐츠를 복사하는 것은 쉽고 멈추기 어렵기 때문에 MP3 오디오 파일이나 전자 책과 같은 디지털 제품 제공 업체는 고객에게 콘텐츠의 온전한 소유권을 부여하지 않는 대신 임대하고 사용자가 라이센스로 활용할 수 있는 작업을 만들어 왔다. 비트코인은 가치가 있는 항목이 디지털로 검증 가능한 고유한 것임을 보여 주었다. 아무도 원장을 조작하거나 '이중지출’을 하거나, 비트코인을 복제할 수 없기 때문에 유일한 물건 또는 자산으로 인식할 수 있다. 즉 이제 우리는 블록체인 거래에 들어가는 어떤 형태의 가치, 예를 들어 재산권이나 음악 트랙등을 표현할 수 있다. 그리고 이런 방식으로 다양한 형태의 가치를 디지털화 함으로써 우리는 그 주변에서 작동하는 경제를 관리하기 위한 소프트웨어를 도입할 수 있다. 소프트웨어 기반으로 돌아가는 이러한 새로운 디지털 자산에는 “X일 경우 Y다” 라는 특성이 부여될 수 있다. 다시 말해, 돈이 프로그래밍 가능해진다. 예를 들어 엔진을 활성화하거나 비활성화 하는 디지털 토큰을 사용하여 전기자동차를 연결하고, 스마트 컨트랙트의 인코딩된 조건을 충족시킬 수 있다. 지폐, 금속동전과 같은 아날로크 토큰과는 상당히 다르며, 이것이 무엇에 어떻게 사용될지도 상당히 다르다. 이러한 프로그램이 가능한 통화 계약을 '스마트’하게 만드는 것은 자동화가 아니다. 우리는 이미 은행이 매월 신용카드 청구서를 자동으로 지불하는 프로그램된 지침을 따르고 있다. 컨트랙트를 실행하는 컴퓨터는 분산된 블록체인 네트워크에 의해 모니터링 된다. 그것은 모든 서명자들이 공정하게 수행 될 것이라는 현명한 계약을 맺도록 보장한다. 이 기술을 통해 화주와 수출업자의 컴퓨터는 두 사람이 사용하는 분산형 소프트웨어가 디지털 통화의 지불 또는 암호학적으로 깨지지 않는 지불 약속에 대한 신호를 보내면 상품의 소유권 이전을 자동화 할 수 있다. 어느쪽도 반드시 다른쪽을 신뢰하지 않지만, 그럼에도 불구하고 제3자에게 의존하지 않고 자동이전을 수애할 수 있다. 이런식으로 스마트 컨트랙트는 자동화를 새로운 차원으로 끌어올려 훨씬 더 개방적이고 글로벌한 관계를 가능하게 한다. 프로그래밍 가능한 돈과 스마트 컨트랙트는 공동체가 공동의 목표를 추구하면서 스스로를 제어할 수 있는 강력한 방법을 구성한다. 심지어 사람들이 자신의 이익과 공동선을 동시에 제공할 수 없다는 오랜 개념인 '공유지의 비극’에 대한 잠재적인 해결책을 제공한다. 이는 지난해 열린 유엔 기후 변화 회의에서 Hack4Climate에 참여한 100명의 소프트웨어 엔지니어가 제안한 블록체인에서 더욱 분명해 졌다. 여기에서 승리한 팀은 'GainForest’라는 프로젝트를 제안했는데, 기부자는 환경 복원을 위해 취할 수 있는 입증 가능한 조치를 취하여 열대 우림에 살고 있는 지역 사회에 보상할 수 있다. 그럼에도 불구하고 이 유토피아적이고 마찰 없는 '토큰 경제’는 현실과 거리가 멀다. 중국, 한국, 미국의 규제기관들은 발행인과 토큰 거래자들을 단속하고, 그러한 통화를 세계적인 변화의 새로운 경제보델로 보기 보다는 증권법을 피하는 투기적인 부가가치적인 제도롬나 보았다. 일부 개발자들은 ICO에서 사전 판매된 토큰을 가지고 있지만 제품을 만들고 판매하기 위해 유치한 자금을 사용하지 않았다. 절대 개방성과 불변성에 가장 큰 약속을 가지고 있는 비트코인과 이더리움과 같은 퍼플릭 블록체인은 점점더 고통에 직면하고 있다. 비트코인은 여전히 초당 7번 이상 거래를 처리할 수 없고, 거래수수료도 이따금씩 금등한다. 한편, 은행과 같은 이러한 창조적 파괴에 취약한 중앙 집중화된 기관들은 이러한 기술을 파고들고 있다. 그들은 정직하게 존재하기 위하여 기존의 많은 규제와 규정에 보호받고 있었다. 그리고 이는 스타트업의 준수비용을 부과한ㄴ다. 뉴욕 주 재정부는 BitLicense가 암호화폐 송금에 부과한 부담스러운 보고절차 및 자본 요구 사항과 같은 규정은 기존 업체를 보호하는 진입장벽이 된다. 블록체인 기술의 오픈 소스 특성, 그 기술에 대한 열정, 그리고 토큰 가치의 상승은 현명하고 열정적이며 재정덕으로도 동기를 부여 받은 컴퓨터 전문가들로 구성된 글로벌 연합을 장려했다. 그들은 끊임없이 기술을 향상시킬 것이라고 가정하는 것이 합리적이다. 인터넷 소프트웨어에서 보았듯이, 이와 같은 개방적이고 확장가능한 프로토콜은 혁신을 위한 강력한 플랫폼이 될 수 있다. 블록체인 기술은 빠르게 움직이기 때문에, 비트코인이나 이더리움 등의 최신 버전 또한 빠르게 개선 될 것이다. 닷컴 버블과 같은 암호화폐 버블은 미래의 기술을 구축할 수 있는 인프라를 만들고 있다. 하짐나 중요한 차이점이 있다. 이렇게 모이는 돈이 물리적인 인프라를 구축하는데 사용되는 것이 아니라 사회기반 인프라를 구축하는데 사용된다는 것이다. 상호작용하는 개발자들 사이의 아이디어는 오픈소스 소프트웨어 라인에 성문화 되어 있다. 자유롭게 액세스 할 수 있는 코드는 아직도 상상할 수없는 수많은 아이디어를 가능하게 한다. 그리고 이것은 미래의 분산된 경제의 건설에 기초가 될 것이다. 1990년 중반, 구글, 페이스북, 우버의 등장을 예측할 수 있는 사람은 거의 없었다. 블록체인 기반 어플리케이션이 분산된 미래를 지배하기 위해 이러한 '버블’사이에서 어떤 결과를 가져올지 예측할 수 없다. 인터넷 개방형 프로토콜이든, 블록체인의 핵심 구성요소든 알고리즘 적 합의와 분산된 기록 보관의 핵심 구성요소든, 이 모든 것의 힘은 세계적인 변화를 꿈꾸고 전개할 준비가 되어 있는 혁신가들에게 완전히 새로운 패러다임을 제공하는데 있다. 그 들이 취하는 형태가 무엇이든지 간에, 이러한 어플리케이션들은 현재 중앙 집중식 경제를 지배하고 있는 많은 게이트 키퍼 기관을 혼란시키는 것을 목표로 삼을 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"ICO 위험성, 규제 그리고 책임","slug":"ICO-Risks-Regulation-Accountability","date":"2018-07-24T15:00:00.000Z","updated":"2018-07-25T04:13:20.000Z","comments":true,"path":"2018/07/25/ICO-Risks-Regulation-Accountability/","link":"","permalink":"https://www.yceffort.kr/2018/07/25/ICO-Risks-Regulation-Accountability/","excerpt":"Initial​ ​Coin​ ​Offerings​ ​(ICOs): Risks,​ ​Regulation,​ ​and​ ​Accountability 원문 ICO는 암호화폐를 사용하는 크라우드 펀딩의 유형으로, 암호화폐를 펀딩할 목적으로, 일정수의 토큰을 공개하고, 그 토큰에 관심을 갖는 사람들로부터 비트코인/이더리움/명목상 화폐등으로 교환하여 초기 자본을 확충하는 방법이다. ICO는 더 빠르고 쉬운 자본 유치 수단으로 사용되고 있다. 2017년 11월 현재 50개 이상의 기업이 ICO를 하고 있는 것으로 나타냈다. 그러나 ICO는","text":"Initial​ ​Coin​ ​Offerings​ ​(ICOs): Risks,​ ​Regulation,​ ​and​ ​Accountability 원문 ICO는 암호화폐를 사용하는 크라우드 펀딩의 유형으로, 암호화폐를 펀딩할 목적으로, 일정수의 토큰을 공개하고, 그 토큰에 관심을 갖는 사람들로부터 비트코인/이더리움/명목상 화폐등으로 교환하여 초기 자본을 확충하는 방법이다. ICO는 더 빠르고 쉬운 자본 유치 수단으로 사용되고 있다. 2017년 11월 현재 50개 이상의 기업이 ICO를 하고 있는 것으로 나타냈다. 그러나 ICO는 다양한 위험이 도사리고 있으며, 다양한 우려를 낳고 있다. 단적인 예로, 절반에 가까운 ICO가 채 4개월을 넘기지 못하고 끝난다. 암호화폐의 경우 최초의 ICO는 2013년 7월에 있었던 MasterCoin이 있었으며, 뒤이어 카르마코인이 ICO를 하면서 ICO가 지속적으로 나타나게 되었다. KIK이라는 메신저에서 ICO를 했었는데, 소셜미디어를 통해 KIK ICO에 대한 잘못된 URL을 퍼뜨려서 피싱사기가 이루어진 바가 있다. 그러나 이후 웹브라우저 Brave의 ICO로 30초만에 3천 5백만달러를 모았던 것처럼, 이러한 사기는 투자자들이 ICO로 뛰어드는 것을 막지 못했다. 그 결과 2017년 ICO는 23억달러로, 2016년에 비해 10배이상 커진 것으로 나타났다. ¶위험, 규제 및 책임 이더리움의 ICO는 ICO부문에서 지속적인 문제점을 보여준다. ICO의 상당수가 사기, 피싱, 폰지 등을 불러왔는데, 이는 전체 ICO의 10%이상을 차지한다. 미국 증권거래위원회 (이하 SEC)는 투자자들에게 ICO를 이용한 사기꾼들에 대해 경고한 바 있다. 특히 자본을 일시적으로 모금한 다음 짧은 시간 사이에 이익을 내는 다른 수단과 교환하여 이후 투자된 자금을 모두 팔아치우는 ‘pump and dump’ 사기에 대해 주의를 요하라고 경고하였다. SEC는 연방증권법을 ICO에 적용할 수 있는 권한을 가지고 있다고 밝혔으며, 모든 블록체인 토큰이 반드시 증권으로 간주하지는 않겠지만, 이를 사례 별로 관리하곘다고 밝혔다. 이 같은 조치는 투자자가 ICO에 투자하도록 장려할 수 있지만, ICO는 일반적으로 미국 투자자의 참여가 미국 정보 관할권을 벗어나지 못하도록 방지해야 한다. 일례로 SEC는 RECoin 및 DRC World의 ICO와 관련하여 사기죄로 기소한바 있다. 영국의 경우 ICO는 매우 높은 위험을 가진 투기적인 투자이며, 어떤 경우에는 사기이고 투자자를 보호할 수 없다고 경고했다. 합법적인 ICO의 경우에도 일반적으로 높은 위험을 가진 초기 개발 단계에 있으며 투자자에게는 상당한 단점이 있다. 중국의 경우 모든 ICO를 금지했으며, 더 나아가 과거 ICO의 수익금을 모두 투자자에게 환불하지 않으면 심각한 수준의 처벌을 받을 것이라고 밝힌바 있다. 한국의 경우에도 2017년 9월 ICO를 전면 금지한 바 있다. 스위스의 경우 ICO에 호의적이고 우호적인 스탠스를 취하고 있는 것으로 간주되었지만, 2017년 9월 스위스 금융당국은 불특정 코인에 대해 스위스 규정을 준수하는지에 대해 조사한 바 있다. 캐나다나 프랑스등 은 아직 ICO에 대해 이렇다할 규제지침을 발표한 바 없다. 그러나 홍콩, 뉴질랜드, 호주, 지브롤터, UAE등은 포괄적인 지침을 발표했다. 홍콩에서는 증권선물위원회가 토큰이 법적인 틀내에서 목적을 위한 증권을 구성할 수 있다고 성명서를 밝혔다. 뉴질랜드에서는 ICO와 관련해 규제에 대해 지침을 밝히기도 했다. 지브롤터와 UAE에서도 ICO에 대한 공식 지침을 밝혔다. ¶결론 ICO의 초기 성격을 감안할때, 규제 대응이 조금 늦었으며 비트코인과 마찬가지로 일부지역에서는 호의적이었지만 다른 곳에서는 그렇지 못했다. 일반적으로 비트코인과 같이 일종의 감독과 책임성이 필요없는 환경보다 ICO에서 사기의 위험이 훨씬 높다. 그러므로 ICO는 책임과 규제가 필요하며, 호주, 미국, 등 일부국가들의 경우와 마찬가지로 사례 별로 접근하는 것이 가장 적절할 수 있다. 홍콩과 뉴질랜드 처럼, ICO를 정기적인 보안관련 조례 및 법률 내에서 접근하는 것도 장점이 있다. ICO현상은 위험, 규제 및 책임 메커니즘에 대한 학술적, 실무적 고려를 필요로 하기 때문이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"ICO","slug":"ICO","permalink":"https://www.yceffort.kr/tags/ICO/"}]},{"title":"블록체인에 대한 잘못된 진실","slug":"wrong-myth-of-blockchain","date":"2018-07-23T15:00:00.000Z","updated":"2018-07-24T04:20:25.000Z","comments":true,"path":"2018/07/24/wrong-myth-of-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/07/24/wrong-myth-of-blockchain/","excerpt":"11 Common Myths About Blockchain And Cryptocurrency You Shouldn’t Believe 원문 ¶1. 블록체인은 비트코인이다 블록체인은 네트워크 전체에 분산 원장을 만들고, P2P 트랜잭션을 기록할 수 있는 기술이다. 비트코인은 은행과 같은 3자가 필요없이 두사람 사이에서 직접 거래할 수 있는 암호화폐다. 비트코인을 구현하면서 블록체인의 개념이 생겨났으며, 블록체인은 화폐 거래 이외에도 다양한 것을 기록할 수 있다. ¶2. 블록체인은 암호 화퍠로만 사용할 수 있다 블록체인은 암호화폐로","text":"11 Common Myths About Blockchain And Cryptocurrency You Shouldn’t Believe 원문 ¶1. 블록체인은 비트코인이다 블록체인은 네트워크 전체에 분산 원장을 만들고, P2P 트랜잭션을 기록할 수 있는 기술이다. 비트코인은 은행과 같은 3자가 필요없이 두사람 사이에서 직접 거래할 수 있는 암호화폐다. 비트코인을 구현하면서 블록체인의 개념이 생겨났으며, 블록체인은 화폐 거래 이외에도 다양한 것을 기록할 수 있다. ¶2. 블록체인은 암호 화퍠로만 사용할 수 있다 블록체인은 암호화폐로만 사용가능한 것이 아니며, 모든 비즈니스 및 산업에서 분산 원장의 기본 기술을 응용할 수 있다. ¶3. 블록체인에서 활동한 정보는 공개적으로 볼수 없다 블록체인 활동에서의 대부분은 추적이 가능하다. 블록체인에서 비밀을 숨길수 없으며, 범죄 또한 존재하기 힘들다. ¶4. 암호화 거래는 익명이다 많은 사람들이 비트코인과 암호화 거래가 익명이라고 잘못 생각하고 있다. 비트코인은 한주소에서 다음 주소로 얼마나 많이 보냈는지 추적가능한 공개 원장이다. 많은 정부기관이 주소를 소유자와 매핑하기위해 주요 거래소와 관계를 맺고 있다. 익명인 부분은, 주소 소유자와 사람의 관계 이다. ¶5. 블록체인은 비즈니스에서 일어나는 거래의 모든 것을 바꿀것이다 현재는 실제 프로세스가 확장하기 어렵고 거래를 확인하는데 많은 시간이 걸린다. 보안검증과 거래기록이 불변해야하는 경우 유용하지만, 그렇지 않다면 아직까지는 사용사례는 제한적이다. ¶6. 암호화폐는 불안정하여 블록체인을 믿을 수 없다 암호화폐의 가치와 블록체인의 기술 신뢰성을 혼동하는 경우가 종종 있다. 블록체인은 암호화폐이외에 많은 응용 프로그램을 보유하고 있으며, 장기적으로는 게임체인저가 될 가능성이 크다. 대부분 기술의 초기 인식과 마찬가지로, 사용사례, 인터페이스, 콘텐 츠 등은 과대평가되지만 기본 기술이 과소평과되는 경향이 있다. ¶7. 암호화폐는 범죄자에게 유용하다 분권화와 익명성이 범죄자들에게 좋은 특징임은 사실이지만, 경제/정치적으로 불안정한 환경에 있는 법을 준수하는 시민들에게는 좋은 특징이기도 하다. 부패로 인해 지방은행을 신뢰할 수 없거나 국가가 불안정해질 가능성이 있는 경우 돈을 보관하는데 유용하다. ¶8. 블록체인은 단순히 저장장치 일 뿐이다 블록체인의 이점은 저장이 아닌, 거래에 있다. 거래를 익명으로 처리하고 중개자를 제거하는 것이 큰 이점이다. ¶9. 암호화폐와 블록체인은 금융권과 기술에서만 유용하다. 더 많은 기업에서 블록체인을 활용할 수록, 평균적인 소비자들에게 알려지지 않은 것에대한 두려움이 더 커질 것이다. 이 기술이 점차 확대될 수록, 일반 대중들도 이러한 기술을 신뢰하기 시작할 것이다. ¶10. 토큰과 코인은 같은 것이다. 블록체인은 토큰과 ICO가 있다. 코인은 단순히 가치 저장소 역할을 하는 유틸리티다. 토큰은 좀더 복잡한 수준으로, 재산, 유동성, 소득, 부동산과 같은 복잡한 수준의 가치를 저장할 수 있다. ¶11. 암호화폐는 근본적으로 다른 화폐와 다르다. 블록체인을 둘러싼 너무 많은 과대 광고가 있었고, 그 중심에는 암호화폐의 '암호’측면이 있었다. 통화의 근본적인 측면은 무엇인가? 그것은 측정 단위이며, 우리가 가치를 전달하는 방식이다. 이 새로운 암호화폐에 대한 가치의 중추가 되는 자산은 무엇일까?","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인: 원리와 응용 (1)","slug":"Blockchain-Technology-Principles-and-Applications","date":"2018-07-23T15:00:00.000Z","updated":"2018-07-24T01:15:45.000Z","comments":true,"path":"2018/07/24/Blockchain-Technology-Principles-and-Applications/","link":"","permalink":"https://www.yceffort.kr/2018/07/24/Blockchain-Technology-Principles-and-Applications/","excerpt":"Blockchain Technology: Principles and Applications 원문 블록체인이 나타나기전에, 이중 지출을 막기 위해 신뢰도 있는 중앙서버가 있는 환경에서 사용되는 디지털 현금이 개념화 된 바 있다. 암호화가 향상되다 하더라도, 중앙 집중화, 익명성, 이중 지출 방지 등의 문제를 해결하지 못하면 새로운 혀태의 돈의 생존 가능성에는 의구심이 생길 수 밖에 없다. 30년 후, 비트코인은 중앙서버의 업무를 작업 증명에 기초한 합의 메커니즘으로 대체함으로써 세계적인 평판을 얻었다. 기존의 디지털 통화의 실험에","text":"Blockchain Technology: Principles and Applications 원문 블록체인이 나타나기전에, 이중 지출을 막기 위해 신뢰도 있는 중앙서버가 있는 환경에서 사용되는 디지털 현금이 개념화 된 바 있다. 암호화가 향상되다 하더라도, 중앙 집중화, 익명성, 이중 지출 방지 등의 문제를 해결하지 못하면 새로운 혀태의 돈의 생존 가능성에는 의구심이 생길 수 밖에 없다. 30년 후, 비트코인은 중앙서버의 업무를 작업 증명에 기초한 합의 메커니즘으로 대체함으로써 세계적인 평판을 얻었다. 기존의 디지털 통화의 실험에 대한 참신함과 비트코인에 의해 허용되는 지불 시스템의 분산된 특성으로, 글로벌을 넘어 기업 지배구조, 사회제도, 민주적 참여 등에 이르는 새로운 시대를 열었다. ¶블록체인 기술의 입문 ¶암호화 경제 (크립토 이코노미) 암호화 기술은 암호화를 활용하여 저장 또는 통신에서 중요한 정보를 보호할 수 있다. 처음에는 정보 보안 시스템을 위해 고안되었지만, 다른 용도에서도 널리 사용 중이다. 크립토 이코노미는 지리적 위치, 정치 구조 또는 법률 시스템에 의해 정의된 바 없지만, ‘신뢰할 수 있는 제3자를 사용하는 대신 행동을 제한하는 암호화 기술을 사용하는 경제시스템’(economic system, which is not defined by geographic location, political structure, or legal system, but which uses cryptographic techniques to constrain behaviour in place of using trusted third parties) 으로 정의내릴 수 있다. 경제의 새로운 하위 개념인 '크립토 이코노미’는 '분권화된 디지털 경제에서 재화외 서비스의 생산, 유통 및 소비를 교율하는 프로토콜&quot; 로 정의 될 수 있다. ¶블록체인 블록체인은 공개키 암호화를 바탕으로 이중 지출 문제를 제거하여 각 에이전트의 프라이빗키와 다른 모든 에이전트와 공유되는 공개키가 할당된다. 거래는 디지털 화폐의 다음 소유자가 자신의 공개키를 원 소유자에게 보낼 때 시작된다. 화폐는 해쉬된 디지털 서명에 의해 전송된다. 여기서 공개 키는 블록체인에 저장된 암호화로 생성된 주소다. 모든 화폐는 주소와 관련이 있으며, 크립토 이코노미에서 거래는 단순히 한 주소에서 다른 주소로 화폐를 이동하는 것이다. 블록체인의 두드러진 특징은 공개키가 실제 신원과 연결되지 않는 다는 점이다. 거래는 추적가능하지만 신원을 밝히지 않고도 가능하다. 이것은 추적이 불가능한 현금 거래를 제외하고는 법적 성격을 가진 특정 경제 주체자 (물리/사법적)와 관련 이 있는 화폐통화 거래와 큰 차이가 있다. ¶지불의 최종성 지불의 최종성은 ‘자금 이전 및 취소할 수없고 무조건적인 이전에 의한 의무 이행’ 이다. 명목화폐에서, 지불 최종성은 지불인, 수취인 및 중개자 역할을 하는 은행과 관련된 삼자 지불 구조내에서 은행돈과 관련하여 개념화된다. 여기에서 중개자란 암호화폐가 나타나기전까지는, 모든 지불에서 요구되는 신뢰할 수 있는 제 3자를 의미했다. 그러나 암호화폐는 신뢰할 수 있는 제 3자를 배제할 수 있는 프로토콜이다. 크립토 이코노미에서 지불 최종성에 부여되는 의미는 전통적인 은행 시스템과 다르다. 블록체인에 포함되면 거래가 최종적으로 이루어지므로 여기에서 동시에 검증 될 수 있다. ¶마이너와 컴퓨팅 문제 풀이 블록체인은 네트워크 참여자 (마이너)의 집합이 어려운 연산을 해결함으로써 연결되는 거래 기록의 사슬이다. 마이너들은 가장 효율적인 방법으로 수학적 문제를 해결하기 위해서 네트워크에서 치열하게 익명으로 경쟁하여 블록체인에 다음 블록을 추가한다. 블록보상은 마이너의 주소로 보내지며, 이 화폐를 쓰고 싶다면 마이너의 개인 키로 서명해야 한다. 시스템 전체의 채광력이 증가하면 블록 계산 난이도가 장그한다. 현재는 약 10분 에 한번꼴로 나올 수 있도록 일정하게 유지되고 있다. 초기에는 채굴이 주로 중앙/그래픽 처리 장치를 통해 개인용 PC에서 이루어졌지만, 복잡도가 증가함에 따라서 강력한 마이닝 기술을 요구하고 있다. ¶해시와 해시 함수 블록체인은 해시와 해시함수에 광범위하게 의존한다. 해시(출력)은 원래 정보(입력)을 변환한 결과다. 해시 함수는 입력을 취하여 출력으로 변환하는 수학적인 알고리즘이다. 암호화 해시 함수는 출력값을 입력값으로 바꾸는 것은 극단적으로 어려우며, 이를 다시 말하면 입력 값은 거의 하나의 단일한 출력값이다. 이를 충돌저항성이라고 부른다 ¶지분 증명과 작업 증명 작업 증명은 비트코인 프로토콜 블록생성의 핵임이다. 새로운 블록을 허용하려면 암호화된 증명이 필요하다. 트랜잭션을 확인하고 작업 증명을 계산하기 위헤 비트코인이라는 이중 SHA256 해싱 알고리즘이라고 하는 암호화 해시 함수에 의존한다. 목표값이 낮을 수록 새로운 블록을 생성하는 것이 어려워지고, 시간이 많이 소모 된다. 블록이 유효하려면 현재 대상 보다 작은 값으로 해시해야 한다. 새로 생산된 각 블록은 작업을 수행하여 생성되었음을 인정한다. 지분증명은 특정 알트코인에 의해 만들어진 작업 증명의 대안이다. 마이너의 상대적인 해시 속도에 비례하여 블록을 분할하는 대신, 지분 증명은 현재 마이너의 지분에 비례하여 지분 블록을 분할한다. 이더리움의 개발자는 지분 증명이 작업증명보다 더 많은 장점을 가지고 있다고 주장한다. ¶블록체인 기술의 전체 적인 관점 ¶비탈릭 부테린 (이더리움 최고 개발자)의 블록체인 정의 비탈릭 부테린은 블록체인에 대해 다음과 같이 정의하였다. 블록체인은 누구나 스스로 실행되는 프로그램을 자유롭게 업로드하고 내릴 수 있는 매직 컴퓨터이며, 현재와 이전의 프로그램의 모든 상태가 공개되어 있고, 체인상에서 컴퓨터 프로그램의 실행이 암호경제학적으로 강력하게 보안이 유지되며, 블록체인 프로토콜이 정의한 바 대로 정확하게 실행된다. the blockchain is a magic computer that anyone can upload programs to and leave the programs to self-execute, where the current and all previous states of every program are always publicly visible, and which carries a very strong cryptoeconomically secured guarantee that programs running on the chain will continue to execute in exactly the way that the blockchain protocol specifies. 여기서 '매직 컴퓨터’라는 말은 논쟁의 여지가 있지만, ‘원장’, ‘돈’, ‘거래’ 라는 언어를 언급하지 않음으로써 블록체인의 본질이 통화영역과 직접적으로 관련이 없다는 점을 지적한다. 그런 의미에서 블록체인은 토큰이 없는 상태로 존재할 수 있다. 블록체인이 통화가 아닌 여러 자산을 나타낼 수있도록 '데이터베이스 스키마’를 수정한다면, 해당 화폐를 완전히 없앨 수 있다. 이로 인해 어떤 종류의 자산에 대해서도 P2P 금융 어플리케이션에서 합의와 보안을 달성할 수 있는 블록체인을 만들어낼 수 있다. 그러나 이 개념은 모든 전문가가 동의하는 바는 아니다. 화폐는 보안 유지를 위한 네트워크 인센티브 매커니즈의 필수적인 요소라고 보는 이들도 있다. 부테린은 개념적인 정의를 특정 합의 알고리즘 또는 블록체인의 기술적 특성에 연결하지 않았다. 비트코인 알고리즘은 블록체인의 특징이 아니라, 블록체인을 응용한 프로그램에 불과하다. 부테린의 정의가 이전에 언급한 핵심 개념 중 '크립토 이코노미’와 ‘지불최종성’ 이 특징이 아니라, 금전적 / 경제적 영역으로 확대된 블록체인 응용의 기본적인 특성이라는 점에서 눈여겨 볼만 한다. ¶프라이빗, 퍼블릭 블록체인 공공 분산 원장은 모든 인터넷 사용자가 접근할 수 있다. 공공이라는 특성은 체인에 어떤 블록이 추가되는지, 현재 상태가 무엇인지 결정하는 과정에서 모든 사람들이 자유롭고 무조건적으로 참여하는데 기인한다. 이러한 완전히 분산된 블록체인은 검증을 위한 합의 메커니즘에 달려 있다. 비트코인의 경우 가장 많은 증명으르 가진, 가장 긴 체인에서 기록이 가능하다. 프라이빗 블록체인은 허가가 필요한 원장에 해당되므로, 조직 프로세스를 통해 사용자를 정의 내릴 수 있다. 퍼블릭 과 다른 점이라고 한다면, 분산되거나 익명성을 보장하는 정도에 있다. 두 극단 사이에는 부분적으로 분산된 블록체인이 목적과 필요에 따라서 존재한다. ¶분산 공개 원장 플랫폼의 기능 ¶전송, 수신, 가치 기록을 위한 프로토콜 비자와 같은 대부분의 지불 플랫폼은, 인터넷에 연결되어 있다하더라도 비자의 보안 통신 네트워크에 의존한다. 이는 중앙 집중식 특성을 가지고 있다는 것을 의미한다. 그러나 블록체인은 순수하게 인터넷 기반이고 비트코인의 블록체인은 분산되어 있다. 인터넷의 엄청난 네트워크 효과 덕분에 블록체인에서 분산의 수준은 단순히 가치를 전송하는 시스템에 비해 훨씬 크다. ¶인터넷 기반 가치 저장고: 동전 또는 토큰 암호화폐 블록체인은 공개 원장에 값을 보내고 수신하며 기록하는 프로토콜이다. 이러한 가치를 전달하는 컨테이너가 없이는 가치 전달이 불가능하라 것이다. 이것이 바로 경제학자들이 '돈’이라고 부르는 것이다. 돈을 사용한다는 것은 반드시 금속통화의 물리적인 존재 여부, 또는 금속물질의 가치 기준의 존재를 의미하지 않는다. 예를 들어 태평양 섬에서 화폐도구로 사용되는 직격 3.6미터 짜리의 라이라는 돌 동전과 블록체인의 원리를 비교해 보자. 돌은 비록 거대하지만, 그것이 중요하지는 않다. 중요한것은 동전의 합법적인 소유자가 누구인지에 대한 것을 정확한 순간에 결정할 수 있는 소유권 및 거래의 지속적인 기록이다. 오늘날 블록체인의 공개원장이나 데이터베이스는 단순히 암호화폐의 전송및 소유권을 매핑하는 현대적인 방법이다. 가치 컨테이너는 '동전’이라고 불리며, 이 동전의 목적은 지불 커뮤니티 구성원 간에 가치를 전달하는 것이다. 이러한 가치 컨테이너에는 또다른 화폐, 또는 금융상품이 포함될 수 있으며, 이는 가상화폐의 상태를 약화 시킨다. 엄밀히 말하자면, 가치 컨테이너 (토큰)과 통화는 동의어가 아니다. ¶협력적인 노력의 인센티브 비트코인의 생태계는 합리성, 자기 이익과 같은 주류 가정에서 출발한다. 암호화폐의 생존 가능성은 마이너들 사이에서 이타주의를 유지하는 것을 의미하며, 개인 및 체계적인 인센티브가 존재할 때 보장된다. 비트코인 생테계에서 분산된 공공 원장은 노동과 컴퓨터 처리시간에 집중되어 마이너들이 어떻게 보상받는지를 반영한다. ¶오픈소스 라이선스와 거버넌스 메커니즘 부테린이 강조한 핵심 기능은 공개 원장 통화 플랫폼 또는 토큰이 없는 블록체인 응용프로그램의 소프트웨어 변경을 허용하는 라이센스 모델이다. 표준 오픈 소스 라이센스는 사용자가 공동작업 방식으로 플랫폼을 수정할 수 있도록 하는 중요한 요소다. 오픈소스는 소프트웨어가 프로세스의 투명성의 힘을 얻을 수 있는 개발방법이다. open development method (ODM), 또는 community-led development는 이 새로운 협업 방식의 거버넌스를 설명하기 위해 만들어 졌으며, 주로 협업 및 사용자 커뮤니티에 중점을 둔다. ¶시스템의 불변성 불변성은 블록체인의 기술적인 특징이다. 전세계적으로 권위적인 중심이이 아닌 곳에서 진실을 선포할 수 있는 능력 덕분에 불변성 또는 변조에 대한 저항이 암호화폐에 내재적인 가치를 부여하는 것이다. 블록체인의 특정 개념은 완화될 수 있지만, 불변성은 그렇지 않다. 불변성이 암호화폐를 본질적으로 거래할 수 있는 가치를 만드는 것이라면, 이는 모든 것의 필수적인 가치가 되어야 한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인과 자산","slug":"blokchain-and-property","date":"2018-07-22T15:00:00.000Z","updated":"2018-07-23T05:51:43.000Z","comments":true,"path":"2018/07/23/blokchain-and-property/","link":"","permalink":"https://www.yceffort.kr/2018/07/23/blokchain-and-property/","excerpt":"Blockchain and property 원문 ¶블록체인은 부동산 시장을 이치에 맞게 조정해준다. 현대 부동산 시장의 거래에는 마찰이 많이 존재한다. 부동산 인프라는 느리고 비싸며, 취약하다. 미국에서 판매되는 주택의 경우 거래 비용이 최대 10%를 차지하고 있는 것으로 나타났다. 현재의 부동산 거래는 중개인, 정부 데이터베이스, 에스크로 회사, 변호사, 검사관, 감정인 및 공증인을 포함한 여러 중개인에 의존한다. 단기적으로는 계약과 승인을 실시간으로 공유하게 된다면, 우편 및 배달로 인한 지연이 줄어들 수 있다. 실제로 골","text":"Blockchain and property 원문 ¶블록체인은 부동산 시장을 이치에 맞게 조정해준다. 현대 부동산 시장의 거래에는 마찰이 많이 존재한다. 부동산 인프라는 느리고 비싸며, 취약하다. 미국에서 판매되는 주택의 경우 거래 비용이 최대 10%를 차지하고 있는 것으로 나타났다. 현재의 부동산 거래는 중개인, 정부 데이터베이스, 에스크로 회사, 변호사, 검사관, 감정인 및 공증인을 포함한 여러 중개인에 의존한다. 단기적으로는 계약과 승인을 실시간으로 공유하게 된다면, 우편 및 배달로 인한 지연이 줄어들 수 있다. 실제로 골드만 삭스는 블록체인 기술이 부동산 소유권 보험 시장에서만 연간 2~4억달라의 비용절감 효과를 얻을 수 있다고 내다 봤다. 또한 모든 당사자가 불변의 동일한 사본을 유지하므로 문서를 조정할 필요가 없다. 또한 값비싸고 많은 시간이 걸리는 기능을 블록체인 및 스마트 컨트랙트로 대체할 수 있다. 임대로, 예금, 수수료 지불 등은 자동화 될 수 있다. 에스크로 어카운트는 스마트 계약 및 다중서명 지갑을 중심으로 재설계 될 수 있다. 임대료 예치에 대한 분쟁과 같이 중립 당사자의 중재가 필요한 다른 거래에도 이러한 동일한 인프라를 사용할 수 있다. 장기적으로 블록체인 기반 레지스트리는 P2P 자산 전송을 허용하여 거래 시간을 수개월 또는 수주에서 수분으로 줄일 수 있다. 거래비용은 판매당 수천달러에서 획기적으로 감소시킬 수 있다. 거래의 용이성과 안전성은 또한 재산권을 효율적으로 분리 하는 것을 가능하게 한다. 토지 소유자는 이웃에게 신속하고 저렴하게 토지를 팔 수 있다. 투자자 들은 임대 지분을 소액으로 매입하고 자동 지불을 통해 임대료의 일부를 받을 수 있다. 이를 통해 전체 토지를 살 여유가 없는 개인은 상대적으로 적은 금액으로 부동산에 투자할 수 있다. 이러한 추세는 금융을 포함하여 막대한 영향을 미칠 수 있으며, 여러 법률 조항에 걸쳐 퍼져 있는 소규모 보둥산 투지를 위한 중개 시장을 창출 할 수 있다. 2020년 까지 부동산 투자가 전체 부동산 투자의 50%이상으로 늘어날 것으로 내다보고 있으며, 블록체인은 지역에 제한되지 않는 부동산 투자자들을 소개함으로써 이러한 추세를 증폭시킬 수 있다. 분산되어 있고, 결함에 유연하며, 사실상 불변이기 때문에 블록체인은 전통적인 트랜잭션 및 기록 보관 시스템에 비해 보안과 탄력성 측면에서 이점을 제공한다. 아이티에서 2010년 지진으로 ‘소유권 증서 및 토지 등기부 등본이 파괴된 사건이’ 발생한 것처럼 파괴에 취약한 단일 중앙 저장소가 없기 때문에 기록은 안전하게 유지될 수 있다. 이러한 거래로 인해 발생하는 사기 및 오류는 모든 거래 행위를 추적하는 불변의 원장으로 축소될 수 있다. 이 기회는 국가 토지 등록 기관 및 소유권 보험에 대한 영향을 미칠 것이다. 소유권 증명이 블록체인에 불변하게 남게 되므로 소유권 보험 설정의 필요성이 줄어 든다. 보다 완전하고 신뢰할 수 있는 부동산 기록을 작성하면, 이는 부동산 관리인 감독 기관 및 토지 관리 회사의 중요한 자산이 될 것이다. 궁극적으로 재산권의 공식화, 현대화 및 토지 관련 데이터 수집 및 분석을 촉진할 수 있는 블록체인의 능력이 토지 지배 구조 개선을 위한 파괴적인 기술이 될 것이다. ¶블록체인 통합을 위한 조건 ¶신원 확인 솔루션 토지 등록 부에서는 어떤 자산에 대해 특정인이 어떤 권리를 가지고 있는지 알려준다. 따라서 이 '누구’를 아는 것은 중요하다. 토지, 건물, 문서등은 체인에 연결 될 수 있지만, 신원은 어떻게 확인해야 할까? 2017년 캐나다에서는 SecureKey라고 하는 블록체인 기반 ID 시스템을 개발한 바 있다. 두바이와 우크라이나에서는 정부를 ‘체인에 연결할’ 의도를 내비친 바 있다. 부산 블록체인 기반 ID플랫폼이 개발 중이며, 이를 실행가능한 옵션도 포함되어 있다. 여기에는 uPort, Civic 등의 솔루션이 있으며, 개인 디바이스가 없는 사람들을 위해 쓰이는 EverID도 있다. 여기서 언급하고자 하는 것은 이러한 시스템의 개발을 기다리라는 것이 아니고, 기존의 디지털 ID 시스템을 활용해야 한다고 생각한다. 예를 들어 스웨덴의 대형 통신회사인 Telia가 신원을 확인하기 위해 디지털 키를 제공한 바 있다. 인도에서는 Aadhaar라는 시스템이 있으며, 에스토니아 또한 강력한 비-블록체인 시스템을 갖고 있으며, 미국에서는 login.gov, 사회보장국, 또는 주정부의 DMV가 토지 등록부에 신원을 증명하는 모습을 상상할 수 있다. 새로운 시스템을 만드는 것 보다 기존에 잘 작동하고 있는 ID시스템을 활용하는 것이 훨씬 좋다. 이는 신원 확인은 별도의 기술 세트를 필요하므로, 확실히 검증된 시스템을 사용하는 것이 고품질의 정보를 가져져올 수 있다. 한 전문가는 ‘유저의 신원을 확인하는 것은, 시스템이 작동하기 위하여 중요한 요건이지만, 시스템에서 거래하는 모든 사람들에게 디지털 ID를 위한 요구사항이 부과되면, 아직 평등하지 못한 개발도상국의 진전을 방해할 것’ 이라고 주장하기도 했다. 여기에는 동의하지만, 어쨌든 디지털 산원정보 시스템을 더 먼저 해결되어야 한다고 생각한다. ¶디지털화 된 등기 해시는 임의의 데이터를 고정된 크기의 비트 문자열로 매핑하고 역으로 다시 해독될 수 없게 하는 수학적 알고리즘이다. 이 해싱의 특징중 하나는 충돌저항으로, 동일한 해시를 생성하는 입력값을 찾기가 매우 어렵다. 또한 해싱은 약간의 변경만 있어도 왕전히 다른 해싱값을 생성하게 된다. 문서를 해시하고, 그 해시를 공개 체인에 게시함으로써 문서 자체를 게시하지 않아도 된다. 종이 문서는 해시할 수 없으므로 (사실 이미지도 일련의 string의 집합이므로 해싱이 가능하다.) 문서를 스캔한 뒤에 해시할 수 있다. 따라서 블록체인에 통합되기전에 모든 기록을 완전히 디지털화 해야 한다. 스웨덴과 조지아는 블록체인에 통합하기 전에 모든 기록을 디지털화 하였다. ¶다중 서명 지갑 만약 누군가 열쇠를 훔치거나, 분실하게 되면 어떻게 될까? 만일 누군가 머리에 총을 겨누고, 실제 열쇠 없이 디지털 서명만 하게 되면 어떻게 될까? 블록체인에 내장된 public-private 암호화 키는 키를 보유한 개인만이 등록하거나 전송할 수 있게 해준다. 그러나 이 키를 분실하거나 도난당하면 키와 관련된 재산을 복구해야 한다. 법적인 논의가 필요하겠지만, 하나의 명확한 해결책은 다중 서명 지갑이다. 이 지갑은 트랜잭션이 완료되기 전에 단일 키가 아닌 최소 여러개중 한개의 키로 검증되어야 한다. 판매자가 단순히 '판매’를 누르는 대신, 등록된 기관은 판매자와 은행가가 거래에 서명하도록 요구할 우 있다. 혹자들은 공증인이 두번째 서명자로 있어야 한다고 하지만 그렇지 않다. 블록체인 기반 플랫폼이 이미 쇠퇴하고 있는 구식 시스템에 엮여있을 필요는 없다. 공증인은 기술혁신에 직면하여 후퇴하고 있는 시스템 중 일부다. 미국에서 공증인은 역사적으로 신원을 보증하기 위하여 사용되었지만, 현대에 이르러서는 필요치 않다. 예를 들어, 은행 가 및 등록 기관과 같은 유효한 거래에 권한을 가진 다른 이해 관계자가 두번째 서명인 역할을 할 수 있다. 신원이 확인되고 모든 거래가 불변의 원장에 존재하면, 블록체인에서는 공증인이 필요하지 않으며, 비용또한 저렴하다. ¶프라이빗 혹은 하이브리드 블록체인 블록체인 기반 등기에는 특별한 형식이 있는 것은 아니지만, 어떤 형태로든 프라이빗 블록체인을 사용하는 것이 좋다. 그이유는 아래와 같다. 1. 사법부와 등기부는 원장을 조정할 수 있어야 한다. 비트코인과 이더리움과 같은 공개 체인에는, 공개 키로 식별된 두명의 당사자가 거래한 기록과 여기에 추가된 코멘트만 존재한다. 일반적으로 사기성 데이터가 입력된다면, 이를 수정할 수 있는 유일한 수단은 이전 항목을 뒤집는 또다른 트랜잭션 밖에 없다. 만약 법원이 한 배우자가 집을 소유해야 한다고 결론 내리지만, 다른 배우자가 이전하기를 원치 않는다면? 키를 잃어버리거나 전달하지 않고 죽는다면 소유권은? 공공 인프라 건설을 위한 비상장 토지는? 이런 것들은 공공 블록체인에서 모두 답하기 어렵다. 그러나 이러한 결정은 프라이빗 체인에, 그리고 재산권에 대한 내용은 해시되어 기재되는 퍼블릭체인에 있는, 두체인을 모두 활용하는 하이브리드 체인이라면, 등기부와 사법부에 적절한 권한을 부여하여 해결할 수 있다. 이는 실제 자산을 관리할때 중요하다. 만약 정부가 이 권한을 남용한다면? 이는 분명한 위협이지만, 블록체인의 주요한 요소중 하나는 모든 거래를 기록한다는 것이 아니다. 따라서 이러한 예외적으로 처리되는 경우에 대해서는 필요하지만, 이것이 비밀리에 시행될 필요는 없다. 모든 거래는 프라이빗 - 퍼블릭체인에 기록되고 액세스 가능한 사람들에게 볼 수 있기 때문에 적절하게 구성되면 권한을 식별하고 수정하는 것이 용이하다. 2. 퍼블릭 체인이 처리하기에는 데이터의 크기가 크다. 등기에는 증서, 제목, 지도 등이 있다. 이 모든 문서는 어딘가 보관해야 하지만, 퍼블릭체인에는 이렇게 많은 양을 넣을 수 있다. 물론 이런 문제를 해결하기 위해 IPFS, Swarm, Sia, Storj, Maidsafe와 같은 분산형 저장 전송 시스템들이 나오고 있지만, 아직 초기단계에 있다. 등기는 일반 서버에 문서에 문서를 저장하고, 해시를 퍼블릭 체인에 게시할 수 있지만, 실제 데이터의 블록체인 기반 레코드가 필요한 경우 등기는 프라이빗 블록체인을 사용해야 한다. 3. 익명성은 선택사항이 아니다. 등기는 부동산을 등록하거나 이전하는 사람ㅇ르 알아야 한다. 퍼블릭 블록체인을 사용하면 키를 가진 사람이 누구든지, 자신이 무엇인지 든 관계 없이 유요한 트랜잭션을 전파할 수 있다. 등기가 올바른 신원을 확인한 당사자만이 거래할 수 있는지 확인하려면 프라이빗 블록체인이 필요하다. 재산세가 있는 지역에서는 세제 당국이 세금을 부과하기 위해 공개 키 이상을 요구할 수도 있다. ¶등기는 가능한 정확해야 한다. 블록체인은 불변성을 가지고 있으므로, 블록체인으로 전송되는 기존 데이터가 모두 정확한지 확인해야 한다. 디지털이든, 종이든, 기존 모든 등기에는 부정확성이 포함되어 있을 수 있다. 오류의 원인은 양성일 수 있지만, 사기와 부패는 항상 위험을 초래한다. 이상적으로는 등기가 불변의 플랫폼에 올라가기전에 모두 정리되고 최신의 상태여야 한다. 그러나 현실은 등기를 정리하는 것이 어느정도 위험성도 가지고 있다는 것이다. 등기를 투명성을 높이고 거래비용을 절감할 수 있는 플랫폼으로 끌어올리면 신속하게 정리가 가능하다. 서류 등기의 경우 특히 그렇다. 디지털화가 되기 전까지 오류를 찾는것이 매우 어렵다. 등기가 사용중이며 공개 기록으로 작동하는 경우에는 가능한 유용한 기술로 있어야 한다. 신기술로 전환하면, 오류가 있거나 충돌하는 기록이 표면적으로는 체계적으로 처리 될 수 있다. 레코드에 플래그를 지정할 수 있으며, 구현을 지연시키지 않고 모든 당사자에게 발언권을 주는 프로세스를 시작할 수 있다. 그러나 등기가 오류 투성이라면, 블록체인을 통합하기전에 그러한 오류를 처리하기 위해 자원이 소모될 수 있다. ¶연결성과 기술에 대한 인식 디지털 플랫폼을 채택하기전에 비용 및 지원 요구 사항을 고려해야 한다. 초기에는 추가 비용이 들어 매력적이지 않게 보일 수 있지만, 새로운 시스템은 여러가지 운영 비용을 제거할 수 있다. 블록체인 소프트웨어는 복잡하고, 하드웨어 요구사항은 상당하다. 대부분의 에이전시가 이를 사내에서 책임을 감당하기는 어렵다. 따라서 인프라 및 소프트웨어의 서비스화 모델 (IaaS&amp;SaaS)의 확산이 필요하다. 이 모델을 통해 초기에 많은 자금을 투자하는 대신 가입 기준으로 서버 및 소프트웨어를 구매할 수 있다. 이는 일종의 BaaS (Blockchain as a Service)다. 선불비용은 없는 대신, 자동비용지불로 대체 될 것이다. 그러나 유지 보수 및 문제 해결 비용은 공급업체에서 부담하므로 매우 낮은 에러율을 담보해야 한다. 퍼블릭 블록체인이 강력해졌지만, 지갑, 거래, 스마트 컨트랙트 같은 2차 소프트웨어는 해커들의 목표가 될 수 있으므로, 전문적인 수준의 품질 보증과 관리가 필요하다. 연결이 제한되거나 소비자가 디지털 거래에 익숙하지 않은 곳에서는 블록체인이 최적이 아닐 수 있다. 시스템이 디지털화 되어 있지 않다면, 디지털화 부터 시작해야 할 것이고 이 때 부터 이미 큰 도전일 것이다. 자메이카 등기부는 직원을 재교육하고 사무실 문화를 변화시켜 새로운 디지털 시스템을 작동시켜야 했고, 블록체인 시스템으로 이동하는 것은 이와 비슷한 수준의 도전일 것이다. ¶시스템을 활용할 사람들에 대한 교육 이 새로운 시스템이 제대로 작동하기 위해서는 모든 당사자들이 새로운 시스템에 대해 교육 받아야 한다. 전환 초기에 블록체인과 사옿작용할 전문 커뮤니티를 참여시키는 것이 중요하다. 이를 위해서는 먼저 블록체인의 기본개념, 능력, 단어 등을 공부해야 한다. 블록체인 등기부에 대한 기술적, 구조적 요구사항에 대한 명확한 비전이 있더라도, 교육과 역량 구축이 필요할 것이다. ¶블록체인 등기 시스템 도입을 위한 프레임워크 Blockchain Property Registry Adoption Levels Source: Future of Property Rights program, New America Level Name 설명 예시 0 통합 없음 블록체인을 사용하지 않음 대부분의 경우 1 블록체인 기록 토지거래와 관련된 기록을 퍼블릭 블록체인에 기록하기 위해 사용 브라질, 조지아, 두바이 2 스마트 워크 플로우 블록체인이 거래 과정을 기록하는데 사용됨 스웨덴, 두바이 3 스마트 에스크로 에스크로에 스마트 컨트랙트가 활용됨 Propy 4 블록체인 등기 중앙 데이터베이스를 허가된 블록체인으로 대체 두바이이, 조지아 5 권한 분리 단일 구획에 대한 다양한 권리가 블록체인에서 분리되어 관리됨 없음 6 분산된 권리 다양한 소유주에게 분배된 권리가 블록체인에서 관리됨 없음 7 P2P 거래 레벨4 시스템 내에서 중개자 없이 거래가 이루어짐 없음 8 정보처리 상호 운용 다양한 등기 블록체인이 합쳐짐 없음 ¶부동산에서의 블록체인의 미래 블록체인이 부동산 및 토지 분야에서 널리 사용되기 위해서는 많은 장애물이 있다. 상호운영성을 위한 표준 프로토콜이 부족하고, 퍼블릭 블록체인이 소멸될 수도 있는 가능성도 있다. 또한 데이터 보안을 손상시키지 않으면서 트랜잭션의 속도도 증가해야 한다. 수많은 마이크로 트랜잭션이 발생한다면, 이를 유지하기 위해서는 적절한 처리량 대비 속도가 있어야 한다. 이는 합의 메커니즘에 달려 있다. 작업 증명은 대규모 블록체인에서는 성공적이 었지만, 느리고 많은 에너지를 필요로 한다. 이더리움의 지분증명 메커니즘은 아직 입증되지 못헀다. 미국 많은 주에서 스마트 컨트랙트 및 블록체인 기록을 인정하기 위해 움직이고 있지만, 의회가 충분히 이 기술을 정의할 수 없어서 초기 법안이 계류하고 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"property","slug":"property","permalink":"https://www.yceffort.kr/tags/property/"}]},{"title":"블록체인으로 스마트 그리드의 보안을 향상시키는 방법","slug":"how-blockchain-help-increase-the-security-of-smart-grids","date":"2018-07-20T15:00:00.000Z","updated":"2018-07-21T11:20:27.000Z","comments":true,"path":"2018/07/21/how-blockchain-help-increase-the-security-of-smart-grids/","link":"","permalink":"https://www.yceffort.kr/2018/07/21/how-blockchain-help-increase-the-security-of-smart-grids/","excerpt":"How Blockchain Can Help Increase The Security Of Smart Grids 원문 블록체인은 많은 산업을 혼란에 빠뜨릴 수 있는 뜨거운 기술이다. 이 기술은 스마트 전력망 관리 시스템이 자동적으로 문제와 비상사태를 진단하고, 이에 대한 대응을 재구성 한다는 점에서 견인력을 얻는다. 이는 지난 2016년 러시아가 미국에서 최소한 한개 이상의 전력망을 성공적으로 해킹했다는 점에서 의미가 있다. 스마트 그리드의 보안은 무엇보다 중요하다. 블록체인기술은 상호 연결성, 데이터 교환 및 권한 제어의 향상된","text":"How Blockchain Can Help Increase The Security Of Smart Grids 원문 블록체인은 많은 산업을 혼란에 빠뜨릴 수 있는 뜨거운 기술이다. 이 기술은 스마트 전력망 관리 시스템이 자동적으로 문제와 비상사태를 진단하고, 이에 대한 대응을 재구성 한다는 점에서 견인력을 얻는다. 이는 지난 2016년 러시아가 미국에서 최소한 한개 이상의 전력망을 성공적으로 해킹했다는 점에서 의미가 있다. 스마트 그리드의 보안은 무엇보다 중요하다. 블록체인기술은 상호 연결성, 데이터 교환 및 권한 제어의 향상된 보연 표준에 대한 해답을 제시할 수 있다. ¶에너지 스마트 그리드와 관련된 두가지 기본적인 보안 관련 문제 스마트 그리드는 자동화 및 원격 액세스에 의존한다. 개인이나 적대적인 의도를 가진 주체가 해킹할 가능성은 이미 발생하고 있다. 반드시 해결해야 하는 두가지 보안 문제는 아래과 같다. 인증: 스마트 그리드에 접근하는 사람은 그가 누구인지 인증해야 한다. 승인: 인증 받은 사람이 그러한 작업을 처리할 수 있다는 권한을 갖고 있다는 것을 확인 다음은 스마트 그리드의 취약성과 블록체인이 이를 방지할 수 있다는 것을 나타내는 사례다. ¶1. 전력망에 대한 해킹 및 악의적인 공격 방지 2016년 여름, 오클라호마 대학교 연구팀은 풍력 발전소의 허가를 받아서 터빈 통제실의 보안을 물리적으로 해킹했다. 일단 그들은 45달러짜리 라즈베리 파이를 심고, 그들의 PC로 돌아가 터빈을 차단하는 일련의 공격을 시작했다. 이로 인해 그들은 실제로 전체 풍력 발전소에 접근할 권한을 취득할 수 있었고, 또한 더 나아가 이를 폐쇄할 수도 있었다. 풍력 발전소는 에너지 공급에서 작은 비율을 차지하지만, 이는 스마트 그리드의 잠재적인 취약성을 확인할 수 있다. 블록체인 기술이 이를 잠재적으로 막을 수 있다. 블록체인은 기본적으로 주요 접근 권한을 가진 public-private key 를 통해 식별할 수 있는 보안을 갖추고 있다. 특정 기능에 액세스 하려는 사람들은 자신의 신원과 그에 대한 승인을 확인해야 한다. 핵심 접근 코드가 안전하게 유지된다면, 블록체인은 이외의 것을 안전하게 처리할 수 있다. ¶2. 안전하고 효율적인 스마트 시티 인프라의 중추 도시화는 전세계적으로 빠르게 성장하고 있는 추섿. 매주 150만명이 도시 지역으로 이주하고 있다. 이에 대한 대안으로 나오는 것이 스마트 시티다. 이는 급속도로 증가하는 인구에 따라 발생되는 자원의 필요성을 효율적이고 지속가능한 방식으로 충족 시키는 인프라와 기술을 갖추고 있다. 이런 필요성과 장애물애는 더 나은 폐기물 관리, 교통 통제 난방, 냉각 및 전기 자원 사용이 포함되어 있다. 스마트 빌딩은 아침에 인간이 도착하기 전에 난방 및 냉방 시스템을 시작하고, 밤에는 자동으로 꺼서 소비를 최적화할 수 있도록 프로그래밍할 수 있다. 거리에 조명은 차량이나 인간이 접근할 때 마다 스마트 그리드를 통해 켜고 끄도록 프로그래밍 된다. 수도의 경우 사용과 고장 모두를 모니터링하여 필요한 경우 물 공급을 제공하고, 문제에 신속하게 대응할 수 있다. 폐기물 관리를 지속적으로 추적하고 기록하므로 그에 따라 사용량에 비례하여 청구할 수 있다. 등등의 이러한 모든 혁신은 사물을 켜고 끄는 기술을 필요로 하며, 그 기술을 명확하게 모니터링해야 한다. 그리고 이 문제를 해결할 이상적인 해결책이 바로 블록체인이다. 블록체인을 통해 신원을 확인하고 액세스 권한을 부여할 수 있다. 트랜잭션을 불변 레코드에 기록하고 저장할 수 있으며, 분산된 요소간에 데이터를 원활하고 비용 효율적인 방식으로 교환할 수 있다. 간단히 말해, 블록체인은 스마트 시티를 계속 운영할 수 있는 보안을 제공한다. ¶3. 안전한 P2P 에너지 거래 대체 에너지원을 창출하고 사용하는 사람들이 서로 에너지를 구매, 판매 등 거래할 수 있는 움직임이 점차 증가하고 있다. 영국에서는 Verv라는 회사가 최초의 에너지 P2P 거래 프로젝트를 시작했다. 태양 전지판이 있다면, Verv는 아파트 거주자들 사이에서 거래를 할 수 있도록 설정해준다. 블록체인 기술을 통해 신원을 확인하고 거래가 일어나는 것을 기록한다. 개인 소비자가 대체 에너지 원을 점차 사용함에 따라 저장된 에너지를 다른 상품처럼 사고 팔수 있다. 이런 거래가 합법적이고 영구적으로 기록되도록 보안을 갖추는 것이 핵심이며, 블록체인이 이에 적합하다. 블록체인 기술은 인증, 승인 및 데이터 교환을 위한 새로운 변조 방지 메커니즘을 제공하는 에너지 산업에서 중요한 잠재력을 보여준다. 산업은 규제 측면에서 여전히 엄격하지만, 가까운 미래에는 어느정도의 블록체인 기반 혁신을 기대할 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smart-grid","slug":"smart-grid","permalink":"https://www.yceffort.kr/tags/smart-grid/"}]},{"title":"블록체인 기술을 기반으로 한 스마트 에너지 그리드","slug":"Smarter-City-Smart-Energy-Grid-based-on-Blockchain-Technology","date":"2018-07-19T15:00:00.000Z","updated":"2018-07-20T03:17:07.000Z","comments":true,"path":"2018/07/20/Smarter-City-Smart-Energy-Grid-based-on-Blockchain-Technology/","link":"","permalink":"https://www.yceffort.kr/2018/07/20/Smarter-City-Smart-Energy-Grid-based-on-Blockchain-Technology/","excerpt":"Smarter City: Smart Energy Grid based on Blockchain Technology 원문 스마트 시티에서 사용할 블록체인이 적용된 스마트 에너지 그리드 솔루션은, 분산 자원의 에너지 투자쪽으로 지출 균형을 크게 전환할 수 있는 분산형 에너지 시장의 창출을 가능하게 한다. 현재 전력이 분배되고 규제되는 방식과는 다르게, 새로운 에너지 시장 이해 관계자들에게 전력이 재분배 될 가능성 이 있다. (하단 그림 참조) 1. 생산: 전력은 발전소에서 전력생산자에 의해 생성된다. 생산된 전력은 전압을 제어","text":"Smarter City: Smart Energy Grid based on Blockchain Technology 원문 스마트 시티에서 사용할 블록체인이 적용된 스마트 에너지 그리드 솔루션은, 분산 자원의 에너지 투자쪽으로 지출 균형을 크게 전환할 수 있는 분산형 에너지 시장의 창출을 가능하게 한다. 현재 전력이 분배되고 규제되는 방식과는 다르게, 새로운 에너지 시장 이해 관계자들에게 전력이 재분배 될 가능성 이 있다. (하단 그림 참조) 생산: 전력은 발전소에서 전력생산자에 의해 생성된다. 생산된 전력은 전압을 제어하는 변전소로 향한다. 전송: 전력선은 고압전류를 먼거리에 있는 다양한 지역으로 보낸다 분배: 전력선을 타고 분배된 전력은 전압을 낮추고, 가정이나 회사에 분배된다. 스마트 에너지 그리드에서 블록체인 기술을 활용함으로 써 발생하는 영향은 엄청나다. 비즈니스 관점세어 볼때, 스마트 에너지 그리드는 분산된 에너지 시장을 창출하는데 도움이 될 것이다. 즉 블록체인 기술과 통신기술을 결합하여 수백만명의 사용자 사이에서 안전한 거래 및 지불을 용이하게 하는, 전력시장에서 가장 파괴적인 시나리오다. 이 시나리오 상에서 블록체인 시스템의 고유한 특성은 분산된 사용자가 이웃 소비자에게 문제없이 에너지를 판매할 수 있게 한다. 뉴욕에서는 스타트업 TransActive Grid이 블록체인 기술을 기반으로 이러한 유형의 P2P 에너지 판매 네트워크를 만든 바 있다. 이 네트워크에서는 지붕 태양 전지판이 있는 주택이 같은 지역에 있는 이웃에세 판매할 수 있다. 이에 따라 고려해야 할 것 중 하나가 바로 네트워크 구조 그 자체다. 시스템의 모든 Peer에 대해 에너지 시장에서 트랜잭션을 수행할 수 있는 이러한 가능성은, 분산 네트워크를 허용하는 기술로 보다 많은 변화를 가져올 것이다. 여기에는 스마트 장치 뿐만 아니라 IoT, 전기 자동차, 태양렬 지붕, 에너지 저장 및 연료 전지와 같은 에너지 자원이 포함된다. 이러한 변화는 네트워크 자체의 신뢰성과 효율성을 향상 시키고, 전기 수요와 공급을 일치 시키고, 실시간으로 에너지 가격을 규제하며 전송 및 유통 인프라 비용을 줄임으로써 긍정적인 영향을 미칠 것이다. ¶기술적인 구조 블록체인 기술과 IoT를 결합한다면, 분산 에너지 거래가 가능해진다. 또한 메쉬 네트워크를 통해 배포되는 유/무선 데이터 링크를 사용하면 초과 에너지 소비에 대한 정보와 같이 소비자에게 유용한 실시간 서비스를 사용할 수 있다. 소비자들은 그들의 전력 수요에 자동으로 반응할 수 있을 것이다. 블록체인 기반 원장을 사용하는 이점은 공급업체와 소비자의 에너지 거래를 가능하게 해주는 반면, 거래 당사자의 신원은 알 수 없게 해줄 수 있다. 위에서 언급한 가정을 나타내는 하단 그림에서 볼 수 있듯이, 지역 또는 지역 기준으로 활성화된 다양한 '블록체인 스마트 그리드’를 설계할 수 있다. 이 시나리오를 위해 아래 그림과 같은 아키텍처를 설계하였다. 그림과 같이 주거용 건물에 WIFI 라우터를 통해 건물 외부의 데이터를 전송할 수 있는 태양 에너지 카운터가 광전지 패널에 장착되어 있다. 태양열 에너지 미터기는 아래에 설명된 대로 ‘블록체인 스마트 에너지 그리드 앱’ 이라는 특수 구현된 앱을 통해 원격으로 관리 될 수 있는 전용 에너지 축적기 (Energy Accumulator)에 연결된다. ![Blockchain and Smart Energy Grids Proposed Architecture](/images/2018/07/Blockchain and Smart Energy Grids Proposed Architecture.png) 이러한 구조 중간에 양방향 에너지 카운터 (Bidirectional Energy Counter, BEC)가 위치하여 동일한 앱에서 관리하고 에너지 축적기에 연결된다. BEC는 EA에 저장된 에너지를 사용하여 가정용 가전 제품에 에너지를 제공할 때 즉시 활용할 수 있다. 또한 사용자는 공유 거래 플랫폼을 통해 등록된 에너지 회사 중 하나를 선택하여 EA에 저장된 에너지를 판매할 수 있다. ¶블록체인 스마트 에너지 그리드 어플리케이션 또한 블록체인 기술을 사용하여 에너지를 거래할 수 있도록 앱을 개발할 수 있는데, 이는 아래와 같은 기능을 가지고 잇을 것이다. 기능1) 활동모니터: 사용자는 자신의 장비의 에너지 소비와 같은 데이터를 실시간으로 볼 수 있다. 기능2) 활동플랜트: 이 기능을 통해 마이크로 그리드 내에서 자체 시스템을 관리할 수 있으며, 기술 특성을 파악하고 동시에 결함을 감지할 수 있다. 기능3) 블록체인: 거래 플랫폼에서 사용 가능한 에너지 공급업체 중 하나를 선택해 판매할 수 있다. 기능4) 아카이브: 시스템에서 발생된 에너지를 판매하고 거래 관련 데이터를 모아서 볼 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smart-grid","slug":"smart-grid","permalink":"https://www.yceffort.kr/tags/smart-grid/"}]},{"title":"블록체인을 활용한 스마트 그리드","slug":"How-Blockchain-Could-Give-Us-a-Smarter-Energy-Grid","date":"2018-07-18T15:00:00.000Z","updated":"2018-07-19T03:17:07.000Z","comments":true,"path":"2018/07/19/How-Blockchain-Could-Give-Us-a-Smarter-Energy-Grid/","link":"","permalink":"https://www.yceffort.kr/2018/07/19/How-Blockchain-Could-Give-Us-a-Smarter-Energy-Grid/","excerpt":"How Blockchain Could Give Us a Smarter Energy Grid 원문 전력 망에서는 태양, 바람 또는 기타 재생 가능한 소스에서 생성된 전기와 화석 연료에 의해서 생성된 전기를 구별할 수 없다. 얼마나 많은 청정 에너지가 생산되는지 추적하기 위해 전세계 정부는 거래가능한 인증서를 기반으로 한 시스템을 만들고 있다. 그러나 한 전문가는 이런 인증서를 ‘거지같은’ 방식으로 관리해서 재생가능한 에너지에 대한 투자를 억제하고 있다고 주장하기도 했다. 그리고 그는 비트코인과 다른 디지털 화폐의 중심에 있는 블","text":"How Blockchain Could Give Us a Smarter Energy Grid 원문 전력 망에서는 태양, 바람 또는 기타 재생 가능한 소스에서 생성된 전기와 화석 연료에 의해서 생성된 전기를 구별할 수 없다. 얼마나 많은 청정 에너지가 생산되는지 추적하기 위해 전세계 정부는 거래가능한 인증서를 기반으로 한 시스템을 만들고 있다. 그러나 한 전문가는 이런 인증서를 ‘거지같은’ 방식으로 관리해서 재생가능한 에너지에 대한 투자를 억제하고 있다고 주장하기도 했다. 그리고 그는 비트코인과 다른 디지털 화폐의 중심에 있는 블록체인을 기반으로 한 새로운 시스템이 이를 개선시킬 수 있다고 주장했다. 재생 가능 에너지의 인증서를 추적하는 것은 기존 비즈니스를 방해하지 않고 전기 부문의 데이터 관리 문제를 해결할 수 있는, 블록체인 기술을 활용한 잠재적인 응용프로그램 중 하나다. 이 전문가를 비롯한 많은 사람들은 장기적으로 이 기술이 그리드 자체의 아키텍처를 변화시키는데 도움이 될 수 있다고 믿고 있다. 블록체인은 컴퓨터 네트워크에서 유지, 관리, 공유되는 암호화된 원장이다. 이 기술의 지지자들은 그리드를 통해 연결된 전력 생산자와 소비자간의 네트워크 같이 공유 데이터 세트에 의존하는 산업에서 특히 유망할 수 있다고 이야기 한다. 재생 가능한 에너지 발전소에서 전기를 생산하면, 미터기는 스프레드 시트에 기록되는 데이터를 뱉어낸다. 그런 다음, 스프레드 시트를 레지스트리 공급자에 전송하여 데이터가 새 시스템에 입력되고 인증서가 작성된다. 중개인은 판매자와 구매자 간의 거래를 성사시키지만, 이 거래가 승인된 후에 야 이 인증서의 진위여부를 다름 제 3자를 통해서 확인 할 수 있다. 이런 시스템에는 거래 비용이 수반될 뿐만아니라, 실수에서 부터 사기에 이르기까지 다양한 회계적인 오류를 발생할 여지를 가지고 있으며, 투명성 또한 부족하다. 만약 미터기가 직접 블록체인 상에 데이터를 기록하면 어떨까? 이는 대부분의 문제를 한번에 사라지게 할 수 있다. 많은 에너지 전문가들은 블록체인 기술이 현대 전력 공급망의 근본적인 변화를 가져올 수 있는 잠재력을 가지고 있다고 확신한다. 전력 산업의 여전히 상당수는, 배전선을 통해 장거리로 송전되는 전력을 생산하는 거대한 중앙 집중식 발전소를 기반으로 한다. 그러나 최근 몇년간 옥상에서 태양열 패널 및 전기 자동차 배터리와 같은 소형 ‘분산된’ 발전기 및 저장 시스템이 전력 시스템에 연결되고 있다. 기존의 전력 시스템은 너무 비효율적이기 때문에 가치를 극대화 하기 위해 많은 노력을 기울여야 한다. 생산자가 에너지를 P2P로 교환할 수 있는 블록체인 기반 플랫폼을 개발하는 호주 스타트업 Power Ledger의 CEO 는 이렇게 이야기한다. 예를 들어, 전기 생산자가 수익을 받기 위해서는 일반적을 60~80일이 걸린다. 그러나 블록체인 시스템을 기반으로 하게 되면, 생산자는 즉시 돈을 받을 수 있으므로 생산 사업을 시작하고 운영하기 위한 자본이 덜 필요하게 된다. 이런 시스템이 있다면, 이웃끼리도 단순히 에너지를 교환하는 것이 가능하다. 그리고 이것은 전기를 전력공급망에서 판매하는 것보다 훨씬 효율적인 과정을 거친다. 앞서 언급한 Power Ledger를 예로 들면, 태양 전지 패널 및 배터리 저장 시스템을 기반으로 아파트 건물 자체를 마이크로 그리드로 전환 할 수 있는 플랫폼을 선보인 바 있다. LO3 Energy라는 스타트업은 브루클린에서 이웃간 마이크로 그리드를 구축한 바 있다. 그러나 전통적인 시스템은 이런 종류의 지역거래를 처리하는 방법을 알지 못했다. 블록체인 기술은 보다 세분화된 거래를 가능하게 함으로써 시장에 세련미를 더할 수도 있다. Energe Web Foundation 이라는 새로운 비영리 단체는, 에너지 부문을 위해 만들어진 블록체인을 출시한 바 있다. 이더리움을 기반으로, 이 네트워크는 에너지 관련 사례의 테스트 베드가 될 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smart-grid","slug":"smart-grid","permalink":"https://www.yceffort.kr/tags/smart-grid/"}]},{"title":"스마트 그리드에 적용하는 블록체인","slug":"integration-of-the-blockchain-in-a-smart-grid-model","date":"2018-07-18T15:00:00.000Z","updated":"2018-07-19T03:17:07.000Z","comments":true,"path":"2018/07/19/integration-of-the-blockchain-in-a-smart-grid-model/","link":"","permalink":"https://www.yceffort.kr/2018/07/19/integration-of-the-blockchain-in-a-smart-grid-model/","excerpt":"INTEGRATION OF THE BLOCKCHAIN IN A SMART GRID MODEL 원문 전세계적으로 전기 소비량이 꾸준히 증가하고 있다. 이는 지속적으로 전기를 사용하는 장비와 IoT로 인하여 증가하는 경향이 있다. 오늘날, 인터넷에 연결된 물건 들은 단순히 시계에서 부터 집에 이르기까지, 일상의 필수적인 부분으로 자리잡고 있다. 전세계적으로 전기에너지의 48%는 화석에너지에서 비록되며, 화석에너지의 부족으로 인해 많은 문제가 발생하고 있다. 희소성 이외에도, 온실 가스 배출로 인해 대기와 물을 모두 오염시킨다. 에","text":"INTEGRATION OF THE BLOCKCHAIN IN A SMART GRID MODEL 원문 전세계적으로 전기 소비량이 꾸준히 증가하고 있다. 이는 지속적으로 전기를 사용하는 장비와 IoT로 인하여 증가하는 경향이 있다. 오늘날, 인터넷에 연결된 물건 들은 단순히 시계에서 부터 집에 이르기까지, 일상의 필수적인 부분으로 자리잡고 있다. 전세계적으로 전기에너지의 48%는 화석에너지에서 비록되며, 화석에너지의 부족으로 인해 많은 문제가 발생하고 있다. 희소성 이외에도, 온실 가스 배출로 인해 대기와 물을 모두 오염시킨다. 에너지 소비는 해마다 증가하고 있으므로, 이를 잘 관리하는 것은 무엇보다 중요하다. 가능한 해결책 중 하나는 재생가능한 에너지를 1차 에너지 분야로 활용하는 것이다. 재생가능한 에너지는 좋은 계획이지만 문제가 없는 것은 아니다. 재생 가능한 에너지는 간헐적인 생산이라는 문제점을 가지고 있으며, 이는 날씨 (태양, 바람, 조수)에 달려 있다. 이러한 단점을 관리하고 최적화하기 위해서는 현재 생산 시스템을 체계적으로 최적화 하는 것이다. 이러한 관점에서 스마트 그리드는 탄생하였으며, 주택, 소비자 가전 제품 및 재생가능 에너지 발전소에 연결된 네트워크를 구축하고 있다. 그리고 이는 디지털 측면으로 보았을때, 소비의 최적화를 달성화 할 수 있는데 이에 필요한 것이 바로 블록체인 기술이다. 스마트그리드의 정의는 여기를 참조하자. 블록체인은 비트 코인과 함께 등장한, 거래기록을 가지고 있는 일종의 거대한 원장이다. 이 기술은 중앙 통제 기관이 필요 없는 P2P 통화거래를 가능하게 한다. 블록체인은 현재 시스템의 신뢰부분을 나타내고 있는 '중앙’을 제거 하기 위해 데이터의 분산을 기반으로 한다. 비트코인은 이더리움과 같은 다른 유형의 블록체인을 낳았다. 그리고 이 사이에는 다양한 규칙을 수립할 수 있는 스마트 컨트랙트라는 특징을 가지고 있다. 최근 지역 에너지 생산을 촉진하기 위해서 에너지 블록체인이 만들어 졌다. P2P 에너지 트랜잭션은 기존 그리드 시스템에서 필요한 전기 수요를 줄일 수 있으며, 블록체인은 트랜잭션을 안전하고, 거래를 기록할 수 있다. ¶현재 상황 오늘날 에너지 생산의 증가로 이어지는 전력 소비 증가를 관리하기위해, 재생 가능 에너지에 기초한 지역 에너지 생산의 이행을 필요로 하며, 인구 증가에 비례하는 CO2 배출을 유도한다. 또한 과도한 수요가 발생한다면 전력선은 그러한 과도한 전력 흐름을 지원하지 못하므로 전력선에도 직접적인 영향을 미치고 있다. 즉, 풀타임에 최고 소비량을 기록하고 아닐 때에는 소비량이 감소한다. 전력선에 부담을 덜기 위해서는 소비곡선을 부드럽게 만들어야 하며, 이를 위해 지역 사회내에서 자체적으로 전기 생산을 하는 것이 흥미로운 아이디어로 자리잡고 있다. 지역 에너지 생산을 촉진한다는 것은 기존 네트워크 내에서 재생 가능 에너지를 통합한다는 것을 의미한다. 그러나 이러한 통합은, 바람이나 태양과 같은 이러한 에너지가 간헐적으로 전기를 생성하기 때문에 관리가 필요하다. 때문에 안정적인 전력 시스템을 만들기 위해서는, 디지털 적으로 관리가 필수로 보인다. 이 디지털 관리는 스마트 그리드 그 이상일 수도 있다. 이웃 간의 P2P 에너지 거래가 좋은 해결책이 있다. 그래서 대규모 스마트 그리드 프로젝트에서 블록체인을 통합하는 아이디어가 나오고 있다. 비트코인의 간략한 개요 ¶블록체인을 적용한 스마트 그리드 첫번째 접근법은 전력 공급 측면과 관련한 블록체인을 제공하는 여러 블록체인을 조합하는 것이다. 브루클린 지역의 경우와 마찬가지로 마이크로 그리드 전기 네트워크를 구축하여 동일한 마이크로 그리드의 주민들이 태양 에너지 뿐만 아니라 다양한 곳에서 생산된 모든 다른 에너지 (바람, 태양, 배터리 등)을 교환할 수 있도록 하는 것이다. 에너지 소비곡선을 완화하기위해 에너지 생산을 촉진하고 고 에너지 생산을 완화 한다. 분산적인 특성은 P2P 거래에서 유연성을 제공한다. 두 이웃이 에너지를 같은 마이크로 그리드 내에서 거래하는 모습을 생각해보자. A는 8kWh 만큼의 에너지를 생산하고, 5kWh를 소비하고 3kWh을 보유하고 있다. B는 4kWh가 필요하다. 두 사람 사이에 스마트 컨트랙트가 생성된다. (거래를 위한 규칙) ¶마이크로 그리드 관점 스마트 컨트랙트의 규칙에 따라 마이크로 그리드 두 사람 사이에서 A는 3kWh를 B에게 보내고 싶어 한다. 마이크로 그리드는 전기 라우팅 및 전력선을 기반으로 트랜잭션을 수행할 수 있는지 확인한다. 라우팅이 유효하다는 것이 밝혀지면, 트랜잭션을 가능하게 하는 전력선의 가용량을 고려하면서 A의 에너지를 B에게 전송한다. 마이크로 그리드는 부족한 1kWh를 충족시키기 위해 전력망에 해당 전기를 요청한다. 전력망은 나머지 1kWh를 마이크로 그리드에 제공하고, 마이크로 그리드는 이를 B로 보낸다. ¶채굴자 관점 A와 B사이에서 발생한 스마트 컨트랙트 규칙에 따라, A는 3kWh를 B에게 보내고 시펑한다. 이 둘 사이의 거래는 다른 거래가 있는 블록에 저장되며, 마이너에의해 검증된다. PoS가 확인되면 블록이 유효성을 검사한다음, 가장 체인에 연결된다. ¶이 모델에 남겨진 숙제 사용자가 블록체인을 떠날 수 있는가? 블록체인 네트워크에 가입이나 탈퇴할 수 있다면, 이 절차는 무엇인가? 이웃이 다른 체인으로 전환할 수 있는가? 수익창출 모델이 있어야 하는가? 이 블록체인 내 통화를 다른 통화로 교환이 가능한가? 에너지 없는 소비자가 이 블록체인 내의 코인을 획득할 수 있는가? 이 코인은 이웃이나 기존 네트워크의 에너지에 대해서만 재판매 가능한가? 이 에너지를 소비자에게 돌려주고 생산과정에서 수익성을 얻는 것이 나은가? 장기적인 측면에서 보았을때, 별개의 블록체인 보다 기존의 블록체인에 합치는 것이 나은가? ¶결론 스마트그리드에서 블록체인의 중요성은 명확해보이지 않지만 사실은 중요하다. 에너지를 교환하는 이러한 방법은, 국지적으로 재생 가능 에너지의 생산을 촉진하여 전력선에서 발생하는 에너지 손실을 축소화 할 수 있다. 아직 몇가지 문제가 남아있지만, 직면한 문제를 해결할 수 있는 방법이 있다. 이 모델은 전기 수요를 분배하고 균일화함으로써 네트워크의 중단을 피하고자 같은 도시에 여러 블록체인을 설치하는 것을 기반으로 한다. 도시의 네트워크를 마이크로 그리드로 나누면 에너지 흐름 및 P2P 트랜잭션을 보다 잘 관리 할 수 있다. 이러한 모델에서는 금전적인 측면을 고려하지 않았다. 왜냐하면 생산된 에너지를 흥정하고, 에너지 트래픽을 발생시킬 수 있는 가능성을 암시하기 때문이다. 이것이 현실화 된다면, 세금의 기준을 마련해야 할 것이다. 그리고 에너지생산을 독려하기 위해서는, 블록체인에서 발생된 코인을 생산자에게 일정부분 주는 혜택을 부여하는 방법을 택할 수 있을 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"smart-grid","slug":"smart-grid","permalink":"https://www.yceffort.kr/tags/smart-grid/"}]},{"title":"블록체인은 어떻게 금융을 바꾸고 있는가","slug":"how-blockchain-is-changing-finance","date":"2018-07-17T15:00:00.000Z","updated":"2018-07-18T04:42:32.000Z","comments":true,"path":"2018/07/18/how-blockchain-is-changing-finance/","link":"","permalink":"https://www.yceffort.kr/2018/07/18/how-blockchain-is-changing-finance/","excerpt":"How Blockchain is changing finance 원문 오늘날 글로벌 금융 시스템은 하루 수조 달러를 움직이며 수십억명의 사람들에게 서비스를 제공한다. 그러나 이 시스템은 문제가 많아 수수료와 지연으로 인해 추가적인 비용을 지불하고, 중복되고 번거로운 서류작업을 통해 마찰을 일으키고, 사기와 범죄의 기회를 제공한다. 지불 네트워크, 증권 거래소, 송금서비스와 같은 금융 중개인의 45%는 매년 경제 범죄로 고통받고 있으며, 이는 전체 경제로 봤을 땐 37%, 전문 서비스 및 기술 분야로 봤을 땐 각 각 20%, 27%","text":"How Blockchain is changing finance 원문 오늘날 글로벌 금융 시스템은 하루 수조 달러를 움직이며 수십억명의 사람들에게 서비스를 제공한다. 그러나 이 시스템은 문제가 많아 수수료와 지연으로 인해 추가적인 비용을 지불하고, 중복되고 번거로운 서류작업을 통해 마찰을 일으키고, 사기와 범죄의 기회를 제공한다. 지불 네트워크, 증권 거래소, 송금서비스와 같은 금융 중개인의 45%는 매년 경제 범죄로 고통받고 있으며, 이는 전체 경제로 봤을 땐 37%, 전문 서비스 및 기술 분야로 봤을 땐 각 각 20%, 27%에 달하는 수치다. 규제의 비용이 지속적으로 증가하고 은행업계에 지속적인 관심으로 남아있는 것은 더이상 놀라운 일이 아니다. 왜 우리의 금융 시스템은 비효율적인가? 낡은 산업 기술과 종이 기반의 프로세스가 단순히 디지털화 된 것이기 때문이다. 중앙 집권화 되어 변화를 꺼려하고 시스템 실패와 공격에 취약하기 때문이다. 수십억명의 사람들이 기본적인 금융 서비스에 액세스 하지 못하도록 배제하고 있다. 은행업계는 이렇게 지저분한 상황임에도 경제 활력과 진보에 필요한 창조적인 파괴를 피해오고 있었다. 그러나 블록체인이라고 하는 혁신에 대한 해결책이 등장했다. 블록체인은 원래 비트코인과 같은 암호화폐의 기술로 개발되었다. 수백만개의 디바이스에서 실행되는 광범위하고 전세계적인 분산원장으로, 가치르르 지니고 있는 모든 것을 기록할 수 있다. 돈, 주식, 채권, 소유권, 증서, 계약 등 거의 모든 종류의 자산은, 은행이나 정부와 같은 강력한 중개인이 아닌 네트워크 합의와 암호화에 의해 신뢰가 확립됨으로 안전하고 사생활을 보호하는 선에서 자산을 이동하고 저장할 수 있다. 인류 역사상 처음으로 두 명 이상의 당사자는 서로 알지도 못하는 기업이나 개인이 중개자에 의존하지 않고 계약을 맺고, 거래를 성사시키며, 가치를 창출할 수 있다. 이러한 파괴적인 기술의 비전과 위험에 처해 있는 금융업계의 많은 회사들은 은행 및 보험 비즈니스 부터 감사 및 전문 비즈니스에 이르기 까지 블록체인 솔루션에 대대적으로 투자하고 있다. 무엇이 이 돈과 흥미를 이끌고 있는 것일까? 대부분의 기업은 마찰과 비용을 줄일 수 있는 기회를 언급한다. 결국 대부분의 금융 중개인은 어지럽고 복잡하며 값 비싼 중개인들에 의존하여 자신들의 서비스를 운영한다. 유럽 Santander은행은 블록체인으로 절약할 수 있는 비용을 연간 200억 달러로 내다보았다. 컨설팅회사 Capgemini는 블록체인 기반 응용 프로그램을 통해 매년 최대 160억 달러의 은행 및 보험 수수료를 절약할 수 있다고 예측했다. 블록체인은 현재 기술에 투자하고 있는 JP 모건, 씨티그룹, 크레딧 스위스 같은 기존기업을 더 작게, 더 적은 비용으로 프로세스에서 위험을 줄일 수 있다. 그러나 구조가 근본적으로 바뀐 사업이나 시장에서는 비용을 어떻게 줄일 수 있을까? 여기서 블록체인은 진짜 게임 체인저다. 블록체인은 경제에 참여하는 모든 참가자들의 트랜잭션 비용을 줄임으로써, 기존 조직에서 상당부분 중복되어 활용할 수 있는 대규모 P2P 협업 모델을 지원한다. 예를 들어, 새로운 벤처 기업이 growth capital에 어떻게 접근할 수 있는지 생각해보자. 전통적인 방식으로는, 기업은 새로운 사업의 초기단계에서는 엔젤 투자자를 대상으로 하고, 나중에는 벤처 자본가를 찾고 최종적으로는 증권 거래소에서 IPO를 달성한다. 이 산업은 투자 은행가, 감사, 변호사, 크라우드 플랫폼 과 같은 여러 중개자를 필요로 한다. 블록체인은 글로벌 분산 오퍼링을 통해 모든 규모의 회사가 P2P 방식으로 돈을 모을 수 있게 함으로서 기존의 논리를 바꾼다. 이 새로운 자금 조달 매커니즘은 이미 블록체인 산업을 변화시키고 있다. 2016년 블록체인 기업들은 전통적인 벤처 투자자들로 부터 4억달러를, ICO를 통해 2억달러를 모금했다. 이러한 ICO는 단지 회사로 가장하는 새로운 암호화폐가 아니다. 콘텐츠 및 디지털 저작권 관리 플랫폼 (SingularDTV), 분사 벤처 펀드(DAO), 심지어 ICO에 투자하고 디지털 자산을 쉽게 관리할 수 있는 새로운 플랫폼을 대표한다. 세계 모든 블록체인을 연결하는 통합 기술인 Cosmsos같은 ICO가 파이프라인을 구축하고 있다. 앞으로 더 많은 신생 블록체인 기업이 다른 수단 보다 ICO를 통해서 더 많은 자금을 조달할 것으로 보인다. 그리고 이는 역사적인 변곡점이라 할 수 있다. 근본적인 새로운 비즈니스 모델과 마찬가지로 ICO도 위험을 안고 있다. 일단 규제 감독이 전무한 상태다. 실사와 기업 공개가 부족하며, ICO를 실시한 일부 회사는 파산하기도 했다. 그러나 매수자 부담원칙을 명심하자. ICO는 자금을 모으는 효율성을 향상시킬 뿐만 아니라, 기업가와 투자자르 위한 자본 비용을 낮추고 세계 자본 시장에 참여하는 것을 민주화 할 수 있다. 벤처 캐피털의 세계가 1년안에 근본적으로 변할 수 있다면, 그 밖에 우리가 무엇을 변화 시킬 수 있을까? 블록체인은 신원과 평판, 송금, 저축, 대출과 차입, 거래가치, 보험, 리스크 관리 등 여러가지 복잡한 중간 기능을 뒤집을 수 있다. 우리가 알고 있던 은행 업무는 종말을 고할것인가? 그것으 현존하는 사람들이 어떻게 반응하느냐에 따라 달려 있다. 블록체인은 새로운 기술 패러다임을 받아들이고 내부에서 혼란을 겪는 사람들에게는 실존적인 위협이 아니다. 문제는 금융 서비스 산업에서 누가 혁명을 이끌어 낼 것인가 이다. 역사적으로 본다면, 오래된 패러다임의 지도자들은 새로운 것을 받아들이기 위해 애썼다. 왜 AT&amp;T는 스카이프를 만들지 않고, 비자는 페이팔을 만들지 않았을까? CNN은 트위터를 만들수도 있었다. GM이나 Hertz는 Uber를 출시할 수 있었다. 메리어트는 Airbnb를 만들 수 있었다. 블록체인 기술의 강력한 힘은 현대 금융의 기반시설에 달려 있다. 이전의 패러다임 변화와 마찬가지로, 블록체인은 승자와 패자를 만들어 낼 것이다. 우리는 이 피할 수 없는 충돌이 오래된 화폐 기계가 모두를 위한 번영의 발판으로 변하기를 원한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"financing","slug":"financing","permalink":"https://www.yceffort.kr/tags/financing/"}]},{"title":"탈중앙화 자율조직, 탈중앙화 자율 회사, 탈중앙화 어플리케이션 등 - 용어에 대한 불완전한 가이드","slug":"DAOs-DACs-DAs-and-More","date":"2018-07-17T15:00:00.000Z","updated":"2018-07-18T02:25:50.000Z","comments":true,"path":"2018/07/18/DAOs-DACs-DAs-and-More/","link":"","permalink":"https://www.yceffort.kr/2018/07/18/DAOs-DACs-DAs-and-More/","excerpt":"DAOs, DACs, DAs and More: An Incomplete Terminology Guide 원문 디지털 컨센서스 분야에서 가장 인기 있는 주제 중 하나는 탈중앙화 자율 실체 (decentralized autonomous entities)의 개념이다. 많은 사람들이 분권화된 자율기업을 개발하고, 탈중앙화된 응용 프로그램을 개발하고 있지만, 아무도 이 불가사의한 용어에 대한 명확한 의미를 모른다. 탈중앙화 조직은 정확히 무엇이며, 탈중앙화 조직과 프로그램의 차이는 무엇이며, 이를 자율적으로 만드는 것은 무엇일까? ¶스","text":"DAOs, DACs, DAs and More: An Incomplete Terminology Guide 원문 디지털 컨센서스 분야에서 가장 인기 있는 주제 중 하나는 탈중앙화 자율 실체 (decentralized autonomous entities)의 개념이다. 많은 사람들이 분권화된 자율기업을 개발하고, 탈중앙화된 응용 프로그램을 개발하고 있지만, 아무도 이 불가사의한 용어에 대한 명확한 의미를 모른다. 탈중앙화 조직은 정확히 무엇이며, 탈중앙화 조직과 프로그램의 차이는 무엇이며, 이를 자율적으로 만드는 것은 무엇일까? ¶스마트 컨트랙트 스마트 컨트랙트는 탈중앙화 자동화의 가장 간단한 형태다. 스마트 컨트랙트는 디지털 자산 및 2개이상의 당사자가 참가하는 메커니즘으로, 일부 또는 모든 당사자가 자산을 배치하고, 계약 당시에 알려지지 않은 특정 데이터를 기반으로 한 공식에 따라 자동으로 재분배되는 메커니즘이다. 이 때 이 공식에 사용 되는 데이터의 결과는 컨트랙트가 시작되는 시점에서는 정해져 있지 않다. 고용계약을 예로 들어보자. A는 웹사이트 구축을 위해 B에 500달러 지불 하기를 원한다. 스마트 컨트랙트에서는 계약이 아래와 같이 작동한다. A는 계약에 500달러를 넣고 이 자금은 잠겨있다. B가 작업을 끝내면 스마트 컨트랙트에 자금을 해제하라는 메시지를 보낼 수 있다. A가 동의하면, 그 자금이 B에게 풀려 나간다. B가 웹사이트 개발을 끝내지 않으면, B는 자금을 포기하는 메시지를 보내 컨트랙트를 종료할 수 있다. B가 끝냈지만, A가 동의하지 않는다면, 7일간의 대기 기간 뒤에 제 3자 J를 통해서 해결한다. 이 스마트 컨트랙트의 핵심 속성은 간단하다. 한정된 숫자의 당사자만 존재한다. 그리고 계약이 시작되는 시점에 모든 당사자가 정해져 있을 필요는 없다. A가 자신의 자산 50단위를 B자산 10단위를 주는 사람에게 판다고 제안하는 매도 주문도 스마트 컨트랙트의 일종이다. 스마트 컨트랙트는 영원히 실행 될 수 있다. 헤지 계약과 에스크로 계약이 좋은 예다. 그러나 이렇게 영원히 운영되는 스마트 컨트랙트에는 여전히 고정 된 수의 당사자가 있어야 한다. (탈중앙화된 거래소는 스마트 컨트랙트가 아니다) 그리고 영구히 작동되도록 의도하지 않는 컨트랙트도 스마트 컨트랙트다. 왜냐하면, 한정된 시간에만 존재한다는 것은 곧 한정된 수의 당사자만을 수반하게 되기 때문이다. 여기에 애매한 영역이 있다. 한쪽에서는 한정적이고 다른 한쪽에서는 영속성을 가진 컨트랙트 들이다. 예를 들어, 내가 디지털 자산을 헤지 하고 싶다면, 나는 누구나 자유롭게 컨트랙트에 참여하고 떠날 수 있는 그런 계약을 만들고 싶을 수 있다. 이 경우 내 쪽은 한정적이지만 (나) 다른쪽, 2x 레버레지로 그 자산에 베팅하려는 사람은 제한되어 있지 않다. 그래서 여기서는 이런 구분을 제안한다. 만약 한정된 숫자의 당사자를 갖는 쪽이 특정한 서비스를 받는 쪽이라면 (소비자), 이는 스마트 컨트랙트다. 그러나 한정된 숫자를 갖는쪽이 수익을 위해 참여한 것이라면 (생산자) 이는 스마트 컨트랙트가 아니다. ¶자율 에이전트 (Autonomous Agents, AA) 자율 에이전트는 전혀 인간의 참여가 필요하지 않다. 에이전트가 실행되는 환경을 구축하는데 어느 정도 인간의 노력이 필요할 수 있지만, 에이전트가 존재하는 데 있어서는 인간이 존재할 필요가 없다. 이러한 예로는 컴퓨터 바이러스를 들 수 있다. 바이러스는 인간의 의도적인 행동 없이 기계에서 기계로 복제함으로써 생존하며 거의 생물학적 유기체로 존재한다. 이보다 좀더 긍정적인 사례로는 탈중앙화된 자체 복제 클라우드 컴퓨팅 서비스 (decentralized self-replicating cloud computing service) 가 될 수 있다. (AWS, Goole cloud computing service) 이러한 시스템은 가상 개인 서버에서 자동화된 비즈니스를 실행하기 시작한다음, 수익이 증가하면 (트래픽이 증가하면) 다른 서버를 임대하고 자체 소프트웨어를 설치하여 네트워크에 추가한다. 완전한 자율 에이전트 또는 완전한 인공 지능은 공상과학 소설의 꿈이다. 이는 상황의 변화에 적응할 수 있고, 이론적으로 자체 지속 가능성에 필요한 하드웨어를 제조하기 위해 확장 될 수 있다. 이 사이에 있는 컴퓨터 바이러스와 같은 단일 목적 에이전트는 광범위한 가능성을 가지고 있다. 예를 들어, 자기 복제 클라우드 서비스는 특정 공급자에서 서버를 임대할 수 있다. 그리고 좀 더 복잡한 버전으로는, 검색엔진을 사용해서 서버 공급자들을 알려주는 웹사이트를 찾아내고, 거기에 등록된 공급자에게서 서버를 빌려오는 방법도 파악할 수 있어야 한다. 그 다음 단계는 아마도 진화 알고리즘을 사용해 소프트웨어를 스스로 업그레이드 하거나, 서버를 렌탈하는 새로운 패러다임에 적응한다던지 등이 있을 수 있고, 마지막 전 단계는 새로운 산업을 발견하고 스스로 진입하는 능력이 있어야 한다는 것이다. 물론 궁극적인 단계는 AI로 완벽하게 진화하는 것이다. 자율 에이전트를 창조하는 것은 굉장히 어려운 일이다. 이것이 성공하기 위해서는 복잡하고 빠르게 변화하는 환경 뿐만 아니라 적대적인 환경에서도 살아남을 수 있어야 하기 때문이다. 자율 에이전트는 부정행위를 감지하고, 시스템에서 부정행위 노드를 제거하거나 중화할 수 있어야 한다. ¶탈중앙화 어플리케이션 (Decentralized Applications, DA) 탈중앙화 어플리케이션은 스마트 컨트랙트와 유사하지만 두가지 다른 특성이 있다. 탈중앙화 어플리케이션은 시장의 모든 측면에서 참여자 숫자가 정해져 있지 않다. 탈중앙화 어플리케이션은 꼭 금융적인 부분을 다룰 필요는 없다. 두 번째 특성으로 인해, 탈중앙화된 어플리케이션은 실제로 만들기 쉬운 것들 중 하나다. 예를 들어 Popcorn Time, BitMessage, Tor, Maidsafe 등이 있다. 일반적으로 탈중앙화 어플리케이션은 두 종류로 나뉘며, 이 둘 사이에 애매한 영역이 있을 수 있다. 첫번째 클래스는 완전히 익명의 탈중앙화 어플리케이션이다. 여기에서는 노드가 누구인지 중요하지 않다. 모든 참가자는 본질적으로 익명이며, 시스템은 일련의 즉각적인 단절된 상호작용으로 구성된다. 비트토렌트와 비트메시지가 그 예가 될 수 있다. 두번째 종류는 평판을 기반으로 한 탈중앙화된 어플리케이션이다. (평점을 매기는 시스템을 상상해보자.) 여기서 시스템이 모든 노드를 추적하고, 각 노드는 어플리케이션 안에서 평판 상태를 유지하고, 이 평판은 신뢰를 보장하는 목적으로만 순수하게 운영되는 메카니즘 내에서 사용된다. 평판상태는 양도될 수 없어야 하고, 자체적으로 금전적인 가치를 지녀서도 안된다. Maidsafe가 이러한 예다. 물론 완벽하게 구분은 불가능하다. 비트토렌트 같은 시스템도 DDOS를 방어할 목적으로 피어 들이 다른 피어들의 평판과 같은 통계치를 사용하게 할 필요 성이 있다. 하지만 이런 통계값은 완전히 백그라운드에서만 제한된 영역에서 존재해야 한다. 탈중앙화된 어플리케이션 다른 것들 사이의 흥미로운 회색 영역은 비트코인, 네임드 코인과 같은 어플리케이션 들이다. 이 들은 전통적인 어플리케이션들과는 다른데, 왜냐면 생태계를 만들고 이 안에서 가치를 가지는 가상 자산의 개념을 만들기 때문이다. 비트코인의 경우 비트코인이, 네임코인에서는 네임코인들과 도메인 네임들이 될 수 있다. ¶탈중앙화된 조직 (Decentralized Organizations, DO) 일반적으로 인간 조직은 두 가지 조합으로 정의 될 수 있다. 자산의 집합, 그리고 개인들의 집합을 위한 프로토콜이 그것이다. 여기서 개인은 그 집합에 들어오고 나가는 조건에 따라 특정한 클래스들로 나뉠수도 , 아닐 수도 있다. 그리고 이 프로토콜을 통해 개인은 서로 간에 상호작용을 하게 되는데, 여기에는 각 개인들이 어떤 조건에서 어떤 자산을 사용할 수 있는지에 대한 규칙들도 포함되어 있다. 예를 들어, 체인 스토어를 운영하는 간단한 회사를 상상해보자. 이 회사는 투자자, 직원, 고객이라는 세가지 클래스의 구성원이 있다. 투자자를 결정하는 규칙은 가상 자산의 몫을 얼마나 가지고 있나로 판단된다. 투자자가 되기 위해서는 가상자산의 일부를 사면 되고, 지분을 팔기전까지는 투자자로 남는다. 직원이 되기 위해서는 투자자에 의해 고용되거나 투자자에 의해 구체적으로 권한을 받은 다른 직원에 의해 고용되어야 하며, 같은 방법으로 해고될 수도 있다. 그리고 고객은 오픈 멤버쉽 시스템인데, 누구나 언제든지 공식적으로 인정된 방법으로 자유롭게 가게와 상호작용할 수 있다. 공급자의 경우에는 이 모델에서는 개념적으로 직원과 마찬가지다. 비영리 단체의 경우 기부자와 회원을 가지는 조금 다른 구조를 가지고 있다. 탈중앙화된 조직의 아이디어는 조직개념을 따르되, 그것을 탈중앙화 시키는 것이다. 사람들과 상호작용하고 법을 통해 자산을 관리하는 관리자들의 집합을 통해 운영되는 위계 구조 대신에, 탈중앙화된 조직은 코드에서 명시되고 블록체인 위해 집행 되는 프로토콜에 따라서 상호작용하는 사람들의 집합을 의미한다. 이 경우에도 물리적 자산을 보호하기 위해 법적인 시스템을 사용할 수 있지만, 이는 2차적인 요소일 뿐이다. 예를 들어 주주소유의 기업을 블록체인 위에 완전히 옮길 수 있다. 장기적으로 운영되는 블록체인을 기반으로한 컨트랙트는 각 개인의 소유 지분을 블록체인에 기록하여 유지하고, 블록체인에서 투표를 통해 주주들은 이사회와 직원들의 포지션을 결정할 수 있다. 스마트 자산 시스템 또한 블록체인에 직접 결합할 수 있고, 이것을 통해 자산을 통제할 수 있게 된다. ¶탈중앙화된 자율 조직 (Decentralized Autonomous Organizations, DAO) 여기서의 가장 궁극적인 목표이자, 가장 모호한 정의를 가진, 탈중앙화된 자율조직과 그것의 기업적인 하위 개념인 탈중앙화된 자율 기업에 대해 알아본다. 탈중앙화된 자율조직의 이상은 쉽게 설명할 수 있다. ‘인터넷 위에 생존하는 독립체이고, 자율적으로 존재하는 한편, 자동화만으로 자체적으로 해결할 수 없는 특정한 과제들을 수행하기 위해 사람을 직접 고용하는 것도 중요시한다.’ 탈중앙화된 어플리케이션(DA)와 탈중앙화된 자율조직 (DAO)의 주요한 차이는 DAO의 경우 내부자본을 가지고 있다는 것이다. DAO는 특정한 방법에 의해 가치가 있는 내부 자산을 가지고 있으며, 특정 활동에 대해 보상을 주기 위한 메커니즘으로 서 그 자산을 사용할 능력이 있다. 비트토렌트는 내부자산이 없다. 비트클라우드, maidsafe등은 평판을 가지고 있지만, 이는 팔수 있는 자산이 아니다. 비트코인과 네임코인은 그러나 자산을 갖고 있다. 두번째로, DO를 살펴보자. DO와 DAO의 분명한 차이, 즉 언어 자체의 차이는 'Autonomous’라는 단어다. DO에서는 결정하는 주체는 사람이지만, DAO는 어떤 식으로든 자체적으로 결정을 내린다. 이는 굉장히 구분하기 어렵다. 직접적으로 결정을 내리는 행위자들의 집합과, 정보를 통제하는 행위자들 간에는 별 차이가 없기 때문이다. 비트코인의 경우 소수의 마이닝 풀이 모여 51% 공격을 함으로써 블록체인 위에 있는 트랜잭션을 바꿔치기 할 수 있다. 그리고 탈중앙화된 자율 기업(DAC)에서 데이터 입력 공급자들이 모두 짜고 DAC로 하여금 모든 자산을 특정 주소로 보내게 하고, 이를 10년 동안 백만 노드의 컴퓨터 파워를 얻기 위해 지불하는데 사용된 것처럼 보이도록 속일 수도 있다. 이러나 둘 간에는 명백한 차이가 있다. DO와 DAO 는 모두 이러한 짜고치는 공격에 취약한데, 여기서 절대다수 또는 상당 부분의 특정 멤버들이 DO로 하여금 특정 행동을 하게 만드는 지시를 내리는 공모를 하게 된다. 하지만 여기에 차이가 있다. DAO서는 이것이 하나의 ‘버그’ 로 간주되지만, DO에서는 이는 하나의 '기능’이다. 예를 들어 민주주의에서 복수의 구성원이 가장 선호하는 것을 선택하면, 그 선택된 솔루션이 실제로 실행되게 된다. 반면 비트코인의 경우, 특정한 결과를 바라는 아무런 의도나 목적 없이 각자의 이익에 따라 모든 사람이 행동할 때 생기는 ‘기본 행동’ 이 목적이고, 특정 블록체인을 겨냥한 51% 공격은 하나의 일탈로 치부된다. 이러한 사회적 합의 개념은 정부와 비슷하다. 지역 범죄조직이 가게 주인들에게 재산세를 걷기 시작한다면, 이를 정당한 것으로 간주하는 사람은 없을 것이다. 만일 정부가 똑같은 것을 한다면, 대중의 반응은 이를 지지하는 쪽으로 기울어지게된다. 2013년 하나의 예외적인 블록이 사고로 만들어 졌는데, 이 블록이 비트코인 0.8 클라이언트에게는 유효한 것으로, 0.7에선 뮤효한 것으로 여겨지는 사건이 있었다. 일부 노드는 예외블록이 따르는 블록체인을 따랐으며(B1), 나머지는 새로 분리된 블록체인 (B2)위에서 작업하면서 그 예외 블록이 무효라고 간주했다. 마이닝 풀은 IRC에 모여서 B2체인에서 채굴하도록 전환하는 것에 동의했다. 그 이유는, 그렇게 하는 것이 사용자들에게 따로 업그레이드를 요구할 필요가 없기 때문이 었다. 그리고 6시간 후 B2체인은 B1을 추월하게 되었고, 이러한 ‘의도된 행동’ 으로 B1체인이 사라졌다. 이는 커뮤니티에 의해 의도된 ‘51% 공격’ 이었고, 이는 비트코인을 DAO보다는 DO처럼 보이게 만들었다. 하지만 다른 경우에는 이런 일이 일어나지 않을 것이므로, 비트코인을 분류하는 가장 좋은 방법은 '자율성 구현에 약간의 결함이 있는 DAO’정도로 보는 것이다. 하지만 비트코인을 DAO로 보는데 동의 하지 않는 사람들도 있을 것이다. 비트코인은 사고하지도 않고, 채굴 프로토콜 외에는 사람을 고용하지도 않고, DAO 종류라기 보다는 DO류의 업그레이드 프로세스를 따르기 때문이다. 이 견해를 가진 사람들은 DAO를 더 많은 정도의 자체적인 자율 지능(AI)를 가지고 있는 무언가로 본다. 하지만, 이러한 관점이 가진 이슈는 DAO와 AA/AI 간에 구분이 있어야 한다는 점이다. AI는 자율적인 반면, DAO는 동작하기 위해서 DAO가 정의하고 있는 프로토콜에 따라서 구체적인 상호작용을 하는 사람들의 개입을 요구한다는 것이다. DAO는 자동화의 중앙에, 접점에는 사람이 있다. 따라서 대체적으로 비트코인과 네임코인을 DAO로 보는 것이 적절하다. 물론 DA와의 경계썬을 간신히 넘어선 존재이긴 하지만 말이다. 다른 중요한 구분으로는 내적 자본이다. 내적 자본이 없는 DAO는 DA고 내적자본이 없는 조직은 포럼이다 (G8과 같은). DC는 탈중앙화된 커뮤니티다. 이러한 예로는 레딧을 들 수 있는데, 여기에는 탈중앙화된 플랫폼이 있지만, 이를 둘러싼 커뮤니티가 존재하고, 진짜 책임을 맡고 있는 부분이 커뮤니티인지 프로토콜인지는 사실 모호하다. ¶탈중앙화된 자율 기업 (Decentralized Autonomous Corporations, DAC) 탈중앙화된 자율 기업은 DAO의 부분집합이다. DAC는 Daniel Larimer가 최초로 주장 했고 그가 주장하는 정의를 빌려오자면, DAC는 배당을 지불한다는 것이다. 즉 DAC에는 지분 개념이 있고, 이는 특정 방법으로 사거나 거래할 수 있으며, 이는 보유자에게 DAC 성공에 따른 지속적 배당을 받을 수 있는 권리를 잠재적으로 부여한다. DAO는 비영리다. DAO에서 돈을 벌 수 있지만, 이는 DAO에 투자하는 것이라 그 생태계에서 참여하는 것이다. 물론 이러한 구분이 명백하지는 않다. 모든 DAO들은 소유할 수 있는 내부자본을 갖고 있으며, 그 가치는 DAO가 강력해지고, 유명해짐에 따라 올라갈 수 있으므로, 많은 종류의 DAO는 어느정도 DAC가 될 수 밖에 없다. 그러므로 이 구분은 상당히 유동적이며, 어느 것을 강조하느냐에 따라 달려 있다. 배당이 얼마나 중요한 것인가? 참여자들에 의해 획득되는 토큰들에 대해 얼마큼 중요한가? 지분이라는 개념이 단순 가상 자산에 대비해 얼만큼 중요한가? 예를 들어 비영리 이사회의 회원 자격은 실제로 지분이 아니다. 외냐면 회원 자격은 자발적으로 부여되고 회수되기 때문에, 투자 가능한 재산으로 분류될 수는 없기 때문이다. 비트코인은 보유자에게 시스템에서 의사결정을 할 수 있는 능력이나 수익배분을 할 권리를 부여하지 않으므로 지분은 아니지만, 기업에서의 지분은 명백하게 '지분’이다. 결국 궁극적인 이 구분은 수익 메커니즘과 합의 메커니즘이 동일 한 것이 아닌가 하는 매우 불확실 할 수 박에 없는 것일지도 모른다. 위 정의는 여전히 완성에 가깝지 못하다. 여전히 애매한 영역과 헛점이 많고, DO가 DAO가 되기 위해서는 정확히 어느정도의 자동화가 필요한지는 매우 어려운 문제다. 또한 이것들이 어떻게 만들어 져야 하는 지에 대한 질문도 있다. 예를 들어 AI는 개인 서버 네트워크로 존재하며, 각 서버는 독점적인 로컬 코드를 실행하지만, DO는 완전히 오픈 소스 및 블록체인 기반 이어야 한다. 이 AI와 DO사이에는 추구해야할 다양한 패러다임이 있다. 핵심 코드에 얼마나 많은 지능이 들어가 있어야 하는가? 업데이트를 위해 유전자 알고리즘을 사용해야 하는가? 혹은 개인을 기반으로 투표나 심사 메커니즘을 채택해야 하는가? 회원 자격은 기업처럼 판매가능하고 양도가능한 주식이어야 하는가? 혹은 비영리 처럼 투표로 결정해야 하는가? 블록체인은 작업증명, 지분증명, 혹은 평판을 기준으로 이루어져야 하는가? DAO는 다른 통화로 잔고를 관리해야 하는가 혹은 자체적인 내부코인을 발행해서 보상해야 하는가? 이는 어려운 문제이고, 이제 우리는 이 문제들의 표면을 겨우 보기 시작했을 뿐이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://www.yceffort.kr/tags/ethereum/"},{"name":"DAO","slug":"DAO","permalink":"https://www.yceffort.kr/tags/DAO/"}]},{"title":"하드포크와 소프트포크","slug":"hard-fork-vs-soft-fork","date":"2018-07-16T15:00:00.000Z","updated":"2018-07-17T02:25:50.000Z","comments":true,"path":"2018/07/17/hard-fork-vs-soft-fork/","link":"","permalink":"https://www.yceffort.kr/2018/07/17/hard-fork-vs-soft-fork/","excerpt":"Hard Fork vs Soft Fork 원문 프로그래밍 용어로, '포크’는 오픈 소스 코드 수정을 의미한다. 일반적으로 포크는 원본 소스 코드 수정을 위해 이루어지며, 두 개 버전은 각기 따로 공존하게 된다. 때로는 포크가 프로세스를 테스트 하는 데도 사용하지만 (원본 코드에 영향을 미치지 않기 위해) 암호화폐에서는, 근본적인 변경을 만들어내거나, 혹은 원본과 비슷한 (그러나 동일하지 않은) 특성의 새로운 자산을 만드는데 사용한다. 모든 포크가 의도적으로 되는 이루어 지는 것은 아니다. 널리 사용되고 있는 오픈소스 코드 베이","text":"Hard Fork vs Soft Fork 원문 프로그래밍 용어로, '포크’는 오픈 소스 코드 수정을 의미한다. 일반적으로 포크는 원본 소스 코드 수정을 위해 이루어지며, 두 개 버전은 각기 따로 공존하게 된다. 때로는 포크가 프로세스를 테스트 하는 데도 사용하지만 (원본 코드에 영향을 미치지 않기 위해) 암호화폐에서는, 근본적인 변경을 만들어내거나, 혹은 원본과 비슷한 (그러나 동일하지 않은) 특성의 새로운 자산을 만드는데 사용한다. 모든 포크가 의도적으로 되는 이루어 지는 것은 아니다. 널리 사용되고 있는 오픈소스 코드 베이스를 사용하다보면, 모든 노드가 동일한 정보를 복제하지 않을 때 실수로 포크가 발생할 수도 있다. 그러나 일반적으로 포크는 식별되며, 대부분의 암호화폐 포크는 내부 특성에 대한 의견 차이로 인해 발생한다. 포크에서 염두해야 할 정보는 포크가 '원본의 공유된 역사’를 가지고 있다는 것이다. 각 체인의 기록은 분할이전에는 동일하다. ¶하드포크 하드 포크는 이전 버전을 무효로 만드는 프로토콜로 변경하는 것이다. 예를 들어 포크 되기 이전 버전이 계속해서 실행되면, 새로운 프로토콜과는 다른 데이터가 제공된다. 이로 인해 상당한 혼란과 오류가 발생할 수 있다. 비트 코인을 사용하다보면, 블록 크기, 작업증명을 위해 쓰이는 암호 퍼즐의 어려움, 추가 할 수 있는 정보 제한 등과 같은 정의 매개 변수를 변경하기 위해 하드 포크가 필요하다. 이러한 규칙 중 하나를 변경하면, 새로운 프로토콜에 의해 블록이 허용되지만, 이전 버전에서는 거부되어 심각한 문제로 이어질 수 있다. 예를 들어, 블록 크기 제한을 1MB에서 4MB로 늘린다고 가정해보자. 새로운 버전에서는 4MB 크기의 블록이 허용되지만, 구 버전에서는 거부되어 심각한 문제로 이어질 수 있다. 비트코인 블록 크기에 대한 논란은 여기를 참조하자. 이 4MB 블록이 새롭게 포크되어 업데이트 된 노드에 의해 유효성을 검사하고 블록체인에 추가되었다고 가정해 보자. 이 블록이 포크 되기 이전 버전 프로토콜에 의해 유효성 검사를 한다면 어떻게 될까? 블록을 추가하려고 시도하지만 최신 블록이 유효하지 않다고 결론 내릴 것이다. 그래서 해당 블록을 무시하고, 이전 블록에 유요하다고 판단되는 블록을 추가할 것이다. 이렇게 되면 갑자기 구형 버전의 블록과 새로운 버전의 블록체인 총 두가지가 생기게 된다. 이는 두개 이상의 체인이 무기한으로 평행하게 커질 수 있다는 것을 의미한다. 하드포크는 굉장히 어렵고, 잠재적으로 지저분해질 수도 있다. 그리고 새로운 블록에 소비된 비트코인을 오래된 블록에 다시 사용할 수 있기 때문에 위험하다. (이전 코드를 실행하는 사용자는 새로운 코드에 대한 거래를 감지하지 못하므로 사용된 비트코인을 무효로 간주한다.) 이에 대해 유일한 해결책은 포크 된 지점에서 부터 이전 지점을 포기하는 것이며, 이는 일부 채굴자를 잃어버리게 된다. (거래 자체는 손실되지 않고 다시 할당 된다) 이렇게 하거나, 모든 노드들이 동일하게 새롭게 하드 포크된 프로토콜로 동시에 업데이트 하는 방법이 있다. 대표적인 예가 바로, 비트코인 캐시다. ¶소프트 포크 하드포크와 달리, 소프트 포크는 이전 버전과 호환이 가능하다. 예를 들어 특정 룰을 강화하거나, 구조에 영향을 미치지 않는 기능을 추가하는 방식으로 프로토콜이 변경되면, 새 버전 블록이 이전 버전 노드에서 허용된다. 비트코인의 경우, 오래된 버전의 채굴자들은 자신들의 블록이 거부될 수 도 있다는 사실을 인지하고 업그레이드 할 것이다. 더 많은 채굴자들이 업그레이드 함에 따라서, 새로운 블록들이 체인에서 가장 길어지고, 오래된 버전의 블록은 분리됨에 따라서 채굴자들은 노드를 업그레이드 할 것이고, 결국 시스템 자체적으로 수정이 이뤄지게 된다. 새버전 블록은 이전 노드와 업그레이드 된 노드 모두에서 허용되므로 새 버전 블록이 결국 승리한다. 예를 들어, 블록크기를 줄이기로 결정했다고 가정해보자. 새로운 버전 노드는 큰 블록을 거부하고 이전 블록 (업데이트 된 버전으로 채굴된)에서 빌드되어 임시 포크를 만든다. 소프트 포크는 이미 여러번 일어 났다. 처음에는 비트코인 블록 크기에 제한이 없었다. 새로운 규칙이 이전 규칙 보다 엄격헀으므로, 블록 크기 1MB 를 제한 두는 것은 소프트 포크를 통해 이루어졌다. 구조를 변경하지 않고 코드를 향상시키는 pay-to-script-hash함수도 소프트 포크를 통해 추가되었다. 이러한 수정은 모두가 아닌 대다수만 업그레이드 해도되므로 실현가능하고, 파괴적이지 않다. 그리고 또한 소프트 포크는 오래된 노드를 실행하는 사용자가 새버전 과 이전 버전 블록을 모두 읽을 것이므로 하드포크에서 발생할 수도 있는 이중 지출 문제가 발생하지 않는다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"블록체인이 금융을 넘어서 어떻게 쓰일 것인가?","slug":"How-Blockchain-Applications-Will-Move-Beyond-Finance","date":"2018-07-15T15:00:00.000Z","updated":"2018-07-16T04:07:38.000Z","comments":true,"path":"2018/07/16/How-Blockchain-Applications-Will-Move-Beyond-Finance/","link":"","permalink":"https://www.yceffort.kr/2018/07/16/How-Blockchain-Applications-Will-Move-Beyond-Finance/","excerpt":"How Blockchain Applications Will Move Beyond Finance 원문 암호화폐가 성숙함에 따라서 기존 지불 네트워크의 서응을 따라가지 못하고, 금융 시스템 및 정부의 요구사항을 충족시킬 수 없다는 이유로 종종 비판 받고 있다. 그러나 비트코인은 글로벌 네트워크가 값비싼 중개자 없이도 안전하게 거래할 수 있게하고, 가치를 교환할 수 있도록 하는 등 그 문제를 해결하는데 있어서는 성공적이 었다. 게임이론과 암호화를 영리하게 조합함으로써, 비트코인은 트랜잭션 실행 및 보안에 직접적으로 관여하지 않으면서도","text":"How Blockchain Applications Will Move Beyond Finance 원문 암호화폐가 성숙함에 따라서 기존 지불 네트워크의 서응을 따라가지 못하고, 금융 시스템 및 정부의 요구사항을 충족시킬 수 없다는 이유로 종종 비판 받고 있다. 그러나 비트코인은 글로벌 네트워크가 값비싼 중개자 없이도 안전하게 거래할 수 있게하고, 가치를 교환할 수 있도록 하는 등 그 문제를 해결하는데 있어서는 성공적이 었다. 게임이론과 암호화를 영리하게 조합함으로써, 비트코인은 트랜잭션 실행 및 보안에 직접적으로 관여하지 않으면서도 거래 금융 시스템의 ‘가치이전’ 이라는 능력을 매우 훌륭하게 복제해 내었다. 또한 거래할 때 신뢰당사자의 개입을 최소화 한다. 이는 본질적으로 개인정보를 포함하여 현금의 많은 특징을 디지털 방식으로 모방한 것이라 볼 수 있다. 비트코인이나 분산 원장과 같은 암호화폐가 계속 성숙해진다면, 다음에는 어디에 적용할 수 있을까? ¶블록체인은 어떻게 작동하는가? 분산 데이터 베이스: 블록체인 당사자는 전체 데이터베이스와 기록에 액세스 할 수 있다. 어떤 노드도 데이터나 정보를 통제하지 않는다. 모든 당사자는 중개자 없이 거래 파트너의 기록을 직접 확인할 수 있다. P2P 전송: 중앙 노드를 통하는 대신에 피어간에서 직접 발생한다. 각 노드는 정보를 저장하고, 다른 모든 노드로 전달한다. 익명성을 활용한 투명성: 모든 트랜잭션 및 관련된 값은 시스템에 액세스 할 수 있는 모든 사용자에게 표시된다. 블록체인의 각 노드 또는 사용자는 이를 식별할 수 있는 고유의 30개 이상의 String 주소 값을 가진다. 사용자는 익명으로 남아있거나 다른 사용자에게 신원을 증명할 수 있다. 블록체인 주소간에 트랜잭션이 발생한다. 기록의 불변성: 일단 트랜잭션이 데이터베이스에 입력되고 계정이 업데이트 되면 레도는 이전 트랜잭션 레코드와 연결되므로 변경할 수 없다. 데이터베이스의 기록이 영구적이고 시간 순에 따라 정렬되며, 네트워크의 다른 모든 사람들이 사용할 수 있도록 다양한 계산 알고리즘과 접근법이 배포된다. 컴퓨터 로직: 원장의 이런 디지털 특성은 블록체인 트랜잭션이 컴퓨터 로직이나 프로그래밍 된 것과 연결 될 수 있다는 것을 의미한다. 사용자는 노드간 트랜잭션을 자동으로 트리거하는 알고리즘과 규칙을 설정할 수 있다. (스마트 컨트랙트) Zcash는 비트코인보다 높은 수준의 프라이버시를 제공하고, 이더리움은 스마트 컨트랙트 및 탈중앙화 어플리케이션 제작을 위한 강력한 플랫폼을 제공하기 시작했다. 전체 암호화폐 생태계가 성숙함에 따라서 디지털 지갑 제공업체와 거래 업체가 전문적이고 안전해 지고 있다. 소비자 측면에서는, Circle이나 Abra는 블록체인 기술을 활용하여 저렴하게 국가간 송금을 하는 서비스를 구현하였으며 이는 Venmo나 Transferwise의 전통적인 회사에 큰 도전이 되고 있다. Visa와 MasterCard는 유사한 기술에 대한 사용을 연구하여 지불 처리방식을 개선하고 있고, Ripple은 글로벌 결제 네트워크를 통해 은행 및 기타 금융 기관 간의 거래비용을 낮추고 있다. 이들 모두 블록체인 기술을 채택하였으며, 소비자와 기업은 분산 원장이 적용된지 인지하지도 못한 채로 해택을 얻을 수 있다. 중앙 은행은 통화 정책, 세제 및 대출을 위해 필요한 디지털 통화에 대해 적극적으로 연구 중이다. 하지만 블록체인 기술의 실질적인 응용은 단순히 금융 자산의 범위를 훨씬 뛰어 넘는다. 본질적으로 모든 유형의 디지털 자산을 블록체인을 통해 추적하고 거래할 수 있다. 상품, 신원, 자격 증명 및 디지털 권리의 출처에 대한 정보는 분산원장과 함께 안전하게 저장할 수 있다. 비록 초기 단계이지만 의료 기록(MedRec, Pokitdok), 디지털 소유권 및 소액 지불(Brave browser, Ascribe, Open Music Initiative), 신원(Uport), 공급망(Everledger, Hyperledger) 등 다양한 곳에서 활용되고 있다. 이러한 응용 프로그램들의 공통된 과제는 물리적 자산, 개인 (자격), 자원 사용 (인터넷, 사물장치에서 발생하는 에너지 및 대역폭) 및 공급을 통해 발생하는 기타 이벤트의 속성을 안전하고 안정적으로 기록하는 것이다. 블록체인에 의해 제공되는 불변성은 원래 입력된 정보가 정확할 때만 유용하다. 블록체인은 자신이 지닌 속성을 검증할 수 있지만, 최초에 그런 속성을 기록하려면 노동 집약적인 업무와 중개자 (정부 등) 가 필요할 수 있다. 이 분야에서 IOT와 센서는 블록체인 위에 구축할 수 있는 것을 크게 확장할 수 있다. 장기적으로는 인터넷 서비스가 제공되는 방식(Blockstack, IPFS), 오픈 소스 커뮤니티에 자금을 조달하는 방법, 전문지식을 크라우드 소싱하는 방법, 콘텐츠에 대해 값을 지불하는 방식등이 변할 수 있다. 한 연구에서는 기업을 ‘많은 계약의 결합’ 이라고 정의 한 바 있다. 여기에서는 기업을 고용인, 고객, 주주들 과 같은 다양한 당사자 간의 계약을 모은 것에 지나지 않는다고 이야기 하였다. 암호화폐는 언젠가 스마트 컨트랙트를 통해 가치를 안전하게 이전하고, 자원을 할당함으로써 완전히 새로운 유형의 조직을 가능하게 할 수 있다. 이 새로운 유형의 조직은 시장의 속도와 효율성을 달성하고, 기업의 경계에서 발생하는 복잡한 작업을 수행하는데 필요한 거버넌스를 복제할 수도 있다. 이 획기적인 기술은 머신러닝의 진보와 함께 수십년 동안 자본, 노동 및 아이디어의 흐름을 형성할 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"비트코인, 암호화폐, 블록체인의 의미","slug":"Making-sense-of-bitcoin-cryptocurrency-and-blockchain","date":"2018-07-15T15:00:00.000Z","updated":"2018-07-16T03:03:46.000Z","comments":true,"path":"2018/07/16/Making-sense-of-bitcoin-cryptocurrency-and-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/07/16/Making-sense-of-bitcoin-cryptocurrency-and-blockchain/","excerpt":"Making sense of bitcoin, cryptocurrency and blockchain 원문 블록체인은 암호화폐의 존재를 가능하게 하는 기술 중 하나다. 그 중에서도 비트코인은, 블록체인 기술이 잘 녹아져 있는 암호화폐다. 암호화폐는 미국 달러와 같은 기능을 하지만, 디지털이며 암호화 기술을 사용하여 통화 단위 생성을 제어하고 가치 이전을 확인한다. ¶블록체인 블록체인은 P2P 네트워크를 통한 모든 트랜잭션을 분산 원장에 저장한 것을 의미한다. 참가자는 중앙의 권한 없이 거래를 확인할 수 있다. 이를 활용하","text":"Making sense of bitcoin, cryptocurrency and blockchain 원문 블록체인은 암호화폐의 존재를 가능하게 하는 기술 중 하나다. 그 중에서도 비트코인은, 블록체인 기술이 잘 녹아져 있는 암호화폐다. 암호화폐는 미국 달러와 같은 기능을 하지만, 디지털이며 암호화 기술을 사용하여 통화 단위 생성을 제어하고 가치 이전을 확인한다. ¶블록체인 블록체인은 P2P 네트워크를 통한 모든 트랜잭션을 분산 원장에 저장한 것을 의미한다. 참가자는 중앙의 권한 없이 거래를 확인할 수 있다. 이를 활용하면, 자금 이체, 거래, 투표 등 여러 문제에 활용할 수 있다. ¶블록체인은 단순히 비트코인과 암호화폐를 넘어서는 잠재력을 가지고 있다. 간단하게 말해 블록체인은 P2P 네트워크에서 발생하는 모든 트랜잭션에 대한 기록을 유지하는 디지털 분산 원장이다. 이 기술이 시장 참여자가 중앙 집중형태로 제 3자가 필요 없이 인터넷을 통해 자산을 이전할 수 있게 해준다는 것이 주요 핵심이다. 비즈니스 관점에서 볼때, 블록체인 기술을 차세대 비즈니스 프로세스 개선 소프트웨어의 한 유형으로 보는 것이 도움이 된다. 블록체인과 같은 협력적인 기술은 기업 간 비즈니스 프로세스를 개선하여 '신뢰에 드는 비용’을 궁극적으로 낮출 수 있는 능력을 약속한다. 이런 이유로, 대부분의 전통적인 투자보다 투자당 훨씬 높은 수익을 제공할 수 있다. 근래에 금융회사는 어떻게 블록체인 기술을 활용해서 청산과 결제에서 부터 보험에 이르기까지, 모든 것을 뒤엎을 수 있는지 연구하고 있다. 기술이 빠르게 움직이면 그 옆으로 비켜서 있는 것은 매우 위험하다. 현재 우리는 블록체인이 신생 기업의 아이디어에서 기존 기술로 옮겨져가는 모습을 보고 있다. 이는 인터넷이나 PC가 표준적인 도구로 받아지는데 걸리는 시간 만큼이 나 짧은 시간이 소요될 것이다. 블록체인 기술은 금융 서비스 산업에서 근본적으로 다른 경쟁적인 미래를 가져올 수 있다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"비트코인은 살아남지 못하더라도, 블록체인은 살아남을 이유","slug":"Why-Blockchain-Will-Survive-Even-If-Bitcoin-Doesnot","date":"2018-07-14T15:00:00.000Z","updated":"2018-07-15T10:37:33.000Z","comments":true,"path":"2018/07/15/Why-Blockchain-Will-Survive-Even-If-Bitcoin-Doesnot/","link":"","permalink":"https://www.yceffort.kr/2018/07/15/Why-Blockchain-Will-Survive-Even-If-Bitcoin-Doesnot/","excerpt":"Why Blockchain Will Survive, Even If Bitcoin Doesn’t 원문 블록체인은 세가지 이유로 산업을 변화시킬 수 있는 힘을 지니고 있다. 1. 신뢰와 영구적인 기록이 필요한 거래에 매우 적합하다. 2. 블록체인은 여러 당사자들과의 협의를 필요로 하는데, 오픈소스로 구현되는 경우 이런 집단 행동의 문제를 피할 수 있다. 이는 개인이 집단적으로 행동했을 때 특정한 이익을 취하지 못하게 하는 힘을 가지고 있는 것이다. 3. 과대광고다. 암호화폐에 대한 현재 시장의 흥ㅁ분은, 블록체인이 개발자를","text":"Why Blockchain Will Survive, Even If Bitcoin Doesn’t 원문 블록체인은 세가지 이유로 산업을 변화시킬 수 있는 힘을 지니고 있다. 신뢰와 영구적인 기록이 필요한 거래에 매우 적합하다. 블록체인은 여러 당사자들과의 협의를 필요로 하는데, 오픈소스로 구현되는 경우 이런 집단 행동의 문제를 피할 수 있다. 이는 개인이 집단적으로 행동했을 때 특정한 이익을 취하지 못하게 하는 힘을 가지고 있는 것이다. 과대광고다. 암호화폐에 대한 현재 시장의 흥ㅁ분은, 블록체인이 개발자를 유치하고 기술을 채택할 수 있도록 장려하는 힘을 가지고 있다. 기업들은 블록체인이라는 말만 들으면, 시스템을 업데이트 하는데 큰 돈을 쓸 준비가 되어 있을 것이다. 블록체인은 요즘 유행어 중 하나인 '클라우드’와 비슷하다. 클라우드를 비난 하는 사람들은 클라우드를 그저 '다른 사람의 컴퓨터’라고 비웃었지만, 많은 산업계에 새로운 비즈니스 프로세스, 서비스 요금 부과 방법, 파괴적인 신생기업 및 기존 부서에 새로운 사업 기회를 제공했다. 블록체인은 이와 같은 잠재력을 지니고 있다. 모든 참여자들은 사본의 공유된 데이터 베이스를 가지고 있다. 참여자가 다른 참여자에게 자산을 전아고 싶을때, 트랜잭션을 나타내는 데이터 '블록’이 만들어진다. 블록은 그룹에서 공유되지만, 암호적으로 비공개로 남아 있다. 비밀 디지털 서명이 공개 서명과 연결되어 이쓰므로 네트워크는 블록을 인식할 수 있다. 블록이 승인되면, 모든 참가자들은 그들의 사본에 블록을 추가한다. 수학적으로 복잡한 로직이 조작을 방지하며, 데이터베이스 복사본 간의 합의를 유지한다. ¶블록체인의 모든 것 물류를 예를 들어보자. 이미 월마트에서 판매되거나 판매된 110만개의 닭고기와 아몬드 우유를 포함한 상품들이 블록체인에 존재하고 있으며, 이는 회사가 제조업체에서 매장으로의 흐름을 추적하는데 도움이 된다. 글로벌 해운 업체인 Maersk는 IBM과 동일한 기술을 사용하여 선적 컨테이너를 추적하고, 더 빠르고 쉽게 운송하며 세관을 통해 물품을 받을 수 있다. 이 프로젝트들은 여전히 거대 기업에서 진행되는 전반적인 운송 추적 프로그램의 일부이지만, 조직에서나 산업 전반에 걸쳐 빠르게 확산되고 있다. 블록체인을 통하여 상품을 추적하는 다른 회사로는 크로거, 네슬레, 타이슨 푸드, 유니레버 등이 있으며, 이 외에도 많은 회사들이 있다고 IBM에서는 이야기 한다. Everledger는 2014년 4월에 시작하여 전세계에 모든 인증된 다이아몬드를 블록체인에 등록하겠다는 의도로 출발하였으며, 이미 220만개의 다이아몬드 기록을 가지고 있다. 이 회는 한달에 약 10만개의 다이아몬드를 계속해서 추가하고 있다. 이 솔루션은 각 다이아몬드의 ‘물리적으로 복제가 불가능한’ 40가지 측정기록을 포함하여 다이아몬드가 채광되어 소비자가 구입한 날까지의 다이아몬드 기록을 추적할 수 있다. 광부에서 다이아몬드 연마, 소매점에 이르기 까지 모든 참여자들은 블록체인 네트워크에서 데이터베이스의 전체 사본을 가진 노드를 유지한다. CarateSense는 인터넷과 연결된 센서를 화물팔레트에 설치하고 분석하여 물품이 지연되거나 손상될 시기를 예측하는 회사다. 이 서비스를 이용하면, 스캔이나 종이로 서명된 문서를 물리적으로 전달하는 것이 아니라, 블록체인 데이터베이스를 활용하여 물품의 모든 단계를 추적, 기록할 수 있다. ¶규제를 코드로 대체하다 블록체인은 신기술을 빠르게 활용할 수 있는 기업과 중앙정부에서 우선적으로 시행되고 있다. 두바이는 2020년까지 세계 최초로 블록체인 기반 정부로 성장하곘다는 의사를 밝혔다. 이는 부동산 관리를 간소화할 수 있다. 모든 거래의 중심기록을 블록체인으로 이동 시킴으로써 두바이는 부동산 소유권을 더 빠르고 쉽게 이전할 수 있다. 블록체인에 포함될 수 있는 '스마트 컨트랙트’는 코드로 구성되어 있기 때문에, 수정이나 이전 할 수 있는 방법에 대한 규칙을 포함할 수 있다. 이런식으로 블록체인은 기존에 공무원에서 컴퓨터로 집행의 의무를 이전 할 수 있다. 예를 들어, 사기 방지를 위해 특정계정에만 소유권을 이전하거나, 에스크로에서 자금 이전과 같은 다른 조건이 충족된 후에만 이전할 수 있다. 블록체인이 기술이나 어떤 움직임으로서 여러 세대의 소프트웨어 엔지니어를 좌절시킨 문제를 극복할 수 있는 힘을 가지고 있다고 말하기엔 너무 이르다. 이러한 회의론 중 하나는, 블록체인의 영향력이 굉장히 점진적이라는 것이다. 어떤 경우에는, 블록체인은 그저 기존의 시스템과 거의 다를바가 없는 마케팅 용어로도 불리우기도 한다. 하지만 잘 동작한다면, 많은 것을 근본적으로 가능하게 할 수 있는 기술이 될 수 있다. 네트워크에 뎉이터를 전송하기 위한 새로운 표준이 될 수도 있다. 언젠가는 우리가 투표하는 방식에서 부터 온라인으로 사람을 만나는 것, 구매에 이르기까지 모든 것의 기초가 될 수 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"}]},{"title":"어떻게 블록체인 기술이 디지털 경제에 영향을 미치는가?","slug":"How-Blockchain-Technology-Will-Impact-the-Digital-Economy","date":"2018-07-12T15:00:00.000Z","updated":"2018-07-13T01:38:33.000Z","comments":true,"path":"2018/07/13/How-Blockchain-Technology-Will-Impact-the-Digital-Economy/","link":"","permalink":"https://www.yceffort.kr/2018/07/13/How-Blockchain-Technology-Will-Impact-the-Digital-Economy/","excerpt":"How Blockchain Technology Will Impact the Digital Economy 원문 ¶미래의 플랫폼 어떤 조직이든, 생존하기 위해서는 재능, 아이디어 자본을 끌어오고 보상하는데 있어 경쟁자와 시장을 능가하는 능력을 가지고 있어야 한다. 인터넷으로 인해 통신 및 거래비용이 급격히 감소함에 따라서 새로운 플랫폼이 등장하기 시작했고, 이전에는 상상할 수도 없는 속도와 효율성으로 상품과 서비스를 제공하게 되었다. 이러한 새로운 디지털 플레이어는 기술의 변화를 활용하여 기존 비즈니스 모델에 도전하고 기존의 가치","text":"How Blockchain Technology Will Impact the Digital Economy 원문 ¶미래의 플랫폼 어떤 조직이든, 생존하기 위해서는 재능, 아이디어 자본을 끌어오고 보상하는데 있어 경쟁자와 시장을 능가하는 능력을 가지고 있어야 한다. 인터넷으로 인해 통신 및 거래비용이 급격히 감소함에 따라서 새로운 플랫폼이 등장하기 시작했고, 이전에는 상상할 수도 없는 속도와 효율성으로 상품과 서비스를 제공하게 되었다. 이러한 새로운 디지털 플레이어는 기술의 변화를 활용하여 기존 비즈니스 모델에 도전하고 기존의 가치 사슬을 재고했다. 그리고 이러한 방식으로 성공한 사람들은 남들은 복제할 수 없는 수준의 효율성의 수준을 달성했기 때문에 성공할 수 있었다. 온라인상의 피드백 시스템을 통해 디지털 플레이어는 개인, 제품 및 서비스가 그 어느 때보다 효과적으로 조화를 이룰 수 있는 글로벌 시장을 만들 수 있었다. 큐레이션을 제공하고 거래의 안정성을 보장함으로써, 새로운 유형의 중개자들은 이 첫번째 디지털화의 흐름에서 수익을 거둘 수 있었다. 블록체인과 암호화 기술이 발달하고 메인스트림 애플리케이션이 등장함에 따라서 이와 유사한 변화가 발생할 예정이다. 이러한 새로운 기술 변화의 물결속에서, 중개인들은 여전히 거래에 가치를 더할 수 있을 것이지만, 중재의 성격은 근본적으로 바뀔 것이다. 일부 기성 기업은 이 기회를 통하여 사업을 확장할 수 있지만, 다른 기업들은 완전히 새로운 가치창조 및 포착을 제안하는 신규 진입자에 의해 도전을 받을 것이다. ¶인간의 지능으로 인공지능 보완 조직들간의 복잡성과 상호의존성이 증가하고, 기술적 한계를 발전시키기 위해 필요한 전문화가 증가하면서, 인간의 능력은 실시간 정보의 생성, 처리 및 확산에 핵심적인 병목현상이 되었다. 이러한 추세를 상쇄하기 위해서 의사결정을 단순화하고 궁극적으로 조직이 다양한 시장으로 확장할 수 있도록 더 나은 기술, 거버넌스, 계약을 개발했다. 기술 측면에서 인공지능은 예측비용을 극적으로 줄이고 있으며, 인간의 판던을 완전한 자동화 이전의 마지막 관문으로 남겨두었다. 그리고 우리는 암호화폐라는, 의사결정을 일정하게 활용하고 선택하며 보상하는 기술을 보유하고 있다. 우리는 아이디어와 솔루션을 크라우드 소싱하고 (Innocentive, TopCoder), 재능(UpWork), 서비스(Uber, lift, airbnb), 자본(kickstarter)을 공급할 수 있었다. 이러한 솔루션은 대중의 의도, 원천 기술 및 수익을 재분배 하기 위해서 전통적인 플랫폼에 의존한다. 또한 이러한 시장을 확대하기 위해서 전문 투자자들이 도움을 줄 수천개의 스타트업을 샅샅이 뒤져야 한다. 이 모든 플랫폼들은 거래가 안전하게 이루어지기 위해 필요한 평판, 지불, 신용 시스템을 구축함으로써 새로운 시장의 중심에 위치할 수 있었다. 인터넷 덕분에 정보가 자유롭게 흘렀지만, 가치는 그렇지 못했다. ¶글로벌 플랫폼을 확장하는 새로운 방법 블록체인 기술로 인한 변화를 이해하기 위해서는, 지금까지 가장 크게 이루어졌던 구현체인, 비트코인에서 부터 시작히는 것이 필요하다. 비트코인은 기존 지불 네트워크의 성능이나 금융 시스템 및 정부 요구사항에 부합하지 못한다는 이유로 비판을 받기도 했지만, 많은 비용이 필요없이 글로벌 네트워크가 안전하게 거래하고 가치를 교환할 수 있는 문제를 해결하는데에는 매우 성공적이었다. 게임이론과 암호화를 영리하게 혼합하여 비트코인 네트워크는 일정한 간격으로 분산원장의 올바른 상태에 대한 합의에 도달 할 수 있었다. 비트코인 원장을 공격으로부터 보호하는 것은, 정확히 계산된 작업증명이다. 작업증명을 풀기위한 퀴즈에 비교적 저렴한 하드웨어를 투자하면 (지금은 그렇다고 볼순 없지만…) 비트코인은 전통적인 거래를 실행하고 확보하는데 드는 업무와 비용 없이 금융 시스템의 가치 전달 능력을 복제할 수 있다. 또한 거래 할 때 신뢰 당사자의 개입을 최소화 하면서 현금의 개인정보보호기능을 포함한 많은 기능을 디지털방식으로 모방하여 거래했다. ¶비트코인에서 암호화 토큰으로 활성화된 시장까지 암호 토큰 (이더리움 등)에 의해 활성화된 시장은 분산되고 인센티브 중심적인 성격의 현물시장과 유사하지만, 전통적인 회사에서 사용되는 보다 복잡한 형태의 거버넌스를 복제할 수 있는 새로운 유형의 조잭 형태를 나타낸다. 예를 들어, 아직은 초기 단계에 있는 스마트 컨트랙트의 경우, 암호화 상태를 기반으로 수행되는 트랜잭션에 미묘한 차이를 추가한다면 새로운 유형의 계약과 교환이 발생할 수 있다. 이를 활용하는 조직은 자본, 재능, 아이디어 공급 및 수요를 일치시키는 방식으로 상당한 규모의 경제적 이익을 얻을 수 있다. 이는 인프로 비용없이 글로벌 규모로 자원을 활용할 수 있기 때문이다. 개방형 프로토콜로 개발되면, 이러한 생태계는 혁신가들이 여러 방향으로 잠재력을 확장함으로써 이익을 얻을 것이며, 그 중 대부분은 기존의 초초기이 상상도 못한 범위에서 일어어날 것이다. 대부분 현재 비용을 낮추고 산업내에 표준화를 추진하는 방법으로 블록체인 기술을 채택하고자 하는 반면, 혁신의 구조적 특성상 일부 기존 사업자들은 장기적인 준비가 부족할 수도 있다. 이러한 새로운 체제에서 중개자는 여전히 시장에 상당한 가치를 더할 수는 있지만, 이는 기존의 단순한 가치 이전, 자산을 통제하는 것으로 부터 오지는 않을 것이다. ¶새로운 디지털 경제 암호 토큰과 블록체인은 블록체인에 기록될 수 있는 트랜잭션을 확인하는 비용과 네트워킹 비용, 이 두 가지 주요 비용의 절감과 관련이 있다. 시장에서 기능하려면 거래가 시작 되기전 후에 개인, 회사, 재화 및 서비스의 주요 속성을 검증하고 감사해야 한다. 이 과정은 종종 노동 집약적이거나, 안전을 위해 제3자가 필요하지만, 이제는 분산원장에서 저렴하게 구현할 수 있다. 블록체인의 타임스탬핑과 불변의 특성도 있지만, 이는 이 기술을 혁신적으로 만드는 것은 아니다. 사실, 이 두가지 특징보다 저렴한 형태로 비용을 절감할 수 있기 때문에 현재의 가치 사슬과 잘 부합하는 것이다. 암호화로 인해 발생하는 아키텍쳐의 변경은 대신 성장, 운영 및 플랫폼 보안을 위해 네이티브 토큰을 사용하는 것과 관련이 있다. 비트코인과 마찬가지로, 토큰은 누구나 허가 없이 기본 프로토콜을 기반으로 새로운 어플리케이션을 구축할 수 있는 혁신 생태계의 개발을 촉진할 수 있다. 네트워크 사업자 또는 중간 참가자들은 적절한 인센티브와 결합하여 전세계적으로 부족한 자원의 할당에 대해 합의에 도달하기 위해 암호화를 사용할 수 있다. 이는 온라인 커뮤니티나 플랫폼이 달성할 수 있는 규모와 범위를 크게 확장시킬 것이다.","categories":[],"tags":[]},{"title":"토큰 이코노미란 무엇인가?","slug":"token-economy","date":"2018-07-12T15:00:00.000Z","updated":"2018-07-12T23:32:37.000Z","comments":true,"path":"2018/07/13/token-economy/","link":"","permalink":"https://www.yceffort.kr/2018/07/13/token-economy/","excerpt":"먼저, 기존의 토큰 이코노미의 사전적인 정의 부터 알아보자. ¶Token economy 토큰 이코노미는 특정 목표 행동을 체계적으로 강화하는 것을 기초로한 수반성 관리 시스템이다. 수반성: 일종의 if-then 진술문이다. X라는 사건이 발생할 때에만 Y라는 사건이 발생할 경우, 사건 Y는 사건 X에 수반된다. 한 사건은 자극 수반적(한 자극의 출현에 의존적)일 수도 있고 반응 수반적(한 행동의 출현에 의존적)일 수도 있다. 여기서 행동을 강화하기 위한 강화인자는 다른 강화인자와 교환할 수 있는 '토큰’을 의미한다. 토큰 이코","text":"먼저, 기존의 토큰 이코노미의 사전적인 정의 부터 알아보자. ¶Token economy 토큰 이코노미는 특정 목표 행동을 체계적으로 강화하는 것을 기초로한 수반성 관리 시스템이다. 수반성: 일종의 if-then 진술문이다. X라는 사건이 발생할 때에만 Y라는 사건이 발생할 경우, 사건 Y는 사건 X에 수반된다. 한 사건은 자극 수반적(한 자극의 출현에 의존적)일 수도 있고 반응 수반적(한 행동의 출현에 의존적)일 수도 있다. 여기서 행동을 강화하기 위한 강화인자는 다른 강화인자와 교환할 수 있는 '토큰’을 의미한다. 토큰 이코노미는 operant conditioning (조작적 조건 형성)과 행동경제학의 원칙에 기반을 두고 있으며, 행동 분석을 하는데 활용될 수 있다. ¶토큰 이코노미의 기본 조건 ¶토큰 토큰을 효과적으로 사용하기 위해 강화인자로 사용되어야 한다. 토큰은 물질적인 강화인자, 서비스, 권한 (백업 강화인자)과 교환 할 수 있는 오브젝트나 심볼이다. 실제 실험에서는 동전, 체크마크, 작은 태양 그림 등 다양한 토큰이 사용되었다. 이러한 기호나 물제는 환자와 실험자 관계 외에서는 쓸모가 없지만, 이들의 가치는 다른 것과 교환할 수 있다는 것에 있다. ¶백업 강화인자 토큰은 본질적으로 가치가 없지만, 다른 가치가 있는 백업 강화인자와 교환할 수 있다. 대부분의 토큰 이코노미는 사실상 무엇이든 될 수 있는 다양한 백업 강화인자를 가지고 있다. 예를 들면 아래와 같다. 물질적인 강화인자: 과자, 담배, 돈 서비스: 침대에서 아침식사, 방청소, 특정활동 특권 이나 기타: 건물이나 지역을 떠날 수 있는 패스, 침대에 머무를 수 있는 권한, 전화, 벽에 이름이나 그림을 새기는 것 백업 강화 인자는 토큰 이코노미가 설정된 개인, 그룹이 사용할 수 있는 가능성에 따라 선택된다. 토큰 이코노미를 시작하기 전에 백업 강화인자에 얼마나 많은 토큰을 지불할지를 결졍해야 한다. 이러한 일종의 가격 목록을 노출하거나 제공할 수 있다. 일부 백업 강화인자는 언제나 구매할 수 있지만, 다른 경우 교환시간이 제한적일 수도 있다. ¶특정 타겟 행동 토큰 이코노미가 목표로 하는 다양한 행동 목표가 있을 수 있다. 자기관리, 특정 활동 참석, 학업, 또는 파괴적인 행동 등. 토큰 이코노미는 교환 가능한 토큰을 단순히 사용하는 것 이상의 의미를 지닌다. 토큰 경제가 작동하려면 기준을 지정하고 명확하게 해야 한다. 일례로, 고객이 긍정적이고 올바르게 행동하고 있다고 판단하여 고객에게 직원이 단순히 토큰을 주는 것은 토큰 이코노미라고 볼 수 없다. 일부 고객 메뉴얼의 경우에는 특정 행동별로 얻을 수 있는 토큰 수가 포함 된 경우가 있다. 예를 들어, 침대를 만드는 것이 목표 행동이라면, 직원과 고객은 잘 만들어진 침대가 어떤 모습을 하고 있는지 알아야 한다. 시트는 매트리스 밑에 있어야하는가? 아니면 쿠션 위에 있어야 하는가? 그러나 이러한 자세한 사양을 만드는 것은 어렵다. 예를 들어, 예의바르고 긍정적으로 협력하는 것 과같은 행동은 구체적으로 이를 명시화 하기 어렵다. 각 목표 행동으로 얼마나 많은 토큰을 얻을 수 있는지 계획하기 위해서는 몇가지 요인을 고려해야 한다. 한편으로는 고객이 최소한의 노력을 통해서 최소한의 토큰을 얻을 수 있어야 하며, 또한 고객은 너무 빨리 토큰을 모을 수 있어서는 안된다. ¶토큰 이코노미의 역사 19세기 학교와 교도소에서 토큰 이코노미의 선구자가 있었다. 이러한 시스템에서 토큰은 다양한 항목과 특권을 획득하고 교환 할 수 있었다. 1960년대, 정신과 병원에서 최초의 토큰 이코노미가 시작되었고 이후 널리 보급되기 시작했다. 그러나 80년대 이후 많은 문제와 비판에 직면하면서 감소하기 시작했다. ¶문제와 논란 성인을 대상으로 토큰 이코노미를 활용하는 것은 많은 비판의 대상이 되었다. 또한 일부 장애와 정신건강관리 악화로 인해 문제가 발생하기도 했다. 환자 치료 방식의 변화: 토큰 이코노미는 최적의 결과를 얻기 위해 수개월에서 수년이 걸림에도 불구하고 만성 정신 질환 환자를 위한 효과와 유용성이 입증되기도 했다. 그러나 이는 보험 및 정부 정책이 가능한 가장 짧은 입원을 목표로 하기 때문에 문제가 된다. 그리고 이런 치료가 커뮤니티를 기반하는 치료로 많이 이동하면서 외래 및 재택간호가 더 선호되고 있었다. 이렇게 분산된 환자 치료법은 토큰 이코노미 연구하고 발전하는 것을 어렵게 했다. 법적 윤리적 문제: 사유재산, 기본적이니 편안함과 치료 선택의 자유는 토큰 이코노미 가능성을 제한했다. (토큰 이코노미는 이러한 것들을 강화인자로 사용하므로) 예를 들어 담배를 강화인자로 사용하는 것이 윤리적으로 정당화 되는가? 치료 수단으로 '보상과 처벌’을 사용하는 것이 올바른 일인가? 고객저항: 토큰 이코노미를 성인에게 저항하면, 당연히 저항에 부딪히게 된다. 반응 유지와 일반화: 토큰 이코노미가 중지되면 그동안 토큰으로 유인화 했던 행동을 유지하기 어려워진다. 외재적 내재적 동기: 보상행동은 외적 동기는 증가시키지만, 동시에 내재적인 동기를 감소시킨다. 토큰을 과거 우리가 좋아했던 포켓몬 스티커에 비유해보자. 포켓몬 도감을 모으기 위해 아이들은 포켓몬 스티커가 든 빵을 먹었다. 도감이 완성될 즘에 다른 사람이 내가 원하는 스티커를 갖고 있다면, 그것을 내가 먹으려고 했던 빵과 교환할 수 있었다. 스티커라는 토큰은 이른바 도감 완성이라는 백업 강화인자를 위해서 였고, 이는 특정 타겟 행동, 즉 빵을 사먹는 제빵업계의 목표와 연결되었다. ¶블록체인에서의 토큰 이코노미 블록체인에는 디지털 토큰이 있다. 이러한 블록체인 토큰은 분산된 소프트웨어 프로토콜의 일부로, 블록체인에서 생성된 토큰이다. 다양한 유형의 블록체인 토큰이 있으며 이는 다양한 특성과 용도를 지니고 있다. 예를 들어 비트코인과 같은 일부 블록체인 토큰은 디지털 화폐로 기능한다. 다른 디지털 토큰은 금이나 부동산과 같은 유형 자산에 대한 권리를 나타낼 수도 있다. 블록체인 토큰은 새로운 프로토콜 및 네트워크에서 분산된 응용 프로그램을 만드는데도 사용할 수 있다. 후자의 토큰은, 미래에 소비자에게 유용할 수 있다는 약속이나, 그 토큰을 가치있는 디지털 자산과 교환할 수 있다고 가정할 때 소비자들은 구입한다. (송금에 쓰이는 리플을 얼마나 많은 사람들이 사갔는지…) 어떤 종류의 토큰이 증권으로 분류되고 그렇지 않은지에 대한 논란과 불확실성은 여전하지만, 토큰 판매에 대한 열정 (ICO)는 계속해서 불타오르는 중이다. 온라인에서 이런 토큰을 많이 사서 교환한다면 어떻게 될까? ICO는 이미 우리가 예상했던 것을 훌쩍 뛰어넘어버렸다. 2017년 한 전문가는 ICO가 최소 10억달러를 모을 것이라고 했지만, (당시 10월) 이미 23억달러를 넘어버렸고 이는 계속 증가 중이다. 이러한 엄청난 숫자는 ICO를 회의적으로 보는 사람들 마저 휘둥그레 하게 만들었으며, 이러한 볼륨의 ICO가 거래 수수료, 속도, 확장성에 미치는 영향에 대한 질문을 제기하기도 했다. 또한 ICO는 ‘투자의 민주화’ 에 대한 질문을 던지고 있다. 인터넷이 갑자기 우후죽순으로 블로그를 만들고 누구나 기자 노릇을 할 수 있게 해주었던 것처럼, 토큰은 전세계 수많은 평범한 사람들이 투자자가 되도록 할 것이다. (우리나라 만 봐도) 이는 많은 이점과 함께 잠재적으로 초보자들에게는 큰 위험이 동반된다. (심지어 소위 전문가라고 스스로 말하는 사람들에게도) 그렇다면 다양한 토큰이 모두 발행되고 서로다른 플랫폼에서 거래될 수 있다면 어떤 일이 벌어질까? 이더리움에서 스마트 컨트랙트의 사용 사례가 증가하면서 이더리움 블록체인 내의 디지털 자산 수가 급격히 증가하고 있다. 그리고 이러한 추세는 계속 될 가능성이 높아서 자산을 교환하거나 여러가지 토큰으로 구성된 포트폴리오의 균형을 맞추려는 사용자의 수요가 증가할 수도 있다. (빗썸에서 다양한 암호화폐를 사는 사람들을 생각해보자.) 분산 주문서는 이러한 수요를 충족하기 위해 생겨났지만, 분산된 자산 교환에서 P2P 거래를 위한 옵션도 있다. 빗썸, 업비트와 같은 중앙집중식 암호화폐 교환은 비트코인을 비롯한 암호화폐를 현지 통화로 교환할 필요성 때문에 존재하게 되었다. 이러한 토큰(암호화폐)가 여전히 상인과 소비자들 사이에서 널리 사용되고 있지 않기 때문이다. 예를 들어, 담보대출이나 청구서를 비트코인으로 지불할 수 없다. 마운틴 곡스 거래소 사건은 중앙집중식 암호화폐 거래소의 잘못된 예다. 그러나 이는 초기였고, 많은 중앙 집중식 거래가 성공적으로 운영되고 있다. 이들의 생존은 전통적인 은행 시스템과 좋은 관계를 맺을 지, 그리고 그들이 제공할 수 있는 유동성(코인이 없는데 훼이크로 거래하는게 아닌)을 관리하고 소비자에게 질 좋은 서비스를 제공할 수 있는지에 따라 달려 있다. 그러나 이러한 교환이 신뢰할 수 있는지, 얼마나 많은 위험에 노출되어 있는지, 신용 위험, 보안 (빗썸이 얼마전에 털린 것처럼), 또는 이러한 보호 부족 같은 것들을 사용자가 항상 쉽게 알 수 없다. 이런 중앙 집중식 거래소가 아닌, 분산된 거래소는 이러한 한계 중 일부를 해결 할 수 있기 때문에 많은 관심을 끌고있다. 예를 들어 분산 주문을 사용하는 Ox, 사용자가 P2P로 교환할수 있게 해주는 AirSwap, KyberNetwork 등이 있다. 일부는 디지털 토큰을 전통적인 명목화폐로 교환하는 것을 용이하게 하거나, 다양한 유형의 디지털 토큰을 교환하도록 설게 되어 있다. 또한 블록체인과 소위 말하는 ‘오프 체인’ 시스템을 작동시키는 플랫폼으로 나뉘기도 한다. 토큰 이코노미의 미래에는, 우리가 거래하는 방식을 획기적으로 바꾸면서도 다양한 플랫폼에서 디지털 자산이 거래 될 것이다. 그리고 이러한 창업 커뮤니티에 쏟아지는 새로운 자금의 물결은, 이미 모든 종류의 분산된 혁신이 일어나고 있는 새로운 형태의 '블록체인 실리콘 밸리’를 만들어 내고 있다. 이는 클라우드 컴퓨팅이 공유 경제를 충족시키는 것이라고도 볼 수 있다. 투자와 사업의 미래에 관심이 있다면, 토큰 이코노미에서 일어나는 일에 대해서 토큰 이상의 관심을 가져야 할 때다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"token-economy","slug":"token-economy","permalink":"https://www.yceffort.kr/tags/token-economy/"}]},{"title":"토큰 이코노미를 위한 분산 거래의 가치","slug":"The-Value-of-Decentralized-Exchanges-for-a-Token-Economy","date":"2018-07-12T15:00:00.000Z","updated":"2018-07-13T05:56:37.000Z","comments":true,"path":"2018/07/13/The-Value-of-Decentralized-Exchanges-for-a-Token-Economy/","link":"","permalink":"https://www.yceffort.kr/2018/07/13/The-Value-of-Decentralized-Exchanges-for-a-Token-Economy/","excerpt":"The Value of Decentralized Exchanges for a Token Economy 원문 ¶왜 블록체인 인가? 블록체인을 활용하면, 이전의 중앙 집중식 정보 시스템을 중앙화에서 벗어나게 하여 제어권을 많은 사람들에게 제어권을 분산 시킬 수 있다. 이는 굉장한 이점을 지니고 있다. 첫째, 분산화는 중앙 집중식 정보관리를 쓸모 없게 만드는 대신, 다양한 문제를 결정하는 합의 알고리즘을 실행하여 관료적 효율성을 높이는데 도움을 준다. 둘째, 공유 원장에 대한 제어권을 배포하여 시스템의 보안을 향상시킨다. 이론적으로","text":"The Value of Decentralized Exchanges for a Token Economy 원문 ¶왜 블록체인 인가? 블록체인을 활용하면, 이전의 중앙 집중식 정보 시스템을 중앙화에서 벗어나게 하여 제어권을 많은 사람들에게 제어권을 분산 시킬 수 있다. 이는 굉장한 이점을 지니고 있다. 첫째, 분산화는 중앙 집중식 정보관리를 쓸모 없게 만드는 대신, 다양한 문제를 결정하는 합의 알고리즘을 실행하여 관료적 효율성을 높이는데 도움을 준다. 둘째, 공유 원장에 대한 제어권을 배포하여 시스템의 보안을 향상시킨다. 이론적으로 네트워크에 대한 제어권 분포는 더이상 단일 실패지점이 없다는 것을 의미한다. 원장을 제어하기 위해서는 단일 중앙 데이터베이스 대신 전테 네트워크의 대부분을 제어해야 한다. 마지막으로 중앙 정보기관이 중재하지 않는 P2P 무역을 통해 경제 시스템을 조직해야 한다는 믿음때문에, 중앙 집중식 정보 시스템은 순전히 이데올로기적 이유로 거부될 수 있다. 거대한 블록체인 혁신을 촉발시킨 2008년 비트코인 백서는 중앙 통화당국과는 별도로 암호화폐인 비트코인을 통해 P2P 전자 현금시스템을 계획했었다. ¶중앙 집중식 거래 2018년 까지 빠르게 진행되고 있는 전통적인 중앙 집중식 관리모델은 디지털 자산을 저장하고 거래하는 지배적인 형태로 남아있다. 대다수의 디지털 토큰은 현재 중앙 집중식 거래 시스템에 저장되어 있다. 이러한 중앙 집중식 상점의 오래된 구조와 가치 거래는 기술적으로 문화적으로도 오랜 기간 지속되어 왔다. ¶왜 이것이 나쁜가? 중앙 집중식 거래는 다른 중앙 집중식 기관들이 직면하는 것과 동일한 비판에 취약하다. 중앙 집중식 거래는 실패를 할 수 있는 포인트가 되어 버린다. 많은 양의 디지털 토큰을 보유하고 있기 때문에, 점점 더 공격자들에게 매력적으로 작용하기 때문이다. 일본의 NEM에서 벌어진 해킹으로 5억달러를 손실을 입은 이 사건은은 이러한 사실을 단적으로 보여주는 예다. 이러한 손실은 블록체인 기술의 보안과 관련이 없지만, 블록체인에 대한 인식을 손상시키고 채택되는 것을 늦춘다. 간단히 말해, 중앙집중식 거래는 시스템을 체인 외부에서 유지하므로 거래가 블록체인에서 저장되지 않는다. 결과적으로 이는 분산된 피어 네트워크에서 가져올 수 있는 동일한 수준의 보안을 제공할 수 없다. 또한 대부분의 중앙 집중식 거래소는 Private Key를 제어를 사용자에게 전달하지 않으므로, 사용자는 저장된 자산에 대한 간접적인 액세스만 가질 수 있게 된다. (빗썸에서 내 계좌를 볼 수는 있지, 실제 비트코인 지갑 주소를 알 수없는 것 처럼) 따라서, 신뢰가 필요없는 기술로 고안된 것에 대해서 거래를 할 때 신뢰가 필요한 상황이 된 것이다. 이렇듯 무능력하거나 부주의한 거래, 또는 불확실한 형태로 거래 상대방의 위험성이 증가하면서, 디지털 자산을 저장하고 거래하는 새로운 방법이 증가하게 되는 이유가 되고 있다. ¶Decentralized Exchange (DEX) 위에서 설명한 문제에 대한 잠재적인 해결책 중 하나는 분산된 거래 프로토콜 (DEX) 이다. 이 시스템은 구현한 시스템별로 약간 상이하다. 일부는 중앙 집중식 거래 구조의 아이디어를 가져와서 분산된 요소를 추가하려고 시도하는 반면, 일부는 보다 급진적인 P2P 접근법을 취한다. 대부분은 설계단계에서 주문서의 개념을 채택하는 반면, 일부는 자산을 다른 자산과 직접 거래하는 P2P 방식의 대안을 채택한다. 그러나 이들 시스템이 모두 공유하는 요소는 바로 '비구속적’인 특성이다. 사용자는 이러한 플랫폼에서 거래하면서 자금을 관리한다. 스마트 컨트랙트의 잠재력을 활용하여, 사용자는 거래가 실행된 후에만 자금을 관리할 수 있다. 현재 대부분의 거래가 중앙집중식 거래소에서 이루어지고 있기 때문에, DEX에서의 유동성은 낮은 수준이다. 아래는 몇가지 분산 거래소의 예다. 온 체인 주문서: Etherdelta, Omisego 온 체인 P2P: KyberNetwork 오프 체인 주문서: 0x 오프 체인 P2P: Airswap ¶분산 거래 프로토콜: 주문서 호스팅 거래소를 설계할 때 우리는 이론적으로 다음과 같은 특성을 염두해 두어야 한다. 거래는 특정자산을 판매하려는 것과 특정 자산을 사고 싶은 것과 일치한다. CoinBase와 Bitfinex와 같은 중앙 집중식 거래에서 거래소는 두 종류의 주문이 기록되는 중앙 집중식 주문서를 호스팅한다. 주문이 일치하면 중앙 집중식 거래가 주문을 채운다. 그리고 이 모든 것은 체인 외부에서 일어난다. 분산된 거래소의 현재 구현상의 가장 큰 문제점은 유동성이 낮기 때문에 느리다는 것이다. 게다가 이미 보안을 제공하기 위해 블록체인에 있는 Etherdelta 호스트와 같은 기존의 분산 거래소가 존재한다. 체인에 주문서를 호스팅하면 블록체인 자체가 스케일링 문제가 있을 때 거래가 느려지게 된다. 예를 들어, 이더리움 블록체인에서 주문을 호스팅, 수정, 또는 취소하면 이더리움 블록체인의 가스 (수수료)가 발생한다. 분산 거래 프로토콜 0x는 기술적으로 ‘오프체인 주문, 온체인 정착’ 이라는 원칙을 세워서 이 문제를 해결한다. 즉, 오프 체인으로 이를 브로드캐스팅하고, 거래가 확정되면 이를 그 때 체인에 올린다. Relayer가 수수료를 밝히면, maker는 판매를 등록하고, taker는 relayer의 수수료를 보고 구매를 결정하면 스마트 컨트랙트를 통해 그때 거래가 확정된다. 여기서 Relayer는 분산 거래 프로토콜의 역할을 하게 된다. 가격에 대한 권리도 없고, 거래를 매칭시킬 수도 없지만, taker에게 가격을 추천할 수는 있다. 이를 연결하고 수수료를 받는 것이 이 거래의 형태다. 이론적으로, 여러 주문 릴레이에 대한 호스팅은 거래에 필요한 유동성을 제공하는 것이다. 0x프로토콜을 기반으로하는 중간 역할을 하는 Relayer는 사용자가 특정 주문이 taker로 채워질 때가지 자산을 저장할 수 있는 자동화된 스마트 컨트랙트를 제공한다. 중앙 집중식 거래와 달리 Relayer들은 더이상 거래되는 자산을 제어하지않고, 최종 사용자가 유동성이 있는 주문서로만 호스팅한다. 이들은 0x 프로토콜에서 보상으로 수수료를 받게된다. 시간이 지남에 따라 이들의 경쟁은 수수료를 낮추게 될 것이다. 기술적으로, Coinbase와 Bitfinex와 같은 대규모 중앙 거래소는 0x 프로토콜에서 향후 Relayer가 될 수 있다. 이는 사용자가 공유 유동성 풀의 해택을 받는 동시에, 자금을 관리할 수 있게 된다. ¶분산 교환 프로토콜: P2P KyberNetwork는 이전과 달리 이더리움 블록체인에서 토큰 교환에 필요한 모든 단계를 수행하는 거래를 목표로 한다. 앞서 언급한 주문서 방식을 채택할 경우 비용이 많이 든다. (거래수수료, 이더리움에서 발생하는 GAS 등) 이점을 염두해 두고, 이더리움 블록체인을 기반으로 한 스마트 컨트랙트를 통해 거래를 수행하는 P2P 네트워크를 구축하게 되었다. 이렇게 하면 저렴한 수수료와 함께 신뢰가 필요없는 거래 경험을 구축할 수 있게 된다. KyberNetwork는 준비금을 도입해 분산된 거래소에서의 낮은 유동성 문제를 해결하고자 한다. 여기서 준비금은 이미 플랫폼에 레버리지 될 수 있는 수준의 높은 유동성을 제공한다. KyberNetwork는 네트워크의 첫번째 보류지가 되지만, 결국 예비 시스템의 일부로서 대규모 거래를 이기기를 희망한다. 토큰을 거래하는 것 외에도, 토큰 경제의 단편화를 해결하기 위한 방책으로 특정 토큰을 통해서만 접근할 수 있는 서비스를 제공한다. 서비스 제공업체는 사용자가 다른 디지털 화폐로 서비스 비용을 지불하고, Kyber가 필요한 토큰을 제공하기 위해 Kyber 스마트 컨트랙트 인터페이스를 활용할 수 있다. 따라서 사용자는 하나의 단일 트랜잭션에서 토큰 B의 지불을 수락하도록 의도된 수신자에게 토큰A 를 보낼 수 있다. 분산된 거래를 위한 더욱 급진적인 방식은 오프체인 P2P 방식이다. 이러한 유명한 서비스에는 Airswap이 있다. 이시스템에서 사용자는 오프체인 방식으로 거래를 체결해야 한다. 사용자가 거래 환경에서 서로를 찾는 방법은 이른바 '인덱서’를 활용하는 것이다. 인덱서는 주문에서 실행을 포함하지않는 거래 의도를 집계한다. Air Swap에서의 거래 maker: 판매, 구매 주문을 올리는 사람 taker: 주문에 맞게 거래에 응하는 사람 Oracle: 시스템 외부에서 제시하는 가격 정보. 현재는 Airswap에서 제공하며, 이후 인센티브를 바탕으로 서드파티에서도 가능하게 구현할 예정 indexer: maker와 taker가 만나는 공간. 의도를 확인할 수 있는 정도의 용도 maker가 indexer에서 가격정보를 조회 taker는 indexer에 가격 정보를 업로드 indexer는 maker에게 해당 가격을 원하는 정보를 기반으로 하는 maker가 있음을 알림 서로 거래의 의도를 교환 서로 거래의 의도를 교환 스마트 컨트랙트를 통해 거래 인덱서에서 잠재적 거래에 대한 정보를 수집한 이후에는 Oracle 에 가격정보를 요청하여 선택적으로 가격정보를 받을 수 있다. Oracle 는 양측 모두가 가격결정을 내리고 협상 과정을 원활하게 진행할 수 있도록 지원한다. 궁극적으로 거래는 P2P 방식으로 이루어지기 때문에 높은 수준의 개인정보보호를 제공할 수 있다. ¶도입할경우 발생할 수 있는 문제 중앙 집중식 거래와 관련된 문제를 극복하기 위하여, 거래 유동성을 손상시키지 않고 거래자산에 대한 보안을 향상 시키는 거래 프로토콜을 만들어냈다. 그리고 이 프로토콜이 언제 채택될 것인가에 대한 질문에 답하기 위해서는, 무엇이 사용자들이 중앙집중식 거래소를 이용하게 되었는지 이해해야 한다. 그 이유중 하나는 자금을 보유하는 것과 관련된 자산에 대한 낮은 수준의 책임이다. 이러한 거래에서 개인키를 자동으로 넘겨주지 않으면, 사용자는 이러한 개인키를 관리하고 유지할 여력이 없다. 이러한 중앙집중식 거래에 대한 규제가 높아지면, 도난된 거래의 경우 최근 NEM의 사례처럼 사용자가 손실을 보상해야 한다. 중앙 집중식 거래소에 디지털 자산을 보유하는 것은 법률에 따라 고객의 자금을 책임지는 은행과 그 모양새가 점점 흡사해지고 있다. 중앙 집중화된 거래소에서 자금을 인출하려는 결정은 애초에 우리가 왜 분산형 시스템을 설계했는지에 대한 이유와 함께 이데올로기적 관점에서 더 가깝다. 용자가 중앙 집중식 거래소와 관련된 규제 불확실성에 대한 두려움 때문에 분산형 거래 프로토콜에 자산을 둘 수 있는 유인이 되는 것이다. 마지막으로, 다양한 대안에 대한 설명이 보여주듯이 분산 거래 프로토콜은 거래 서비스에대한 진입 장벽을 낮추는 유망한 방법이다. 완전히 새로운 중앙집중식 거래소 보다, 0x API를 이용해 주문서를 위한 Relayer를 두는 것이 더 쉽게 설정가능하다. KyberNetwork에서 예약은 토큰 이코노미에서 더 나은 사용자 경험을 위해 통화간 스왑을 쉽게 만들어 낼 수 있다. 미래에서 분산된 거래는, 토큰화된 경제활동의 대부분이 거래하는 통로일 수도 있다.","categories":[],"tags":[]},{"title":"어떻게 블록체인이 가난을 종식시키는가?","slug":"how-blockchain-can-end-poverty","date":"2018-07-11T15:00:00.000Z","updated":"2018-07-12T07:06:36.000Z","comments":true,"path":"2018/07/12/how-blockchain-can-end-poverty/","link":"","permalink":"https://www.yceffort.kr/2018/07/12/how-blockchain-can-end-poverty/","excerpt":"How Blockchain Can End Poverty 원문 오랫동안 서양 경제학자들은 사유재산권과 경제 발전 사이의 관계를 인식하지 못했다. 칼 마르크스는 사유 재산을 부의 원천으로 보고, 평등을 증진시키기 위해 이를 제거할 것을 요구했다. 한 세기 반이 지난 지금, 재산권을 등록하는 제도가 없는 나라의 경제 발전은 저해되고 있고, 시민이 잠재력을 완전히 실현하지 못하고 있다는 사실을 잘 알고 있다. (북한 같은) 간단한 사실이다. 경제 개발으로 가는 길은 동사무소를 통해 시작된다. 오늘날 세계 경제의 큰 격차는 재산권을 등","text":"How Blockchain Can End Poverty 원문 오랫동안 서양 경제학자들은 사유재산권과 경제 발전 사이의 관계를 인식하지 못했다. 칼 마르크스는 사유 재산을 부의 원천으로 보고, 평등을 증진시키기 위해 이를 제거할 것을 요구했다. 한 세기 반이 지난 지금, 재산권을 등록하는 제도가 없는 나라의 경제 발전은 저해되고 있고, 시민이 잠재력을 완전히 실현하지 못하고 있다는 사실을 잘 알고 있다. (북한 같은) 간단한 사실이다. 경제 개발으로 가는 길은 동사무소를 통해 시작된다. 오늘날 세계 경제의 큰 격차는 재산권을 등록할 수 있는 25억 인구와, 그렇지 못하는 빈곤한 인구 50억 사이에 있다. 재산권이라는 시스템이 부재하면 일어나는 일에 대해 생각해보자. 개인이 소유한 자산의 가치가 감소한다. 개인 자산을 소유하는 근로자의 임금은 평가 절하된다. 소유자는 신용을 얻거나 공공서비스를 이용하기 위해 자산을 담보하여 사용할 수 없다. 자산이 사람들에게 허용될 때 발생하는 여러 혜택을 잃게 된다. 1973년 연구에 따르면 세계인구의 2/3이 재산권에 대한 공식 시스템이 부재하여, 미개발된 자원과 자산이 약 170조 달러에 이르며 이 가치는 미국 전체 자산의 63%인 170조달러에 달한다고 밝혀진 바 있다. 설문조사, 위성사진, GPS 등 다양한 기술이 발전됨에 따라서 지구상에서 가시적인 자산의 위치에 대한 정보를 얻을 수 있게 되었다. 그러나 여전히 일부 개발도상국의 경우에는 자산을 소유한 사람에 대해 설명할 수 있는 접근 가능한 기록이 부재하다. 심지어 원시 사회에서도 누가 무엇을 소유하는지에 대한 기록이 존재했다. 이 발견을 바탕으로 페루에서는 재산 소유권 등록을 수립하기 위해 이러한 기록을 공식화하는 조직적인 노력을 수행하기도 했다. 1980년 Shining Path(페루의 좌익 게릴라 조직)은 무력을 통해 원시적인 재산권을 행사함으로써 가난한 페루 원주민들의 지지를 얻었다. 1990년, 페루가 원주민 페루인의 원시 재산 기록이 법적인 증거임을 공식적으로 인정함으로써, 총을 법률로 대체하려는 미국의 지원을 모색하면서 협력한 바 있다. 그 당시 게릴라 조직은 페루 전체 영토의 60%를 지배하고 있었다. 당시 미국 상원의원이었던 필 그램은 이러한 재산을 등록하려는 노력에 자금을 지원했고, 궁극적으로 페루의 군대와 새롭게 자산을 소유할 권리를 얻고 싶어하는 농부와 광부들간에 동맹이 맺어지게 되었다. 원주민들에게 재산 소유권에 대한 공식적인 증거를 제공함으로써 재산권 등록은 그들의 마음과, 지갑을 감동시켰다. 자신의 자산을 보호해야 한다는 신념은 공산주의 테러리스트를 압도하기에 충분했다. 이테러리스트의 지도자들은 가난한 사람들의 분노를 맞닥드리는 대신 감옥을 선택하면서 항복했다. 재산 소유권에 대해서 법적으로 확실성을 부여하는 것은 엄청난 경제적 이익을 창출할 수 있다. 1990년 국영 페루 통신화사인 CPT는 리마 증권거래소에서 5,300만 달러로 평가되었다. 정부는 CPT를 외국인 투자자들에게 판매하고 싶었지만, 회사의 자산에 대한 페루의 소유권이 글로벌 표준을 충족하지 못하여 불발되었다. CPT는 ILD의 가이드라인을 준수하면서 공식적으로 재산권을 수립하는 프로그램을 시작했다. 그리고 3년 후, CPT는 이전 가치의 38배인 20억달러에 팔리게 되었다. 2010년, 노점상인 모하메드 부아지지는 튀니지 의 도시인 'Sidi Bouzid’에 불을 지르면서 '아랍의 봄’을 촉발 시켰다. 연구에 따르면 이렇게 희생한 사람들의 이유는 종교적인 문제가 아니라, 재산권과 법치주의의 부재에 항의하고 있다는 것이 밝혀졌다. 페루의 성공과 재산권의 중요성에 대한 인식이 높아짐에 따라 개발 도상국 전역에서 부동산 소유에 관한 기록을 수집하기 위한 산발적인 노력이 진행중이다. 그러나 어디서나 접근 가능하고 쉽게 업데이트 할 수 있는 형태로 이러한 기록을 수집하고 유지하는 것이 어려웠다. 다행히도 세계적인 부동산권 등록 시스템을 실현할 수 있는 새로운 기술이 있다. Overstock.com의 CEO인 Patrick Byrne은 전세계적으로 부동산 권리의 기록 수집 및 유지 보수를 현대화하는데 많은 자원을 투입했다. 블록체인은 기록을 보관하고, 수백만 명의 사용자에게 액세스 하게 할 수 있으며, 부동산 소유권 이전을 지속적으로 업데이트 할 수 있다는 점에서 유망한 기술로 떠오르고 있다. 블록체인 기술이 컴퓨터 플랫폼 상에 재산권을 등록하려는 공공 및 민간의 노력에 힘을 실을 수 있다면, 우리는 전세계에 사유재산 등록이라는 축복을 공유할 수도 있다. 마르크스의 빈곤한 평등을 촉진하기 위해 사유재산을 파괴하는 대신, 모든 인류에게 재산권을 가져올 수 있다. 재산권이 보장되는 곳에서는, 진정한 안정과 평화를 가져오는 부의 번영, 자유, 소유권 도 보장될 것이다.","categories":[],"tags":[]},{"title":"블록체인이 세계 빈곤을 종식시키는 방법","slug":"how-blockchain-can-potentially-end-global-poverty","date":"2018-07-10T15:00:00.000Z","updated":"2018-07-11T13:57:25.000Z","comments":true,"path":"2018/07/11/how-blockchain-can-potentially-end-global-poverty/","link":"","permalink":"https://www.yceffort.kr/2018/07/11/how-blockchain-can-potentially-end-global-poverty/","excerpt":"how blockchain can potentially end global poverty 원문 오늘날 사용자가 블록체인 기반 서비스를 통해 은행 및 금융거래를 처리하는 것이 어느때보다 간편하다. 그리고 이는 거래에 대한 더 나은 접근을 통해 수백만명의 가난하고 소외된 사용자의 삶을 잘 변화 시킬 수 있다. 세계 은행의 글로벌 금융 지표에 따르면, 전 세계 인구의 1/4를 차지하는 25억명이 은행의 서비스를 이용하지 못하고 있는 것으로 나타났다. 이 정도 숫자의 인구가 금융거래애 접근할 수 없다는 것은 잠재적으로 삶을 변화 시킬","text":"how blockchain can potentially end global poverty 원문 오늘날 사용자가 블록체인 기반 서비스를 통해 은행 및 금융거래를 처리하는 것이 어느때보다 간편하다. 그리고 이는 거래에 대한 더 나은 접근을 통해 수백만명의 가난하고 소외된 사용자의 삶을 잘 변화 시킬 수 있다. 세계 은행의 글로벌 금융 지표에 따르면, 전 세계 인구의 1/4를 차지하는 25억명이 은행의 서비스를 이용하지 못하고 있는 것으로 나타났다. 이 정도 숫자의 인구가 금융거래애 접근할 수 없다는 것은 잠재적으로 삶을 변화 시킬 수 있는 자원을 확보할 수 없다는 측면을 가지게 된다. 예를 들어 신용카드는 응급상황에서 사용할 수 있는 좋은 수단이다. 의료비, 긴급 수리, 작은 기업의 확장조차 카드로 쉽게 해결 가능하다. 하지만 신용카드나 은행계좌가 없다면 어떨까? 대부분의 이러한 사용자들에게 최후의 수단은 대출과 극도로 높은 이자율로 돈을 빌리는 것이다. 이러한 약탈적인 대출관행은 종종 대출자가 원금 지불을 끝내기도 전에 부채에 깊게 빠지게 하기 때문에 빈곤의 악순환에 기여하게 된다. 따라서 핀테크 기업과 다른 신생 기업들은 이제 능력있고 돈있는 사용자들 뿐만 아니라, 금융혁신을 통해서 소외된 부문에 다뤄야할 필요성도 존재하게 된다. 한 나라에서 부를 늘리는 가장 좋은 방법은 비즈니스를 할 수 있는 환경을 쉽게 만들어 주는 것이다. 자본주의, 기업가 정신, 자유로운 돈의 흐름은 어떤 개발 계획이나 정부정책보다 더 많은 삶을 개선했다. 블록체인의 분산된 특성으로 인해, 이러한 지불 플랫폼을 더 효율적이고 안전하게 만들어 준다. 다른 모든 것들은 너무 중앙집중화되어 있다. 모든 사람들이 지불 및 비즈니스 서비스에 동일한 액세스 권한을 가지게 되면, 모든 사람들이 돈을 벌 수 있는 더 많은 기회와, 더 나은 삶을 줄 수 있는 것이다. 태국과 미얀마와 같은 신흥 시장에 거점을 두고 있는 Everex는 이주 노동자들이 블록체인 거래를 통해 돈을 집으로 보낼 수 있게 해준다. 물론, 이보다 더 좋은 방법은 전통적인 은행이 요구하는 공식적인 절차를 거치지 않고도, 소액 대출거래를 통해 소량의 돈을 저렴한 이자율로 빌릴 수 있게 해주는 것이다. 이러한 거래에서 비용과 속도는 혁신의 주요 동인이다. 이더리움과 블록체인 기술은 일반적으로 거래비용을 낮추고, 투명성을 높이고 많은 사람들이 금융서비스에 액세스 할 수있게 해준다. 그리고 이러한 혁신은 특히 아시아와 같은 신흥 지역에서 금융인프라를 강화하고 있다. ¶경제적 포용을 통해 빈곤의 순환을 깨는 것 이러한 금융 거래 뿐만 아니라, 블록체인은 경제적인 정체성을 갖게 해준다. 신원, 은행 기록, 신용 기록 과 같은 내용은 은행서비스를 이용하지 못하는 사람들에게 확립하기 어려운 개념이다. 중앙 집중식 권한 없이 사용자 간에 직접 데이터를 공유할 수 있는 블록체인에, 사용자의 신원 데이터를 저장한다. 그리고 블록체인의 안전하고 불변의 특성은 정보를 잃어버리거나 변경하는 것에 대해 걱정하지 않고, 민감한 사용자 데이터를 공유하는 방법을 제공한다. 이러한 사람들을 장기적으로 빈곤으로 부터 구제하는 진정한 방법은, 거래에 참여하기 위한 신원을 구축하는 것이다. ¶결론: 더 좋은 접근성은 더 나은 기회를 의미한다. 블록체인을 비롯한 이러한 기술은, 경제적으로 소외된 사람들이 앞으로 나아갈 수 있는 유일한 방법이 될 수 있다. 보안된 사용자 신원 조회, 사기없는 거래와 같은 이전에 접근하기 어려운 서비스에 액세스할 수 있는 수단을 제공함으로써, 블록체인을 만드는 신생기업은 사람들을 빈곤에서 벗어나 보다 포괄적인 경제로 끌어드리는데 도움이 될 것이다.","categories":[],"tags":[]},{"title":"블록체인 없는 블록체인 혁명","slug":"blockchain-revolution-without-the-blockchain","date":"2018-07-09T15:00:00.000Z","updated":"2018-07-10T10:04:25.000Z","comments":true,"path":"2018/07/10/blockchain-revolution-without-the-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/07/10/blockchain-revolution-without-the-blockchain/","excerpt":"Blockchain Revolution Without the Blockchain 원문 현재 블록체인은 마치 닷컴 붐 때 인터넷과 비슷한 수준의 관심을 끌고 있는 것 같다. 많은 사람들이, 신뢰할 수 있는 제3자의 필요 없이, 불변성을 암호화하고, 스마트 컨트랙트를 가능하게 하는 공개적인 분산원장을 기반으로 하는 이 새로운 기술에 흥분하고 있다. 많은 기업들이 거래를 더 빠르고 안전하며 투명하게 분산처리 함으로써 비용을 낮추고 싶어하기 때문에, 이 기술에 많은 관심을 갖고 있다. 그러나 블록체인 너머에 있는 기술에 대해 이해하고","text":"Blockchain Revolution Without the Blockchain 원문 현재 블록체인은 마치 닷컴 붐 때 인터넷과 비슷한 수준의 관심을 끌고 있는 것 같다. 많은 사람들이, 신뢰할 수 있는 제3자의 필요 없이, 불변성을 암호화하고, 스마트 컨트랙트를 가능하게 하는 공개적인 분산원장을 기반으로 하는 이 새로운 기술에 흥분하고 있다. 많은 기업들이 거래를 더 빠르고 안전하며 투명하게 분산처리 함으로써 비용을 낮추고 싶어하기 때문에, 이 기술에 많은 관심을 갖고 있다. 그러나 블록체인 너머에 있는 기술에 대해 이해하고 있는 사람들은 많지 않다. 어떤 이점을 가져다 줄지, 혹은 왜 실패 할 수 있는 지에 대해 알고 있는 사람은 많지 않다. 새로운 기술이 맞이하는 신선함과 불확실성은 새로운 현상은 아니지만, 이는 경제에 영향을 미치는 요소다. 이러한 낙관론은 미디어에서도 나타나는데, 막대한 비용의 절감을 이야기 하지만 어떻게 이러한 절감액이 발생하는지에 대해서는 구체적인 정보를 제공하지 않는다. 이 기술을 자세히 살펴보면, 이른바 블록체인이 주는 이점은 사실 대부분이 블록체인에서 나온 것이 아니다. 블록체인 기술에서 파생된 기술 - 스마트 컨트랙트, 암호화, 분산원장 - 들은 별개의 개념이다. 세가지는 한꺼번에 구현될 수 있지만, 그럴필요 는 없다. 그리고 사람들이 얘기하는 대부분의 이점은 암호화와 스마트 컨트랙트에서 나온다. 하지만 암호화와 스마트 컨트랙트에는 꼭 블록체인이 필요한 것은 아니다. 따라서 이러한 기술의 물결이 솔루션의 채택을 촉진할 수 있지만, 블록체인 혁명 이우에는 실제 블록체인 응용 프로그램이 거의 포함되지 않을 수도 있다. 대신, 이러한 변화는 암호화와 스마트 컨트랙트에 초점이 맞쳐줘 있을 것이다. ¶블록체인을 둘러싼 혼란 많은 사람들과 시장이 이른바 '블록체인 혁명’에 열광하고 있다. 블록체인 시장규모는 2016년 2억 1천만 달러에서 2021년 20억달러 이상으로 증가할 것으로 추정된다. 블록체인 기술은 금융 산업, 서플라이 체인, 정부의 기록방식 과 다양한 분야에서 변화를 만들어 줄 것이라고 기대한다. 파이낸셜 타임즈에서는 아래와 같이 말했다. 블록체인은 기록의 블록에서 지속적으로 유지되는 거래로 이루어진 전자 원장이다. 중요한 것은 원장이 모든 참가자들에 의해 공동으로 운영된다는 것이다. 이는 암호화적으로 안전하며, 누구든 기록을 조작할 수 없다는 것을 의미한다. 블록체인에서 가장 기대되는 것은 비용 절감이며, 이에 대해서 파이낸셜 타임즈에서 다음과 같이 언급했다. 블록체인은 비트코인 시장을 뒷받침 하기 위해 만들어진 전자 원장이다. 이 기술의 신봉자들은 더 값싸고, 안전한 방식으로 많은 거래를 할 수 있을 것이라고 주장한다. 이 기술은 현대 금융이 복잡한 신뢰 네트워크를 자동화 하는데 목적이 있으며, 금융 부문에서 수천만달러의 비용을 절약할 수 있다. 자원을 절약할 수 있다는 주장은 보안강화, 거래 속도 향상, 공유 원장에서 비롯된다. 블록체인의 빠른 거래는 (항상 빠른 것은 아니다) 스마트 컨트랙트에서 기인한다. 블록체인은 신뢰할 수 있는 제 3자 없이 작동하므로 중개자를 제거하기 때문에 비용을 절감한다. 그러나 블록체인의 장점에 대한 이러한 가정은, 적어도 세가지 개념을 혼동하는 것으로 보인다 1. 암호화, 2. 스마트 컨트랙트, 3. 분산원장.(분산형 데이터베이스) 그러나 이것들은 별개의 도구이며 블록체인 시스템에서는 모든 도구가 필요하지 않다. 그렇다면 블록체인은 무엇인가? 표준적인 정의는 없지만, 가장 간결하고 일반적인 정의는 ‘거래의 분산원장’ 이다. 이것이 바로 '블록체인 기술’이라는 용어가 분산 원장 기술과 상호적으로 이용되는 이유다. 특히 신뢰 할 수 없는 제3자 없이 모든 분산 원장을 확보할 수 있거나 스마트 계약을 포함할 필요가 있는 것은 아니다. 더 중요한 것은 암호화 또는 스마트 컨트랙트가 분산원장(블록체인) 내에서 구현될 필요가 없다는 것이다. ¶이런 혼란은 어디서 오는가? 블록체인이라는 용어는 비트코인 시스템의 일부인 ‘거래 블록의 체인’ 의 약자로 소개되었다. 이 맥락에서는, ‘거래의 분산원장’ 을 의미했다. 나중에 '블록체인’은 비트코인을 넘어서 거래의 분산원장에 다른 용도가 있는지에 대한 대중의 토론에서 독립적인 용어로 불리기 시작했다. 2009년 비트코인이 시작된 이래, 제3자 없이 운영되는 비트코인 시스템은 블록체인의 사기를 막는데 성공했다. 다시 말해 비트코인의 블록체인은 '불변’의 목적을 달성한 것이다. 비트코인의 블록체인은 모든 거래를 볼수 있으며, 어떠한 참여자도 원장에 거래를 추가하고 유효성을 확인할 수 있다. 일부 전문가들은 블록체인이 분산, 보안, 공개, 허가가 없는 속성을 가지고 있으며, 신뢰할 수 있는 제3자의 필요없이 작동할 것이라고 잘못 추정한다. 블록체인 속성은 실제 기술과 인간의 행동을 설명하는 인센티브 조합에서 비롯된다. 그리고 비트코인은 공개 키 암호화, 해싱 알고리즘 등의 암호화를 사용한다. 그러나 블록체인의 이러한 속성을 바꾸기엔 많은 비용이 들기 때문에, 이 시스템은 사실상 변하지 않는다. 비트코인의 블록체인은 비트코인 시스템의 일부이기 때문에 이러한 특성을 갖고 있다. 다른 분산 시스템은 이러한 속성을 유지할 수 없다. 이는 비트코인 시스템이 단순이 블록체인 이상이기 때문이다. 이 시스템에서는 고유의 암호화폐, 채굴 및 기타 요소를 포함한다. 예를 들어 이, 속성을 변경하거나 제거하면, 참가자의 인센티브에 영향을 미치므로 분산 원장의 속성이 변경될 수 있다. 또한 스마트 컨트랙트는 비트코인 블록체인의 핵심속성이 아니다. 비트코인 시스템은 트랜잭션과 함께 주석을 허용하여 일부 트랜잭션을 자동으로 실행할 수 있는 코드를 만드는 기본 기능을 제공헀다. 이더리움은 이에 스마트 컨트랙트를 촉진하는 목적으로 블록체인을 도입하여 이 기능을 확장했다. 대중들이 블록체인 맥락에서만 ‘스마트 컨트랙트’ 를 사용하는 것은 블록체인이 이것의 고유한 속성이라는 인식을 불러일으켰을지도 모른다. 그러나 트랜잭션을 자동으로 실행하는 코드는 다양한 엔티티에 의해 실행 될 수 있다. 따라서 스마트 컨트랙트, 암호화 및 분산 원장은 별도의 개념이다. 이들은 함께 구현될 수 있지만, 그럴 필요는 없다. 블록체인이라는 용어는 이 용어를 포괄하는 목적으로 사용해서는 안된다. ¶스마트 컨트랙트, 암호화, 분산원장을 왜 별도의 개념으로 이해해야 하는가? 이 들은 독립적으로 구현될 수 있기 때문에 특정 어플리케이션에는 이 들 중 일부만 사용될 수 있다. 이는 블록체인 형명의 미래에 중요한 사실일 수도 있다. 스마트 컨트랙트: 당사자간의 계약 조건을 자동으로 구현하는 컴퓨터 프로그램이다. 스마트 컨트랙트의 실행에는 인간의 결정, 행동을 포함하지 않기 때문에 더 빠르고 실수를 줄일 수 있다. 그리고 이는 비용을 절감한다. 이 용어는 Nick Szabo의 1997년 기사에서 비롯되었다. 이는 비트코인과 블록체인의 12년 전으로, 이미 오래 전 부터 존재하던 사실이었다. 스마트 컨트랙트는 중앙 집중식 시스템에도 설치되어 운용될 수 있으므로, 블록체인이 굳이 필요하지 않다. 암호화: 암호화는 현재 비즈니스 운영하에서는 활용도가 낮다. 최근까지는 퍼블릭-프라이빗키 암호화가 일반적으로 비즈니스 정보 기술 시스템에 로그인하는데 사용되었지만, 일단 시스템 내에 진입하면, 이러한 암호화는 거의 존재하지 않았다. 비트코인의 광풍은 이러한 암호화의 새로운 발전에 관심을 돌렸다. 비트코인의 블록체인은 표준을 따르는 잘 정립된 암호화 도구 (퍼블릭-프라이빗 키 암호화, 해시 등) 을 사용한다. 최근 개발된 도구는 단순 컴퓨터 보호를 넘어서 정보를 보호하는 암호화 시스템도 만들고 있다. 이러한 노력은 이미 산업 내에서 빛을 보고 있다. 우리는 암호화와 키 관리를 중점을 두고, 이를 AWS와 Google과 함께 이러한 문제를 연구했다. 우리 개발자들은 특정 데이터 로딩을 AWS, google에서 할지, 우리 데이터선터에서 할지 관심이 없다. (어디에 저장되어 있는지는 중요하지는 않다는 뜻) 그리고 우리는 모든 컴퓨터가 적대적이라고 가정한다. 데이터가 어디에 있는지는 중요한 문제가 아니다. 출처 이는 사이버 보안에 대한 접근 방식의 패러다임 변화를 의미한다. 현재 사기 및 해킹과 관련하여 많은 예산이 지출되고 있기 때문에, 암호화를 통한 변화는 상당한 비용절감의 가능성을 가지고 있다. 2016년 연구에 따르면 미국 대기업이 사이버 범죄 예방을 위해 평균 1700만달러를 소모하고 있고, 전세계 평균 950만 달러를 사용하고 있는 것으로 조사되었다. 이렇듯, 암호화의 이점을 얻고 비용을 절약하기 위해 블록체인이 필요한지는 의심스럽다. ¶그렇다면 블록체인의 이점은 무엇인가? 분산원장: 시스템의 여러 당사자가 공유 원장에 거래를 추가할 수 있으며, 이는 변경사항이 모든 사본에 지속적으로 반영되는 방식으로 적용된다. 이는 모순된 원장을 일치시키는데 비용이 많이 드는 곳에서 이점을 제공한다. 또한 이러한 합의 매커니즘은 중앙집중식 보다 더 많은 시간이 소요된다. 또한 원장을 여러곳에 저장해야 하므로 저장 및 계산 비용이 크게 증가할 수 있다. 현재까지 분산 원장을 사용하면서 얻는 이점이 네트워크 지연과 중복 저장소 비용을 능가하는 상황인지 명확하지 않다. 블록체인 기술을 지지하는 사람들은 단순한 분산 원장 보다 새로운 기술에서 더 많은 것을 기대 한다. 비트코인의 블록체인이 시작된 이래로 위조에서 자유로웠다는 사실로 미뤄봤을 때, 전문가들은 블록체인이 암호화 이상의 보안 혜택을 제공한다고 추정한다. 전문가들은 블록체인을 채택하면 중개자가 더이상 필요없으므로 비용 절감이 더 많이 발생할 것으로 기대한다. 사실 비트코인 컴퓨터 혁신의 핵심은 ‘허가가 필요없는 분산된 원장의 보안’ 이다. 시스템 어디에도 신뢰할 수 있는 제3자가 필요없다. 분산원장은 30년간 알려져 사용되어온 분산 데이터베이스의 특수한 유형이다. 이전의 배포된 데이터베이스는 제3자가 관리하고 유지하도록 요구되었지만, 비트코인은 허가 없이 배포되는 데이터비에스를 이용하는 최초의 사례다. 따라서, 비트코인의 블록체인은 사실상 불변의 존재다. 그러나 이러한 이점은 비트코인 없는 블록체인에서 실현하기 어려울 수 있다. 고유의 암호화폐(예: 비트코인)이외의 자산을 전송하기 위해 분산되고 허가가 필요업슨 안전한 블록체인을 만드는 것이 상당히 어려운 것으로 입증되었다. 첫번째 과제는 게이트웨이 문제다. 예를 들어, 블록체인을 사용하여 토지 소유권을 기록하고 이전한다고 생각해보자. 이 프로세스를 시작하려면 게이트웨이가 특정 토지가 있음을 증명하고, 초기 소유자에게 할당되어야 한다. 이는 게이트웨이가 개인, 기관, 컨소시엄이든지 블록체인의 사용자를 위해 신뢰할 수 있는 제3자가 되어야한다. 그러나 중요한 것은 비트코인에 게이트웨이가 필요하지 않다는 것이다. 비트코인 통화는 블록체인에 고유하므로, 모든 비트코인은 블록체인에 자동으로 생성되고, 비트코인 프로토콜에 따라 전성될 수 있다. 두번째 과제는 ‘돈(통화)’ 없이 원장의 불변성을 보장하는 것이다. 비트코인의 불변성은 암호화 뿐만 아니라 시스템의 내장된 인센티브에서 비롯된다는 것을 잊지말자. 원장을 불변으로 만든다는 사실은, 블록체인에 블록을 추가한다는 것이며, 이는 비용이 많이 든다. 네트워크 참여자 (광부)는 블록체인에 새로운 거래 블록을 추가할 권리르 부여하는 토너먼트에서 승리하기 위해 상당한 컴퓨팅 자원을 소비한다. 이는 불변성을 제공한다. 그리고 이에 대한 대가로 비트코인을 받는다. 비트코인이 없다면, 네트워크 참여자들은 다른 외부의 인센티브를 받아야 한다. 현재 제안된 어플리케이션은, 이 두 과제를 폐쇄된 블록체인을 만들어 해결하고 있다. 비트코인이 없는 블록체인은 제3자 없이 불변하지 않기 때문이다. 대부분의 경우 허가된 블록체인은 해당 목적을 위한 올바른 도구다. 하지만 우리는 이러한 사례가 비트코인의 혁신에서 벗어났다는 사실을 이해해야 한다. 이들은 분산 데이터베이스의 전통적인 개념으로 돌아 간 것이다. 또한 ‘허가가 없는’ 것이 최종 목표가 아니라면, 블록체인, 즉 트랜잭션의 분산원장이 ‘허가가 필요한’ 분산 데이터베이스에 대한 최적 설계인지 여부를 고려해야 한다. 증명 작업은 전기 뿐만 아니라, 속도와 탄력성 측면에서도 매우 비효율적인 합의 매커니즘이다. 거래의 전체 히스토리를 유지하는 것은 균형을 유지하는 것 보다 더 많은 메모리를 소모한다. 비트코인의 블록체인은 ‘허가가 필요없는’ 분산 데이터베이스를 수용하기 위하여 이러한 비효율성을 수용한다. 비트코인이나 다른 암호화폐가 외부에서 구현된 블록체인은 이러한 속성을 잃는다. 이는 더이상 ‘허가가 필요없는’ 시스템이 아니며, 제3자 없이 불변이지도 않다. 이런 ‘허가가 필요한’ 시스템을 수용한다면, 30년간 컴퓨터 과학 분야에서 연구한 분산 데이터베이스에 대한 연구가 더 효율적인 솔루션 (더 나은 합의 알고리즘, 메모리 공간)을 제공한다. 이는 아마도 블록체인보다 나을 수도 있다. 블록체인 혁명의 간접적인 효과 중하나는 전통적인 분산 데이터베이스의 대중화 일 수 있다. 분산 데이터베이스는 수십년간 컴퓨터 연구분야에서 중점적으로 연구되었다. 그러나 비트코인 이전에는 이러한 관심의 대부분이 Facebook과 같은 대형 인터넷 업체의 백오피스 운영으로 제한되었었다. 블록체인 혁명은 분산된 데이터 베이스에 대한 관심을 끌어올렸으며, 활용을 위한 새로운 아이디어와 다양한 적용을 가져왔다. 그러나 분산된 데이터베이스의 이점은 매우 특정한 어플리케이션에서만 제한된다. 그리고 이는 응용 프로그램 맥락에서 가치 있지만, 분산형 데이터베이스가 비용절감을 가져올 수 있는지는 분명하지 않다. ¶블록체인 혁명의 미래 블록체인 기술은 금융과 많은 산업에 상당한 영향을 미칠 것이다. 그러나, 이는 우리가 상상한 방식이 아닐 수도 있다. 컴퓨터 연산과 통신기술의 발달은 디지털 기업가 정신 실현 비용을 감소시켰다. 이로인해 스타트 업이 확산되었으며, 경쟁을 조성하고 기존 시스템의 비효율을 드러냈다. 스타트업과 기존 기업은 스마트 컨트랙트와 비트코인 블록체인의 특성에 관심을 갖고 있다. 그러나 시스템의 여러 측면에서 이점을 깨닫게 되면, 새로운 암호화 도구와 스마트 컨트랙트는 명확한 이점을 가지며, 분산된 원장은 이에 비해 제한된 영향력을 가질 수도 있다. 그리고 많은 어플리케이션에서 가장 적합한 것은 비트코인의 블록체인 기반이 아니라 전통적인 분산 데이터베이스가 될 것이다. 무엇보다도, 비트코인과 다른 암호화폐의 외부에는 '신뢰 할 수 있는 제3자가 필요없이 불변성을 암호화하는 무제한적인 분산원장’을 제공할 기술이 없다는 사실을 깨달아야 한다. 블록체인 혁명은 우리에게 새로운 도구를 제공하고, 산업의 풍경을 바꿀 수 있다. 그러나 암호화와 스마트 컨트랙트의 이점은 분산원장이 없이도 실현될 수 있기에, 블록체인 이후의 세계는 아마도 블록체이니 없는 세계일 것이다.","categories":[],"tags":[]},{"title":"블록체인 세계로의 가이드","slug":"a-guide-to-the-world-of-blockchain","date":"2018-07-08T15:00:00.000Z","updated":"2018-07-09T14:41:26.000Z","comments":true,"path":"2018/07/09/a-guide-to-the-world-of-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/07/09/a-guide-to-the-world-of-blockchain/","excerpt":"A Guide to the World of Blockchain 원문 비트코인으로 부터 만들어진 오리지널 블록체인은 암호화폐 기술이 선도한 독특한 방식으로 정보를 기록하려는 수천건의 시도에 영감을 주었다. 블록체인을 정의하는 방법에 대해서는 많은 논쟁이 있지만, 이 용어를 사용하는 대부분의 프로젝트는 사람이나 기관, 그룹이 공유하고 유지하는 단일 데이터베이스를 만드려고 한다. 블록체인의 대다수는 비트코인과 같은 새로운 가상화폐를 포함한다. 그러나 전 세계의 기업과 정부들은 이 기술을 이용해서 방대한 양의 데이터를 안정적으로 저장","text":"A Guide to the World of Blockchain 원문 비트코인으로 부터 만들어진 오리지널 블록체인은 암호화폐 기술이 선도한 독특한 방식으로 정보를 기록하려는 수천건의 시도에 영감을 주었다. 블록체인을 정의하는 방법에 대해서는 많은 논쟁이 있지만, 이 용어를 사용하는 대부분의 프로젝트는 사람이나 기관, 그룹이 공유하고 유지하는 단일 데이터베이스를 만드려고 한다. 블록체인의 대다수는 비트코인과 같은 새로운 가상화폐를 포함한다. 그러나 전 세계의 기업과 정부들은 이 기술을 이용해서 방대한 양의 데이터를 안정적으로 저장하는 방식에 대해 관심을 갖기 시작했다. ¶퍼블릭 블록체인 많은 새로운 암호화폐는 비트코인과 비슷하며, 컴퓨터를 가진 사람 누구나 다른사람의 허가 없이 업데이트 하는데 도움이 되는 공개 블록체인에, 모든 거래를 기록한다. ¶비트코인 비트코인: 오리지널 블록체인 기반 가상화폐는 새로운 온라인 통화라는 원래의 기대에 미치지는 못했지만, 금과 비슷한 희소한 디지털 상품으로 관심을 끌면서 글로벌 거래 시장을 창출하기 시작했다. Exonum: 비트코인 마이닝용 컴퓨터를 제작하는 업체인 Bitfury는 Exonum이라는 정부의 기록을 저장하는 새로운 방식의 프라이빗 블록체인을 만들어 냈다. (모든 Exonum의 거래는 비트코인 블록체인에 엮여 있다.) ¶이더리움 이더리움: 이더리움은 비트코인을 넘어 이른바 '스마트 컨트랙트’를 블록체인에 쓸 수 이게 하며, 이는 글로벌 컴퓨팅 시스템을 구축한다는 목표를 가지고 있다. 내부 화폐인 Ether는 컴퓨팅 파워를 지불하는데 사용할 수 있다. Axcore: 스타트업 Axoni는 금융시장에 최적화된 이더리움의 새로운 버전을 만들어 냈다. Autonity: 영국 스타트업인 Clearmatics는 여러 은행과 함께 이른바 'Utility Settlement Coin’을 만들어 은행간 거래를 할 수 있게 해주었다. 이더리움 프라이빗 블록체인: 이더리움 얼라이언스는 몇몇 프라이빗 버전의 이더리움을 만들었고, 이는 회사에서 새로운 어플리케이션을 이 위에서 만들 수 있도록 도와주고 있다. Quorum: 이더리움의 변형 버전으로, JP 모건에서 만들어 졌지만, 이후 금융 산업 외부에서도 사용되고 있다. ¶블록체인에서 영감을 받은 암호화폐 원장에 쓰이는 많은 암호화폐들은 누구나 접근할 수 있지만, 여전히 어느 정도는 중앙 기관과 회사에 의존한다. 이 화폐의 원장은 블록체인에서 영감을 얻었지만, 새로운 데이터 구조를 사용한다. 리플: 리플은 XRP라고 알려진 디지털 토큰을 사용한ㄴ 새로운 종류의 공유 원장이다. 리플은 대부분의 XRP 토큰을 보유하고 있으며, 금융 회사가 XRP를 사용하여 국경 간 지불을 빠르고 저렴하게 이용할 수 있도록 한다. Inter Ledger Protocol: 리플 개발자에 의해 만들어졌으며, 디지털 토큰이 없는 다른 원장, 전통적인 은행 원장들 사이에서도 사용될수 있는 소프트웨어를 개발했다. Stellar: 리플의 공통창업자에 의해 만들어졌다. 스텔라는 리플과 비슷한 원리를 사용하면서 리플을 개선하려는 움직임을 가지고 있다. 중앙 재단에서 감독하고, 토큰은 루멘으로 알려져 있다. Hyperledger Fabric: 하이퍼렛저는 IBM이 주도한 재단으로, 현재는 리눅스 재단이 글로벌 블록체인 표준을 반들기 위해 운영하고 있다. ¶다른 종류의 프라이빗 블록체인 많은 기업들이 기존의 블록체인을 사용하지 않고, 처음부터 기업 및 정부에서 사용할 수 있는 전용 블록체인을 구축하고 있다. 이런 개인 블록체인은 컴퓨처 그룹 간에 공유되도록 설계되어 있지만, 공개되어 있지 않다. Corda: 수십개의 세계적인 대형 은행 컨소시엄인 R3가 금융시장에 초점을 맞춰 개발했다. 블록체인의 개념을 사용하지만, 엄밀히 말하면 블록체인으로 간주되지는 않는다. ChainCore: 미국에 기반을 둔 스타트업에 의해 금융 거래를 위해 만들어졌다. Setl: 런던에 기반을 둔 스타트업이 유럽은행의 지원을 받아 만들었다. Digital Asset Platform: 전직 JP모건 경영자 Blythe Masters가 만들었으며, 몇몇 큰 대형은행의 지원을 받고 있다. Sawtooth: 인텔에서 첫 개발을 했으며, 현재는 하이퍼렛저 재단에서 감독하고 있다.","categories":[],"tags":[]},{"title":"소셜임팩트의 미래는 블록체인","slug":"the-future-of-social-impact-is-blockchain","date":"2018-07-06T15:00:00.000Z","updated":"2018-07-07T12:27:54.000Z","comments":true,"path":"2018/07/07/the-future-of-social-impact-is-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/07/07/the-future-of-social-impact-is-blockchain/","excerpt":"The Future Of Social Impact Is…Blockchain 원문 지난 3월 28일, 암호화폐인 리플은 거래에서 사용되는 디지털 코인 XRP 2,900만달러 가량을 DonorChoose.org의 모든 프로젝트에 기부하였다. 이 전례 없는 자선 기부는, 비트코인과 암호화폐가 소셜임팩트의 미래로 자리잡고 있다는 신호였지만, 이는 빙산의 일각일 뿐이다. 다음과 같은 기술을 상상해보자. * 나이지리아에서 자녀가 90% 이상의 출석률을 달성한다면, 자동으로 그 가족에게 현금을 제공하여 나이지리아 소녀의 졸업률을 증가","text":"The Future Of Social Impact Is…Blockchain 원문 지난 3월 28일, 암호화폐인 리플은 거래에서 사용되는 디지털 코인 XRP 2,900만달러 가량을 DonorChoose.org의 모든 프로젝트에 기부하였다. 이 전례 없는 자선 기부는, 비트코인과 암호화폐가 소셜임팩트의 미래로 자리잡고 있다는 신호였지만, 이는 빙산의 일각일 뿐이다. 다음과 같은 기술을 상상해보자. 나이지리아에서 자녀가 90% 이상의 출석률을 달성한다면, 자동으로 그 가족에게 현금을 제공하여 나이지리아 소녀의 졸업률을 증가 시킨다. 뮤지션이 특정한 음악의 저작권료 50%를 자동으로 자신이 원하는 곳에 기부할 수 있도록 한다. 주택에서 스마트 냉장고로 전기세를 절약하면, 절약한 만큼을 자동으로 자선단체에 기부한다. 이러한 상상이 현실화 될 수 있는 것은 블록체인 기술덕분이다. 블록체인은 아직 ‘얼리어답터’ 수준에 있지만, 전 지구에 걸쳐 엄청난 소셜임팩트를 가져올 잠재력을 가지고 있다. 블록체인은 아래와 같은 잠재력으로 국제 개발에 큰 영향을 미칠 것이다. 신뢰를 구축하고 비용을 절약하는 새로운 방법: 투명성과 책임성을 향상시키면 신뢰가 높아진다. 금융 거래와 계약을 용이하기 위해 블록체인을 사용하면 거래비용을 줄이고 효율성을 향상시킬 수 있다. 새로운 ‘기부’ 방식: 디티털 통화와 자산을 토큰화 할 수 있는 능력은 기부자에게 새로운 방법으로 '기부’할 수 있도록 도와준다. 사회적 문제를 해결하는 새로운 방법: 디지털 신원 관리는 개인의 권한을 강화 하고 시민권 박탈을 방지한다. 분산 원장과 디지털 화폐는 부를 보호하고, 재정적 통합을 촉진시키기 위한 새로운 방안을 제시한다. 블록채인의 잠재력 중 가장 큰 것은, 기부자에서부터 수령인에게 까지 직접 현금을 지급 할 수 있다는 것이다. 세계 식량 계획은 2020년 까지 그들이 진행하는 프로그램의 50%가 현금 기반으로 지원되는 것으로 변경 될 것이라고 내다 보았다. 이 조직은 블록체인을 활용하여 거래 오버헤드 비용을 3.5% 에서 1% 이하로 낮추었으며, 이는 수백만달러에 이르른다. 새롭게 떠오르는 기술이기 때문에, 많은 사람들이 이용하기에는 아직 장애물이 존재한다.최근 이 기술에 뛰어들만한 잠재적인 이익과, 블록체인 기술이 가져다 주는 도전에 대한 연구가 진행 된 바 있다. 효율성을 높이고 소셜임팩트 섹터 전체의 비용을 절감할 수 있는 분산 원장 기술을 어떻게 구현할 것인지 논의해 보아야 합니다. 일부 개별 조직은 단독으로 기술에 대한 한치의 의심없이 솔루션을 개발 할 것이지만, 이러한 접근 방식이 퍼지게 되면 더 큰 기회, 즉 데이터를 공유하고 규제 감독의 부담을 줄이며, 수혜자에 대한 견해와 영향에 대해 우리의 견문을 향상시킬 수 있는 기회를 놓칠 수도 있다. 우리는 이 더 큰 문제에 대해 함께 논의하고, 일해야 합니다. 출처 이 기술이 계속해서 발전하고, 사용사례가 시장에서 성공적으로 나타남으로써, 더 많은 기술이 제공될 것이다. 기부자와 수혜자의 기대가 점점더 직접적이고 투명한 모델로 이동하고 있기 때문에, 이 흥미로운 기술에 대한 최신의 정보를 유지하는 것에 소셜임팩트의 미래가 달려 있다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"social-impact","slug":"social-impact","permalink":"https://www.yceffort.kr/tags/social-impact/"}]},{"title":"보건 데이터를 위한 블록체인과 그 활용 가능성","slug":"a-blockchain-for-healthcare","date":"2018-07-05T15:00:00.000Z","updated":"2018-07-06T06:00:48.000Z","comments":true,"path":"2018/07/06/a-blockchain-for-healthcare/","link":"","permalink":"https://www.yceffort.kr/2018/07/06/a-blockchain-for-healthcare/","excerpt":"Blockchain For Health Data and Its Potential Use in Health IT and Health Care Related Research 원문 유전 연구가 증가하고 정밀 의학발전으로 인해, 건강 관리는 개인의 유전적 구성, 생활 방식 및 환경을 통합한 질병 예방 및 치료에 대한 혁신적인 접근 방식을 목격하고 있다. 동시에 IT 기술의 발전으로 헬스 케어 정보의 대규모 데이터 베이스가 생성되고, 건강 데이터를 추적하는 도구가 제공되며, 개인이 자신의 건강관리에 더 많이 관여할 수 있게 되었다. 이러","text":"Blockchain For Health Data and Its Potential Use in Health IT and Health Care Related Research 원문 유전 연구가 증가하고 정밀 의학발전으로 인해, 건강 관리는 개인의 유전적 구성, 생활 방식 및 환경을 통합한 질병 예방 및 치료에 대한 혁신적인 접근 방식을 목격하고 있다. 동시에 IT 기술의 발전으로 헬스 케어 정보의 대규모 데이터 베이스가 생성되고, 건강 데이터를 추적하는 도구가 제공되며, 개인이 자신의 건강관리에 더 많이 관여할 수 있게 되었다. 이러한 의료 및 정보기술의 발전을 결합하면, 헬스케어 IT 분야에 혁신적인 변화를 촉진할 수 있다. 미국 'The American Recovery and Reinvestment Act’에서는 모든 공공 및 민간 의료 제공자가 2014년 1월 1일 까지 전자 의료기록 (EMR)을 채택하도록 요구했다. 이는 EMR의 가용성과 활용도를 크게 증가 시켰다. 그러나 이러한 시스템 대부분은 보건 정보를 서로 공유할 수 있는 능력이 없다. 그러나 블록체인 기술은 현재 보건 IT 시스템에 존재하는 상호 운용성 문제를 해결하고, 개인, 보건 정보 제공자, 건강 관리 기관 및 의료 연구원이 개인의 건강 데이터를 안전하게 공유할 수 있게 해주는 기술 표준이 될 수 있다. ¶헬스 케어를 위한 블록체인 모델 ¶확장가능성 의료 기록, 문서, 이미지가 포함된 분산 블록체인에는 데이터 저장공간과 처리량에 제한이 있다. 비트코인 블록체인을 모델로 한 경우, 의료 블록체인의 분산 네트워크에 속한 모든 구성원은 미국의 모든 개인에 대한 의료 기록 사본을 저장하게 되는데, 이는 데이터 저장 관점에서는 실용적이지 못하다. 의료 데이터는 동적이고, 굉장히 방대하기 때문에 네트워크의 모든 구성원에게 모든 기록을 복제하는 것은 많은 대역폭을 사양하게 되고, 네트워크 리소스를 낭비하며 데이터 처리량 문제가 제기 된다. 의료 정보 관리가 블록체인의 이점을 실현하기 위해서는, 블록체인이 의료 기록 및 데이터에 대한 액세스 제어 관리자로 기능해야 한다. 때문에 블록체인에 저장되는 정보는 사용자 의료 기록에 대한 색인이다. 색인은 라이브러리의 카탈로그와 유사하다. 카탈로그에는 책에 관련한 메타 데이터와 책을 찾을 수 있는 위치가 포함되어 있다. 의료 블록체인도 같은 방식으로 작동해야 한다. 블록의 트랜잭션에는 사용자의 고유 식별자, 건강 기록에 연결된 암호화 코드 및, 트랜잭션이 생성된 타임스탬프가 포함된다. 데이터 액세스의 효율성을 향상 시키기 위해 트랜잭션에는 건강기록에 포함된 데이터 유형과, 자주 사용되는 쿼리를 용이하게 하는 메타 데이터가 포함된다. 여기에 추가로 공식적인 의료 기록 뿐만 아니라, 모바일 응용 프로그램 및 웨어러블 디바이스의 의료 데이터가 포함된, 완전히 색인된 기록을 포함할 수 있으며, 이는 계속해서 개발 사용자를 따라 다닐 것이다. 블록체인에서 접근하려고 하는 모든 데이터는 ‘Data Lake’ 라고 불리우는 데이터 저장소에 저장된다. 이 'Data Lake’는 확장 가능성이 뛰어나고, 이미지, 문서, 키값 저장소에 이르기까지 다양한 데이터를 저장할 수 있다. 이는 의료 연구를 위한 도구이며, 데이터 분석 등에도 사용 가능하다. 또한 SQL Query, 텍스트 마이닝, 머신러닝을 지원한다. 모든 정보는 암호화 되고, 개인정보보호 및 진위성을 보장하기 위해 디지털로 서명된다. 의료 정보 제공자가 의료 기록을 작성하면, 이 문서와 이미지의 진위 여부를 확인하기 위해 디지털 서명이 만들어진다. 그리고 이러한 데이터는 암호화 되어 'Data Lake’에 보내진다. 정보가 저장될 때마다, 의료 기록에 대한 포인터가 사용자의 고유 식별자와 함께 블록체인에 저장된다. 그리고 환자에게 의료 데이터가 블록체인에 추가되었음을 알린다. 같은 방식으로 환자는 모바일 응용 프로그램 및 웨어러블 디바이스 센서의 디지털 서명 및 암호화로 의료 데이터를 추가할 수 있다. ¶보안 및 개인정보 보호 사용자는 자신의 데이터에 대한 완전한 액세스 권한을 가지며, 공유도 제어한다. 또한 블록체인에 데이터를 쿼리하고 쓸 수 있는 사용자를 지정할 수 있다. 모바일 대시보드 응용프로그램을 사용하면, 블록체인에 액세스 할 권한을 가진 사용자를 확인할 수도 있다. 또한 사용자는 언제 누가 어떤 데이터에 액세스했는지가 포함된 로그도 확인 가능하다.이런 제어 권한은 유연하며, ‘All or nothing’ 방식으로 권한을 제어할 수 있다. 액세스 제어 정책은 블록체인에 안전하게 저장되며, 정보의 소유자 많이 이러한 데이터를 변경할 수 있다. 의료 서비스 제공자가 사용자 의료 정보에 대한 권한을 부여받으면, 블록체인에 사용자 데이터를 쿼리하고 디지털 서명을 통하여 인증을 한다. 신원 인증은, 금융 기관이나 규제 기관이 수립한 방법을 따르면 될 것이다. 생체인식 시스템을 활용한다면 비밀 번호와 토큰 기반의 보안 방식을 더욱 강화 시킬 것이다. 이러한 모델에서는 사용자는 데이터를 인증된 건강 관리 제공자 또는 건강관리 기관에 대해 액세스를 제어할 권한을 독점적으로 가지게 된다. 디지털 서명된 트랜잭션과 결합된 블록체인의 분산된 특성은, 공격자들이 디지털 서명을 위조하거나 네트워크 자원의 대부분을 통제하여 네트워크를 손상시킬 수 없게 한다. 또한, 암호화된 트랜잭션만 포함되어 있으므로 공개 원장에서는 아무 정보도 찾을 수 없을 것이다. ¶헬스케어 블록체인의 기술적 이점 블록체인은 다양한 오픈소스 소프트웨어, 오픈 API를 기반으로 하므로, 시스템간의 상호운영성을 용이하게 하며, 더 많은 양의 데이터와 사용자를 처리하기 위해 효율적을로 확장 할 수 있다. 그러므로 헬스케어 블록체인은 오픈소스 소프트웨어로 개발되어야 한다. 이를 통해 다양한 응용 프로그램을 선택하여 혜택을 누릴 수 있으며, 특정 요구사항과 옵션에 부합하는 다양한 선택지를 고를 수 있다. 또한 의료 IT 생태계 내에서 상호 운용성 문제를 해결한다. OpenAPI를 사용하여, 서로 다른 시스템간의 복잡한 노드 통합 개발을 필요로 하지 안ㅎ는다. 그리고 환자 의료 커뮤니티, 연구자는 정확하고 포괄적인 환자의 의료 데이터를 얻기 위해 하나의 공유 데이터 소스 (Data Lake)에 액세스 할 수 있다. Data Lake와 연결된 블록체인 데이터 구조는 환자의 모바일 응용프로그램, 센서, EMR, 문서 및 이미지 데이터를 포함하여 다양한 의료 데이터 소스를 제공할 수 있다. 데이터 구조는 유연하고 확장가능하며, 예기치 않은 데이터 또한 수용할 수 있다. ¶헬스케어 블록체인의 장점 모든 의료 데이터에 대한 단일 저장소 위치를 만들고, 실시간으로 개인화된 데이터를 추적하고, 세분화하여 데이터 액세스 권한을 설정할 수 있는 보안은 연구 및 가인 맞츰 의료 서비스 제공에 도움이 된다. 연구자들은 질병에 대한 이해를 높이고, 생물 의학적 발견 속도를 가속화하고, 약물 개발 속도를 향상 시키며 개인 맞춤 별 치료 계획을 설계하기 위해 광범위하고 포괄적인 데이터 세트를 필요로 한다. 블록체인이 제공하는 공유 데이터 환경은 민족, 사회경제적, 지리적인 정보를 포함한 다양한 데이터를 제공한다. 그리고 이러한 정보는 환자의 평생동안 수집되므로 종단 연구에 이상적인 데이터를 제공한다. 또한 기존에 정보에 접근하기 어려웠던 인구의 접근을 촉진시키고 일반 대중을 대표하는 결과 (대표성있는 결과)를 쉽게 만들어낼 수 있게 된다. 블록체인은 실시간 데이터에 대한 지속적인 가용성과 액세스를 보장한다. 임상 치료를 개선하고, 응급의료 상황에서 보다 유연하게 대처할 수 있게 된다. 또 한 공중보건에 영향을 미치는 변화를 신속하게 감지하고 격리할 수 있게 해준다. 이는 전염병을 더 일찍 발견하고 해결할 수있게 도와줄 수 있다. ¶결론 상호 운영성 목표를 발전시키기 위한 가장 효율적이고 효과적인 방법은, 의료 IT를 위한 국가 기술 인프라를 구축하는 것이다. 개방형 API는 상호 운용성을 해결하기 위한 필수적인 과제다. 그리고 일생동안 개인의 의료 데이터를 포괄적으로 볼 수 있는 분산형 공유 인프라도 필요할 것이다. 블록체인을 이러한 방식으로 의료 시스템에 활용한다면, 수백만명의 개인, 의료 정보 관리자, 의료 기관 및 연구원이 방대한 양의 유전, 식이, 생활방식, 건강 데이터를 안전하고, 개인정보보호가 보장된 환경에서 제공해줄 수 있다. 데이터 확득, 저장 및 공유는 의학 연구 및 정밀 의학 발전을 위한 과학적인 기반을 마련하고, 질병을 치료하고 예방하는 새로운 방법을 개발하며, 모바일 장치에서 개인이 자신의 건강관리를 향상시키고 질병을 막을 수 있는 기회를 제공한다. 블록 체인 기술은 의료 IT 시스템 구축에 자리잡고 있으며, 블록체인에 대한 상호 운용성을 기반으로 사용하여 의학의 발전을 촉진시키는 것을 강력하게 고려해보아야 한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"healthcare","slug":"healthcare","permalink":"https://www.yceffort.kr/tags/healthcare/"}]},{"title":"블록체인 기술에서 글로벌 보건 자산까지 - 암호화폐 기술이 글로벌 보건 서비스에 자본을 공급할 수 있는가?","slug":"from-blockchain-technology-to-global-health-equity","date":"2018-07-04T15:00:00.000Z","updated":"2018-07-05T06:00:48.000Z","comments":true,"path":"2018/07/05/from-blockchain-technology-to-global-health-equity/","link":"","permalink":"https://www.yceffort.kr/2018/07/05/from-blockchain-technology-to-global-health-equity/","excerpt":"From blockchain technology to global health equity: can cryptocurrencies finance universal health coverage? 원문 1978년, 알마아타애서 개최된 WHO, UNICEF 합동 회의에서, 보건 의료정책의 기초가 되는 역사적인 선언 '알마 아타 선언’이 결의 되었다. 세계의 건강 자원의 상당수는 소수가 한정된 사람들에게의 서비스와 거기에 필요한 의학, 의료의 연구 개발로 향해지고 있어 대다수는 이 혜택의 밖에서 날마다 여러가지 병으로 괴로워하고 있다","text":"From blockchain technology to global health equity: can cryptocurrencies finance universal health coverage? 원문 1978년, 알마아타애서 개최된 WHO, UNICEF 합동 회의에서, 보건 의료정책의 기초가 되는 역사적인 선언 '알마 아타 선언’이 결의 되었다. 세계의 건강 자원의 상당수는 소수가 한정된 사람들에게의 서비스와 거기에 필요한 의학, 의료의 연구 개발로 향해지고 있어 대다수는 이 혜택의 밖에서 날마다 여러가지 병으로 괴로워하고 있다. … 세계에는 기본적 건강 관리 서비스조차 받을 수 없는 사람들이 수십억 명 있어 보건의료는 이러한 사람들이 건강을 개선해, 생산적인 생활을 보낼 수 있도록 하는 것을 제일로 추구해야 한다. 이를 통해,사회 생활에서의 건강의 중요성과 그것을 실현하기 위한 사회 시스템 구축을 요구했다. 그리고 건강의 실현이 ‘세계에서 가장 중요한 사회적인 목표’ 임을 분명히 했다. 이를 위해 WHO는 보편적 건강 보험 (UHC)을 촉구했다. 이러한 건강에 대한 평등과, 보편적인 의료 접근을 달성하는 것은, 자본 시장에 대해 얼마나 공평하게 접근할 수 있는지에 따라 달려 있다. 이러한 자본 시장은 국가, 지자체, 병원, 인프라 및 공급망 개발을 위해 필요하다. 그리고, 이러한 자본 접근을 위해서는 투명성이 반드시 필요하며, 자금이 언제, 어떻게, 어디서 쓰이는지, 그리고 투자 결과 무엇을 달성했는지 명확하게 알 수 있어야 한다. 그러나 이러한 수준의 투명성은 현재의 통화 시스템 내에서는 불가능하다. 전략, 프로세스, 성과, 자금 조달이 모두 불가분의 관계로 연결된다면 어떨까? 블록체인은 모든 거래에 대해 신뢰할 수 있고, 안전하고 불변하며 상호 운용 가능한 기록을 만드는 네트워크위에 구축된다. 그리고 이렇나 정보는 전세계적 어디에서든 이용할 수 있다. 그리고 이러한 블록체인을 세계 보건의 혁명에 적용하여 혁신을 만들어내는 방법에 대해 설명하려 한다. ¶현재 직면한 헬스케어 금융의 문제 오늘날 중저소득층 국가의 보건 시스템은 자금 부족으로 인해 자본시장 접근에 제한이 되어 있다. 이는 인력과 인프라의 약점과 더불어, 헬스케어 시스템이 당면한 가장 근본적인 문제다. 2014년 저소득국가의 건강을 위한 1인당 지출은 120달러인 반면, 고소득 국가는 5221달러에 이르렀다. 그리고 2040년이 되어도, 고작 195달러 정도선 밖에 증가하지 않을 것으로 보인다. 자금을 제공할 수 있는 사람들이 저소득/중산층 보건 시스템에 대해 투자를 망설이는 데에는 여러가지 이유가 있다. 잠재적인 투자자들은 투자 대상이 되는 기관에 대한 정보가 충분하지 못하다. 이러한 과거 투자는 낭비 까지는 아니더라도 비효율적이었고, 의미있는 개선을 보여주지 못했다. 이러한 데이터 격차, 운영의 비효율성, 부적절한 모니터링과 평가는 이러한 국가 의료시스템으로의 자본 흐름을 제한한다. 그러나 블록체인이 현재 당면한 이런 과제에 의미있는 해결책이 될 수 있다. ¶자금 조달에 대한 보편적인 접근 블록체인을 사용하는 암호화폐는, 제3자 기관을 금융시스템에서 제거하고, 신뢰할 수 있는 P2P 네트워크를 통해 당사자가 직접 자산을 주고 받을 수 있도록 한다. 이러한 보편적인 자금 조달은 글로벌 헬스케어/금융 자산 창출에 대한 중요한 패러다임 전환을 나타낸다. 첫째, 비트코인의 가치는 투명성과 보안성에 있다. 이 시스템은 사기를 최소화 하고, 위조를 방지하며 자금이 있는 사람들에게 재정적 신뢰를 제공한다. 암호화폐는 최빈국에서 가장 부유한 개인과 기관에 이르기까지, 모든 사람들이 안전한 초국과 화폐로 부를 축적하고 신뢰할 수 있는 지불자가 될 수 있게 함으로써 새계 시장에 대한 장벽을 해결할 수 있는 능력이 있다. 둘째, 금융기관과 같은 제3자 중개인을 제거함으로서 블록체인 원장을 이용한 암호화폐는, 빈곤, 불안정성, 부패로 인해 신뢰할 수 있는 금융 기관에 접근하지 못하는 사람들이 이러한 장애물을 우회하도록 허용함으로써 글로벌 금융 자산을 촉진 할 수 있다. 높은 수수료, 긴 처리 시간을 가진 다른 금융 중개자와는 달리 암호화폐는 보다 빠른 지불, 최소 송금 비용과 이러한 돈이 올바르게 도착했는지 또한 검증할 수 있는 가능성을 증가 시킨다. 세계 식량 계획이 10,000명의 시리아 난민을 대상으로, 블록체인 금융이전을 통해서 종전 수수료 1.5%에서 거의 0까지 줄였으며, 이는 한달에 인당 1.5달러, 총 150,000달러를 절약하는 효과를 보았다. 참고 금융 장벽이 사라지면서, 암호화폐 프레임워크는 국가, 기관 및 개인이 투명성과 책임을 질 수 있는 다른 국가, 기관 및 개인에게 직접 자금을 지원할 수 있는 새로운 길을 열어 준다. ¶다자간 금융 메커니즘의 새로운 시대 일반적으로 암호화폐 트랜잭션은, 여러 노드의 검증에 의존한다. 트랜잭션은 구성원이 확인 된 이후에만 발생하며, 이는 중복 또는 위조를 방지한다. 이더리움의 스마트 컨트랙트가 개발되면서, 이를 의료 및 의료 시스템 개발에 다양한 방식으로 이용할 수 있다. ¶기존 자금 조달 스마트 컨트랙트를 통해서, 기존 자금 조달 기관인 IMF, 세계은행, 국제 개발 기구 등에 혁명을 가져올 수 있다. 정책 임안자들에게 돈을 어떻게 써야 하는지에 대한 주권을 제공하고, 사전 설정된 목표가 달성 될 경우 증가된 자금을 제공할 수 있다. 또한 의료 쪽에 블록체인을 연결하여 장비, 공급품, 환자 치료, 실험 결과 등 고유한 식별자를 사용하여 어떤 서비스가 수행되고 어떤 결과가 달성되는지 신속하고 확실하게 증명할 수 있다. 마찬가지로, 지역 및 시스템 관리자와 보조금 제공자가 실시간으로 이익과 손실을 모니터링 할 수도 있다. 그리고 검증가능한 결과에 도달하거나, 개발 목표를 달성하면 추가자금을 제공할 수도 있다. ¶새로운 자금 조달 의료를 위한 스마트 컨트랙트 블록체인은 새로운 자금과 자본흐름을 창출하고, 잠재적으로 새로운 자금 제공자를 글로벌 헬스 케어 시스템에 도입할 수 있다. 예를 들어, 소아 응급실에서 천식을 줄이는 것 부터, 인도 농촌 지역의 소녀들을 위한 교육 접근성 향상에 이르기까지, 다양한 형태로 최근 몇년간 채권과 개발이 증가하면서 사람들이 다양한 분야에서 관심을 가지고 있는 것으로 나타났다. 이러한 관심은, 새로운 자금 공급자들을 개발로 끌어드릴 잠재력이 있지만, 투자에 대한 영향력과 시간차를 측정하기 어려워 투자자들이 어려움을 겪고 있다. 이더리움 과 같은 블록체인 화폐를 기반으로 한 스마트 컨트랙트는 이러한 이슈에 대한 사회적 촉진으로 적합하다. 상호 운용성이 향상됨에 따라 블록체인 스마트 컨트랙트는 대규모 자본을 도입하여 재고관리 시스템에 연결할 수 있게 되었으며, 부여된 자금이 의도된 자본 상품 구매에 사용되고 또한 의도된 수령인에게 제공되게 함으로써 사기와 부패를 방지한다. 블록체인 기반 시스템은 초국적 의료 자본 시장, 분산 벤처 자본 프로젝트, 소액 금융 및 의료 개발 분야에서 전세계에 새로운 대안을 제공한다. ¶보안, 표준화 된 불변의 트랜잭션 현재 시스템 하에서 의료 관련 정보를 교차해서 확인할 수 없으므로, 부정을 저지를 기회가 많고 일부는 이러한 사기로 인해 전세계 보건 관련 투자중 7.29%인 420억달러의 손해를 입은 것으로 밝혀지기도 했다. 그러나 블록체인 기술은 변조, 해킹, 재 작성 등의 이슈로부터 자유로운 모든 거래를 영구적으로 기록할 수 있는 불변의 원장을 만들도록 설계되었다. 결과적으로 트랜잭션을 가속화하면서 동시에 사기 행위 또한 식별할 수 있다. 예를 들어, 오늘날 약사가 처방하는 처방정보는 특정기관에만 저장되어, 모든 기록을 조회하는 것이 불가능하다. 하지만 상호 운용 가능한 블록 체인을 통해 각 기관은 특정 처방을 둘러싼 모든 이슈들을 볼수 있다. 마찬가지로, 실제 환자 데이터와 연결 될 수 있으므로, 사기에 당할 위험성이 현저히 줄어든다. 건강 관련 정보가 블록체인으로 이동함에 따라 사기행위가 더욱 어려워지고, 비정상적인 활동을 탐지하기 쉬워진다. 이미 생체 정보관련 데이터베이스를 만든 국가 기관은, 의료분야에서 블록체인 기술을 활용할 수 있는 위치에 있다. 2016년 인도는 11억 녕이 넘는 인도시민의 사진과 기본 인구 통계, 생체인식 데이터 등이 포함된 데이터 베이스인 Aadhaar Card를 구현했다. 이러한 검증 가능한 디지털 신원 증명을 사용하여, 블록체인은 물품 수령시 이러한 고유 데이터가 포함된 블록을 만들어, 금융 이전 및 재화와 서비스 제공이 의도된 수령인 및 소비자에게 도달할 수 있도록 보장할 수 있다. ¶모든 수준의 건강 데이터를 활용 블록체인을 사용하면 투명하고 개방적인 의료 정보 데이터 네트워크를 만들 수 있다. 그리고 이러한 시장을 만든다면, 개인과 보건 시스템 모두가 자신이 얻은 데이터를 바탕으로 수익을 창출할 수도 있다. 이러한 데이터의 가치는 시간이 지남에 따라 더욱 많이 축적되고, 더 나은 치료 계획이 발명되어 다양한 질병과 사람들에게 사용될 것이다. 그리고 환자의 정보를 연구에 사용할 수 있는지를 선택할 기회도 제공한다. 환자의 생체 데이터를 일종의 private key로 사용하여, 연구자가 익명의 건강데이터를 사용하기 전에 그 private key를 가지고 있는 환자에게 승인을 받아야 한다. 이런 보건 의료 정보를 공개적이고 익명인 공공 원장으로 이동하려면, 국가에서 법률의 방향을 상당부분 재조정해야 한다. 일례로, 미국에서는 보건 정보와 관련된 규제 때문에, 수학적으로 파생된 가명을 사용하는 것이 어렵다. 각 나라의 정치인들은 정보가 블록체인으로 이동할 수 있는 여지를 마련해야 한다. 저/중소득층 국가 정부의 경우, 이러한 유형의 데이터 소유, 마케팅 접근에 대한 대가로 보건 시스템에 대한 투자를 촉진할 수도 있다. 산업은 저/중소득층 투자에 단순히 CSR차원의 예산 이상으로 확장할 수 있으며, 스마트 컨트랙트와 미리 결정된 방향을 바탕으로 실제 시장에 기반한 의사결정을 내릴 수 있다. 그리고 이러한 국가 보건 데이터를 자본화 함에 따라, 평등한 보건 세계 시장을 창출할 가능성이 높다. 모니터링 및 평가 방법에 대한 정부의 접근을 적극적으로 확장하고, 비용 효율적인 국가 및 지역에 보건정책이 개입할 수 있는 가능성을 높여 준다. ¶결론 세계 보건의 형평성은 먼저 자본 시장에 대한 공평한 접근성을 확립하고, 국가에서 부터 환자에 이르기까지 모든 수준에서 자금을 조달하지 않고서는 달성되기 어렵다. 암호화폐와 블록체인 기술의 혁신은 초국적 금융 장벽을 해소하고, 사용 편의성, 책임성, 투명성, 부패 및 사기를 포함한 공평한 자본 접근을 방해하는 모든 문제를 해결 할 수 있다. 블록체인이 잠재력을 최대한 발휘하고, 보건 평등한 사회에 도움을 주기 위해서는 글로벌 보건 공동체와 글로벌 금융 공동체가 협력하여 이 과정을 이끌어 나가야 한다. 그러나, 블록체인은 만능열쇠가 아니다. 이러한 잠재력을 실현하기 전에 극복해야할 많은 장애물이 도사리고 있다. 기존 레거시 조적이 금융거래 및 의료정보를 블록체인으로 옮길 수 있도록 적극적인 자세를 취해야 한다. 블록체인 기술은 근본적으로 누구의 소유도 아닌 오픈소스로 남아야 한다. 의료 정보 (특히 사진) 파일 크기 자체가 블록체인에 올바르게 저장될 수 있어야 한다. 저/중소득층 국가가 블록체인 기술의 잠재력을 충분히 활용할 수 있어야 한다. 가장 먼저 인터넷 액세스 능력부터 향상시킬 필요가 있다. (현재 아프리카의 인터넷 엑세서 비율은 2~30% 수준이다.) 또한 스마트 디바이스 보급, 블록체인 및 사용에 대한 교육, 의료 기술과 블록체인의 상호 운용성 모두 이 프로세스를 가속화 하는데 꼭 필요하다. 정부 의료 기관 및 소비자는 암호화폐와 블록체인이 어떻게 동작하는지 잘 알고 있어야 한다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"healthcare","slug":"healthcare","permalink":"https://www.yceffort.kr/tags/healthcare/"}]},{"title":"블록체인 합의 프로토콜의 종류","slug":"type-of-blockchain-consensus-protocol","date":"2018-07-03T15:00:00.000Z","updated":"2018-07-04T11:41:56.000Z","comments":true,"path":"2018/07/04/type-of-blockchain-consensus-protocol/","link":"","permalink":"https://www.yceffort.kr/2018/07/04/type-of-blockchain-consensus-protocol/","excerpt":"블록체인 합의 프로토콜의 종류 블록체인이 세상을 어떻게 변화시킬 것 인지에 대한 논의가 많아지고 있지만, 이를 글로벌한 규모로 확대하기 위해서는 공유된 공공 원장이 효율적이며 안전한 합의 알고리즘을 필요로 한다. 일례로 비트코인의 작업증명과 같은 합의 알고리즘은 두 가지 일을 한다. 하나는 블록체인의 다음 블록이 올바른 유일한 버전임을 보장하고, 다른 하나는 외부에서 함부로 침입하지 못하게 하는 역할을 하는 것이다. 작업 증명에서 채굴자들은, 매우 어려운 암호화 퍼즐을 해결하기 위한 경주를 통해, 체인에 다음블록을 추가하고 이를","text":"블록체인 합의 프로토콜의 종류 블록체인이 세상을 어떻게 변화시킬 것 인지에 대한 논의가 많아지고 있지만, 이를 글로벌한 규모로 확대하기 위해서는 공유된 공공 원장이 효율적이며 안전한 합의 알고리즘을 필요로 한다. 일례로 비트코인의 작업증명과 같은 합의 알고리즘은 두 가지 일을 한다. 하나는 블록체인의 다음 블록이 올바른 유일한 버전임을 보장하고, 다른 하나는 외부에서 함부로 침입하지 못하게 하는 역할을 하는 것이다. 작업 증명에서 채굴자들은, 매우 어려운 암호화 퍼즐을 해결하기 위한 경주를 통해, 체인에 다음블록을 추가하고 이를 통해 발굴되는 수익을 얻기 위해 노력한다. 그러나 이런 작업증명은 완벽하지 못하다. 일반적인 비판은, 엄청난 양의 컴퓨팅 파워가 필요하고, 시간이 오래 걸리며 (10~60분), 대부분의 채굴이 전기가 저렴한 지역에서 집중되고 있다는 것이다. 이를 해결 하기 위해, 다양한 합의 프로토콜이 등장하기 시작했다. ¶Proof of Stake (지분 증명) 작업 증명의 일반적인 대안으로 알려진, Proof of Stake (지분 증명) 이다. 비싼 컴퓨팅 파워로 채굴을 하는 대신, '검증자’는 시스템의 코인에 투자하게 된다. 지분 증명하에서는 코인이 생성(채굴) 되지 않는다. 지분의 증거로, 다음 블록을 만들 확률은 자신이 소유한 시스템의 코인의 양에 달려 있다. 300개를 갖고 있는 사람은, 100개를 가진 사람 보다 선택될 확률이 3배다. 지분소유자가 블록을 작성하면, 해당블록은 블록체인에 커밋된다. 이 후는 각 시스템 마다 다르다. Tendermint에서는 시스템의 모든 노드가 다수 표결에 도달 할 때까지 서명되어야 하며 (비잔틴 합의 알고리즘), 다른 시스템에서는 랜덤한 서명 그룹이 선택된다. PeerCoin (최초로 채택) blackcoin NXT ethereum ¶Proof of Stake Anonymous (익명 지분 증명) 거래를 다른 사람이 볼 수 없도록 익명으로 만든 사용자가 보상을 받는 방식이다. 한 사용자가 거래를 요청하게 되면, 이른바 'Cloaker’들이 등장하여, 이 거래를 추적할 수 없도록 무작위로 여러 참가자를 섞는 것이다. 그리고 이에 따른 보상을 받게 된다. Cloakcoin ¶Delegated Proof of Stake (위임 지분 증명) 전체 노드를 실행하고, 이득을 얻을 수 있는 '위임자’에게 투표하여 이익을 얻을 수 있는 권한을 부여받는 방식이다. Bitshares ¶Proof of Activity (활동 증명) 인플레이션을 피하기 위해, 비트코인은 21m개만 생산되도록 되어 있다. 즉, 이 후에는 보상이 끝나고 비트코인 마이너들은 거래 수수료만 받게 된다. 그러나 이것이 '공유지의 비극’으로 인한 보안 문제를 일으킬 수 있다고 추측하는 사람들도 있다. (여기를 참조하세요.) 그래서 이에 대한 대안으로 나오는 것이 Proof of Activity (활동 증명) 이다. 활동에 대한 증거로, 채굴자는 기존 작업 증명 방식으로 컴퓨팅 퍼즐을 풀면서 마이닝을 시작한다. 다만 이렇게 채굴한 블록에는 (구현에 따라 다르지만)트랜잭션이 없고, 오로지 헤더와 마이너의 보상 주소만 포함 되어 있다. 이 시점에서 지분 증명 시스템으로 바뀌게 된다. 헤더의 정보를 기반으로 새블록에 서명하기 위해 임의의 검증자 그룹이 선택된다. 검증자가 코인이 더 많을 수록 이것이 선택 될 가능성이 더 커진다. 이 검증 이 끝나면, 본격적인 블록이 되는 것이다. 수수료는 채굴자와 검증자가 적절히 나눠 갖게 된다. Decred ¶Proof of Burn (소각 증명) 값비싼 컴퓨팅 장비에 투자하는 대신, 동전을 회수 할 수없는 주소로 보내서 ‘소각’ 하는 방식이다. 누구도 소유할 수 없는 주소로 코인을 보냄으로서, 무작위 선택 프로세스에 따라서 시스템에서 마이닝을 평생에 걸쳐 할 수 있는 권리를 얻는 것이다. 채굴자들은 해당 코인, 또는 비트 코인과 같은 코인을 태워버림으로써 다음 블록을 채굴할 확률을 높이는 것이다. 시간이 흐를수록, 돈을 더 소각 시켜서 마이닝에 당첨될 확률을 높이기 위해 더더 코인을 태우게 된다. (이는 마이닝을 위해 컴퓨팅 장비를 사는 것과 유사하다.) 하지만 이는 여전히 자원을 낭비하며, 단순히 더 돈을 많이 태우는 사람에게 유리하다는 이슈가 있다. slimcoin ¶Proof of Capacity (Proof of storage, Proof of space) (용량 증명) 간단히 말해, 하드드라이브 공간을 지불하는 것이다. 하드드라이브 공간이 많을 수록, 다음 블록을 채굴하고 블록 보상을 얻을 확률이 높아진다. 이 시스템 하에서는, 마이닝하기전에 알고리즘을 통해 하드드라이브에 저장할 ‘플롯’ 이라고 불리는 대규모 데이터 세트를 생성한다. 플롯이 많을 수록, 체인에서 다음 블록을 찾을 확률이 높아진다. BurstCoin ¶Proof of elapsed time (경과 시간 증명) 인텔에서 만든 자체적인 대체 합의 프로토콜이다. 이는 작업증명과 유사하지만, 전기를 적게 소비한다. 참가자는 암호화 퍼즐을 푸는 대신, SGX와 같은 신뢰실행환경 (Trusted Execution Enviroment) 내에서 작동된다. 네트워크의 참여자들은 무작위로 선택된 기간을 기다려야 하며, 가장 먼저 이 경과시간을 완료하는 첫 번째 노드가 블록에서 승리하는 것이다. 블록체인 네트워크의 각 노드는 임의의 대기시간을 생성하고, 대기 상태로 있게 된다. 먼저 꺠어난 사람, 즉 가장 짧은 경과 시간을 가진 노드가 깨어나 새로운 블록을 투입하고, 필요한 정보를 전체 네트워크에 전파한다. 한 가지 문제점은, 블록체인은 제 3자의 신뢰를 없애기 위해 만든 건데, Intel을 믿어야 한다. ¶Proof of Importance (중요도 증명) 중요도 증명은 어떤 네트워크 참여자(노드) 가 블록체인에 블록을 추가할 자격이 있는지 결정하는데 사용되는 메커니즘이다. (이 프로세스를 수확이라고 한다) 블록을 수확하는 대가로, 노드는 블록 안에 있는 트랜잭션 수수료를 거둘 수 있다. 중요도 점수가 높은 어카운트는 블록을 수확할 확률이 더 높다. 중요도 계산의 적격성을 확보하기 위해, 수확자격을 얻으려면 어카운트에 최소 10,000개의 XEM(화폐단위)를 보유해야하고, 다른 사람들과 거래를 많이 할 수록 이러한 수확을 할 확률이 높아진다. 즉, 해당 코인의 경제를 적극적으로 도와주는 사람들이 (중요도가 높은 사람) 더 많은 보상을 얻는 것이다. NEM ¶Proof of Stake Time (지분 시간 증명) 지분의 양을 확인하는 대신, 지분을 가지고 있었던 시간 (특정 주소에서 보유되고 있었던 시간)을 활용하는 것이다. Vericoin ¶Proof of Stake Velocity (지분 속도 증명) 얼마나 많은 지분을, 얼마나 적극적으로 사용하는지 에 따라 달려있다. Reddcoin","categories":[],"tags":[]},{"title":"이더리움 - 프라이빗 블록체인 만들기 (2)","slug":"ethereum-create-private-blockchain-2","date":"2018-07-02T15:00:00.000Z","updated":"2018-07-03T06:00:48.000Z","comments":true,"path":"2018/07/03/ethereum-create-private-blockchain-2/","link":"","permalink":"https://www.yceffort.kr/2018/07/03/ethereum-create-private-blockchain-2/","excerpt":"여기에서 이어집니다. 자바스크립트 기반의 콘솔입니다. ¶1. 어카운트 확인하기 1 2 > eth.accounts [\"0x44e74080949320292839b9a0df55e4459dd51434\"] 아까 생성한 한계의 어카운트가 보입니다. ¶2. 잔고 확인하기 1 2 > eth.getBalance(eth.accounts[0]) 300000 첫 제네시스 블록을 만들때 alloc 했던 양 만큼 할당이 되어 있네요. ¶3. 단위 변경하기 그런데 저 단위는 사실 ether가 아니고 wei입니다. 아래 처럼 변환하면 됩니","text":"여기에서 이어집니다. 자바스크립트 기반의 콘솔입니다. ¶1. 어카운트 확인하기 12&gt; eth.accounts[&quot;0x44e74080949320292839b9a0df55e4459dd51434&quot;] 아까 생성한 한계의 어카운트가 보입니다. ¶2. 잔고 확인하기 12&gt; eth.getBalance(eth.accounts[0])300000 첫 제네시스 블록을 만들때 alloc 했던 양 만큼 할당이 되어 있네요. ¶3. 단위 변경하기 그런데 저 단위는 사실 ether가 아니고 wei입니다. 아래 처럼 변환하면 됩니다. 참고 12&gt; web3.fromWei(eth.getBalance(eth.accounts[0], &quot;ether&quot;));&quot;0&quot; ¶4. 채굴 시작하기 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; miner.start()INFO [07-03|15:33:29] Updated mining threads threads=0INFO [07-03|15:33:29] Transaction pool price threshold updated price=18000000000null&gt; INFO [07-03|15:33:29] Starting mining operationINFO [07-03|15:33:29] Commit new mining work number=1 txs=0 uncles=0 elapsed=597.603µsINFO [07-03|15:33:31] Generating DAG in progress epoch=0 percentage=0 elapsed=413.009msINFO [07-03|15:33:31] Generating DAG in progress epoch=0 percentage=1 elapsed=751.934msINFO [07-03|15:33:31] Generating DAG in progress epoch=0 percentage=2 elapsed=1.091sINFO [07-03|15:33:32] Generating DAG in progress epoch=0 percentage=3 elapsed=1.437sINFO [07-03|15:33:32] Generating DAG in progress epoch=0 percentage=4 elapsed=1.769sINFO [07-03|15:33:32] Generating DAG in progress epoch=0 percentage=5 elapsed=2.142sINFO [07-03|15:33:33] Generating DAG in progress epoch=0 percentage=6 elapsed=2.480s...INFO elapsed=36.298sINFO [07-03|15:34:07] Generating DAG in progress epoch=0 percentage=94 elapsed=36.666sINFO [07-03|15:34:07] Generating DAG in progress epoch=0 percentage=95 elapsed=37.058sINFO [07-03|15:34:08] Generating DAG in progress epoch=0 percentage=96 elapsed=37.432sINFO [07-03|15:34:08] Generating DAG in progress epoch=0 percentage=97 elapsed=37.796sINFO [07-03|15:34:08] Generating DAG in progress epoch=0 percentage=98 elapsed=38.208sINFO [07-03|15:34:10] Generating DAG in progress epoch=0 percentage=99 elapsed=39.469sINFO [07-03|15:34:10] Generated ethash verification cache epoch=0 elapsed=39.471sINFO [07-03|15:34:11] Successfully sealed new block number=1 hash=48f248…d2232eINFO [07-03|15:34:11] 🔨 mined potential block number=1 hash=48f248…d2232eINFO [07-03|15:34:11] Commit new mining work number=2 txs=0 uncles=0 elapsed=597.26µsINFO [07-03|15:34:11] Successfully sealed new block number=2 hash=c5c768…b1e445INFO [07-03|15:34:11] 🔨 mined potential block number=2 hash=c5c768…b1e445INFO [07-03|15:34:11] Commit new mining work number=3 txs=0 uncles=0 elapsed=192.809µsINFO [07-03|15:34:12] Successfully sealed new block number=3 hash=163387…646389INFO [07-03|15:34:12] 🔨 mined potential block number=3 hash=163387…646389INFO [07-03|15:34:12] Commit new mining work number=4 txs=0 uncles=0 elapsed=163.111µsINFO [07-03|15:34:12] Generating DAG in progress epoch=1 percentage=0 elapsed=955.391msINFO [07-03|15:34:12] Successfully sealed new block number=4 hash=cee703…d4001cINFO [07-03|15:34:12] 🔨 mined potential block number=4 hash=cee703…d4001cINFO [07-03|15:34:12] Mining too far in the future wait=2sINFO [07-03|15:34:12] Generating DAG in progress epoch=1 percentage=1 elapsed=1.478sINFO [07-03|15:34:13] Generating DAG in progress epoch=1 percentage=2 elapsed=1.855sINFO [07-03|15:34:13] Generating DAG in progress epoch=1 percentage=3 elapsed=2.250sINFO [07-03|15:34:14] Generating DAG in progress epoch=1 percentage=4 elapsed=2.631sINFO [07-03|15:34:14] Generating DAG in progress epoch=1 percentage=5 elapsed=3.005sINFO [07-03|15:34:14] Commit new mining work number=5 txs=0 uncles=0 elapsed=2.003sINFO [07-03|15:34:14] Generating DAG in progress epoch=1 percentage=6 elapsed=3.558sINFO [07-03|15:34:15] Successfully sealed new block number=5 hash=c7111e…cabeefINFO [07-03|15:34:15] 🔨 mined potential block number=5 hash=c7111e…cabeefINFO [07-03|15:34:15] Commit new mining work number=6 txs=0 uncles=0 elapsed=170.026µsINFO [07-03|15:34:15] Generating DAG in progress epoch=1 percentage=7 elapsed=4.427sINFO [07-03|15:34:16] Successfully sealed new block number=6 hash=230787…ba48a2INFO [07-03|15:34:16] 🔗 block reached canonical chain number=1 hash=48f248…d2232eINFO [07-03|15:34:16] 🔨 mined potential block number=6 hash=230787…ba48a2INFO [07-03|15:34:16] Commit new mining work number=7 txs=0 uncles=0 elapsed=141.75µsINFO [07-03|15:34:16] Successfully sealed new block number=7 hash=3a22b7…e4e015INFO [07-03|15:34:16] 🔗 block reached canonical chain number=2 hash=c5c768…b1e445 ¶5. 외부에서 접속하기 1234567deploy@jayg-blockchain2:~$ geth attach http://1.1.1.1:8123Welcome to the Geth JavaScript console!instance: Geth/PrivateNetwork/v1.8.11-stable-dea1ce05/linux-amd64/go1.10coinbase: 0x44e74080949320292839b9a0df55e4459dd51434at block: 25 (Tue, 03 Jul 2018 15:34:38 KST) modules: eth:1.0 miner:1.0 net:1.0 rpc:1.0 web3:1.0","categories":[],"tags":[]},{"title":"블록체인과 Kudo - 교육 기록, 평판, 보상을 위한 분산 시스템","slug":"A-Distributed-System-for-Educational-Record-Reputation-and-Reward","date":"2018-07-02T15:00:00.000Z","updated":"2018-07-03T03:33:22.000Z","comments":true,"path":"2018/07/03/A-Distributed-System-for-Educational-Record-Reputation-and-Reward/","link":"","permalink":"https://www.yceffort.kr/2018/07/03/A-Distributed-System-for-Educational-Record-Reputation-and-Reward/","excerpt":"The Blockchain and Kudos - A Distributed System for Educational Record, Reputation and Reward 원문 ¶1. 교육 목적에 활용하기 위하여, 먼저 블록체인 특성 이해하기 블록체인이 교육과 관련이 있다는 것을 이해하기 위해서는, 블록체인의 구성요소가 교육적인 목적으로 사용될 수 있다는 것을 알아야 한다. 첫번째, 블록체인은 디지털 기록을 분산해서 기록하는 용도로 쓰인다. 블록 체인은 참여하고 있는 모든 컴퓨터에 저장된, 체인으로 연결된 데이터 항목중 가장 긴","text":"The Blockchain and Kudos - A Distributed System for Educational Record, Reputation and Reward 원문 ¶1. 교육 목적에 활용하기 위하여, 먼저 블록체인 특성 이해하기 블록체인이 교육과 관련이 있다는 것을 이해하기 위해서는, 블록체인의 구성요소가 교육적인 목적으로 사용될 수 있다는 것을 알아야 한다. 첫번째, 블록체인은 디지털 기록을 분산해서 기록하는 용도로 쓰인다. 블록 체인은 참여하고 있는 모든 컴퓨터에 저장된, 체인으로 연결된 데이터 항목중 가장 긴 체인으로, 다음 항목은 참여자 대다수의 합의에 의해서만 추가될 수 있다. 두번째, 새로운 블록이 합법적이고, 체인에 추가될 수 있는지를 동의하는 절차인 ‘분산 합의’ 절차가 있다. 이것은 컴퓨터가 공공 블록체인에 새로운 블록을 추가하기전에, 상당한 양의 계산 작업 (작업 증명)을 수행하도록 요구한다. 세번째, 각 블록은 소량의 데이터 (일반적으로 최대 1mb)를 보유 할 수 있다. 이는 비트코인 처럼 통화 거래 기록, 혹은 교육, 시험 작업 증명, 학습 기록 등을 저장할 수도 있다. 이 모든 정보는 참여자 컴퓨터에 저장되며, 암호화 '공개키’를 가진 사람만이 볼 수 있고, 수정은 불가능하다. 마지막으로, 특정 조건이 충족되었을 때 실행되는 스마트 컨트랙트가 있다. ¶2. 분산 디지털 기록으로서 블록체인 블록체인은 다음과 같은 특성이 있다. 전체 기록은 참여 컴퓨터의 광범위한 네트워크에 배포 되므로 인프라 손실에도 탄력적으로 대응 가능하다. 레코드를 추가 하거나 수정할 때 신원을 확인할 수 있다. 참가자 간 합의에 의해 블록이 추가되면, 제거되거나 변경 될 수 없다. 디지털 키가 있어야 액세스 가능함. 이를 교육적으로 사용하는 방법 중 하나는, 학위 증명서와 같은 성취기록을 블록체인에 저장하는 것이다. 인증된 데이터는 학생이나 고용주가 액세스하거나, 온라인에서 CV를 추가할 수 있는 공인 수여 기관에 의해 블록체인에 추가될 수 있다. 그리고 신뢰할 수 있는 전문가와 교사가 인증서와 배지(Badge)를 직접 수여할 수 있도록 기회를 제공한다. The University of Nicosia는 세계 최초로 학위 증명서를 블록체인을 통해 진위성을 확인할 수 있도록 하였으며, Sony Global Education은 학업기록을 저장하기 위한 블록체인 개발을 발표하기도 했다. 블록체인은 학생이 특정한 기관으로 부터 상을 수여한 것을 확인해 줄 수 있으며, 이는 어느 특정 당사자의 신뢰성을 필요로 하지 않는다. 그리고 가짜 증명서, 학생의 부정으로 부터도 자유로워 질 수 있다. 하지만 이를 위해서 MOOC이 광범위하게 사용된 것 처럼, 블록체인 또한 광범위하게 사용되어야하는 문제가 있다. ¶3. 지적 작업 증명을 위한 블록체인 발명, 지식에 대한 기여, 삽화 등 창조적인 작품에 대한 공개 기록을 제출할 수 있는 시스템을 고려해 볼 수 있다. 각각의 아이디어는 저자와 연결되고, 처음 기록된 시기를 나타내기 위해 타임스탬프가 표시된다. 그리고 일단 수정할 수 없지만, 이 후 다른 버전으로 대체 될 수 있다. 이는 지적인 성취로서 개인적인 사용, 혹은 고용주에게 제시될 도 있다. 발명에 대한 주장을 하거나, 이를 증명할 필요가 없다. 스타트업 Blockai는 저작권 침해로 부터 보호받고 자신의 작업물을 등록할 수 있는 블록체인 시스템을 만들었다. Ted Nelson이 고안한 제너두 프로젝트와도 일맥상통하는 부분이 있다. 그는 '전 세계 출판을 위한 디지털 저장소 계획’에 대해 논한 바가 있는데, 월드 와이드웹을 뛰어넘어서 깨지지 않는 링크, 컨텐츠 소유물에 대한 저자에 대한 귀속, 콘텐츠 재사용을 위한 소액 지불 등의 시스템을 주장하였다. 제너두 저장소의 항목은 저자에게 연결되고, 기록은 재난으로 부터 가용성을 유지하기 위하여 많은 위치에 걸쳐서 저장된다. 제너두에 대한 넬슨의 17가지 규칙은, 대부분 블록체인을 통해서 해결할 수 있다. 그러나 이는 역시 ‘존재에 대한’ 증거 일뿐, 블록체인에 있는 데이터가 유효하고, 진실되며, 혹은 유용하다는 것을 보증하지는 않는다. 사용자가 아이디어, 발명, 창조적인 작업의 창시자라고 주장하는 것이 논쟁이 될 수 있으며, 이 것이 다른 사람에게 가치있거나 흥미롭다는 것을 보장해주지도 않는다. ¶4. 지적 화폐로서 블록체인 '평판’은 새로운 디지털 경제의 기초이며, AirBnB 및 Uber와 같은 회사는 평점과 리뷰를 통해 신뢰를 쌓는다. 학자들 사이에서 평판은 이미 거래가 가능한 재화이며, 나아가 승진과 채용은 평판을 기초로 하고 있다. 만약 이러한 학술적 평판을 거래하는 것이, 학계를 넘어서 교육경제의 기초가 된다면 어떻게 될까? 다음 과 같은 예를 상상해보자. 교육 기관 및 컨소시엄이 교육 기록 및 보상을 관리하기 위해 새로운 공공 블록체인을 시작한다. 각 인정받는 교육기관, 혁신적인 조직, 뛰어난 근로자는 Kudos라고 하는 교육 평판 통화를 받는다. 초기 지급은 Times Higher Education World Reputation Rankings for Universities, H-index for academics, Amazon author rank for published authors와 기존에 같은 존재하는 기관에 의지한다. 각 기관은 기금 중 일부를, 명성을 높이고자 하는 직원에게 할당할 수 있다. 각 개인과 기관은 자사의 '월렛’에 이러한 화폐를 저장한다. 그렇게 하면, 모든 기관이나 개인이 평판을 거래할 수 있다. 대학과 같은 교육기관은 학위 또는 인증서를 수여하고, 이 과정에서 인증서는 블록체인에 게시하고, 수여 대상자에게 Kudo를 지급한다. 개인에게는 온라인으로 튜터링 시스템을 만들 수 있다. 학생은 가상화폐(비트코인) 으로 온라인 교육 교사에게 비용을 지불하고, 시험을 합격하거나 과정을 마친 뒤에는 Kudo를 교사에게 지불한다. 스마트 컨트랙트 매커니즘으로, 다양한 통화를 P2P 소액 지불에 이용할 수 있다. 누구든지 교육 블록체인에 포스팅을 할 수 있다. 이는 창조적이거나 학출적인 작품, 예술 작품, 훌륭한 아이디어 일 수 있으며, 이는 타임스탬프와 함께 기록된다. 간단한 게시는 개인이 할 수 있지만, 이는 영구적인 기록이 되고 공유 가능한 e-포트폴리오가 되는 것이다. 평판을 갖고 있는 사람은, 자신이 지갑에 갖고 있는 금액만큼의 kudo와 자신의 작품을 포스팅할 수 있다. 이 금액은 사용되지 않지만, 이 작업이나 아이디어에 대한 가치를 나타낸다. 다른 사람들은 이 것에 대해 명성(kudo)을 높이기 위해 자신의 평판(kudo)을 줄 수도 있다. 이는 특정아이디어를 알리는 킥스타터 프로젝트와 비슷한 방식이지만, 평판을 화폐로 이용한다는 것에 차이가 있다. 결과적으로 교육 블록체인은 평판이 좋은 크레딧과 관련되어 있는 창의적인 작품이나 아이디어에 대한 보편적인 기록을 제공한다. 각 항목과 관련된 Kudo의 양은 저자에게 그 가치를 나타내므로, 필요할 경우 이를 실제 세계에서 통화가치로 활용할 수도 있다. 마지막으로, Kudo는 기관에 의해 ‘채굴’ 될 수 있을 것이다. 기관들은 증명 알고리즘을 바탕으로 유효한 블록을 체인에 추가하는데, 이를 보상으로 추가적인 Kudo를 받는다. 이론적으로는 블로그 게시, comments, assignment 등이 될 수 있고 나아가 이에 대한 제한은 없지만, 이러한 분산 교육 기록을 저장하고 유지하는데는 비용이 들 것이다. 기록은 공개 되어 있으므로 누구나 사람이 어떻게 kudo를 얻었는지 알 수 있으며, 가치와 연관된 규칙은 블록을 채굴하는 사람들의 합의에 의해 결정된다. 이는 그렇게 허황된 시스템이 아니다. 블록체인과 Kudo는 없지만 이와 비슷한 것이 Open University iSpot citizen science에서 운영되고 있다. 이 사이트에서, 야생 동물 전문가는 처음에 높은 평판 점수가 부여되고, 새로운 유저들은 야생에서 관찰하고 다른 사람들의 관찰을 확인하는 과정에서 평판 점수를 얻을 수 있다. 이러한 평판 시스템은 자동으로 이루어지며, 교육용 블록체인 및 평판 시스템을 관리하는데 필요한 대부분의 복잡성은 사용자 또는 교육기관에서 숨길 수도 있다. 이 논문에서는 OpenLearn의 배지를 프라이빗 블록체인에 추가하는 실험을 하고 있다. 이 블록체인은 일련의 스마트 컨트랙트로 구성된 분산 응용 프로그램의 생성을 지원하는 이더리움 인프라내에서 구현되었다. 현재 학생들이 수업을 등록하고, 마이 페이지에서 볼 수 있는 배지를 받을 수 있게 한다. 관리자는 학생들에게 배지를 수여할 수 있다. 모든 트랜잭션에 타임스탬프가 설정되어 있고, 암호화로 서명되어 있다. 이러한 트랜잭션은 P2P로 이루어지기 때문에, 이를 수여하기 위해 다른 호스트 기관을 필요로 하지 않는다. ¶5. 영향 많은 기관에서 접근할 수 있고, 배포할 수 있는 교육 성취 내용에 대한 단일의 보안된 기록을 제공하는 것이다. 일단 인증된 교육 블록체인 이 생기면, 개인과 기관은 개인의 성취에 대한 공공기록을 안전하게 저장할 수 있다. 학자들과 관련된 학술적 평판시스템을 개방하는데 도움이 될 수 있다. 이미 AirBnB나 iSpot과 같은 교육시스템에서, 평판(평점)을 관리하는 사례가 나온 바가 있다. 학술과 관련있거나 중요한 아이디어에 대한 담보로 사용하고 (kudo), 새로운 블록을 체인 추가하는 것을 검증함으로써 평판을 교환할 수도 있다. 교육적인 명성을 통화로 거래함으로써, 실질적이고 이데올로기적인 문제가 발생할 수 있다. 새로운 아이디어나 A+ 논문의 경제적 가치는 얼마인가? 와같은, 평판과 돈 사이에 전환율을 어떻게 만들어 낼 수 있을 까하는 문제다. 이데올로기적인 문제로는, 평판을 거래하는 시스템이 장학금 이나, 지적가치에 대한 공감이 없이 교육 상품을 검색, 구매, 소비하는 상품화를 부추긴 다는 것이다. 사용하기에 따라서, 블록체인과 이러한 평판 통화 시스템이, 교육을 단순 '지식 시장’으로 축소하거나, 연구자와 발명가 공동체를, 좋은 아이디어를 나누고 싶은 사람들에게 까지 확장시킬 수 있을 것이다.","categories":[],"tags":[]},{"title":"이더리움 - 프라이빗 블록체인 만들기 (1)","slug":"ethereum-create-private-blockchain-1","date":"2018-07-02T15:00:00.000Z","updated":"2018-07-03T01:51:20.000Z","comments":true,"path":"2018/07/03/ethereum-create-private-blockchain-1/","link":"","permalink":"https://www.yceffort.kr/2018/07/03/ethereum-create-private-blockchain-1/","excerpt":"Geth client 설치부터 사설 블록체인 시작까지 본 포스팅은 ubuntu 16.x 버전을 기준으로 작성되었습니다. ¶1. 이더리움 설치 1 2 3 4 5 sudo apt-get install software-properties-common sudo add-apt-repository -y ppa:ethereum/ethereum sudo apt-get update sudo apt-cache madison geth sudo apt-get -y install ethereum ¶2. geth 실행 확인해보기 1 2 3 4","text":"Geth client 설치부터 사설 블록체인 시작까지 본 포스팅은 ubuntu 16.x 버전을 기준으로 작성되었습니다. ¶1. 이더리움 설치 12345sudo apt-get install software-properties-common sudo add-apt-repository -y ppa:ethereum/ethereumsudo apt-get updatesudo apt-cache madison gethsudo apt-get -y install ethereum ¶2. geth 실행 확인해보기 1234567891011121314151617deploy@jayg-blockchain2:~$ gethINFO [07-03|10:55:27] Maximum peer count ETH=25 LES=0 total=25INFO [07-03|10:55:27] Starting peer-to-peer node instance=Geth/v1.8.11-stable-dea1ce05/linux-amd64/go1.10INFO [07-03|10:55:27] Allocated cache and file handles database=/home/deploy/.ethereum/geth/chaindata cache=768 handles=1024INFO [07-03|10:55:27] Initialised chain configuration config=&quot;&#123;ChainID: 1 Homestead: 1150000 DAO: 1920000 DAOSupport: true EIP150: 2463000 EIP155: 2675000 EIP158: 2675000 Byzantium: 4370000 Constantinople: &lt;nil&gt; Engine: ethash&#125;&quot;INFO [07-03|10:55:27] Disk storage enabled for ethash caches dir=/home/deploy/.ethereum/geth/ethash count=3INFO [07-03|10:55:27] Disk storage enabled for ethash DAGs dir=/home/deploy/.ethash count=2INFO [07-03|10:55:27] Initialising Ethereum protocol versions=&quot;[63 62]&quot; network=1INFO [07-03|10:55:27] Loaded most recent local header number=0 hash=d4e567…cb8fa3 td=17179869184INFO [07-03|10:55:27] Loaded most recent local full block number=0 hash=d4e567…cb8fa3 td=17179869184INFO [07-03|10:55:27] Loaded most recent local fast block number=0 hash=d4e567…cb8fa3 td=17179869184INFO [07-03|10:55:27] Loaded local transaction journal transactions=0 dropped=0INFO [07-03|10:55:27] Regenerated local transaction journal transactions=0 accounts=0INFO [07-03|10:55:27] Starting P2P networking INFO [07-03|10:55:29] UDP listener up self=enode://78fe76020fb45f87bc6633033c9a176893601f10b45e7347b34a9f0036236b72713b9dd2fb29249d95b9e64cc7da50e94899a87357e5dd1c47f9837abe16976b@[::]:30303INFO [07-03|10:55:29] RLPx listener up self=enode://78fe76020fb45f87bc6633033c9a176893601f10b45e7347b34a9f0036236b72713b9dd2fb29249d95b9e64cc7da50e94899a87357e5dd1c47f9837abe16976b@[::]:30303INFO [07-03|10:55:29] IPC endpoint opened url=/home/deploy/.ethereum/geth.ipc 정상적으로 설치 된 것 같습니다. ¶3. Account 만들기 123456deploy@jayg-blockchain3:~$ geth --datadir ./ethereum/data/ account newINFO [07-03|10:42:38] Maximum peer count ETH=25 LES=0 total=25Your new account is locked with a password. Please give a password. Do not forget this password.Passphrase: Repeat passphrase: Address: &#123;44e74080949320292839b9a0df55e4459dd51434&#125; 암호를 입력하면 어카운트가 생성 됩니다. ¶4. Account 확인하기 123deploy@jayg-blockchain3:~$ geth --datadir ./ethereum/data/ account listINFO [07-03|10:42:57] Maximum peer count ETH=25 LES=0 total=25Account #0: &#123;44e74080949320292839b9a0df55e4459dd51434&#125; keystore:///home/deploy/ethereum/data/keystore/UTC--2018-07-03T01-42-40.966434322Z--44e74080949320292839b9a0df55e4459dd51434 ¶5. Genesis block 만들기 Genesis Block은 블록체인에서 가장 첫번째로 생성되는 블록으로, 이전 블록에 대한 정보를 갖고 있지 않은 유일한 블록입니다. 이더리움은 이 블록에 많은 것들을 저장할 수 있도록 다양하나 옵션을 지원하며, 원하는 옵션을 구현함으로써 사설 블록체인 네트워크를 구축할 수 있습니다. 네트워크에 참여하는 노드들은 모두 이 블록을 가지고 있어야 참여할 수 있습니다. 12345678910111213&#123; \"config\": &#123; \"chainId\": 15, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 &#125;, \"difficulty\": \"20\", \"gasLimit\": \"2100000\", \"alloc\": &#123; \"44e74080949320292839b9a0df55e4459dd51434\": &#123; \"balance\": \"300000\" &#125; &#125;&#125; config: 이더리움관련 설정이 들어 있습니다. config.chainId: chain id는 현재 chain을 구별하는 값이며, replay attack으로 부터 보호해주는 역할을 합니다. replay attack이란, 네트워크 공격의 한 종류로, 유효한 데이터 전송을 악의적으로 반복시키거나 지연시키는 공격의 일종입니다. config.homesteadBlock: homestead는 이더리움의 4단계 로드맵 중 두번째 메이저 단계입니다. 여기를 참조하시면 됩니다. 0은 여기서 true 정도를 의미한다고 생각하시면 됩니다. config.epi155Block: eip는 Ethereum Imporvement Proposal의 약자로, 개발자들이 이더리움을 업그레이드 하기 위해 제안된 아이디어를 의미합니다. 여기서느 epi155를 채택한다는 뜻이 되겠네요. 155 는 chainId와 마찬가지로, replay attack을 막기 위한 설정입니다. 여기를 참조하세요. config.eip158Block: state clearing입니다. 어카운트에서 상태 변경이 이루어지고, 이 변경으로 인해 계정 의 상태가 nonce=0, balance=0, code 및 storage가 빈 값이 되면 어카운트를 삭제한다는 것을 의미합니다. 여기를 참조하세요. 위 4가지 설정은 사설 블록체인을 만들 때 기본적으로 동일한 설정입니다. difficulty: 채굴 난이도 입니다. 값이 클 수록 채굴 난이도가 상승하고, 채굴에 오래 걸리니까 낮은 값으로 정해두었습니다. gasLimit: 블록당 가스(수수료)의 제한입니다. 몇 개의 거래를 하나의 블록에 담을 수 있는 지 결정하는데 필요한 옵션이고, 클 수록 거래를 &amp; 테스트를 많이 할 수 있으므로 씨게 잡아둡시다. alloc: 블록생성과 동시에, 여기에 주소를 적어두면 이더를 원하는 만큼 이더를 보낼 수 있습니다. ¶그 밖에 안넣은 값 parentHash: 제네시스 블록은 부모가 없기 때문에 (ㅠㅠ), 넣지 않았습니다. coinbase: 블록 채굴시 주어지는 보상입니다. 어차피 내맘대로 alloc을 하는데, 채굴 보상이 의미가 없죠. nonce, mixhash: 이 두 개는 블록이 제대로 채굴되었는지 증명해주는 옵션입니다. 블록체인의 증명을 위해서는 mixhhash와 nonce가 조합된 hash 값이 일정한 수 이하인 nonce를 찾는데, 가장 최근에 추가된 블록의 헤더의 해시가 nonce 값의 조합으로 일정 수를 찾아 작업증명을 완료 하게 됩니다. 이를 가지고 있는 이유는, 공격자가 잘못된 nonce로 블록을 만들 경우, 이것이 위조되었는지 빠르게 확인하기 위해서 입니다. mixhash는 nonce를 찾기 위한 중간 계산 값입니다. 두 옵션 모두 ‘블록이 제대로 만들었는지 증명하는 용도’ 로 이해하면 됩니다. 이 역시 제네시스 블록에서는 의미가 없는데, (어차피 채굴이 아니고 내가 만든거니깐) 랜덤한 값을 넣어서 다른 누군가 우연히 똑같은 제네시스블록으로 체인을 연결하지 않도록 할 수도 있습니다. timestamp: 해당 블록이 취득된 시점을 의미하는 값으로, 유닉스 타임스탬프 값이 들어갑니다. 어차피 최초의 블록이므로, 0 (0x00) 으로 설정해도 됩니다. 이는 블록간의 순서 및 난이도 조절 (간격이 짧으면 쉽고, 길면 어렵고)을 위해 쓰입니다. 파일을 생성하고, 제네시스 블록으로 시작합니다. 1234567891011deploy@jayg-blockchain3:~$ touch genesis.jsondeploy@jayg-blockchain3:~$ geth --datadir ./ethereum/data/ init ./genesis.jsonINFO [07-03|11:57:49] Maximum peer count ETH=25 LES=0 total=25INFO [07-03|11:57:49] Allocated cache and file handles database=/home/deploy/ethereum/data/geth/chaindata cache=16 handles=16INFO [07-03|11:57:49] Writing custom genesis block INFO [07-03|11:57:49] Persisted trie from memory database nodes=1 size=143.00B time=71.193µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [07-03|11:57:49] Successfully wrote genesis state database=chaindata hash=e41c72…24d37bINFO [07-03|11:57:49] Allocated cache and file handles database=/home/deploy/ethereum/data/geth/lightchaindata cache=16 handles=16INFO [07-03|11:57:49] Writing custom genesis block INFO [07-03|11:57:49] Persisted trie from memory database nodes=1 size=143.00B time=52.505µs gcnodes=0 gcsize=0.00B gctime=0s livenodes=1 livesize=0.00BINFO [07-03|11:57:49] Successfully wrote genesis state database=lightchaindata hash=e41c72…24d37b ¶6. 이더리움 네트워크 실행하기 123456789101112131415161718192021222324deploy@jayg-blockchain3:~$ geth --identity &apos;PrivateNetwork&apos; --datadir ./ethereum/data/ -port &apos;33333&apos; --rpc --rpcaddr 0.0.0.0 --rpcport &apos;8123&apos; --rpccorsdomain &apos;*&apos; --nodiscover --networkid 1900 --nat &apos;any&apos; --rpcapi &apos;db,eth,net,web3,miner&apos; consoleINFO [07-03|12:07:27] Maximum peer count ETH=25 LES=0 total=25INFO [07-03|12:07:27] Starting peer-to-peer node instance=Geth/PrivateNetwork/v1.8.11-stable-dea1ce05/linux-amd64/go1.10INFO [07-03|12:07:27] Allocated cache and file handles database=/home/deploy/ethereum/data/geth/chaindata cache=768 handles=1024INFO [07-03|12:07:27] Initialised chain configuration config=&quot;&#123;ChainID: 15 Homestead: 0 DAO: &lt;nil&gt; DAOSupport: false EIP150: &lt;nil&gt; EIP155: 0 EIP158: 0 Byzantium: &lt;nil&gt; Constantinople: &lt;nil&gt; Engine: unknown&#125;&quot;INFO [07-03|12:07:27] Disk storage enabled for ethash caches dir=/home/deploy/ethereum/data/geth/ethash count=3INFO [07-03|12:07:27] Disk storage enabled for ethash DAGs dir=/home/deploy/.ethash count=2INFO [07-03|12:07:27] Initialising Ethereum protocol versions=&quot;[63 62]&quot; network=1900INFO [07-03|12:07:27] Loaded most recent local header number=0 hash=e41c72…24d37b td=20INFO [07-03|12:07:27] Loaded most recent local full block number=0 hash=e41c72…24d37b td=20INFO [07-03|12:07:27] Loaded most recent local fast block number=0 hash=e41c72…24d37b td=20INFO [07-03|12:07:27] Regenerated local transaction journal transactions=0 accounts=0INFO [07-03|12:07:27] Starting P2P networking INFO [07-03|12:07:27] RLPx listener up self=&quot;enode://08a5d152bedf418cc043b439737bb8f2203e0da33892cf7f1779bed890714f02cb7202394a7f95c12b69fd9696872aeea7ae5071d51b94d637b5c3e48723bd9d@[::]:33333?discport=0&quot;INFO [07-03|12:07:27] IPC endpoint opened url=/home/deploy/ethereum/data/geth.ipcINFO [07-03|12:07:27] HTTP endpoint opened url=http://0.0.0.0:8123 cors=* vhosts=localhostWelcome to the Geth JavaScript console!instance: Geth/PrivateNetwork/v1.8.11-stable-dea1ce05/linux-amd64/go1.10INFO [07-03|12:07:27] Etherbase automatically configured address=0x44E74080949320292839B9A0df55e4459dD51434coinbase: 0x44e74080949320292839b9a0df55e4459dd51434at block: 0 (Thu, 01 Jan 1970 09:00:00 KST) datadir: /home/deploy/ethereum/data modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 짜잔","categories":[],"tags":[]},{"title":"산업용 사물인터넷을 위한 블록체인 플랫폼","slug":"blockchain-platform-for-industrial-internet-of-things","date":"2018-07-01T15:00:00.000Z","updated":"2018-07-02T04:15:04.000Z","comments":true,"path":"2018/07/02/blockchain-platform-for-industrial-internet-of-things/","link":"","permalink":"https://www.yceffort.kr/2018/07/02/blockchain-platform-for-industrial-internet-of-things/","excerpt":"Blockchain Platform for Industrial Internet of Things 원문 사물인터넷은 원격 감지/작동 기능을 갖춘 사물로 구성되며, 다른 연결된 장치 및 응용프로그램과 직 간접적으로 데이터를 교환할 수 있다. IoT장치는 데이터를 수집하고, 더이터를 로컬에서 처리하거나, 중앙집중식 서버 또는 클라우드 기반 응용 프로그램 백엔드에 보내 처리 할 수 있다. 이런 IoT 기술은 산업 및 제조 시스템에서 유망할 것으로 보인다. 전문가들은 이 기술이 산업과 제조분야에 미치는 영향을 약 1조달러로 분석하기도 했","text":"Blockchain Platform for Industrial Internet of Things 원문 사물인터넷은 원격 감지/작동 기능을 갖춘 사물로 구성되며, 다른 연결된 장치 및 응용프로그램과 직 간접적으로 데이터를 교환할 수 있다. IoT장치는 데이터를 수집하고, 더이터를 로컬에서 처리하거나, 중앙집중식 서버 또는 클라우드 기반 응용 프로그램 백엔드에 보내 처리 할 수 있다. 이런 IoT 기술은 산업 및 제조 시스템에서 유망할 것으로 보인다. 전문가들은 이 기술이 산업과 제조분야에 미치는 영향을 약 1조달러로 분석하기도 했다. 이 논문에서는 암호화폐 비트코인에서 사용되고 있는 블록체인 기술을 산업용 IOT에 활용한, BPIIoT라고 불리우는 분산화된 P2P 플랫폼을 제안한다. BPIIoT플랫폼은 클라우드 기반 제조를 위한 핵심 지원역할을 수행하며, 기존 CBM(Cloud Based Manufacturing)의 기능을 향상 시키고, 특히 기존 장비를 클라우드 환경에 통합하는데 있어 클라우드 기반 제조의 핵심으로 작용한다. 클라우드 기반 제조는, 제조에 필요한 자원에 대한 주문형 액세스가 가능하지만, 제조 서비스를 이용하려는 사용자 간의 거래에는 신뢰할 수 있는 중개자가 필요하다. 블록체인 기술을 사용하여 BPIIoT플랫폼을 사용하면 분산화되고, 신뢰할 수 있는 P2P의 중개자가 필요없이 서로 상호작용할 수 있다. 제조업을 위해 다양한 분산 앱(Dapps)을 개발 할 수 있는 산업용 인터넷을 위한 블록체인 플랫폼(BPIIoT)를 제안한다. a. Slock.it Dapp은 유저와 실제 물리적인 소유물을 소유하고 있는 주인 간에 스마트 컨트랙트를 할수 있게 해준다. 예를 들어 유저가 잠긴 문을 열수 있게 임차료를 지급하면, 자동으로 스마트 계약이 실행되어 문을 열수 있게 되는 것이다. b. BPIIoT는 기존 솔루션보다 훨씬 더 많은 기능을 제공한다. 이는 다양한 P2P 제조 응용프로그램을 개발할 수 있기 때문이다. 위 그림은 기존 Slock.it 플랫폼과 차이점을 보여준다. 예를 들어 기존 솔루션은 특정작업 (잠긴 문을 여는 것)을 수행하기 위해 전문화된 Dapps로 볼 수 있지만, BPIIoT는 다양한 분산 및 P2P 제조 응용프로그램을 제작 할 수 있기 때문에 훨씬더 광범위한 범위를 제공하고 있다. Slok.it, 슬로킷은 airbnb와 매우 유사한 서비스 입니다. 호스트가 방이나 주택에 슬로킷 도어락을 설치하고, 숙박금액과 보증금액을 이더를 통해 설정할 수 있게 해줍니다. 숙박객은 이더리움 블록체인을 통해 해당 금액을 지불하면, 그 기간 동안 잠금 장치를 열거나 닫으면서 숙박할 수 있게 됩니다. 이 Dapp을 사용하면, 신뢰할 수 있는 중개자 없이 소비자 대 기계, 혹은 기계 간 기계간의 트랜잭션을 가능하게 한다. 기존 레거시를 클라우드 환경에 통합 유지 보수 및 진단 작업을 자동화 모든 거래, 자산 및 재고 기록에 대한 분산되고 안전하며 공유된 원장을 제공 등이 가능해진다. 블록체인과 스마트 컨트랙트의 구조 ¶스마트 컨트랙트 스마트 컨트랙트는 블록체인 내에 있는, 고유한 주소로 식별되는 코드다. 실행 가능한 함수와 상태변수가 포함되어 있다. 이는 이러한 기능에 대한 트랜잭션이 수행될 때 실행된다. 트랜잭션에는 계약의 함수에서 요구하는 입력 매개 변수가 포함된다. 컨트랙트는 다양한 언어 (solidity, python)등올 작성할 수 있다. 컴파일 되면 계약에 고유한 주소를 할당하는 블록체인 네트워크에 컨트랙트가 업로드된다. 블록체인 네트워크의 모든 사용자는 컨트랙트에 트랜잭션을 전송하여 컨트랙트의 기능을 트리거할 수 있다. 컨트랙트 코드는 새로운 블록의 검증의 일환으로 네트워크를 참여하는 각 노드에서 실행된다. ¶Dapp 분산 응용 프로그램 (Dapp)은 스마트 컨트랙트를 사용하는 응용프로그램이다. Dapp은 스마트컨트랙트를 사용자에게 익숙한 인터페이스로 제공한다. 암호화폐는 Dapp의 일종이며, 블록체인 네트워크에서 실행된다. a) CBM(Cloud Based Manufacturing) model, b) 산업용 IOT를 위한 블록체인 CBM은 서비스를 이용하는 소비자가 제조 자원을 구성, 선택 및 활용할 수 있는 서비스 지향 제조 모델이다. CBM은 IaaS, PaaS, Haas, SaaS의 네가지 주요 클라우드 컴퓨팅 모델을 활용한다. BPIIoT는 스마트 컨트랙트가 포함되어 있는 블록체인 네트워크를 기반으로 한다. 이 플랫폼에서는 스마트 컨트랙트를 주문형 제조 서비스를 제공하기 위해, 서비스 소비자와 제조자원 간의 계약으로 활용된다. BPIIoT는 기존 레거시 장비를 클라우드 환경에 통합할 수 있으며, 분산 및 P2P 제조 응용프로그램을 개발 할 수 있다. BPIIoT의 구조 IoT장치는 기존 시스템이 클라우드와 통신할 수 있을 뿐만 아니라, 블록체인의 작업도 실행 가능하게 한다. 이 IoT장치는 기기가 운영중인 데이터를 클라우드 내에서 서로 교환하고, 관련된 스마트 컨트랙트 트랜잭션을 보내며, 네트워크의 피어로부터 트랜잭션을 받을 수 있는 'Plug and Play’솔루션이다. 이 IoT 장치에는 인터페이스 보드 (아두이노 기반)와 단일 보드 컴퓨터 (라즈베리 파이 또는 비글본 블랙)가 포함되어 있다. 인터페이스 보드에는 디지털 입출력 및 아날로그 입력 기능이 있다. 센서 및 엑추에이터는 인터페이스 보드의 디지털 또는 아날로그 핀과 인터페이스 한다. 인터페이스 보드는 단일 보드 컴퓨터에 직렬 인터페이스를 가지고 있다. 인터페이스 보드와 단일 컴퓨터 사이의 센서브리지를 통해 단일 보드 컴퓨터는 데이터를 캡처하고, 제어신호를 엑추에이터로 전송할 수 있다. 단일 보드 컴퓨터 관리자는 사용자가 웹 인터페이스를 통하여 이를 구성하고, 장치 상태 및 통계를 볼수 있게 한다. 이 단일 보드 컴퓨터의 블록체인 서비스는, 블록체인 네트워크와 통신하고, 네트워크를 통해 트랜잭션을 전송/수신 한다. 각 IoT장치는 블록체인 네트워크에 자체 어카운트를 갖고 있으며, 자체 블록체인 월렛을 유지 하고 관리한다. 컨트롤러 서비스는 장치 관리 인터페이스를 통해 구성할 수 있는 다양한 작업을 수행한다. 예를 들어, 센서 브리지에서 데이터를 받아 클라우드 브리지를 통해 게시하는 작업 등이 가능하다. 또 기계 상태 및 운영환경을 모니터링 하고, 블록체인 네트워크의 관련 스마트 컨트랙트를 보낼 수도 있다. BPIIoT를 이루는 것은 Interface Board(아두이노 등으로 만들어진 실제 Machine 과 브릿지 역할을 하는 것)와 단일 보드 컴퓨터 (라즈베리파이로 이루어진 소프트웨어를 실행하는 레이어)라고 할 수 있습니다. Interface Board가 직접 Machine가 interface하여 입출력 데이터를 받습니다. 단일 보드 컴퓨터는 이러한 데이터를 받아 처리하는 부분으로, 클라우드와 연결하여 (클라우드 브릿지) 데이터를 전송하거나, 블록체인 네트워크와 연결하여 (블록체인 브릿지) 고객과 장치관리자 사이의 스마트 컨트랙트를 실행하는 등의 역할을 합니다. ¶활용가능한 범위 온디맨드 생산: 기계가 자체적으로 블록체인 계정을 보유하고, 사용자가 CBM과 같은 주문형 모델에서 제조 서비스를 이용할 수 있도록 기계를 직접 공급하고 거래할 수 있는 제소 서비스 시장이 가능하다. 사용자가 기계에 트랜잭션을 전송하여 제조서비스를 이용할 수 있는 P2P 네트워크 제조 응용프로그램이 가능하다. 스마트 진단 &amp; 기계 관리: 기계가 상태를 모니터링하고, 문제를 진단하며 자율적으로 서비스, 소모품 또는 기계 유지 보수 업체에 교체 요청을 할 수 있는 기계용 스마트 진단 및 자가 진단 어플리케이션을 만드는데 사용 될 수 있다. 공금 조달 및 기계 서비스 유지를 위한 제조업체와 공급업체간의 스마트 컨트랙트는 기계 유지 보수 작업을 자동화하는데 도움이 될 수 있다. 추적가능성: 제조된 제품을 추적할 수 있는 응용 프로그램을 개발하는데 사용할 수 있다. 소비자와 제조업체간의 스마트 컨트랙트를 예로 들면, 공장 내의 어떤 기계가 특정 제품을 제조하는데 사용되었는지와 같은 생산기록을 유지하는데 사용할 수 있다. 제품이 배달 된 후 리콜의 경우, 이 기능은 영향 받은 제품을 식별하는데 도움이 될 수 있다. 공급망 추적: 블록체인 및 스마트 컨트랙트는 제품을 등록하고 유지하여 공급망의 다른 지점에서도 소유물을 추적할 수 있다. 이러한 프로그램은 배송 확인에 대한 자동화된 금융결제를 가능하게 할 수도 있다. 제품 인증: 제품의 제조정보를 블록체인에 기록하여, 조작이 쉬운 물리적이 인증서의 필요성을 제거하고, 제품의 진위성을 입증하는데 도움을 줄 수 있다. 소비자-기계, 기계-기계 간 거래: 예를 들어 소비자가 암호화폐 (이더)를 지불함과 동시에 스마트 컨트랙트에 거래를 보내 제품 제조 요청을 보낼 수 있다. 다른 기계와의 서비스가 필요한 경우 기계간 마이크로 트랜잭션을 보낼 수도 있다. 공급자 신원 및 평판 추적: 공급자의 다양한 매개 변수 (배달시간, 고객 리뷰, 판매자 등급)를 추적하는 공급 업체 신원 및 평판 관리 응용 프로그램을 개발하는데 사용할 수 있다. 이러한 응용 프로그램은 소비자가 제조 요구 사항을 충족시킬 수 있는 판매자와 소모품 공급업체를 찾는 제조업체를 찾는데 사용할 수 있다. 스마트 컨트랙트는 판매자의 평판을 기반으로 실시간으로 소모품 및 이에 대한 최고가격을 자동으로 협상하는데 도움이 될 수도 있다. 자산 및 재고 등록: 자산 식별 정보의 기록과 공급망에 대한 자산 이동을 보관하여 수동으로 레코드를 기록할 필요성을 없앨 수 있다. ¶결론 이 플랫폼을 통해, 기계가 자체 블록체인 어카운트를 보유하고, 사용자가 제조 서비스를 이용하기 위해 기계를 직접 제공하고, 거래할 수 있는 제소 서비스 시장을 가능하게 했다. 블록체인을 활용하여 산업용 IoT에 적용한다면 아래와 같은 이점이 있다. 탈중앙화 &amp; 신뢰가 필요없음: 블록 체인은 서로 다른 분산 노드에 의해 유지되는 네트워크상의 모든 트랜잭션에 대한 공개 원장입니다. 블록체인 기술은 분산되고 신뢰가 필요없는 P2P 네트워크를 가능하게 하는데, 피어들은 서로 상호 작용하기 위해 신뢰할 수 있는 중개자가 필요하지 않습니다. 블록 체인 네트워크는 중앙 당국에 의해 제어되지 않으며 모든 거래는 shem 간의 합의에 의해 검증되고 검증되므로 피어는 서로를 신뢰할 필요가 없습니다. 유연함: 블록체인은 실패로 부터 유연하며, 분산화 되어 있기 때문에 단일점 장애로 부터도 자유롭다. 블록체인은 불변의 원장이며, 피어간의 합의가 변경되거나 삭제 될 수 없다. 확장가능성: 블록체인 네트워크는 그 특성상 확장이 매우 용이하다. 보안 및 감사가능성: 블록체인 네트워크의 모든 트랜잭션은 강력한 암호화로 보안된다. 또한 블록체인은 공개 원장을 투명하게 관리하기 때문에, 네트워크의 모든 사람들이 거래에 대해 알고 있기 때문에 논재응로 부터 자유롭고 안전하다. 하지만 널리 보급되기 위해선 아래와 같은 문제를 해결해야 한다. CAP &amp; 블록체인: 분산형 데이터 시스템의 경우, 일관성과 가용성 사이에 trade-off가 있다. 블록체인은 가용성과 분단가용성을 위해 일관성을 포기했다.(AP만 존재. 이는 아파치 카산드라, 카우치 디비와 유사한 속성) 블록체인은 결국 일관성 있는 분산화된 원장이다. 모든 노드는 결국 동일한 원장을 보게 된다. 이더리움에서는 블록타임 (새 블록이 채굴되는 데 걸리는 시간)이 댜력 17초이며, 이는 10분인 비트코인보다 빠르다. 빠른 블록타입은 보안이 감소하게 되므로, 많은 블록체인 어플리케이션은 이 중지출을 막기 위해 새로 채굴된 블록에 대해 여러가지 확인을 거친다. 블록 타임이 빨라지면, stale block (성공적으로 채굴은 헀지만, 다른 빠른 블록 때문에 블록체인에 연결되지 못한 블록)이 점점더 많아 지게 된다. 이런 블록이 많아지게 되면, 메인 체인의 보안이 감소하게 된다. (블록생성 시간이 짧아질 수록, 공격자들은 더 많은 블록을 생성해서 전체 네트워크에 공격을 가할 수 있다. 자세한 것은 이더리움 블로그에서 발간한 글 On Slow and Fast Block Times를 참조) 이 문제를 대응하기 위해 GHOST Protocol이 제안되었다. CAP는 분산형 데이터 저장방식으로는 CAP 모두를 만족시킬 수 없다는 이론이다. 여기서 CAP은 Consistency (일관성: 모든 사용자가 같은 데이터를 볼 수 있다.) Availability(가용성: 모든 사용자가 항상 읽고 쓸 수 있다. (몇몇 노드가 죽어도 다른 시스템에 영향이 가선 안된다.)) Partition Tolerance(분단가용성: 물리적으로 분리된 분산환경에서 동작한다. 일부 메시지를 잃더라도 시스템은 정상동작해야 한다.) 스마트 컨트랙트 자체의 취약성: 2016년 6월 해커들은 slock.it의 기반인 DAO(Decentralized Autonomous Organization)에서 360만개의 이더를 해킹해서 가져갔다. 한글 공격과정 이는 스마트 컨트랙트를 구현하는 DAO 자체의 코드 결함으로 밝혀졌다. 스마트 컨트랙트는 당사자 간의 계약이며, 네트워크 외부에서 합법적으로 실행될 수 없기 때문에, 이러한 공격은 조직, 채굴자, 심지어는 블록체인 네트워크가 위험에 쳐할 수 있다. 인식: 블록체인은 초기 기술이며, 대부분 금융 분야에서 사용되고 있다. 다른 분야에 블록체인을 도입하는 것에 대한 인식 부족은 블록체인이 널리 확장되는데 영향을 미치고 있다. 규제: 블록체인의 특성상 규제 장애물은 피할 수가 없다. 이런 시스템은 새로운 정부 및 산업 규정이 필요하다. 또한, 분쟁을 피하기 위해 스마트 컨트랙트의 법적 집행 가능성을 거래 당사자들 사이에서 보장할 필요가 있다. 프라이버시: 블록체인은 공개원장이며 네트워크 참여자 누구나 거래를 볼 수 있기 때문에, 거래 당사자에 대한 개인정보 보호 문제가 남아 있을 수 있다. 효율성: 블록체인은 다음 블록을 채굴하기 위해 모든 노드가 동일한 컴퓨팅 계산을 수행해야 하므로, 효율적이지 못하다. 이렇게 어려운 계산을 여러노드가 실행해도, 결국 전체 네트워크에 대한 개별 노드의 기여도는 매우 적다.","categories":[],"tags":[]},{"title":"암호화폐의 다른면 - 비트코인의 보안 및 개인정보 보호를 통한 사용자 경험","slug":"user-expriences-with-bitcoin-security-and-privacy","date":"2018-07-01T15:00:00.000Z","updated":"2018-07-02T06:00:00.000Z","comments":true,"path":"2018/07/02/user-expriences-with-bitcoin-security-and-privacy/","link":"","permalink":"https://www.yceffort.kr/2018/07/02/user-expriences-with-bitcoin-security-and-privacy/","excerpt":"The Other Side of the Coin: User Experiences with Bitcoin Security and Privacy 원문 2016년 발표된 논문입니다. 그 때 당시 데이터 기준이라 작성하는 현재 (2018년) 과는 많은 차이가 있을 수 있습니다. 그럼에도 불구하고, 비트코인 생태계와 관련된 첫번째 대규모 설문이라는 점에서 의미가 있습니다. 현재 시가 총액이 35억달러인 비트코인은 암호화폐 중에서 가장 성공적인 모습을 보인다. (2018년 현재는 $109,351,638,467이다. 참고) 하루에 약 13","text":"The Other Side of the Coin: User Experiences with Bitcoin Security and Privacy 원문 2016년 발표된 논문입니다. 그 때 당시 데이터 기준이라 작성하는 현재 (2018년) 과는 많은 차이가 있을 수 있습니다. 그럼에도 불구하고, 비트코인 생태계와 관련된 첫번째 대규모 설문이라는 점에서 의미가 있습니다. 현재 시가 총액이 35억달러인 비트코인은 암호화폐 중에서 가장 성공적인 모습을 보인다. (2018년 현재는 $109,351,638,467이다. 참고) 하루에 약 130,000 건의 거래가 이루어지고 있으며, 상당한 언론 조명도 받고 있다. 암호화폐의 인기가 증가하고 있지만, 아직은 큰 현상이라고 보기엔 이르다. 그 이유 중 하나는 사용자들에게 공개 키를 암호화 처리하도록 강요하는 것이다. 또한 비트코인은 중앙 집중식 통화 시스템에 비해 대부분의 보안조치를 최종 사용자에게 이전한다. 비트코인을 관리할 수 있는 다양한 소프트웨어가 있지만, 기술적인 기본 사항을 처리하고 백업을 수행해야 하는 필요성은 여전히 존재한다. 따라서 이러한 시스템은 인간의 오류에 유연하게 대처하지 못한다. 온라인 포럼과 메일링 리스트의 보고서에 따르면, 많은 수의 비트코인의 사용자가 낮은 키관리의 유용성과, 악성 거래, 지갑과 같은 모안 침해로 인해 자신의 자산을 잃어버린 것으로 나타났다. 이는 비트코인 생태계와 인간의 상호작용에 대한 연구에 동기를 부여한다. 비트코인 사용자는 가상의 자산을 관리하는데 사용할 수 있는 다양한 툴을 가지고 있다. 이러한 도구들은 흔히 지갑(wallet)이라 불린다. 지갑은 원래 여러개의 private key를 모아둔 것으로 정의 되었다. (비트코인 wallet) 따라서, 이러한 이러한 private key를 적어둔 종이나, 머리속에 기억해 둔 것도 일종의 지갑이라고 불리울 수 있다. 그러나 이러한 도구의 대부분은 트랜잭션의 수행과 같은 저장 이상의 기능을 제공하지는 못한다. 다른 public key 암호화 시스템과는 다르게 (PGP/GPG) 비트코인은 완전한 독립적인 통신채널을 가지고 있지 않다. 비트코인의 경우, 분산 시스템을 운영하기 위해서는 비트코인 네트워크와 반드시 상호작용 해야 한다. 비트코인 툴은 다른 서명 시스템과는 달리, 수행된 트랜잭선, 계정 잔액에 대한 상태 정보를 각각 유지해 주어야 한다. 이 연구의 목표는 비트코인과 유저의 상호작용 방법과 가상의 자산을 관리하는 방법을 이해하는 것이다. 비트코인 네트워크에서 보안, 프라이버시 및 익명성과 관련한 경험과 인식도 연구되었다. 사용자 보고서를 수집하기 위해, 990명의 참가자를 대상으로 포괄적인 온라인 인터뷰를 실시하고, 그 중 10명을 대상으로는 정성적인 인터뷰도 진행되었다. 가장 많이 사용되는 CMT(Coin Management Tool)인 CoinBase, Xapo는 보안 책임을 제3자에게 넘기는 웹기반 도구 이다. 그러나 사용자의 1/3이 이 데이터가 암호화되어 있는지, 백업되어 있는지 알지 못하는 것으로 나타났다. 이 솔루션을 사용하는 사용자중 50%는 이 솔루션 만을 사용한다고 하였고, 나머지는 관리를 위해 다른 제품도 사용하는 것으로 나타났다. 위험 시나리오와 관련하여, 두번째로 큰 위험은 이런 CMT의 취약성으로 인해 나타났다. 또한 익명으로 남는 다는 것에 대한 오해가 생각보다 많은 사용자에게 나타나는 것도 발견되었다. 또한 사용자의 25%가 보안으로 취약한 '토르 위에서 비트코인을 사용’하는 것으로 나타났다. 참고(Bitcoin over Tor isn’t a good idea). 그리고 이미 사용자의 22.5%가 보안 침해로 인해 비트코인을 잃어버렸다고 이야기 했다. 이 중 절반 가량은 이 손실을 자신들의 잘못으로 여기고 있고, 대다수는 그 잃어버린 자산을 영원히 되찾지 못햇다. 이 연구에서 이뤄진 조사 https://www.soscisurvey.de/에서 오로지 비트코인 사용자만을 대상으로 조사를 실시. 참가자들에게 비트코인을 보상으로 제공 (0.0042비트코인, 그 때 당시 약 1.22 달러. 현재는 27달러 ^^) 참가자들이 다른 참가자를 모집해오면, 보상으로 0.001 비트코인을 제공. ¶결과 요약 ¶참가자들의 국적 ¶가장 많은 참가자를 모집해온 Top5 참가자 ¶비트코인을 어떻게 사용하나요? 팁과 도네이션 (38.0%) 가상 물건을 구매하기위해 (웹 호스팅, 온라인 뉴스 등) (33.3%) 온라인 쇼핑 (27.5%) 알트코인 (26.5%) 도박 (26.5%) 비트코인 기프트 카드 (19.9%) 기타. 마약 (… 약 5%) ¶얼마나 자주 사용하나요? 주 1회 (30.2%) 월 1회 (25%) 일 1회 (19%) 그 외는 연 1회 혹은 그 이하 ¶비트코인을 언제 시작했나요? 2013~2015년 (70%) 2011~2012년 (17%) ¶다른 암호화폐는 무엇을 사용하나요? (전체 응답자 중 58%가 알트코인을 사용한다고 하였음.) 도지코인, 라이트코인이 가장 많았음. ¶주 거래소는 무엇인가요? BTCE (20.9%) Bittrex (14.0%) Bitstamp (13.0%) ¶11.4%가 현재 마이닝 중이라고 하였으며, 대부분이 2014년 이후 마이닝을 시작함 이전에 마이닝을 한 사람들은, 현재는 그것이 불가능하다고 생각하기 때문에 (수익성을 내기 어렵다) 중단하였다고 응답. ¶19.7% 는 현재 비트코인 서버를 운영 중이라고 응답. (bitcoin Node) 이러한 서버를 운영하는 이유는 비트코인 네트워크에 기여하기 위해 (60.5%) 빠르게 트랜잭션 전파를 뒤따르기 위해 (46.6%) 네트워크 분석 (30.3%) 이중 지불 방지 (26.1%) ¶비트코인을 시작한 이유? 비트코인의 분산화된 성격 때문에 호기심 비트코인 시작에 대한 흥미로운 사례 중 하나는, 우크라이나 - 러시아 분쟁이 시작된 당시 크림반도에 살았던 참가자가 언급한 사회적치적인 이유였다. 그는 당시 미국 회사에서 일하고 있었으며, 크림반도에서 봉급을 받을 수 있는 안전하고 저렴한 옵션을 찾고 있었다. 그 중 비트코인이 가장 좋은 선택이었다고 한다. 당시 크림반도에서 많은 사람들이 비트코인을 사용중이라고 하였다. 일부 참가자들은 개인적으로 채굴을 했었는데, 이는 소규모 수익성이 있었다. ¶참가자들이 사용한 월렛 (CMT) 참가자들은 자신이 이용하는 월렛이 ¶비트코인을 사용하면서 느끼는 위협 참가자들에게 비트코인에서 발생할 수 있는 11가지 위험 시나리오를 제공하였다. 각 시나리오에 대해 설명을 제공하고, 이러한 위험이 발생할 가능성이 있는지 없는지 물어보았다. 그 결과 ¶보안 침해 22.5%는 비트코인이나 개인키를 잃어버린 적이 있다고 응답했다. 이 중 43.2%는 자신에게 책임이 있다고 하였다. 이러한 일이 발생한 원인은 하드웨어 (하드를 포맷하거나, 담아두었던 드라이브를 분실하는 등) (26.5%) 소프트웨어 (keyfile corruption) (24.4%) 보안 침해 (멀웨어, 해킹) (18%) 비트코인 분실자들 중 대다수는 (77.6%)는 키를 복구 할 수 있는지 여부를 밝히려 하지 않았다. 그 중 65%는 키를 복구하지 못했다. 이들이 잃어버린 비트코인의 총합은 660.6873개 (현재 가치 418만 달러 ㅠㅠ). 그러나 언제 분실되었는지 묻지 않았으므로 분실된 비트코인의 가치를 정확하게 계산하기란 어렵다. 전체 가자중 13.1% 가 HYIPS(고수익을 보장하는 일종의 사기) 나 피라미드 사기로 인해 잃어버린 것으로 나타났다. 7.9%는 마운트곡스에서 잃어버린 것으로 알려졌다. 그리고 이러한 사건에 어떻게 대응했는지 물어보았다. 그러나 대다수는 잃어버린 키를 회수 하기 위해 어떠한 조치도 취하지 않고 단순히 이러한 손실을 겸허히 받아드린 것으로 나타났다. 어떤 이들은 재정적 손실이 더이상 조치를 취할 가치가 없으며, 무엇을 해야할지 모르기 때문에 무력감을 느낀다고 하였다. 실제로 행동을 취한 소수는 온라인 월렛 제공자나 거래 당사자에게 항의를 한것으로 나타났다. 그리고 온라인에서 악의적인 공격으로 잃어버린 사람들은 다른 월렛으로 갈아탔다고 이야기 했다. HYIPS에서 돈을 잃은 사람들은 이제 덜 위험한 투자를 사용하며, 이전 실수에서 배운 것이 있다고 말했다. 그리고 그들의 주옥같은 명언들 (…) 나는 이제 ‘잃을 각오가 된 이상으로 투자하지말라’ 라는 규칙을 따르기로 했다. 나는 내 돈이 털린 것을 받아드리기로 했다… 그리고 절대로 거래 할때 월렛을 사용하지 않기로 헀다. 모든 것을 내손에 쥐고 있기로 했다. 많은 것을 배웠다. 나는 굉장히 어리석었다. 심층 인터뷰를 한 8명은, 의도적이거나 실수로 비트코인이나 private key를 잃어버린 적이 있다고 이야기 했다. 참가자들 중 3명이 마운트 곡스 사건에 연루되어 있었고, 그 중 두명은 크라켄을 고소한 것으로 나타났다. (사건 참고). 참가자중 한명은 Casascius Coin을 잃어버렸지만, 그 당시 가치가 9달러 밖에 안되서 굳이 찾지 않았다고 한다. ¶사용성에 대한 인식 심층 인터뷰에 참가한 대부분은 비트코인의 관리측면에서 사생활과 보안에 대해서 매우 우려하고 있지만, 비기술적인 비트코인 사용자들에게 온라인 지갑을 추천할 것이라고 했다. 주요 이점으로는 편의성과 사용 용이성을 꼽았다. 한 참가자는 복구를 쉽게하고, 포괄적인 백업 뿐만 아니라, 니모닉에 도움이 되도록 개인키가 중앙서버에 저장되는 월렛을 추천할 것이라고 말했다. 6명 참가자는 MyCelium을 가장 유용한 월렛으로 추천하였다. 이미 이 월렛을 사용하는 사람들은 종이 백업 절차를 가장 유용하고 안전한 방법으로 이야기 했다. 대부분의 사람들은 비트코인을 처음이용하기 위해서는 기초적인 공부가 필요하다는 것을 강조했고, 비트코인은 본질적으로 복잡하며, 공개키 암호화의 기본 아이디어는 학교에서 가르쳐야 하고 통화시스템은 문화의 문제라고 언급했다. ¶결론 많은 수의 사용자들이 암호화와 백업 같은 충분한 조치를 취하지 않기 때문에, 비트코인의 관리가 여전히 많은 사용자들에게 주요한 과제임이 드러났다. 그리고 대부분이 CMT에서 어떠한 보안기능을 제공하는지도 알지 못하고 있었다. 그리고 가장 널리 사용되는 CMT는 웹 호스팅 솔루션이다. 이 중 절반은 이러한 웹 호스팅 솔루션 만을 사용하며, 나머지는 로컬 클라이언트도 병행해서 사용하고 있었다. 웹 클라이언트는 유용하고 편리한 솔루션이어야 하지만, 일정 수준의 신뢰를 필요로 하며, 암호화와 백업 관리에 대한 책임을 제 3자에게 이전해야하는 리스크가 있다. 그리고 22.5%가 이미 비트코인을 통해 손실을 경험했고, 그 중 절반이 자신의 실수로 인한 것이라고 언급했는데 이는 여전히 사용자가 비트코인을 관리하기 어렵다는 것을 보여준다. 비트코인 생태계와의 상호작용을 전문가와 비전문가인 유저 모두에게 보장하기 위해, 단순히 비밀키 관리를 넘어서 비트코인의 관리개념을 다시 생각할 필요가 있다. 비트코인은 peer간 상호작용과 메시지와 데이터 전파 및 검증이 중요한 검증 시스템이다. 이 측면을 무시한다면, 비트코인은 단치 가치 가없는 숫자들의 집합일 뿐이다. 전체 질문은 원문에서 확인하세요.","categories":[],"tags":[]},{"title":"소셜임팩트를 위한 블록체인","slug":"blockchain-for-social-impact","date":"2018-06-30T15:00:00.000Z","updated":"2018-07-01T09:17:17.000Z","comments":true,"path":"2018/07/01/blockchain-for-social-impact/","link":"","permalink":"https://www.yceffort.kr/2018/07/01/blockchain-for-social-impact/","excerpt":"Blockchain for Social Impact 원문 소셜임팩트를 가져올 블록체인의 잠재력은 엄청나지만, 얼마나 과장되어 있고, 얼마나 현실적일까? 블록체인 지지자들은 모든 주요 산업을 혼란을 야기하지 않는 범위내에서 영향을 미칠 것이고, 심지어 사람들과 사회가 상소학용하는 방식도 바꿀 것이라고 주장한다. 효율성도 높이고, 비용을 절감하며, 투명성을 증신시키는 이 기술은 사회적인 영향을 미치는 분야에 중요한 영향을 미칠 수 있을 것이다. 시스템을 바꾸고, 인프라를 도약할 수 있는 잠재력은, 이전에 블가능하다고 생각했던 솔루","text":"Blockchain for Social Impact 원문 소셜임팩트를 가져올 블록체인의 잠재력은 엄청나지만, 얼마나 과장되어 있고, 얼마나 현실적일까? 블록체인 지지자들은 모든 주요 산업을 혼란을 야기하지 않는 범위내에서 영향을 미칠 것이고, 심지어 사람들과 사회가 상소학용하는 방식도 바꿀 것이라고 주장한다. 효율성도 높이고, 비용을 절감하며, 투명성을 증신시키는 이 기술은 사회적인 영향을 미치는 분야에 중요한 영향을 미칠 수 있을 것이다. 시스템을 바꾸고, 인프라를 도약할 수 있는 잠재력은, 이전에 블가능하다고 생각했던 솔루션을 가능하게 할 수 있다. 그러나 여전히 문제는 남아있다. 과연 블록체인은 사회적으로 막대한 영향을 미칠 역사적인 기술의 정점에 있는가, 혹은 그냥 단순한 최신 기술의 유행어 일 뿐인가? ¶아직은 초기 단계이지만, 충격은 가까이에 있다. 소셜임팩트를 위한 블록 체인 이니셔티브는 아직 초기단계다. 34%는 2017년, 혹은 그 이후 부터 시작되었고, 74%는 여전히 파일럿/아이디어 단계에 머물러 있다. 그러나 블록체인 이니셔티브의 55%는 2018년 말까지 수혜자에게 영향을 미칠 수 있을 것으로 추정된다. ¶블록체인은 이전에는 불가능했던 문제를 가능하게 해준다. 연구된 193개의 블록체인 이니셔티브 20%는 블록체인 없이는 솔루션을 제공할 수 없었으며, 86%는 기존 솔루션보다 실질적인 향상이 있었다. ¶보건 분야는 다른 분야보다 더 많은 블록체인을 사용할 유인이 존재한다. 보건 분야는 두번째로 많은 경제분야(Financial) 보다 두배 더 많은 활동이 이루어 지고 있었다. (각 각 25%, 13%) 자선 사업과 원조, 민주주의와 거버넌스 분야가 그 뒤를 11%로 잇고 있었다. ¶블록체인은 지불을 촉진하고 기록을 확인하는데 가장 자주 사용된다. 블록체인의 주요 사용 사례는 기록 및 검증 (26%) 과 지불 및 송금 (25%)다. 블록체인의 가장 보편적인 혜택은 위험과 사기(38%)를 줄이고, 효율성을 높이는 것(24%) 이다. 소셜임팩트를 위한 블록체인 응용프로그램의 앞으로의 성장성과 채용가능성을 알기에는 아직 이를 수도 있지만, 잠재적으로 변화 가능성이 있는 소셜임팩트를 위한 블록체인 어플리케이션이 이미 등장하고 있는 것으로 나타났다. 이러한 블록체인 어플리케이션은 성숙함에 따라, 아래 두 가지를 최종적으로 제안한다. ¶소셜임팩트를 위해 개발되고 있는 블록체인 어플리케이션의 진행과정에 주의를 기울여라 조사결과 블록체인이 세계에서 가장 어려운 도전을 해결하려는 사람들에게 점진적 (65%) 또는 혁신적인 해결책 (25%)을 주고 있다는 것을 시사하고 있다. 초기 파일럿 프로그램에서 실제 동작하는 프로그램으로 점점 더 많은 이니셔티브가 옮겨 감에 따라서, 진행상황을 면밀히 모니터링 한다면, 과대광고를 넘어서 이를 통해 입증된 사용사례가 더욱 나타나 결국 추가적인 지원 및 채택을 얻을 수 있다. 이미 블록체인은 민주주의와 거버넌스에 영향을 미치기 시작했는데, 향 후 6개월 내로 이 분야에서 67% 정도가 블록체인에 의해 영향을 받을 것으로 예상된다. 블록체인 어플리케이션이 점차 채택되고 영향력이 커짐에 따라서, 향 후 블록체인이 실제로 불가능해 보이는 솔루션에 해결책을 줄 수 있을지, 아니면 적어도 기존 솔루션 개선에 도움이 될 지는 지켜봐야 할 문제다. 새로운 블록체인을 만들기 위해, 다른 사람들의 작업을 따라서 배울뿐 만 아니라 파트너가 될 기회를 모색해야 된다. 이 연구에서는 블록체인 솔루션을 제공하기 위해 여러분야에서 협력이 필요한 것을 강조하였다. 특히 정부와 비영리단체가 기본적인 서비스의 발전을 위해 추진하는 민간 부문 섹터와 협력하여 프로젝트를 실행할 수 있는 잠재력이 있다고 생각한다. ¶해결하려고 하는 문제가 무엇인지 이해하고, 그 것이 얼마나 블록체인을 통해 해결할 수 있는지 살펴봐라. 블록체인은 여러 당사자간의 신뢰를 심어주고, 비용을 절감하며, 효율성을 높이고, 보안을 향상 시킬 수 있는 잠재력을 제공한다. 블록체인의 일반적인 과제는 지불, 송금, 기록 및 신원확인이다. 블록체인을 사용한다면 불가능한 솔루션에 해결책을 줄 수 있다. The Deloitte Blockchain Framework는 블록체인이 가장 적합할 수 있는 네가지 전제 조건에 대한 지침을 적용한다. 공유된 레파지토리에서 정보를 변경하는 트랜잭션을 생성하는 당사자가 여럿일 경우 거래가 타당하다고 믿어야 하는 당사자가 필요한 경우 중개인이 비효율적이거나 진실된 중재자로 신뢰받지 못하는경우 보한 강화가 필요한 경우 사람들이 새로운 것을 하기 위해 신기술을 사용할때, 종종 과장광고가 증폭되는 경우가 있다. 어플리케이션에 사용할 기술을 먼저 찾는 것이 아니라, 당신이 해결하려고 하는 문제가 블록체인이 제공하는 가치와 맞는지 먼저 생각해보라. 블록체인이 어떻게 가치를 가장 잘 전달 할 수 있는지에 더 중점을 둔다면, 과장광고에서 벗어나 더욱 현실에 가까워 질 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"social-impact","slug":"social-impact","permalink":"https://www.yceffort.kr/tags/social-impact/"}]},{"title":"블록체인에 대한 진실","slug":"the-truth-about-blockchain","date":"2018-06-28T15:00:00.000Z","updated":"2018-06-29T01:21:51.000Z","comments":true,"path":"2018/06/29/the-truth-about-blockchain/","link":"","permalink":"https://www.yceffort.kr/2018/06/29/the-truth-about-blockchain/","excerpt":"The truth about Blockchain 원문: 하버드 피즈니스 리뷰 계약, 거래, 그리고 이와 관련된 기록은 경제, 법률, 정치 시스템을 정의하는 구조 중 하나다. 이들은 재산을 보호하고, 조직에 대한 경계를 설정한다. 그리고 정체성과 시간 흐름에 따른 연대기를 구축하고 확립한다. 이들은 개인, 커뮤니티, 조직, 국가 들간의 상호작용을 통제한다. 그리고 경영과 사회와 관련된 행동을 가이드 한다. 그러나 이러한 중요한 도구들과 관료들은 경제에서 일어나는 디지털 변화를 따라가지 못했다. 디지털 세계에서는, 통제를 규제하고","text":"The truth about Blockchain 원문: 하버드 피즈니스 리뷰 계약, 거래, 그리고 이와 관련된 기록은 경제, 법률, 정치 시스템을 정의하는 구조 중 하나다. 이들은 재산을 보호하고, 조직에 대한 경계를 설정한다. 그리고 정체성과 시간 흐름에 따른 연대기를 구축하고 확립한다. 이들은 개인, 커뮤니티, 조직, 국가 들간의 상호작용을 통제한다. 그리고 경영과 사회와 관련된 행동을 가이드 한다. 그러나 이러한 중요한 도구들과 관료들은 경제에서 일어나는 디지털 변화를 따라가지 못했다. 디지털 세계에서는, 통제를 규제하고 유지하는 방식에 변화가 필요하다. 블록체인은 이러한 문제를 해결할 수 있는 기술이다. 비트코인과 다른 암호화폐의 중심에 있는 이 기술은 개방적이고 분산된 원장으로, 두 당사자간의 거래를 효율적이고 검증가능하며 영구적인 방식으로 기록 할 수 있다. 또한 원장 자체에 트랜잭션을 자동으로 트리거하도록 프로그래밍 할 수도 있다. (스마트 컨트랙트) 블록체인을 통해, 계약이 디지털 코드 내에 내장되어, 투명하고 공유된 데이터베이스에 저장되어 삭제, 조작 및 임의 수정으로 부터 보호되는 세계를 만들어 나갈 수 있다. 모든 계약, 절차, 업무, 지불금에는 디지털 기록과 서명이 있을 것이고, 이 기록은 확인, 검증, 저장, 공유 될 수 있을 것이다. 변호사, 중개인, 은행가 같은 중간에 있는 중개자들이 더 이상 필요하지 않을 수도 있다. 개인, 조직, 기계 및 알고리즘은 마찰이 거의 없는 상태에서 자유롭게 거래하고 상호 작용한다. 이는 블록체인의 엄청난 잠재력이다. 실제로 모든 사람들이 블록체인이 기업에 혁명을 불러오고, 기업과 경제를 재정의 할 것이라는 주장을 들어봤을 것이다. 우리는 그러한 잠재력에 대해 공유하고 는 있지만, 과대 포장되어 있지 않은지도 우려한다. 예를 들어 보안문제(예를 들어 2014년에 비트코인 거래가 붕괴되고 해킹된 사건) (주: 여기서 이야기 하는 사례는 아마도 마운트곡스에서 발생한 사상 최악의 비트코인 해킹사건을 이야기 하는 것 같다. 여기를 참조) 만이 걱정되는 사항이 아니다. 기술 혁신에 대해 연구한 여기서의 경험은, 블록체인 혁명이 일어나기 위해서는 기술적, 지배구조적, 조직적, 심지어 사회적인 장벽이 무너져야 한다는 사실을 보여준다. 어떤식으로 블록체인이 사회구조를 장악할 것인지 모르는채 블록체인의 혁신으로 뛰어드는 것은 명백한 실수가 될 것이다. 블록체인을 중심으로 한 비즈니스와 정부의 변화는 여전히 수년이 더 소요될 것으로 보인다. 블록체인은 ‘파괴적인’ 기술이 아니라, 저렴한 솔루션으로 전통적인 비즈니스 모델을 공격하고 기존 기업을 빠르게 추월할 수 있기 때문이다. 블록체인은 굉장히 기초적인 기술이다. 블록체인은 우리의 경제 및 사회 시스템을 위한 새로운 토대를 만들 잠재력이 있다. 그 영향은 엄청날 것이지만, 블록체인이 우리 경제 및 사회 기반 시설로 스며 드는데는 아마도 수십년이 걸릴 것이다. 기술적, 제도적인 변화의 파도가 모멘텀을 얻음에 따라 이러한 변화는 점진적이고 안정적으로 이루어질 것이다. 여기에서 다루고자 하는 것은 그 통찰과 전략적 함의이다. ¶기술 도입의 양상 블록체인 전략과 투자에 뛰어들기 전에, 새로운 기술이 채택되는 과정, 특히 다른 기초적인 기술이 받아드려지는 양상에 대해 생각해보자. 가장 관련성이 높은 사례 중 하나는 인터넷 발전에 토대를 마련한 TCP/IP 채택에서 볼 수 있는 분산 컴퓨터 네트워킹 기술이다. 1972년에 소개된 TCP/IP는 상업용 인터넷의 미 국방부 선구자인 ARPAnet의 연구자들 사이에서, 전자 메일의 기초로서 처음으로 단일 용도 사례로서 탄력을 받았다. 이전에 통신 아키텍처는 두 당사자 또는 기계간의 연결을 교환을 바탕으로 사전에 설정하고, 유지해야 하는 '회로 스위칭’을 기반으로 했다. 두 노드가 통신할 수 있도록 통신 서비스 제공업체와 장비 제조업체는 전용 회선을 구축하는데 수십억 달러를 투자했다. 그러나 TCP/IP는 이러한 방향성을 완전히 뒤바꿔놓았다. 이 새로운 프로토콜은 정보를 각각의 주소를 디지털화하고, 주소정보를 포함한 매우 작은 패킷으로 분해하여 정보를 전송했다. 이 패킷이 네트워크로 릴리즈 되면 패킷은 어떤 수신자든지 취할 수 있다. 네트워크 단에서 송수신 노드는 패킷을 분해하고, 재조립하고, 인코딩된 데이터를 해석할 수 있다. 이를 위한 전용 회선이나 대규모 인프라는 필요하지 않다. TCP/IP는 유지 보수 및 개선을 담당하는 중앙 기관이나 담당작 없이 개방적이고 공유된 공공 네트워크를 만들어 냈다. 전통적인 통신사업체나 컴퓨팅 분야에서는 TCP/IP를 비관적인 시각으로 보았다. 이러한 새로운 아키텍처에서 강력한 데이터, 메시징, 음성 및 비디오 연결을 제어하거나 관련한 시스템을 안전하게 확장할 수 있다고 생각한 사람은 거의 없었다. 그러나 80년대 후반 부터 90년대 까지, Sun, NeXT, HP, Silicon Graphics와 같이 점점 더 많은 회사들이 TCP/IP를 사용하여 조직내에서 사설 네트워크를 만들기 시작했다. 이를 위해 그들은 단순히 이메일을 넘어서 사용범위를 넓히는 도구를 개발하여 전통적인 로컬 네트워크 기술과 표준을 대체했다. 조직에서 이러한 구성 요소와 툴을 채택함으로서 생산성이 크게 향상되기 시작했다. TCP/IP는 90년대 중반 월드와이드웹(www)의 등장으로 순식간에 대중화 되었다. 공용 네트워크에 접속하여 정보를 교환하는데 필요한 하드웨어, 소프트웨어, 각종 서비스와 같은 '배관’을 공급하는 새로운 기술 기업들이 빠른 속도로 늘어나기 시작했다. 넷츠스케이프는 최초로 브라우저와 웹서버, 인터넷 서비스와 어플리케이션 개발 및 도입을 지원하는 도구와 요소들을 상용화했다. 선은 프로그래밍 언어 '자바’를 개발하기 시작했다. 웹 에서 정보가 기하급수적으로 증가하자, 인포시크, 익사이트, 알타비스타, 야후 등 사람들에게 정보를 안내하고 보여주는 검색엔진이 등장하기 시작했다. 이러한 기초적인 기반시설이 충분히 생겨나자, 신생 기업들은 기존 비즈니스를 대체할 강력한 인터넷 서비스를 만들어 내어 저비용 연결의 작점을 극대화 하기 시작했다. CNET은 뉴스를 온라인으로 옮겼다. 아마존은 어떤 서점 보다도 많은 책을 팔기 시작했다. 프라이스라인과 익스피디아느 항공권 판매를 더 쉽게 만들었고, 그 처리 과정은 전례 없이 투명했다. 이렇듯 상대적으로 저비용으로 폭넓은 영향력을 발휘하는 신생기업들의 역량은 기존의 종이신문, 오프라인 소매업체들에게 엄청난 압박을 가하기 시작했다. 광범위한 인터넷 연결을 기반으로, 새로운 기업들은 비즈니스가 가치를 창출하여 얻어내는 방법을 근본적으로 바꾸는 참신하고 혁신적인 어플리케이션을 내놓기 시작했다. 이러한 기업들은 새로운 P2P 아키텍쳐를 기반으로 구축되었고, 분산된 사용자 네트워크를 조정하여 가치를 창출해 내었다. 이베이가 경매를 통해 온라인 세일즈를 바꾸고, 냅스터는 음악산업을, 스카이프는 통신산업을 바꿨으며, 구글이 사용자가 생성한 링크를 통해 연관성이 더 높은 결과를 제공하여 검색을 바꾼 것을 생각해보자. 궁극적으로 TCPIP가 단일용도, 제한용도, 대체, 그리고 혁신에 이르기 까지 모든 단계를 거쳐 전반적인 경제구조를 바꿔놓기 까지 30년이 넘게 걸렸다. 오늘날, 세계에서 시창가치가 높은 절반이상의 기업이 인터넷 중심 플랫폼 기반 서비스 비즈니스 모델을 가지고 있다. 경제의 근간이 바뀌게 된 것이다. 더 이상 물리적인 규모나, 독특한 지적재산권이 강력한 강점으로 작용되지 않는다. 시간이 지날 수록 경제를 이끌어 나가는 것은 커뮤니티와 사용자, 폭넓은 네트워크를 주도적으로 조직하고 영향력을 행사하며 조율 하는 '중추’역할을 하는 기업들이다. ¶새로운 아키텍쳐 인터넷을 기반으로한 P2P 네트워크 중 하나인 블록체인은, 2008년 10월에 새로운 가상화폐 제도인 비트코인을 소개하는 내용의 입부로 사용되었다. 화폐 발행, 소유권이전, 거래 확정을 위해 중앙을 거치지 않는 비트코인은 블록체인 기술을 적용한 첫번째 애플리케이션이다. 블록체인과 TCP/IP는 유사한 점이 있다. 이메일이 둘 사이에 메시지를 보낼 수 있게 하는 것처럼, 비트코인은 둘 사이에서 금융거래가 가능하게 해주었다. 블록체인의 개발과 유지보수는 TCP/IP처럼 공유되어있고, 분산되어있으며, 열려 있다. 세계 각지의 컨트리뷰터들로 이루어진 팀이 핵심 소프트웨어를 관리한다. (비트코인 Github) 이메일이 그랬던 것처럼, 비트코인도 작고 열렬한 집단의 큰 호응을 얻고 있다. TCP/IP가 새로운 경제적 가치를 만들어 낼 수 있었던 이유는 연결비용이 엄청나게 저렴했기 때문이다. 블록체인도 이 처럼 거래비용을 엄청나게 낮출 수 있다. 그래서 모든 거래를 기록하는 시스템으로도 바뀔 수 있다. 만약 그렇게 된다면, 블록체인을 기반으로 영향력과 지배력을 휘두르는 요인들이 발생하면서 경제는 또한번 요동치게 될 것이다. 오늘날 비즈니스가 어떻게 이루어지는지 생각해보자. 끊임없이 생성되는 거래 기록을 저장하는 것이 모든 비즈니스의 핵심이다. 이러한 기록은 과거를 추적하여 미래의 결정하고 행동할 수 있도록 안내해준다. 조직이 내부적으로 어떻게 운영되는지, 외부와의 관계에 대한 시각은 어떤지도 제공한다. 모든 조직은 자체 기록을 보유하고, 이를 외부에 공개하지 않는다. 그러나 많은 조직이 그들의 모든 행위를 기록하는 마스터 장부를 보유하고 있지 않고, 부서나 직무별로 기록이 뿔뿔이 흩어져있다. 문제는 이러한 장부를 넘나들면서 거래를 조율하려면 시간도 오래걸리고, 실수하기도 쉽다. 예를 들어, 일반 주식거래는 1/100,000,000초 만에 사람의 개입이 없어도 거래가 발생한다. 그러나 주식 소유권 이전 과 같은 거래는 확정되기까지 1주일이 넘게 걸리기도 한다. 왜냐하면 거래 당사자가 서로의 장부를 화긴하면서 자동으로 그 주식이 실제 그사람의 주식인지, 양도가 가능한지를 확인할 수 없기 때문이다. 거래 기록을 여러기관을 거치고 각각의 장부가 따로따로 갱신될때, 일련의 중재자들이 보증인 역할을 한다. 블록체인 시스템 내에서는, 다수의 동일한 데이터베이스 내에서 거래장부가 복제되고, 각각의 당사자가 이를 관리하고 유지한다. 하나의 장부에 변화가 발생하면, 모든 장부에 동시에 업데이트 된다. 그러므로 거래가 발생하면 가치와, 자산에 대한 모든 기록이 장부에 영구적으로 기입된다. 소유권을 증명하거나 이전하는데 제3자는 필요가 없다. 블록체인을 기반으로 한 시스템에서 주식거래가 발생하면, 몇초내로 안전하고 확인가능한 방식으로 거래가 이루어질 것이다. (비트코인 거래소를 공격한 해킹은 (앞서 말한 마운트곡스 사건) 블록체인의 약점이 아니라 블록체인과 거래 당사자를 연결하는 시스템의 약점을 이용한 것이다.) ¶블록체인 도입을 위한 프레임워크 비트코인이 마약에 초창기 이메일과 같은 양상을 띈다면, 블록체인이 그 가능성ㅇ르 모두 실현하기 위해서는 수십 년의 시간이 걸릴까? 아마도 어느정도 조건하에서는 그럴 것이다. 정확히 몇년이 걸릴지는 예측하기는 어렵다. 그러나 어떠한 어떤 종류의 어플리케이션이 먼저 관심을 끌고, 결국에는 어떤 방식으로 폭넓게 수용될지는 예측해 볼 수 있다. 역사적으로 볼때, 기반 기술과 비즈니스 활용 사례가 발전하는 방식은 두가지에서 영향을 받는다. 생소함: 이러한 애플리케이션이 얼마나 새롭게 느껴지는 지 정도다. 이것이 클수록, 사용자들이 어떤 문제를 해결할 수 있는지 확실히 이해시키려면 더 많은 노력을 기울여야 한다. 복잡성: 어느 정도의 생톄게 조율을 필요로 하는지 나타내는 복잡성은, 해당 기술로 가치를 생산하기 위해 협력해야하는 이해당사자 수와 종류가 포함된다. 예컨데 사용자가 한명인 소셜네트워크 서비스는 쓸모가 없다. 이ㅡ는 블록체인도 마찬가지다. 이런 애플리케이션의 규모와 영향력이 커질 수록, 도입할 경우 상당한 제도적 변화가 요구된다. 기반기술은 어떻게 자리잡는가 기반 기술이 도입되기 위해서는 일반적으로 네단계를 거치게 된다. 각각의 단계는 어플리케이션의 생소함과, 그것을 실행하는데 얼마나 복합한 조율이 필요한지에 따라 정해진다. 이 두 요소가 덜한 어플리케이션이 가장 먼저 받아드려진다. 그러나 이것이 강한 적용물은 적용까지 수십년이 걸리지만, 경제를 변화시킬 수 있다. TCP/IP단계는 이미 변화단계에 까지 갔지만, 블록체인 어플리케이션은 아직 초기단계다. 위 그림은 앞선 두 요소와 관련이있는 그림이다. 각각의 영역은 기술발전의 단계를 나타낸다. 블록체인 혁신기술이 어느단계에 해당하는지 파악한다면, 경영자들은 이에 따르는 과제의 유형과 필요로 하는 협력, 법률, 규제노력에 대한 요구까지 이해하는데 도움이 될 수 있다. 이 그림은 혁신기술을 도입을 도모하기위해 어떤 유형의 절차와 기반이 세워져야 하는지에 대해서도 알게 해준다. 경영자들은 이것을 활용해 어느 산업이든, 블록체인의 발전단계를 가늠하고 조직 내 블록체인 역량에 대한 투자를 검토할 수도 있다. 단일용도 (Single Use): 생소함과 조정을 필요로 하는 정도가 모두 낮으며, 저렴한 비용으로 우수한 성과를 창출하는 집중화된 솔루션을 생성하는 애플리케이션이다. 전화, 팩스, 우편의 저렴한 대안인 이메일은 한가지 용도에 집중한 TCP/IP 어플리케이션 이었다. 비트코인 역시 마찬가지다. 초창기지만, 비트코인은 대안 결제 수단으로 사용하는 소수 사람들에게 직접적인 가치를 제공했다. 2016년 말에 비트코인 거래 가치는 920억 달러에 이를 것으로 예상된다. 전세계 총 결제금액 411조 달러에 비하면 굉장히 작은 수치에 불과하다. 하지만 빠르게 성장하고 있으며, 즉시결제, 외화 및 자산 거래 같이 현재 금융 시스템이 한계를 느끼는 분야에서는 중요성이 커지고 있다. 제한적인 사용 (Localization): 상대적으로 생소함은 크지만, 즉각적인 가치 창출을 위해 필요한 사용자가 제한적이어서 도입을 하기가 비교적 쉬운 것이 여기에 속한다. 만약 블록체인 네트워크 기술이 비즈니스에 도입될 때 과정을 따른다면, 블록체인 혁신기술도 단일용도 프로그램을 기반으로 제한적인 용도의 프라이빗 네트워크를 만들어 낼 수 있을 것이다. 프라이빗 네트워크ㅇ에서는 다수의 조직이 탈중항화된 거래방주를 통해서 연결된다. 프라이빗 블록체인을 기반으로 한 개발은 상당부분 금융 서비스 분야에서 선제적으로 이뤄지고 있다. 기업은 소규모 네트워크 안에서 진행되므로 조정에 대한 부담이 크지 않다. 일례로 나스닥은 Chain.com 과 함께 협업하고 있다. 뱅크오브아메리카, JP모건, 뉴욕증권거래소 등도 무역금융, 외국환, 국가 간 결제, 증권결제 같은 업무에 대해 문서 기반 수작업을 대체할 블록체인 기술을 알아보고 있다. 캐나다 중앙은행은 은행 간 거래에 CAD-코인이라고 하는 디지털화폐를 시범적으로 운영중이다. 참고 앞으로 다양한 분야에서 다른 목적을 수행하는 프라이빗 블록체인이 급증할 것으로 보인다. 대체 (Substitution): 이 영역은 제한적인 용도의 어플리케이션을 기반으로 함으로 생소함은 적지만, 사용자가 많고 대중화되고 있어 조율이 크게 필요한 어플리케이션이 포함된다. 이러한 혁신의 목표는 비즈니스 방식을 완전히 뒤바꿔 버리는 것이다. 하지만 이를 막는 높은 장벽이 있는데, 이는 기존 방식들이 이미 조직과 기관에 깊게 자리잡고 있기 때문이다. 이러한 사례로 암호화폐를 들 수 있다. 단순한 비트 코인 결제기술을 발전시킨 새롭고 완전한 형태를 갖춘 화폐 제도다. 차이가 있다면 암호화폐는 화폐거래를 하는 모든 당사자가 이 암호화폐를 선택해야 한다는 점에서, 오랫동안 이 거래를 처리하고 있는 정부와 기관에 맞서야 한다.소비자들도 마찬가지로 행동양식을 바꾸고, 암화퍠가 가진 새로운 기술적 역량을 이용하는 방법을 이해해야 한다. 최근 MIT에서 실시한 실험은 이러한 디지털 화폐가 넘어야할 산을 잘 보여준다. 2014년 MIT 학생들이 조직한 비트코인클럽은 학생 4494명에게 100달러 상당의 비트코인을 나눠주었다. 그러나 그 중 30%는 이 공짜 암호화폐를 사용하기 위한 등록조차 하지 않았다. 그 중 또 20%는 비트코인을 즉시 현금으로 교환하였다. 기술 이해도가 뛰어난 사람들 조차 이를 어떻게, 어디에 사용해야 하는지 이해하지 못하는 것이다. 이러한 대체제로서 적용한 블록체인 어플리케이션 중 하나는 바로 스텔라다. 스텔라는 은행이용이 어려운 사람들에게 소액결제, 송금등의 금융서비스를 제공하는 것이 목적인 비영리 시스템이다. 스텔라는 가상화폐인 루멘을 사용자들이 화폐나 다른 통화, 통화시간 (전화) 를 포함한 다양한 자산을 시스템에 보유할 수 있도록 허용한다. 스텔라는 아프리카, 그 중에서도 경게규모가 제일 큰 나이지리아에 집중했다. 그 결과 나이지리아에서 꽤 이용되고 있고, 비용 대비 효율도 크다는 것을 알게 되었다. 그러나 이렇다고 해서 스텔라의 미래가 밝은 것은 아니다. 왜냐면 생태계를 조율해야하는 문제가 남아있기 때문이다. 나이지리아 사람들이 받아드려서 가능성이 증명됬지만, 은행업무의 표준으로 자리잡기 위해서는, 정부정책에 영향을 미치고, 중앙은행과 큰 조직들을 설득시켜야 하기 때문이다. 이는 수년에 걸친 노력을 필요로 할 수도 있다. 변화 (Transformation): 성공할 경우 경제, 사회, 정치제도의 본질을 완전히 뒤집을 수 있는 어플리케이션이 여기에 포함된다. 여기에는 여러 주체들의 행위를 조율하고, 표준과 절차에 대한 기관의 동의도 얻어야 한다. 이를 도입하게 되면 사회적, 법적, 정치적으로 중대한 변화가 요구될 것이다. '스마트 컨트랙트’가 지금으로서는 가장 혁신적인 모델이 될 수 있다. 이 기술은 일정 조건을 만족하면 자동적으로 결제를 실행하고 화퍠나 다른 자산을 이전한다. 예를 들어 스마트 컨트랙트를 활용하면 화물이 도착하자마자 공급업체에 대금을 지불할 수 있다. 업체에서 제품을 받았다고 알리거나, 제품자체에 GPS가 있어서 자동적으로 위치변화를 블록체인에 기록했다고 가정하자. 그렇게 되면, 그것만으로 결제가 이루어지는 것이다. 이미 벤처 펀딩, 은행, 디지털 저작권 관리 분야에서 이러한 스마트 컨트랙트를 실험한 사례를 살펴보았다. 기업은 법인설립에서 구매자-공급자, 직원들 관계에 이르기 까지 전부 계약을 기초로 한다. 계약이 자동화된다면, 전통적인 기업 구조, 프로세스와 더불어 변호사, 회계사 들에게는 어떤 일들이 일어날 것인가? 관리자들은? 이들의 모든 역할에 근본적인 변화가 나타날 것이다. 하지만 스마트 컨트랙트가 수용되려면 앞으로 수십년이 더 걸린다는 사실을 기억하자. 스마트 계약은 제도적인 뒷받침이 없으면 무용지물이다. 스마트계약의 설계, 확인, 실행, 강제 집행 방식을 놓고 많은 조율과 명확성이 요구될 것이다. 이런 업무를 책임지는 기관이 나타나려면 더 긴시간이 필요할 것 으로 보인다. 그리고, 기술적인, 특히 보안과 관련되어 넘어야할 산이 많다. ¶블록체인 투자에 접근하는 가이드 경영자들은 자신의 조직을 위해 블록체인을 어떻게 판단해야 할까? 앞서 공개한 프레임워크가 올바른 기회를 찾는데 도움이 될 수 있다. 대부분, 단일용도로 블록체인을 시작하는 것이 가장 쉽고, 생소하지 않으며, 조율할 일도 적어 리스크를 줄일 수 있다. 한가지 전략은 비트코인을 결제 메커니즘에 추가하는 것이다. 비트코인은 이러한 인프라스트럭쳐와 시장이 잘 되어 있어, 가상화폐를 도입하면 IT, 금융, 회계, 영업, 마케팅을 포함한 다양한 기능들이 블록체인 역량을 쌓을 수 있을 것이다. 또다른 위험이 적은 방법은 블록체인을 물리적인 자산, 내부거래기록, 신원확인 같은 여러 어플리케이션을 관리하기 위한 내부 디비로 사용하는 방법이다. 단일용도로 시범적으로 사용하면, 조직에서 그보다 더 높은 수준의 어플리케이션에 필요한 역량을 키우는데 도움이 될 수 있을 것이다. 스타트업 을 비롯하여, 아마존과 마이크로소프트와 같은 대규모 플랫폼에서도 클라우드 기반의 블록체인 서비스를 공개하여 이러한 실험을 해보기가 쉬워지고 있다. 이 다음 단계는 제한적인 용도로 사용하는 것이다. 프라이빗 블록체인 네트워크에 대한 투자가 이뤄지고 있고, 이런 프로젝트들은 실질적인 단기효과를 추구하고 있는 것으로 보인다. 금융서비스 기업을 예로 들어, 신뢰할 수 있는 제한된 인원의 이해당사자로 구축된 프라이빗 블록체인 네트워크가 거래비용을 상당부분 줄일 수 잇는 것으로 나타났다. 이런 블록체인을 통해, 경계를 넘나드는 거래에서 발생하는 문제도 해결할 수 있다. 예를 들어, 몇몇 회사들은 이미 블록체인을 사용하여 복잡한 공금망내에서의 항목을 추적하고 있다. 다이아몬드 업계에서는, 광산에서부터 소비자에게 이르기까지의 다이아몬드 위치를 추적한다. 이러한 실험에 사용된 기술은 이미 상용화 되었다. 대체 어플리케이션을 만드는 것은 기존 솔루션을 밀어내기 어려우므로 신중한 접근이 필요하다. 한가지 방법은 엔드유저에게 많은 변화를 요구하지 않으면서 고가, 혹은 매력적인 솔루션을 제공하는 '대체’에 집중하는 것이다. 대체재가 호응을 얻기 위해서는 기존 솔루션보다 뒤쳐지지 않고, 관련 생태계가 흡수하고 채택하기 쉬워야 한다. First Data가 블록체인 기반 기브트 카드를 생각한 것은 이러한 대체재의 훌륭한 예시다. 이 키프트 카드를 소비자들에게 제공하는 소매업체들은 외부 결제 처리 업체에게 의존하지 않고, 블록체인을 사용해 계좌내 통화흐름을 추적하여 거래비용을 낮추고, 보안을 강화한다. 이 새로운 기프트 카드는 공용 거래 장부를 통해 상인들끼리 금액을 이전하거나 거래할 수도 있다. 변화를 만들어낼 어플리케이션을 만들기엔 아직 요원하다. 그러나 가능성을 계산해보고 투자를 하는 것은 시도해봄직 하다. 혁신적인 어플리케이션은 가치 창출과 포착의 논리가 기존 접근방식에서 벗어난 새로운 비즈니스 모델과 결합할 때 가장 강력한 힘을 바루히할 것이다. 이런 비즈니스 모델은 도입하기 어렵지만, 기업의 미래 성장동력이 될 수 있다. 스마트 계약이 실행되도록 하려면 로펌이 어떻게 바뀌어야 할지 고민해보자. 일단 소프트웨어와 블록체인과 관련한 지식을 쌓아야 할 것이다. 시간당 책정되는 보수도 변경되어야 할 것이다. 대신, 거래당 비용을 책정하거나, 계약 주관 수수료를 부과하는 방안이 검토될 수 있다. 어느 방침이든지, 경영자들은 반드시 그 비즈니스 모델이 주는 시사점을 이해하고 충분히 시험해 본다음에 전환을 시도해야 한다. 이러한 혁신적인 시나리오는 가장 마지막에서야 호응이 오겠지만, 이것이 가져오는 가치 또한 엄청날 것이다. 하나는 여권 관리 같은 대규모 공공 신원확인 시스템이고, 또다른 하나는 자금 세탁 방지 및 다수 이해당사자를 필요로 하는 복잡한 금융거래에 사용되는 알고리즘 기반 의사결정 시스템이다. 그러나 이런 적용물이 널리 적용되기 위해서는 적어도 10년이상이 걸릴 것이다. 혁신적인 블록체인 어플리케잇녀은 새로운 생태계를 조율하고 관리하는 플랫폼 레벨의 신규 사업자들을 만들어 낼 것이다. 이들이 차세대 구글이나 페이스북이 될 수도 있다. 다만 이러한 성과를 이루기 위해서는 인내심이 필요하다. 당장에 무언가 눈에 띄는 성과를 이루기는 힘들지만, 이러한 기반 기술을 위해 투자하는 것은 충분히 가치 있는 일이다. 블록체인에게 TCP/IP는 적용사례로서 좋은 본보기가 될 수 있다. TCP/IP가 널리 이용되면서, 디지털 데이터, 통신, 컴퓨터 사용을 기반으로 블록체인 어플리케이션이 구축되고 있다. 그리고 이는 새로운 유즈 케이스가 빠르게 나타날 수 있도록 실험 비용도 절감해 주고 있다. 이러하나 틀에서 봤을때, 경영자들은 당장 블록체인에 대한 조직적 역량을 어디서 부터 쌓아나갸아 하는지 파악할 수 있다. 직원들이 블록체인에 대해 배워야만, 기업에 적합한 어플리케이션을 개발하고 블록체인 기반시설에 투자할 수 있을 것이다. 그러나 이를 이룩하는데 소요되는 시간, 장벽, TCP/IP 수준으로 사용되는데 필요한 절대적인 복잡성을 고려한다면, 경영자들으 블록체인을 시범적으로 운영하는데 따른 여러 위험요소도 고려하라 필요가 있다. 확실히, 작게 시작하는 것이 큰 것을 생각하기 위한 노하우를 만드는데는 중요한 방법이다. 하지만 투자의 수준은 회사의 전후 사정과 업계에 따라 다르다. 금융 서비스 기업들은 이미 블록체인을 도입하고 있지만, 제조업은 그렇지 못하다. 맥락이 어떻건 간에, 블록체인이 당신의 사업에 미칠 가능성은 매우크다. 중요한 것은, 언제냐는 것이다. ¶블록체인은 어떻게 동작하는가? 블록체인 기술의 바탕이 되는 5가지 원리 분산형 데이터베이스: 각각의 노드들은 전체 데이터와 모든 이력에 접근 가능하다. 어느 한명이 이 정보를 모두 제어하지 않는다. 모든 노드들은 중계자가 없이 직접 거래 상대의 기록을 확인할 수 있다. P2P 전송: 중앙 노드를 통하지 않고, peer끼리 통신이 이뤄진다. 각각의 노드가 정보를 저장하고, 다른 모든 노드에 전송한다. 투명성과 익명성: 모든 거래와 그와 연관된 가치는 시스템에 접근할 수 있는 모든 사람들이 열람 가능하다. 블록체인 상에 있는 각각의 노드나 유저들은 신원을 대신하는 30자이상의 string 주소를 갖는다. 사용자 선택에 따라 이를 익명으로 하거나, 공개할 수도 있다. 거래는 이러한 블록체인 주소를 기반으로 이뤄진다. 기록의 불변성: 일단 디비에 거래가 입력되고, 계정이 업데이트 되면 해당 거래는 모두 이전거래와 연결되기 때문에 변경이 불가능하다. (그래서 체인이다) 데이터베이스의 기로이 영구적으로 생성 순서에 따라 기록되고, 네트워크 상의 모든 사람들이 이용할 수 있도록 다양한 컴퓨터 알고리즘과 접근법이 효율적으로 활용된다. (작업 증명과 같은 방식) 컴퓨터 로직: 거래장부가 디지털 특성을 지닌다는 것은 블록체인 거래가 컴퓨터 로직과 연결될 수 있으며, 본질적으로 프로그램 설정이 가능하다는 것이다. (script, 이더리움의 스마트 컨트랙트 와 같은) 따라서 사용자들은 노드 사이에 자동적으로 거래를 실행하는 알고리즘이나 규칙을 설정할 수 있다.","categories":[],"tags":[]},{"title":"탈중앙화된 개인정보-블록체인으로 개인정보 지키는 법","slug":"Decentralizing-Privacy-Using-Blockchain-to-Protect-Personal-Data","date":"2018-06-27T15:00:00.000Z","updated":"2018-06-28T01:57:52.000Z","comments":true,"path":"2018/06/28/Decentralizing-Privacy-Using-Blockchain-to-Protect-Personal-Data/","link":"","permalink":"https://www.yceffort.kr/2018/06/28/Decentralizing-Privacy-Using-Blockchain-to-Protect-Personal-Data/","excerpt":"Decentralizing Privacy: Using Blockchain to Protect Personal Data 원문 전세계에서 유통되고 있는 데이터의 총량이 급속도로 증가하고 있다. 최근 조사에 따르면, 지난 2년간 대략 전체 데이터의 20%가 생성되었다는 사실이 밝혀졌다. 세계에서 가장 큰 소셜네트워크 서비스인 페이스북의 경우 개인정보로만 300 페타 바이트를 수집하였는데, 이는 미국의회 도서관이 200년에 걸쳐 수집한 장서의 양보다 100배 더 많은 수치다. 빅데이터 시대에서, 데이터는 지속적으로 수집되고 분석되며,","text":"Decentralizing Privacy: Using Blockchain to Protect Personal Data 원문 전세계에서 유통되고 있는 데이터의 총량이 급속도로 증가하고 있다. 최근 조사에 따르면, 지난 2년간 대략 전체 데이터의 20%가 생성되었다는 사실이 밝혀졌다. 세계에서 가장 큰 소셜네트워크 서비스인 페이스북의 경우 개인정보로만 300 페타 바이트를 수집하였는데, 이는 미국의회 도서관이 200년에 걸쳐 수집한 장서의 양보다 100배 더 많은 수치다. 빅데이터 시대에서, 데이터는 지속적으로 수집되고 분석되며, 이는 혁신과 경제발전을 이룩하는 원동력이 되고 있다. 많은 기업과 단체는 개인화된 서비스를 제공하거나, 중요한 결정을 내리거나, 미래 트렌드를 예측하기 위하여 데이터를 수집한다. 데이터 위주의 사회가 주는 이익이 커지는 반면,개인정보에 대한 우려도 자라나고 있다. 공공 및 민간등 중앙 집중화된 조직에서 많은 양의 개인 및 민감한 정보를 축적하고 있다. 개인은 자신에 대해 저장된 데이터와 그 사용 방법을 거의 제어하지 못한다. 최근 몇 년간 사생활 침해와 관련된 사건이 반복적으로 대두되었다. 페이스북이 참가자들에 대해 명시적으로 알리지 않고 수행한 대규모 실험이 이 중 가장 큰 이슈로 대두되기도 했다. 참고기사 이 논문에서는 블록체인과 비블록체인 스토리지를 결합하여 개인정보보호에 초점을 맞춘 개인 데이터 관리 플랫폼을 구축한다. 그리고 블록체인이 어떻게 신뢰할 수 있는 컴퓨팅 하에서 중요한 자원이 될 수 있는지를 소개한다. 그리고 이 시스템 하에서는 다음과 같은 일반적인 사생활 보호 문제를 방지한다. 데이터 소유권: 사용자는 자신의 데이터에 대한 소유권과 제어권이 있어야 한다. 이 시스템에서는, 사용자는 데이터의 소유자로, 서비스는 허가 받은 게스트로 인식되어야 한다. 데이터 투명성과 감사가능성: 각 사용자는 수집되는 데이터와 액세스 방법에 대해 완전한 투명성을 가지고 있다. 세분화된 접근 제어: 모바일 어플리케이션의 주요 이슈중 하나는 사용자가 가입시 일련의 권한을 부여 해야 한다는 것이다. 이러한 권한은 무기한을 주어지며, 이를 변경하는 방법은 '선택옵션’을 선택하는 것이다. 이 대신, 이 프레임워크 내에서 사용자는 자신이 원하는 아무 때나 자신의 권한을 변경하고 수집된 데이터에 대한 액세스를 취소할 수 있다. 이러한 메커니즘을 적용하면, 모바일 어플리케이션의 기존의 권한 수집 대화상자를 더욱 향상시키고 있다. 사용자 인터페이스는 기존대로 유지하고, 개인정보 액세스 제어 정책은 사용자만 변경할 수 있는 블록체인에 안전하게 저장한다. User: 모바일 어플리케이션을 다운로드 받고 이용하는 사용자 Service: 개인정보를 수집하는 어플리케이션을 제공하는 업체 Node: 인센티브를 대가로 블록체인을 유지하고 개인 Key/Value 값을 분산시켜 저장하는 주체 사용자는 일반적으로 익명으로 남아있지만, 블록체인에 서비스 프로필을 저장하고 신원을 확인할 수 있다. 블록체인은 두가지 타입의 트랜잭션을 받아드린다. $$T_{access}$$: 권한 제어 관리 $$T_{data}$$: 데이터 수집과 회수 이 프레임워크는 기존에 존재하는 모바일 소프트웨어와 쉽게 연동되기 위해 SDK형태로 배포되어야 한다. 다음과 같은 상황을 가정해 보자. 사용자가 자신의 개인정보를 보호하기 위해 해당 어플리케이션을 설치했다. 처음 가입을 하게 되면, 유저의 권한과 함께 새로운 신원정보가 생성되어 $$T_{transaction}$$ 내에 포함되어 블록체인으로 보내진다. 스마트폰에서 수집된 데이터 (위치정보 등)은 암호화키로 암호화되고 $$T_{data}$$ 내에 포함되어 블록체인으로 보내진다. 이 트랜잭션은 이후, 공개원장에 대한 포인터만 유지하면서 비블록체인 Key-Value 스토리지 저장소로 라우팅 된다. (포인터는 데이터의 SHA256 해쉬값이다.) 서비스와 사용자 $$T_{data}$$와 포인터를 사용하여 데이터를 요청할 수 있다. 블록체인은 사용자 또는 서비스의 디지털 서명으로 해당 내용을 검증한다. 서비스의 경우에는, 이에 대한 권한도 함께 확인하게 된다. 사용자는 새로운 일련의 권한을 $$T_{access}$$ 과 함께 발급하여 언제든 개인정보 제한 권한을 변경하거나, 이전에 제공한 정보를 폐기 할 수 있다. 사용자의 데이터와 권한을 변경할 수 있는 웹이나 모바일 기반의 대시보드를 개발하는 것은 매우 쉽고, 이는 비트코인의 코인베이스와 같은 중앙 집중형 지갑을 개발하는 것과 유사하다. 이러한 비블록체인 KeyValue 저장소로는 분산형 해쉬 테이블인 Kademilia (참고논문)에 persistence를 위해 LevelDB 추가해 구현하였다. Distributed Hash Table(이하 DHT)는 승인된 읽기/쓰기 트랜잭션을 수행하는 노드네트워크(블록체인으로 네트워크로 부터 분리될 수 있음)에 의해 유지 된다. 고가용성을 보장하기 위해 데이터가 노드 전체에서 충분히 임의로 추출되고 복제된다. 스토리지에 대해 비블록체인 솔루션을 고려할 수 있다는 점을 유의하자. 예를 들어, 데이터를 저장하는데 중앙 집중형 클라우드가 사용될 수도 있다. 이를 위해서는 타사에 대한 신뢰가 필요하지만, 어느정도 확장성과 구축 용이성에서 이점을 얻을 수도 있다. 개인 정보를 비롯한 민감한 데이터는 공격과 오남용에 취약한 제3자의 손에서 관리되면 안된다. 그대신, 사용자들은 보안을 위협받거나 회사나 관리당국의 개인화된 서비스를 제공할 수 있는 능력을 손상시키지 않는 범위 내에서 자신의 정보를 관리하고 소유할 수 있어야 한다. 이 플랫폼은 블록체인을 액세스 제어 중재자로 사용하는 블록체인과, 비블록체인 스토리지 솔루션을 결합하여 이러한 기능을 제공하였다. 또한 이런 분산 플랫폼을 통해 데이터 수집, 저장 및 공유하는 것에 대한 법적 혹은 규제적인 결정을 내리는 것이 더욱 간결해 져야 한다. 또한 법이나 규제등을 블록체인 그 자체에 프로그래밍하여 자동으로 시행할 수 있다. 원장은 위조가 불가능하기 때문에 데이터에 액세스 하기 위한 법적인 증거로도 사용할 수 있다.","categories":[],"tags":[]},{"title":"트렌드, 팁, 통행료 - 비트코인 수수료에 대한 종단연구","slug":"Trends-Tips-Tolls-A-Longitudinal-Study-of-Bitcoin-Transaction-Fees","date":"2018-06-27T15:00:00.000Z","updated":"2018-06-28T01:57:52.000Z","comments":true,"path":"2018/06/28/Trends-Tips-Tolls-A-Longitudinal-Study-of-Bitcoin-Transaction-Fees/","link":"","permalink":"https://www.yceffort.kr/2018/06/28/Trends-Tips-Tolls-A-Longitudinal-Study-of-Bitcoin-Transaction-Fees/","excerpt":"Trends, Tips, Tolls: A Longitudinal Study of Bitcoin Transaction Fees 원문 거래 수수료는 암호화폐 시스템 일관성을 유지하는 분산 합의 메커지즘에 기여한 마이너에게 주는 보상으로, 점차적으로 블록에 대한 보상을 대체하도록 설계되어 있다. 장기적인 거래 수수료가 불확실한 상황에서 시스템 전체의 보안과 지속 가능성을 고려 해보았을 때 여전히 이문제가 비트코인 생태계에 어떻게 작용될지 물음표로 남아 있다. 몇몇 사람들은 높은 수수료가 비트코인의 소액지불 시스템을 비경제적으로 만들","text":"Trends, Tips, Tolls: A Longitudinal Study of Bitcoin Transaction Fees 원문 거래 수수료는 암호화폐 시스템 일관성을 유지하는 분산 합의 메커지즘에 기여한 마이너에게 주는 보상으로, 점차적으로 블록에 대한 보상을 대체하도록 설계되어 있다. 장기적인 거래 수수료가 불확실한 상황에서 시스템 전체의 보안과 지속 가능성을 고려 해보았을 때 여전히 이문제가 비트코인 생태계에 어떻게 작용될지 물음표로 남아 있다. 몇몇 사람들은 높은 수수료가 비트코인의 소액지불 시스템을 비경제적으로 만들 것이라고 추측하기도 하였다. 예상되는 다른 시나리오에는 사용자간의 시간 선호도에 따라 (거래를 얼마나 빨리 검증할 것인지) 지불되는 수수료의 방대한 변화, 또는 블록체인외에 다른 보상체계가 설계되는지 등이 있다. 미래를 예측하는 것은 프로토콜의 속성 뿐만 아니라 참여자들의 행동, 비트코인의 생태계에 따라 달려 있기 때문에 예측하기가 어렵다. 이를 위해 과거 2014년 8월 말부터 현재까지 퍼블릭 블록체인에 기록된 4천만건의 거래로 지불된 거래 수수료를 분석하여, 종단연구를 수행하였다. 이 짧은 역사에서, 거래수수료를 지불하는 것과 관련된 몇가지 변화가 있었다. 이러한 변화를 설명하고, 비트코인 커뮤니티에서 전통적으로 믿고 있는 몇가지 가설을 시험할 수 있는 증거를 추출하고자 한다. ¶트렌드: 거래 수수료 검정선은 블록당 거래 수수료를 나타내고 있다. 2013년 까지 증가하다가 그 이후로 감소하는 추세를 보이고 있다. 파랑선은 거래금액(비율)에 따른 수수료를 보여주고 있다. 전체적으로, 비트코인 거래 수수료는 전체 거래금액의 0.1% 이하의 수준에 서 형성되고 있으며, 이는 이러한 수수료가 두 개 이상의 비트코인 거래에 포함된다는 사실에 비추어 보았을 때 기존의 지불 시스템이 부과하는 수수료보다 훨씬 낮다는 것을 알 수 있다. 빨간선은 평균 블록크기를 나타내고 있다. 평균 블록크기는 꾸준히 증가하고 있는 것으로 보인다. 블록의 크기가 서서히 한계에 근접할 때 까지 커지고 있지만, 아직 까지는 거래수수료에 영향을 미치지 않는 것으로 보인다. 블록당 총 거래수수료를 달러당 비트코인 환율과 비교할 때 상당히 같은 추세로 이동하고 있는 것을 볼 수 있다. 이는 비트코인으로 결제되지만 기존통화로 가치가 고정되는 많은 상품과 서비스 가격 과는 달리, 수수료를 결정할 때는 비트코인이 지배적인 역할을 하고 있는 것으로 보인다. 대략 블록당 45달러 선에서 안정세를 가지고 있는 것으로 보인다. 주: 2014년 초 블록당 거래수수료는 약 0.07BTC였는데, 2018년 들어서 9.65 BTC까지 치솟았다가 현재는 0.23 BTC내에서 형성되고 있다. 지난 2년간 거래 수수료의 변화량의 변동폭이 매우 극심했다. 참조 다음으로는 명목상 수수료의 가치 변화를 살펴본다. 위 그림은 시간 경과에 다른 거래당 지불되는 수수료의 추세를 보여준다. 2011년 1월 부터는 거의 어떠한 거래도 수수료를 지불하지 않았다. 2011년 6월 이후에 0.0005 비트코인을 받는 수수료가 등장하고, 이는 곧 전체 거래의 20~30%를 차지한다. 2012년 2분기에 제로 수수료의 거래는 감소하고, 60~70%의 거래는 약 0.0005 비트코인의 수수료를 지불한다. 2014년을 기준으로 보았을때, 가장 많은 거래수수료는 0.0001 BTC다. 이러한 추세는 정적이 아니라 시간이 지남에 따라 뚜렷한 추세를 가지고 있음을 보여준다. 이러한 변화에 대해서 추론하기 위해서는, 비트코인 생태계에서 일어난 주요 사건들을 알아 둘필요가 있다. 2011년 6월에 Bitcoin Core 클라이언트 버전 0.3.23이 릴리즈 되었는데, 이는 기본 거래 수수료를 0.01 비트코인에서 0.0005 비트코인으로 줄이는 계기가 되었다. 2012년 2/4분기에 거래 수수료가 증가한 것은 도박 사이트 SatoshiDice (참조)의 등장 때문일 것이다. 이 서비스가 4월에 출시된 이후에 이 도박 서비스는 급속도로 인기를 끌기 시작헀다. 이는 블록체인에 거래가 넘쳐나게 만들었으며, 이는 '비트코인 네트워크에 대한 DDoS공격’과 같은 양상을 띄었다. 2013년초 명목수수료가 0.0005 비트코인 떨어진 것과 직접적인 연관이 있는 사건은 찾지 못했지만, SatoshiDice에서 추정 가능한 이유를 발견했다. 이 전에는 SatoshiDice는 각 지불에 0.0005 비트코인을 거래 수수료로 추가헀다. 그런다음 2012년 4/4분기에 거래수수료를 두배로 늘렸고, (0.001 비트코인) 다른 모든 사람들은 여전히 기본적인 거래수수료 0.0005 비트코인을 지불했다. 2013년 5월, 비트코인 코어 0.8.2가 출시되면서 기본 거래 수수료를 0.0005 BTC/kb에서 0.0001 BTC/kb 로 낮추었다. 그러므로 0.0001 비트코인 수수료의 점유율 증가는 사람들이 해당 클라이언트의 새버전을 채택했는지 여부를 확인할 수 있게 해준다. ¶팁: 수수료 지급에 대한 설명 지금 이 와중에도 거래수수료를 전혀 지불하지 않는 거래가 소수 존재한다. 수수료를 지불하지 않는 많은 사람들은 채무불이행 상태를 고수하지만, 일부는 더 넢은 수수료를 기꺼이 지불하려고 한다. 이에 대한 합리적인 추론 중 하나는 수수료를 지불하면 마이너가 거래 우선순위를 정하는 인센티브를 제공하여 보다 빠른 확인을 이끌어 낼 수 있다는 것이다. 이것이 사실이라면 인내심 없는 사용자들은 거래수수료를 지불할 의향이 있을 것이다. (예를 들어, 거래출력으로 포함된 비트코인을 바로 다시 사용하려 할 경우.) 위 표는 서로 다른 수수료에 대한 거래 대기 시간을 보여준다. 수수료가 없는 거래는 첫번째 확인을 위해 대략 20분이상을 기다려야 했다. 이와 대조적으로, 0.0005 비트코인을 지불하면 절반 시간 내에 블록에 포함될 수 있다. 하지만 극단적인 경우에는 더 차이가 컸다. 제로 수수료 거래 중 10%는 확인하는데만 4시간이 걸렸으며, 0.0005 비트코인을 지불할 경우는 최대 40분까지만 걸렸다. 0.0005 와 0.001 간의 차이는 크지 않지만, 중간값에서의 차이는 여전히 통계적으로나 경제적으로도 중요하다. 위 그림은 보유 시간에 따라 달라지는 수수료를 포함하는 거래 금액을 보여준다. 블록에 포함된 직후에 출력을 사용하는 거래의 경우, 수수료를 포함한 거래의 비율이 더 높다는 것을 알 수 있다. (블록은 10분 마다 생성되므로) 이로 알 수 있는 또다른 사실은, 동일한 블록에서 출력을 재사용하는 트랜잭션의 양이 약 40%를 넘는 다는 것이다. ¶통행료: 문지기 역할을 하는 마이닝 풀 마지막으로, 제로 수수료 거래를 체계적으로 배제하는 마이닝 풀의 동작을 분석한다. 위 그림은 시간의 흐름에 따란 각 마이닝 풀의 블록 솔루션 점유율을 보여준다. 2013년 BTC Guild는 40%에 가까운 점유율을 보였는데, 이는 2014년 GHash.IO와 동일한 크기다. 이 짧은 시간 동안 거의 50%의 점유율에 육박했을때, 논란의 여지가 있기도 했었다. 2014년에는 이외에 다른 마이닝 풀의 점유율이 증가했다. 이전에 인기있었던 마이닝풀 (Slush, 50BTC 등)의 인기가 시들해졌다. 이러한 이유에는 아마도 마이닝 풀 수수료 같은 경제적이거나 기술적인 요인,서비스 가용성, 혹은 공격에 대한 방어 등이 있었을 것이다. 몇 개의 지배적인 마이닝 풀이 지배적인 위치에 있다는 것을 감안한다면, 왜 일부 마이닝 풀이 체계적으로 수수료를 강요하는지 알 수 있다. 위 표에서는 가장 큰 10개의 마이닝풀의 제로 수수료 거래와 그렇지 않은 거래의 점유율을 보여주고 있다. Discus Fish와 Eligius의 경우 각각 30.6%, 62.5% 비율로 거래 수수료가 있는 블록을 선호한다는 것을 볼수 있는데, 이는 평균 14.4%와 비교했을 때 굉장히 큰 수치다. 그러나 이 두 마이닝 풀 이외에는 딱히 거래수수료가 있는 블록을 선호한다는 증거를 찾을 수 없다. Discus Fish와 Eliguis에서 제로 수수료 거래가 없는 블록이 많은 이유는 이러한 블록들은 트랜잭션을 가지고 있지 않기 때문이다. 빈 블록은 2014년 을 기준으로 117개중 한번 꼴로 나타나고 있다. 이를 제어하기 위해, 이러한 블록내의 거래 중앙 값을 알 필요가 있다. Eliguis의 경우, 거래의 중앙값은 75이고, Discus Fish는 233개 이다. 따라서, 제로 수수료가 없는 블록들은 완전히 비어있지 않다. 이 두 마이닝 풀은 블록에서 거래 수수료를 부과한는데 더 엄격한 자세를 취하고 있음을 알 수 있다. 주: 위와 같은 순위는 2014년 기준이고, 2018년 현재 마이닝 풀의 점유율에는 많은 변화가 있었다. 참고 ¶결론 시간이 지남에 따라 거래 수수료의 이질성과 불안정성은 곧, 시장 메커니즘이 거래 수수료에 대한 공정한 가격을 설정하지 못한다는 것으로 해석할 수 있다. 이는 블록 보상이 마이닝의 수입의 대부분을 차지하고, 그 시스템을 방어하기 위한 적절한 동기를 제공하는 한 받아 드릴 수 있는 수준의 불안정성으로 보인다. 그러나 거래수수료만 남게 될 비트코인의 미래에는 두가지 질문이 남아 있다. 공정한 거래 수수료 수준을 형성하는데 영향을 미치는 것은 무엇인가? 이 적정 수준의 수수료를 대략이라도 찾기 위해 실행할 수 있는 메커니즘은 무엇인가? 비용은 시스템내에서 두가지 형태로 발생한다. 마이너들은 최초 확인을 위해 작업 증명 퍼즐을 해결하는 비용을 부담한다. 이 비용은 일회적이고 블록당 고정되어 있으므로, 동시에 확인을 원하는 거래의 숫자에 따라 다르다. 네트워크의 릴레이 (전체 블록체인을 저장하는 모든 클라이언트)가 거래기록을 저장하는 비용. 현재 규칙은 그것을 영원히 저장하는 것이지만, 이론적으로는 거래가 완전히 소비된 이후에는 폐기 될 수 있다. 이 비용은 시간이 지남에 따라 트랜잭션의 크기에 따라 발생하며 (저장 공간) 모든 출력이 소비될때까지의 시간 및 네트워크의 크기 (몇개의 사본이 있어야 하는지)에 따라 달라진다. 1의 비용은 마이너들에 의해 내재화 될 수 있다고 생각 할 수 있다. 그러나 두 번째와 같이 내재화 되지 않는 공공재의 비용 (스토리지를 저장하는데 소모되는 비용)이 무임승차 비용으로 남아 있는 문제가 있다. 두 번째 비용을 유발하는 세가지 요소 중 두 가지 (마이닝 풀에게 유의미한 수수료는? 빠르게 처리되기 위한 적장한 수수료는?)는 트랜잭션이 생성될 때 예측 할 수 없다. 수 많은 트랜잭션에 대해 평균값을 찾는 것은 이에 대한 해답이 아니다. 이는 체리 피킹과 같은 문제를 야기할 것이다. 거래 수수료 위주의 체제에서는, 높은 트랜잭션에 대한 수요와 시간의 선호도가 높은 사람들이, 비트코인이라는 자산을 가지고 아무런 행동을 취하지 않는 사람들에게 보조금을 주는 모양새가 될 수 있다. 이러한 배경에서 보았을 때, 인플레이션을 바탕으로 화폐가치를 평가절하를 유도하는 것이 거래에 수수료를 매기는 것 보다 더 최적의 매커니즘을 보인다.","categories":[],"tags":[]},{"title":"블록보상이 없어질 경우 발생하는 비트코인의 불안정성","slug":"Instability-of-Bitcoin-Without-the-Block-Reward","date":"2018-06-26T15:00:00.000Z","updated":"2018-06-27T00:51:37.000Z","comments":true,"path":"2018/06/27/Instability-of-Bitcoin-Without-the-Block-Reward/","link":"","permalink":"https://www.yceffort.kr/2018/06/27/Instability-of-Bitcoin-Without-the-Block-Reward/","excerpt":"On the Instability of Bitcoin Without the Block Reward 원문 비트코인 컨센서스 프로토콜의 보안은 채굴자들이 모두 정직하게 행동한다는 것에 의존한다. 그리고 그들은 합리적으로 이성적으로 행동한다는 주체라는 가정하에 채굴 수입을 받을 수 있도록 설계되어 있다. 따라서 이러한 기본적인 행동을 이탈하는 채굴자의 행위는 비트코인 보안에 심각한 위협이 된다. 채굴자는 두 가지 유형의 수입, 블록 발견 보상과 거래 수수료를 받게 된다. 블록 보상은 시스템 초기에 채굴자 보상의 대부분을 차지하지만,","text":"On the Instability of Bitcoin Without the Block Reward 원문 비트코인 컨센서스 프로토콜의 보안은 채굴자들이 모두 정직하게 행동한다는 것에 의존한다. 그리고 그들은 합리적으로 이성적으로 행동한다는 주체라는 가정하에 채굴 수입을 받을 수 있도록 설계되어 있다. 따라서 이러한 기본적인 행동을 이탈하는 채굴자의 행위는 비트코인 보안에 심각한 위협이 된다. 채굴자는 두 가지 유형의 수입, 블록 발견 보상과 거래 수수료를 받게 된다. 블록 보상은 시스템 초기에 채굴자 보상의 대부분을 차지하지만, 블록보상이 점차 감소함에 따라, 채굴자의 수익은 거래 수수료로 전환 될 것으로 보인다. (4년에 한번 이 보상은 절반으로 감소한다.) 채굴자들이 각 블록에서 25개의 비트코인을 보상으로 받던지, 거래 수수료로 25개의 비트코인을 받던지는 블록체인의 보상에 별다른 영향이 없다는 것이 일반적인 생각이다. 블록 상태에 따른 채굴자가 취할 수 있는 두 가지 양상 합리적이고 이기적인 채굴자를 가정해보자. 그리고 고정된 블록 보상이 다 떨어져, 기하급수적으로 분산된 보상 블록이 있는 블록체인이 존재한고 상상해보자. 여기서는 위 그림 처럼, 채굴자가 선택할 수 있는 두 가지 옵션이 있다. 적어도 더 많은 트랜잭션이 도착할 때 까지 가장 긴 블록체인을 연장하여 5의 보상을 받고, 다음 채굴자를 위해 0의 보상을 남겨둔다. 가장 긴 블록체인을 연장하는 대신, 이를 포킹하여 50개의 비트코인은 남긴채 나머지 55개를 자신의 보상으로 가져간다. 비트코인 프로토콜은 1번 옵션을 따르 도록 지시하지만, 2번의 옵션이 더 채굴자에게 매력적인 선택지로 보이게 된다. 이에 대해 정확히 추론하기 위해서는, 다른 채굴자들이 어떤 전략을 선택할지도 고려해야 한다. 만약 다른 모든 채굴자들이 경험적인 방법에 따라, 네트워크 지연 없이 기존 행동을 고수할 경우 포킹하는 전략은 효과가 없고 명확하게 다른 모든 채굴자들은 옵션 1을 선택하게 될 것이다. 반면에, 블록 보상이 없는 시스템 하에서 다른 모든 채굴자들이 합리적이라면 이전 블록 대신 포킹을 하기로 선택할 것이고, 옵션2를 통해서 더 많은 이익을 취하게 될 것이다. 고정된 블록 보상이 사라지게 되면, 블록보상에 집착하는 대신, 합리적인 채굴자들은 거래수수료를 통해 자신의 이득을 극대화 하려 할 것이다. 이는 곧 정직한 블록을 만들어 현격히 감소한 블록 보상을 받는 것 보다 마구잡이로 포킹하여 이득을 취하는 것이 더 효율적이라는 의미가 된다. 이는 블록 보상이 고정되지 않았을 때 발생하는 새로운 인센티브 문제를 나타낸다. 이는 블록 보상이 채굴자 입장에서 무시할 수 있는 정도로 감소하고, 거래수수료가 채굴보상을 지배하는 상태에서 비트코인의 안정성에 대한 잠재적인 영향을 이해할 필요가 있다. 이러한 예는 블록 보상이 고정 값으로 존재하지 않을 때 일어나는 새로운 인센티브 문제다. 블록 보상이 무시할 수 있는 수준으로 줄어들고, 거래수수료만 존재하는 비트코인 시스템 내에서는, 안정성에 영향을 받을 수 있다. 이는 거래 수수료가 불규칙하기 때문이 아니라, 거래 슈슈료가 시간에 따라 변하는 특성으로 인해 전략적으로 다양한 접근을 할 수 있는 편차가 발생하기 때문이다. 이는 마이닝 풀의 참여자들이 실시간으로 자신의 보상을 극대화 할 수 있는 마이닝 풀로 'hopping’하는 pool hopping 처럼 참고, 채굴자들이 더 많은 거래 수수료를 제공하는 암호화폐로 'hopping’하는 사례가 발생할 수도 있다. 이러한 불량 채굴전략이 시작되면, 비트코인의 보안에 미치는 영향은 심각할 것이다. 블록체인은 포킹으로 인해 오래된 블록이 고립된 블록이 상당부분을 차지하여 51%공격을 쉽게 하고, 거래 확인 시간이 늘어날 수도 있다. 최악의 경우, 블록 보류 또는 점점 더 공격적인 undercutting으로 합의 프로토콜 전체가 깨져 버릴 수도 있다. 이는 암호화폐 설계에서 블록보상의 근본적인 재고를 하게 만든다. 나카모토는 중앙이 없는 상태에서 비트코인의 초기 할당을 위해, 블록 보상이 필요하지만 이를 일시적인 악으로 보고, 거래 수수료 제도를 이상향으로 보고 있다. 그러나 이는 거래수수료 내에서 채굴자들의 행동을 인센티브 화 하는 것이 블록 보상 제도 보다 더욱 힘든 일이라는 것을 보여준다. 아마도, 이러한 인플레이션의 불가피함을 인지하고 블록 보상을 영구적으로 만들어야 할지도 모른다. 거래 수수료는 마이너들이 자신의 블록에 거래를 포함시키기 위한 동기로 존재할 것이다. ¶결론 블록 규모에 대한 논쟁에서, 블록체인 상에서의 공간은 희소한 자원이며, 사용자들이 충분히 많은 거래 수수료를 지불함으로써 거래 확인을 가속화 시킬 수 있는 시장이 나타날 것이라고 주장한다. 하지만 만약 채굴자들이 블록을 해결할때 의도적으로 ‘비트코인을 남겨두고 오는 경우’ (Undercutting Attack)에는 이러한 가정을 깨트린다. 이는 채굴자들이 채굴자들이 거래 수수료를 최대화할 필요가 없고, 높은 수수료로 거래 우선순의를 정할 이유가 없기 때문이다. 다시 말하면, 블록의 거래 규모에 제약이 가해지고, 이와 같은 undercut을 당할 경우 총 수수료에 또다른 제약이 생기게 된다. 이는 복잡한 방식으로 상호작용하게 된다. 사카시 나카모토는 그의 비트코인 백서에서 아래와 같이 언급했다. 채굴자들을 위한 유인책은 채굴 뿐만 아니라 거래수수료가 될수도 있다. … 사전에 결정된 수 만큼의 화폐가 유통되면, 인센티브는 전적으로 거래수수료로 전환되어, 완전히 인플레이션으로 부터 자유로울 수 있습니다. 이 논문에서는 블록 보상이 채굴의 안정성을 위해 필수적이라고 본다. 최소한의 거래수수료로 체제에서 평행을 유지하는 것은 블록 보상 체계보다 극도로 어려워보이는데, 이 자체만으로 문제가 될 수도 있다. 이더리움이 하는 것처럼, 블록 보상을 영구적으로 유지함으로써 발생하는 통화 인플레이션은, 암호화폐의 안정성을 유지하기 위해 지불하는 작은 대가일 수도 있다. 현재 비트코인의 블록 보상을 보려면 여기를 참고하세요 =)","categories":[],"tags":[]},{"title":"블록체인 백서","slug":"blockchain-white-paper","date":"2018-06-26T15:00:00.000Z","updated":"2018-06-26T16:37:44.000Z","comments":true,"path":"2018/06/27/blockchain-white-paper/","link":"","permalink":"https://www.yceffort.kr/2018/06/27/blockchain-white-paper/","excerpt":"The future is Decentralized: Blockchain White Paper 원문출처 블록체인은 손상되거나, 오염된 시스템에 투명성을 부여하고 상용 프로세스에 검증가능성과 불변성을 가져올 수 있다. 취약한 인프라에 보안과 유연함을 제공하고, 자율성을 보장하면서 개인의 사생활을 보장하며 협력과 신뢰를 장려하고 신뢰가 필요한 곳에서 신뢰를 얻을 수 있다. ¶블록체인은 무엇인가? 일반적인 데이터베이스, 스프레드시트, 원장은 사용자 및 객체 간의 상호작용에 대한 정보를 저장한다. 신용카드 거래부터 금융 거래에 이르기까","text":"The future is Decentralized: Blockchain White Paper 원문출처 블록체인은 손상되거나, 오염된 시스템에 투명성을 부여하고 상용 프로세스에 검증가능성과 불변성을 가져올 수 있다. 취약한 인프라에 보안과 유연함을 제공하고, 자율성을 보장하면서 개인의 사생활을 보장하며 협력과 신뢰를 장려하고 신뢰가 필요한 곳에서 신뢰를 얻을 수 있다. ¶블록체인은 무엇인가? 일반적인 데이터베이스, 스프레드시트, 원장은 사용자 및 객체 간의 상호작용에 대한 정보를 저장한다. 신용카드 거래부터 금융 거래에 이르기까지 대부분의 정보는 이러한 유형의 시스템에 저장한다. 그러나 이러한 유형의 시스템은 중앙 집중화되어 상당한 약점을 가지고 있다. 중앙 집중화는 불투명하고, 허가받지 않은 액세스나 배포에 취약하다. 또한 그것은 ‘마스터’ 원본 이기 때문에, 돌이킬 수 없는 변경이나 삭제에 취약하다. 블록체인 또한 정보를 저장한다. 그러나, 기존 시스템과는 아래와 같은 차이점이 있다. 정보를 블록에 나누고 봉인하여 저장한다. 블록체인을 활용하는 비트코인을 예로 들면, 10분 마다 생성하는 단일 블록에 네트워크에서 발생하는 모든 트랜잭션을 저장한다. 각각의 블록은 이전 블록에 연결하여 체인을 형성한다. 블록체인은 중앙에 저장되지 않는다. 그 대신, 각각의 블록은 분산원장 기술을 활용하여 복사되어 전체 네트워크 참가자에게 전파된다. (블록체인과 분산원장이라는 용어는 종종 상호 교환가능한 형태로 쓰여진다. 좀 더 정확히 얘이야기 하면, 블록체인 기술은 분산원장 기술을 사용하는 경향이 있다.) 누군가 새로운 블록을 체인에 연결할 때 마다, 동시에 모든 이들에게 이 사본이 함께 더해진다. 누군가 트랜잭션을 요청한다. 요청된 트랜잭션은 P2P 네트워크에 참가하고 있는 모든 노드들에게 전파된다. 검증: 네트워크 노드들은 트랜잭션과 사용자의 상태를 사전에 합의된 알고리즘으로 검증한다. 검증된 트랜잭션은 암호화폐, 스마트 계약, 기록 등 다양한 정보를 포함할 수 있다. 검증된 트랜잭션은 다른 검증된 트랜잭션들과 함께 합쳐져 원장을 위한 새로운 블록으로 만들어 진다. 새로 생성된 블록은 기존 블록체인에 추가된다. 이는 영구적이며 불변이다. 트랜잭션이 완료된다. ¶블록체인이 가져다 주는 이점 불변성: 여러 사본의 블록체인이 합의를 통해서 P2P 네트워크에 보관되고 관리되기 때문에, 누구든 과거 트랜잭션을 변경할 수 없다. 보안: 만들기는 쉽지만 풀기는 어려운 것이 기초적인 암호의 원칙이다. 컴퓨터 네트워크 상에서 생성된 암호화는, 더 큰 네트워크에서도 이를 풀어내기 어렵다. 검증가능성: 투명성과 불변성이 함께 공존하게 되면, 이는 곧 모두가 검증가능하다는 것을 의미한다. 블록체인에 있는 누구나 시스템의 룰을 검증하고 확인할 수 있다. 디지털 화폐의 경우, 해당 화폐가 단 한번 쓰였는지를 스스로 확인할 수 있다는 것을 의미한다. 정보를 조작하는 것은 불가능하지만, 네트워크와 크기를 활용하여 쉽게 검증가능하다. 복원력: 분산화된 원장의 성격중 하나는 복원성이 있다는 것이다. 많은 노드가 오프라인이 되어도, 여전히 정보에 대해서 액세스 가능하다. 투명성: 모든 거래가 전파된다는 사실은, 모든 노드들이 원장을 투명하게 만든 다는 것을 의미한다. 암호화된 트랜잭션은 사생활 또한 보장해 줄 수 있다. 이러한 이 점은 개인정보보호, 책임성 및 투명성과 같은 문제가 엄격하게 관리될 수 있도록, 특정기능에 맞게 조정되거나 변형 될 수 있다. 예를 들어 토지 등록은 모든 사람들에게 보편적으로 공개되어야 한다. 반면 정부 자금의 분배와 사용은 모든 사람들이 사용할 수 있는 민감한 세부사항이 없이 공개될 필요가 있다. 이와 비슷하게 개인은 은행, 호텔, 항공사 또는 의사와 함께 상대방이 알지 못하는 상태에서 자신의 신원을 확인하고 싶어할 수도 있다. 이러한 점을 고려했을때, 블록 체인 기술은 매우 뛰어난 시스템으로 간주된다. 하지만 이러한 이점이 어떤 식으로 결합되는지를 고민했을때 기술의 진정한 변화 가능성이 드러나게 된다. ¶신뢰가 필요없는 협업 분산화되고, 투명하고, 검증가능한 시스템의 성격은 더이상 신뢰를 문제 삼을 필요가 없기 때문에 다른 사람들과 기관을 신뢰할 수 있다는 뜻이 된다. 모든 참여자들의 시스템, 그리고 모든 트랜잭션의 무결성은 네트워크에 의해 뒷받침 된다. 신뢰할 수 없는 프로토콜에서 분산, 복원력, 투명성, 불변성들의 조합은 이 기술이 왜 금융및 자산관리에서 부터 개발이나 원조에 이르기까지 많은 사례에 걸쳐 유망한지를 나타내는 단적인 이유다. ¶블록체인이 마법지팡이는 아니다 블록체인을 활용한 많은 어플리케이션과 이점에도 불구하고, 블록체인은 여전히 실험적이고 진화하는 기술임을 기억해야 한다. 잠재력을 가지고 있지만, 완벽하지도, 보편적으로 사용될 수도 없다. 블록체인의 이러한 특성은 현재 컴퓨팅, 스토리지, 보안 및 세부 조정 측면에서 상당한 비용이 수반된다. 따라서 주어진 환경에 따라 무엇이 가장 효율적인 해결책인지 이해하고, 종종 이러한 해결책이 블록체인이나 분산 원장이 아니라는 것을 인정해야 한다. ¶어떤 사람들이 블록체인을 사용하는가 블록체인은 비트코인과 같은 디지털 통화를 뒷받침 하는 것으로 잘알려져 있지만, 많은 사람들이 더 광범위한 범위에서 블록체인을 사용하기 시작했다. 블록체인의 불변성을 활용하여 공증 문서를 제공하거나, 디지털 예술작품 라이센스를 발급 하고 양도하는데 사용하기도 한다. 금융 분야에서, 블록체인은 기존 인프라를 간소화하거나 증권 거래 정산 등을 더 빠르게 할 수 있다. 공급망에 활용된다면, 블록체인은 투명성을 줄 수 있다. 통신에서는 웹사이트 인증을 확인하고 안전한 통신을 제공하는 것을 도울 수도 있다. 컴퓨터 프로그래밍에 특화된 이더리움같은 최첨단 블록체인 플랫폼은 일정 조건이 충족되면 여러 당사자간에 자동적으로 실행되는 어플리케이션인 '스마트 컨트랙트’를 개발하기도 하였다. 이러한 기능을 활용해 개발자들은 크라우드 펀딩, 검열에서 자유로운 마이크로 블로깅, 신원관리 같은 서비스에 사용될 수도 있다. 이러한 즉각적인 사용사례를 넘어서 디지털 화폐에 대한 엔젤투자, 벤처 투자 등이 폭발적으로 증가하기 시작했다. 코인데스트케 따르면, 블록 체인 산업에 종사하는 프로젝트와 회사에 25억달러 이상이 할당되었다. 그리고 MIT, 코넬 등 유수의 기업이 오픈소스 개발을 위해 협력하고 있다. 이러한 오픈소스적인 측면은 보안과 신뢰를 위해 근본적으로 필요하며, 또한 혁신을 촉진시키는 역할도 한다. 오픈소스 플랫폼은 블록체인 기술을 설계하고 사용할 때 더 큰 유연성과 자유를 제공하며, 이니셔티브의 전반적인 가치는 지역, 국가를 넘어서는 규모로 증가한다. 가치가 증가하더라도, 접근성은 낮아야 한다. 블록체인 기술을 적용할 수 있는 많은 문제들이 불균형한 심각성을 가진 어려운 사람들에게 영향을 줄 수 있기 때문이다. 마지막으로, 정부와 중앙은행들 또한 블록체인 생태계에 대해 배우기 원하고 참여를 흼아한다. 민간, 공공 및 학술분야 간의 협업 노력은 강력하고도 새로운 민관 협력의 토대를 마련하게 되었다. ¶그들은 무엇을 위해 브록체인을 사용하는가? 블록체인과 분산원장기술은 인프라가 충분하지 않거나, 신뢰할 수 있는 운영자 역할을 할 후보자가 없을 때 가장 유용하다. 예를 들어, 블록체인 은행시설에 접근하지 못하는 수십억명의 사람들이 금융서비스를 누릴 수 있도록 도울 수 있다. 기존에 은행 서비스를 제공할 수 없었던 이유는, 국제 은행이 비효율적이거나 탐욕스럽기 때문이 아니라, 모든 사람들에게 똑같이 서비스를 제공할 수 없었기 때문이다. 마찬가지로, 블록체인은 토지대장부나 같은 기록에 대한 강력한 정부기반 시설이 부족한 국가, 또는 당사자가 서로 불신하거나 알려지지 않은 공급망 시스템 내에서 사용할 수 있다. ¶돈이 아닌, 신뢰가 세상을 움직인다. 모든 사람이 모두를 믿을 수 있건, 더 이상 신뢰가 문제가 되지 않는 세상을 상상해보자. 국제구호기구들이 더 많은 개인 기부자로부터 기부금을 얻을 수 있게 하고, 이 기부금을 종이 한장 없이 자신의 정체성을 증명할 수 있는 사람들에게 효율적이고 효과적으로 분배할 수 있을 것이다. 두바이에서 열심히 일하는 어머니는 인도에 있는 가족에게 별도의 은행계좌 필요없이 돈을 송금할 수 있을 것이다. 소비자는 음식의 정확한 원산지를 확인할 수 있을것이다. 유권자는 투표조작은 과거의 것으로 치부하고 시민들은 민주적인 과정에 절대적인 믿음을 가질 수 있을 것이며, 누구나 자신이 소유한 재산을 증명할 수 있고, 또한 완전히 새로운 형태의 자산이나 기업 또한 허용할 수 있을 것이다. 이는 아직 현실로 다가오지 못했지만, 블록체인은 불과 몇년전에는 공상과학처럼 보였던 방식으로 세상을 다시 만들어가는데 도움을 주고 있다.","categories":[],"tags":[]},{"title":"Zerocoin) 비트코인 기반의 익명 분산화된 E-Cash","slug":"Zerocoin-Anonymous-Distributed-E-Cash-from-Bitcoin","date":"2018-06-25T15:00:00.000Z","updated":"2018-06-26T01:35:35.000Z","comments":true,"path":"2018/06/26/Zerocoin-Anonymous-Distributed-E-Cash-from-Bitcoin/","link":"","permalink":"https://www.yceffort.kr/2018/06/26/Zerocoin-Anonymous-Distributed-E-Cash-from-Bitcoin/","excerpt":"Zerocoin: Anonymous Distributed E-Cash from Bitcoin 원문 비트코인은 완전히 탈중앙화 되있고, 어떠한 중앙은행이나 인증기관도 필요로 하지 않는다. 비트코인은 보안성을 분산화된 구조와 두가지 가정에 의해 이루고 있다. 다수의 노드는 정직할 것이라는 사실과, 작업증명은 Sybil Attack을 막아줄 것이라는 사실이다. 그 결과, 비트코인은 이중지불이나, 신뢰할 수 있는 기관, 감시체계 등의 법적인 시스템을 갖고 있지 않아도 운영할 수 있게 되었다. 이 탈중앙화된 디자인은 비트코인의 성공을 책","text":"Zerocoin: Anonymous Distributed E-Cash from Bitcoin 원문 비트코인은 완전히 탈중앙화 되있고, 어떠한 중앙은행이나 인증기관도 필요로 하지 않는다. 비트코인은 보안성을 분산화된 구조와 두가지 가정에 의해 이루고 있다. 다수의 노드는 정직할 것이라는 사실과, 작업증명은 Sybil Attack을 막아줄 것이라는 사실이다. 그 결과, 비트코인은 이중지불이나, 신뢰할 수 있는 기관, 감시체계 등의 법적인 시스템을 갖고 있지 않아도 운영할 수 있게 되었다. 이 탈중앙화된 디자인은 비트코인의 성공을 책임지고 있다, 그러나 이 또한 대가가 필요하다. 바로 모든 거래는 공개되어야 하며, 암호로 이루어진 가명 사이에서 이루어 진다는 것이다. 그러나 비트코인의 익명성에 대해 연구하는 학술적인 논문 작업은 비교적 적지만, 지금까지 보여지는 결과는 그다지 고무적이지 못하다. 2011년 도난된 25,000개의 비트코인 을 추적한 연구가 대표적이다. 물론, 도난당한 비트코인을 추적하는 것이 해로운 일은 아니지만, 몇몇 민감한 거래에 대해서 추적할 수 있는 기술이 생겨 나고 있다. 비트코인의 모든 거래가 공개적인 이상, 익명의 거래는 전형적인 전자 화폐 제도와 관련된 절대적인 익명성을 제공하기를 원치 않더라도 제 3자의 추적을 피하기 위해 필요하다. 이러한 거래 외에도, 부분적 또는 명시적으로 참가를 승인한 당사자를 식별하는 매커니즘을 구축할 수 있어야 한다. 그러나 이러한 정보를 공인된 당사자에게 공개하기 전에, 먼저 기본 공개 내역을 익명으로 처리해야 한다. 비트코인 커뮤니티는 비트코인이 익명성에 약점을 가지고 있다는 것에 동의한다. 이를 해결 하기 위해 비트코인을 세탁하는 경우도 있다. 그러나 이 경우에는, 세탁을 하는 운영자가 자금을 훔쳐가거나, 코인을 추적하거나 하는 등의 위험에 노출되게 된다. Zerocoin은 암호화 기술을 이용하여 제3자의 도움없이 거래 당사자 간의 연결 고리를 잘라내는 분산형 전자화폐 시스템이다. Zerocoin은 비트코인 클라이언트 당사자들이 충분한 비트코인을 가지고 있다면, 노드 개개인이 스스로 코인을 발행하는 방식으로 되어 있다. Zerocoin은 분산된, 온라인의,append-only 트랜잭션 저장소가 있다는 가정 하에 사용자에게 강력한 익명성 및 화폐의 보안을 제공하는 분산 전자 현금 체계다.그리고 Zerocoin에서는 이러한 가정으로 비트코인을 사용하였다. a는 일반적인 비트코인 트랜잭션 히스토리를 나타낸다. 각각의 트랜잭션이 이전 트랜잭션과 연결 되어 있다. b는 zerocoin chain이다. zerocoin의 발행과 소비 (점선)를 블록체인 데이터 만으로 연결 고리를 찾을 수 없다. Zerocoin의 구조를 이해하기 위해 아래의 예를 참고해보자. 모든 사용자들이 특정한 게시판에 접근할 수 있다고 가정하자. 액면가 1$ 가량의 Zerocoin을 발행 하기 위해, 엘리스는 먼저 시리얼 넘버 $$S$$로 이루어진 랜덤 코인을 생성한 다음 커밋한다. 커밋 결과 나타난 화폐 $$C$$는, 오로지 일련번호 $$S$$ 를 바탕으로 생성된 난수 $$r$$로만 열 수 있다. 엘리스는, 공개된 게시판에 $$C$$와 함께 1$를 표시해 둔다. 모든 사용자는 $$C$$가 올바르게 구성되어 있고, 올바른 합계의 금액을 가지고 있다면 $$C$$를 수락한다. 엘리스가 $$C$$를 상환하기 위해, 엘리스는 먼저 공개 게시판에 게시되어 있는 유효한 커밋들 $$(C_1, … , C_n)$$ 을 살펴 본다. 엘리스는 그리고 영지식 증명 $$\\pi$$를 생성하여 두가지를 확인한다. 1) $$C \\propto (C_1, … , C_n)$$ 2) $$S$$를 통해 $$C$$에 숨겨진 값 $$r$$. 이는 다른 사람들 관점에서는 완전히 익명으로 보이고 (물론 실제 프로토콜을 익명 네트워크인 Tor를 사용해야 한다고 한다.), 단지 ‘spend’ transaction 을 게시하는 것만이 보일 것이다. 나머지 유저들은 영지식증명 결과 $$\\pi$$를 확인하고, $$S$$가 이전 다른 'spent’거래에서 사용되지 않았는지 확인한다. 조건에 부합한다면, 사용자들은 앨리스가 $1을 가져갈 수 있게 되며, 그렇지 않으면 그 트랜잭션은 기각되고 화폐를 회수 할 수 없게 된다. 이러한 과정은 아래와 같은 목표를 달성하였다. 앨리스가 발행한 코인은 그녀가 회수한 자금과 연결 되지 않는다. 발행된 화폐 $$C$$와 출금에 쓰인 일련번호 $$S$$를 연결짓기 위해서는, 난수 $$r$$을 알아내거나, 어떤 코인이 앨리스가 증명해 낸 코인인지 밝혀 내야 한다. 그러므로, 원래 본연의 달러가 오염되어 있을지라 할더라도, 앨리스의 새로운 달러와는 연결 지을 수 없다. 동시에, 커밋과 영지식증명이 안전하다면, 앨리스는 시리얼 넘버 $$S$$를 재사용하여 이중지불을 할 수 없으며, 그리고 이는 곧 네트워크 참가자들에게 들통날 것이다. 물론, 위의 예처럼 공개된 게시판은 정보가 노출되어 있어 취약할 것이다. 그리고 중요한 것은, 네트워크를 통해 이 프로토콜을 수행하려면 분산된 디지털 통화를 필요로 한다는 것이다. 그 디지털 통화는 바로 비트코인이 될 수 있다. 비트코인 프로토콜은 신뢰할 수 있는 블록체인을 기반으로 탈중앙화 되어 있으며, 정보와 금육 거래 과정을 올릴 수 있는 업로드만 가능한 게시판 (블록체인)을 가지고 있다. 앨리스는 자금을 블록체인에 넣어 추가할 수 있고, 엄격한 프로토콜 조건(동료의 양심이 아닌) 에 따라 자신의 자금을 언제 사용할지 결정할 수 있다. ¶문제점 Zerocoin을 구현하기 위해 이중 이산 로그 증명이 필요한데 이는 증명의 크기가 크고 검증 시간도 길다. Zerocoin은 계산상의 복잡성과 크기를 증가시켜, 강력한 암호화를 구축하였다. 비트코인은 최소한 컴퓨팅 파워의 51%를 소유하지 않는 한 위조가 불가능 하다는 '가정’으로 운영되고 있다. 그리고 Zerocoin은 이러한 가정 대신, 강력한 암호화를 제공한다. 그러나 이는 어디까지나 위조 화폐의 가치가 암호화 비용보다 가치있다는 가정하에서만 유효하다. 마지막으로 보안, 익명성, 프로토콜의 책임사이에 어느정도의 trade-off가 있는지 검토해 볼 필요가 있다.","categories":[],"tags":[]},{"title":"Zerocash) 비트코인 기반의 익명 분산 결제 시스템","slug":"Zerocash-Decentralized-Anonymous-Payments-from-Bitcoin","date":"2018-06-25T15:00:00.000Z","updated":"2018-06-25T18:02:03.000Z","comments":true,"path":"2018/06/26/Zerocash-Decentralized-Anonymous-Payments-from-Bitcoin/","link":"","permalink":"https://www.yceffort.kr/2018/06/26/Zerocash-Decentralized-Anonymous-Payments-from-Bitcoin/","excerpt":"Zerocash: Anonymous Distributed E-Cash from Bitcoin 원문 비트코인 자체는 익명이 아니기 때문에, 이를 익명화 시키는데 많은 노력을 기울이고 있다. (mix라는 표현을 쓰고 있는데, 여기서는 간단하게 세탁이라고 표현하겠다.) While Bitcoin is not anonymous itself, those with sufficient motivation can obfuscate their transaction history with the help of mixes (also known as","text":"Zerocash: Anonymous Distributed E-Cash from Bitcoin 원문 비트코인 자체는 익명이 아니기 때문에, 이를 익명화 시키는데 많은 노력을 기울이고 있다. (mix라는 표현을 쓰고 있는데, 여기서는 간단하게 세탁이라고 표현하겠다.) While Bitcoin is not anonymous itself, those with sufficient motivation can obfuscate their transaction history with the help of mixes (also known as laundries or tumblers). 이러한 세탁의 과정은, 사용자가 일정양의 화폐를 보내면 화폐 pool에서 같은 양의 다른 코인을 돌려준다. 그러나 이러한 세탁의 과정도 한계가 있다. 1) 세탁을 하기 위해서는 일정량의 코인이 있어야 하고, 2) 세탁된 코인도 추적이 가능하며 3) 세탁 과정에서 도난 당할 가능성도 있다. ‘무언가를 감추어야 하는’ 사용자들에게 이러한 위험성은 충분히 감내 할 수 있을지도 모른다. 그러나 일반적인 유저들은 1) 자신의 소비습관을 다른 개인 사용자에게 알리고 싶지 않고 2) 자신의 개인정보 보호를 위해 특별한 노력을 기울이거나 위험을 감수하고 싶지도 않고 3) 그들의 사생활 침해를 인식하지 못하는 경우가 많다. 이 들의 개인정보를 보호하기 위해서는, 위험성이 없어야하고, 자동적으로 이웃이나, 동료나, 상인들에게 소비습관이나 잔고 등이 노출되지 말아야 한다. 그리고 익명의 거래는 화폐의 히스토리와 별개로 시장가치를 보증해주는 역할을 하므로, 사용자들에게 암호화폐가 유용하게 남을 수 있게 해준다. ¶Zerocash Zerocash은 비트코인에서 확장된 개념으로, 강력한 익명성을 보장한다. Zerocash은 화폐 확인을 하기 위해 디지털 서명을 하거나, 이중 지불 방지를 위해 중앙 은행을 필요로 하지 않는다. Zerocash은 이를 위해 영지식증명 을 사용한다. Zerocash은 Zerocash 프로토콜을 활용하여 주기적으로 비트코인을 세탁하는 일을 한다. 일상적으로 이루어지는 거래는 비트코인을 통해 이뤄진다. 그 이유는 아래와 같다. 성능: Zerocash을 교환하기 위해서는 이중 이산 로그 증명을 거쳐야 되는데, 이를 검증하는데 45kb가 넘는 데이터로 450ms 정도의 속도가 걸린다. 이러한 증명 작업은 네트워크를 통해 전파되고, 모든 노드들이 확인하고 그 뒤에는 원장에 영구적으로 저장된다. 이렇게 수반되는 비용은 비트코인 비용보다 더 크기 때문이다. 기능성: Zerocash은 기본적인 전자화폐 기능만으로 구성되어 있기 때문에, 익명의 지불에 필요한 기능이 결여 되어 있다. (잔돈을 거슬러 주거나, 송금기능 등) 주: 하지만 이후에 ZCash라는, 비트코인과는 별개로 Zerocash의 기능을 온전히 이어받은 새로운 암호화폐가 등장하게 된다. ¶zk_SNARK? zk_SNARK는 Zero-Knowledge Succinct Non-Interactive Argument of Knowledge의 약자로, 특정 정보나 증명인과 검증인 사이에 정보 교환없이 특정 정보의 수요를 증명할 수 있는 증명 구조를 의미한다. 증명자는 실제로 숫자에 대한 정보를 공개하지 않고도 그러한 숫자를 알고 있음을 검증자에게 확신시킬 수 있다. ‘간결한’ ZKP는 큰 프로그램의 내용의 경우에도 수백 밀리초 이내에 증명할 수 있다. 기존의 ZPK는 인증장치와 검증장치 사이에 여러 라운드로 통신을 거쳐야 했지만, 이 비대화형 구조에서는 피인증장치에서 검증장치로 보낸 단일 메시지로 구성된다. 블록체인에 게시할 만큼 비대화형의 짧은 ZPK를 생성하는 유일한 방법은 검증자와 증명자 사이에 공유되는 공통 참조 문자열을 초기 설정 단계에 생성하는 것이다. 이 공동 참조 문자는 시스템의 공용 매개변수로 참조하게 된다. ¶결론 탈중앙화 통화는 합법적인 금융거래를 수행할때, 사용자 개인정보를 다른 사람들로 부터 보호해야 한다. Zerocash는 사용자 정보, 거래금액, 잔고 등을 숨김으로 써 이러한 목표를 달성하고 있다. 그러나 이는 책임, 규제, 감독 등을 저해 한다는 비판을 받을 수 있다. 그러나 Zerocash가 기본적인 통화 시스템에서만 활용될 필요가 없다. 예를 들어, 사용자가 모든 거래에 대해 세금을 납부했는지를 거래를 공개하거나, 거래액을 보여주거나, 세금의 액수를 공개하지 않더라도 세금 납부 여부를 확인할 수 있다. 이를 통해 광범위한 규정 준수 및 규제 정책을 수동으로 검증할 수 있다.","categories":[],"tags":[]},{"title":"Zero Knowledge Proof (ZKP)","slug":"zero-knowledge-proof","date":"2018-06-25T15:00:00.000Z","updated":"2018-06-25T16:12:03.000Z","comments":true,"path":"2018/06/26/zero-knowledge-proof/","link":"","permalink":"https://www.yceffort.kr/2018/06/26/zero-knowledge-proof/","excerpt":"Zero Knowledge Proof - 영지식증명 암호학에서, 영지식증명 (Zero-knowledge proof/protocol)은 증명인(페기)이 검증인(빅터)에게 x라는 지식을 증명할 때, 증명인이 알고 있는 x라는 지식 이외에는 어떠한 것도 알려주지 않으면서 증명하는 것을 말한다. 어떠한 사실을 증명하기 위해, 증명자의 일부 비밀 정보에 대한 지식이 필요하다는 것이 검증되면, 검증자는 이러한 비밀 정보를 소유하지 않기 때문에, 검증자는 다른 사람들에게 이러한 사실을 다른 사람에게 증명할 수 없다는 것을 의미한다. 증명할","text":"Zero Knowledge Proof - 영지식증명 암호학에서, 영지식증명 (Zero-knowledge proof/protocol)은 증명인(페기)이 검증인(빅터)에게 x라는 지식을 증명할 때, 증명인이 알고 있는 x라는 지식 이외에는 어떠한 것도 알려주지 않으면서 증명하는 것을 말한다. 어떠한 사실을 증명하기 위해, 증명자의 일부 비밀 정보에 대한 지식이 필요하다는 것이 검증되면, 검증자는 이러한 비밀 정보를 소유하지 않기 때문에, 검증자는 다른 사람들에게 이러한 사실을 다른 사람에게 증명할 수 없다는 것을 의미한다. 증명할 수 있는 사실은 증명인이 이러한 지식을 가지고 있어야만 한다. 그렇지 않으면 이러한 사실이 증명되지 않기 때문이다. 아래 그림을 예로 들어 보자. 증명인 페기는 어떤 동굴안에 있는 비밀 열쇠를 가지고 있다. 동굴은 고리 모양으로 되어 있고, 그 가운데가 문으로 되어 있다. 이러한 문은 동굴입구에서 보이지 않는다. 페기는 이제 빅터에게 자신이 비밀 문을 열수 있는 말을 알고 있다는 것을 증명하고 싶어하지만(사실) 그 말이 무엇인지는 알리고 싶어 하지 않는다. (비밀) 이제 빅터가 밖에서 기다리는 동안, 페기는 아무 방향으로나 들어간다. 빅터는 아무 출구를 골라서 이 쪽으로 나오라고 외친다. 페기가 비밀 문을 열 수 없다면, 50% 확률로 증명할 수 없게 된다. 이 실험을 여러번 반복한다면, 페기가 빅터가 시킨대로 나올 수 있는 확률은 매우 낮다. 20번 만 해도, 그 확률은 $$\\frac{1}{2^{20}}$$이 된다. 반면에 비밀문을 열수 있다면, 빅터의 요구대로 매번 나올 수 있게 될 것이다. (증명) 이 실험을 계속 반복해도, 페기는 빅터 외에 다른 사람에게 어떠한 정보도 주지 않는 셈이 된다. 예를 들어 빅터가 이 과정을 모두 녹화해서 다른 사람에게 보여주어도, 다른 사람들은 이를 짜고친 연극이라 판단하고 믿지 않기 때문이다. 이는 빅터에게만 유효한 증명이 된다. 영지식 증명을 만족시키기 위해서는 아래를 준수해야 한다. 완전성: 진술이 참이라면, 정직한 증명자는 정직한 검증자에게 이사실을 납득 시켜야 한다. 건실성: 진술이 거짓이라면, 어떠한 부적징한 증명자라도 정직한 검증자에게 이 사실을 납득 시킬 수 없어야 한다. 영지식성: 진술이 참이라면, 검증자는 참거짓이외에 (문을 나왔다) 아무런 정보도(문을 열 암호) 얻을 수 없어야 한다. 이러한 기술을 블록체인에 사용하기도 한다. 블록체인에 사용한다면, 발신자, 수신자 등 트랜잭션 관련 내용이 보이지 않더라도, 거래를 신뢰하는 수단으로 ZKP를 사용할 수 있다. A Mind-Bending Cryptographic Trick Promises to Take Blockchains Mainstream 이러한 영지식증명에 대한 아이디어는 20년간 암호전문가들에게 알려져 왔지만, 최근에서야 이 기술을 활용한 서비스가 나오기 시작했다. 이러한 ZKP를 최초로 사용한 것은 바로 ZCash다. ZCash는 발신인, 수취인 및 거래 금액 등에 대한 모든 정보가 숨겨져 있음에도, 트랜잭션을 검증 할 수 있다. 이러한 아이디어는 다른 메이저 은행의 관심을 끌었으며, JPMorgan은 ZCash의 영지식증명 기능을 자사의 프라이빗 이더리움 기반 블록체인에 적용하기도 했다. 그리고 최근 이더리움에도 이 기능이 추가되었다. 궁극적으로, 이 기술이 우리에게 얼마나 더 많은 것을 가져올 수 있을지는 알 수 없다. 그러나 언젠가 우리 온라인 생활의 거의 모든 면에 확대될 가능성이 있다. 이는 개인정보를 다루는 방법에 있어서 가장 혁신적인 시작을 목격하고 있는 것일지도 모른다.","categories":[],"tags":[]},{"title":"BigChainDB) 블록체인을 활용한 데이터 베이스","slug":"bigchain-database-whitepaper","date":"2018-06-24T15:00:00.000Z","updated":"2018-06-24T18:45:56.000Z","comments":true,"path":"2018/06/25/bigchain-database-whitepaper/","link":"","permalink":"https://www.yceffort.kr/2018/06/25/bigchain-database-whitepaper/","excerpt":"BigChain DB 백서 원문 Github BigChainDB는 2016년에 처음 소개된, 블록체인을 기반으로한 데이터베이스다. BigChainDB 기존 데이터 베이스에 탈중앙화, 불변성 등 블록체인의 성격이 녹아있는 DB라고 할 수 있다. 특징\\분류 | 일반적인 블록체인| 일반적인 분산형 DB | BigChainDB –|—|– 탈중앙화|o| |o| 비잔티움 장애 허용|o| |o| 불변성|o| |o| 데이터 소유자가 컨트롤|o| |o| 높은 트랜잭션 속도||o|o| 낮은 지연||o|o| 인덱싱, 구조화된 데이터 등||o|o|","text":"BigChain DB 백서 원문 Github BigChainDB는 2016년에 처음 소개된, 블록체인을 기반으로한 데이터베이스다. BigChainDB 기존 데이터 베이스에 탈중앙화, 불변성 등 블록체인의 성격이 녹아있는 DB라고 할 수 있다. 특징\\분류 | 일반적인 블록체인| 일반적인 분산형 DB | BigChainDB –|—|– 탈중앙화|o| |o| 비잔티움 장애 허용|o| |o| 불변성|o| |o| 데이터 소유자가 컨트롤|o| |o| 높은 트랜잭션 속도||o|o| 낮은 지연||o|o| 인덱싱, 구조화된 데이터 등||o|o| ¶BigChainDB의 장점. ¶1) 완전한 탈중앙화와 비잔티움 장애 허용 BigChainDB는 모든 네트워킹과 합의에 Tendermint를 사용한다. 각각의 노드는 로컬 MongoDB 데이터베이스를 가지고 있고, 모든 통신은 Tendermint protocol을 사용한다. (Tendermint는 블록체인을 기반으로 하는 다수의 머신에서 응용프로그램을 안전하고 지속적으로 replication하는 소프트웨어다. 이 소프트웨어는 BFT 설계를 구현하였다. 참고). 이로 인해 시스템은 BFT를 얻을 수 있게 된다. 또한 이로 인해, 해커가 이 들 노드 중 하나의 MongoDB를 오염시킨 다 하더라도, 최악의 경우 해당 로컬의 데이터베이스만 오염되거나 삭제되는 선에 서 끝나게 된다. 이 말은, 다른 노드들에게는 해킹의 영향이 미치지 않는 다는 뜻이다. 모든 노드가 BigChainDB를 사용하고, 모든 노드들이 각각 다른 주체에 대해 관리 된다면, 이는 한명의 관리자, 단일 관리점, 단일 장애지점이 없기 때문에 완전한 탈중앙화 네트워크라고 할 수 있다. 이상적으로는, 이러한 노드들이 많은 나라에 걸쳐 저장되어 있어야 하며, 이로 인해 법적관할권이나 호스팅에 영향을 받지 않게 된다. 어떤 노드가 실패해도 네트워크는 계속해서 운영될 수 있다. 최대 1/3까지 실패하게 되도 네트워크는 정상적으로 동작한다. (주: 이는 Tendermint에서 주장하는 것과 일치한다. 아마 Tendermint의 프로토콜을 인용한 것으로 보인다.) ¶2) 불변성 일단 BigChainDB 네트워크에 저장이 되면, 이는 일단 거의 변경되거나 지워지기 어렵다. 많약 지워지거나 변경된다면, 이는 추적가능하다. 이러한 불변성을 만들어내기 위해서, 가장 간단한 방법으로, BigChainDB API는 삭제나 변경 기능을 제공하지 않는다. 그리고 모든 노드들은 전체 데이터의 복사본을 MongoDB 데이터베이스에 저장해 둔다. 즉 , 한 노드의 오염이나 삭제는 다른 노드에 영향을 미치지 않는다. 마지막으로, 네트워크에서 일어나는 모든 트랜잭션은 암호로 서명되어 있다. 일단 트랜잭션이 저장되고 나면, 내용을 바꾼 다는 것은 곧 서명을 바꾼 다는 것이며, 이는 전체 네트워크에서 인지할 수 있게 된다. (공개키가 수정되더라도, 이는 추적가능하다. 왜냐하면 트랜잭션의 모든 블록은 노드에 의해 서명 되는데, 이러한 서명에 쓰인 공개키는 모든 노드들이 알기 때문이다.) ¶3) 소유자가 컨트롤하는 DB (Owner-Controlled Assets) 다른 블록체인과 마찬가지로, BigChainDB는 소유자가 자산에 대한 제어권을 가지고 있다. 자산 소유자 만이 이를 이존시킬 수 있다. (여기서 소유자란 일련의 특정 개인키를 가진 사람들을 의미한다.) 노드 운영자는 이를 제어할 수 없다. 또한 비트코인의 비트코인이나 이더리움의 이더 처럼 단하나의 asset 이 존재한다. 하지만 BigChainDB는 외부유저가 자신이 원하는 만큼 asset을 만드는 것을 허용한다. 그러나 사용자가 다른 사람이 만든 것 처럼 보이는 asset은 만들 수 없다. 예를 들어, Joe가 Joe Token이라는 이름으로 1,000개의 토큰을 발행하기로 결심했다고 치자. 그는 BigChainDB 내에서 CREATE 트랜잭션을 만들고, 자신의 개인키로 서명한다음, 네트워크로 전송할 것이다. 결과적으로 Joe는 다른 사람에게 보낼 수 있는 1,000개의 토큰이 생기게 된다. 만약 다른사람에게 40개의 토큰을 보내기 위해 BigChainDB 에 TRANSFER 트랜잭션을 생성하게 되면, Joe는 총 9,960개를 소유하게 된다. BigChainDB는 이중지불을 막기 위해 모든 트랜잭션을 확인한다. ¶4) 높은 트랜잭션 속도 BigChainDB는 초당 많은 거래를 처리할 수 있도록 설계 되어 있다. 이는 Tendermint를 기반으로 했기에 가능한 사실이다. Tendermint를 기반으로 한 Cosmos whitepaer에 따르면, 5개 대륙에서 7개의 데이터센터를 바탕으로 64개의 노드를 클라우드로 구성한 결과, Tendermint Consensus는, 네트워크 지연이 1~2초 정도 있었음에도, 초당 수천개의 거래를 처리해 냈다. ¶5) 낮은 Latency 와 빠른 Tendermint를 기반으로 하였기 때문에, 거래가 포함된 새로운 블록을 만드는데 몇초만이 소요되며, 이는 미래에 변경되거나 삭제할 수 없다. ¶6) 인덱싱, 쿼리 구조의 데이터 BigChainDB의 노드들은 로컬에 MongoDB 데이터베이스를 갖고 있기 때문에, MongoDB의 모든 기능을 사용할 수 있다. 그리고 각각의 노드들은 자신의 노드를 REST Api나 GraphQL 로 최적화 시킬지 자유롭게 선택할 수 있다. ¶7) Sybil Tolerance 비트코인과 같은 일부 블록체인 네트워크는 누구나 네트워크에 붙을 수 있도록 허용해 두었다. 이는 익명의, 허위로 꾸며진 다수의 가짜 사용자가 네트워크에 붙어 공격할 수 있다는 것을 의미한다. (Sybil Attack) 비트코인은 이러한 공격을 확률적으로 굉장히 어렵게 만들었다. BigChainDB 내에서는 네트워크 참여자를 조직할 수 있으므로, 이러한 문제는 존재하지 않는다. ¶BigChainDB의 활용범위 supply chain 지적재산권 관리 디지털트윈과 IOT 신원확인 데이터 거버넌스 불변성을 지닌 감사 추적 ¶BigChainDB는 어떻게 작동하는가? ¶1. BigChainDB 트랜잭션 트랜잭션은 아래와 같은 JSON String 으로 구성되어 있다. 각각의 트랜잭션에는 키와 값과 더불어, 트랜잭션이 어떻게 생성되었는지, 트랜잭션이 유효하기 위해서는 어떤 것을 확인해야 하는지 등의 내용이 포함되어 있다. 1234567891011121314151617181920212223242526272829303132333435&#123; \"id\": \"3667c0e5cbf1fd3398e375dc24f47206cc52d53d771ac68ce14ddf0fde806a1c\", \"version\": \"2.0\", \"inputs\": [ &#123; \"fulfillment\": \"pGSAIEGwaKW1LibaZXx7_NZ5-V0alDLvrguGLyLRkgmKWG73gUBJ2Wpnab0Y-4i-kSGFa_VxxYCcctpT8D6s4uTGOOF-hVR2VbbxS35NiDrwUJXYCHSH2IALYUUZ6529Qbe2g4G\", \"fulfills\": null, \"owners_before\": [ \"5RRWzmZBKPM84o63dppAttCpXG3wqYqL5niwNS1XBFyY\" ] &#125; ], \"outputs\": [ &#123; \"amount\": \"1\", \"condition\": &#123; \"details\": &#123; \"public_key\": \"5RRWzmZBKPM84o63dppAttCpXG3wqYqL5niwNS1XBFyY\", \"type\": \"ed25519-sha-256\" &#125;, \"uri\": \"ni:///sha-256;d-_huQ-eG-QQD-GAJpvrSsy7lLJqyNhtUAs_own7aTY?fpt=ed25519-sha-256&amp;cost=131072\" &#125;, \"public_keys\": [ \"5RRWzmZBKPM84o63dppAttCpXG3wqYqL5niwNS1XBFyY\" ] &#125; ], \"operation\": \"CREATE\", \"asset\": &#123; \"data\": &#123; \"message\": \"Greetings from Berlin!\" &#125; &#125;, \"metadata\": null&#125; ¶2. 트랜잭션을 네트워크로 전송 트랜잭션이 만들어지면, 이를 HTTP Api를 활용하여 BigChainDB로 전송해야 한다. 이러한 요청은 하나이상의 노드에 전달되게 된다. ¶3. 노드가 트랜잭션을 수신 BigChainDB는 WSGI/Gunicorn과 호환되는 파이썬 웹 프레임워크인 Flask를 사용한다. Flask에서는 이러한 요청을 받고, 이 트랜잭션이 유효 한지 확인 한다. 트랜잭션이 유효하지 않다면, 400에러를 내뱉는다. 유효하다면, 이를 Base64 기반으로 변환한다음, 새로운 정보를 포함시켜 JSON String으로 다시 만든다. 그리고 BigChainDB는 이 string 을 로컬 Tendermint 인스턴스에 HTTP POST요청으로 보낸다. ¶4. Tendermint Instacne에서 트랜잭션을 수신 Tendermint에서 트랜잭션을 수신과정에서 어떤일이 일어나는지 확인하기 위해서는, Tendermint의 docs를 참고할 필요가 있다. Tendermint가 거래가 유효한지 확인해기 위해서, BigChainDB에 여러가지요소를 CheckTX를 통해 질의를 하게 된다. CheckTX에는 BigChainDB에서 상속받아 표현한 다양한 변수가 포함되어 있다. Tendermint는 새로운 블록(일련의 트랜잭션이 포함되어 있음) 을생성하고, 모든 노드가 비잔티움 장애 허용 방식으로 다음 블록에 동의 하는지 확인한다. Tendermint에서 BigChainDB에 새로운 트랜잭션을 보내면, BigChainDB는 다시한번 트랜잭션의 유효성을 확인한다. 그리고 유효하다면, Commit 메시지가 Tendermint에서 온다면 그때 비로소 MongoDB에 작성하게 된다. 트랜잭션을 MongoDB에 저장하기 전에, BigChainDB는 asset.data와 metadata를 MongoDB의 다른 컬렉션에 따로 저장하고 이를 지운다. 이렇게 따로 저장함으로서, 사용자는 MongoDB 에서 text search를 할 수 있게 된다.","categories":[],"tags":[]},{"title":"Permacoin) 데이터 보관을 위한 비트코인","slug":"permacoin-repurposing-bitcoin-work-for-data-preservation","date":"2018-06-24T15:00:00.000Z","updated":"2018-06-25T03:41:27.000Z","comments":true,"path":"2018/06/25/permacoin-repurposing-bitcoin-work-for-data-preservation/","link":"","permalink":"https://www.yceffort.kr/2018/06/25/permacoin-repurposing-bitcoin-work-for-data-preservation/","excerpt":"퍼마코인: 데이터 보존을 위한 비트코인 원문 비트코인은 전세계에서 첫번째로 널리 사용하게 된 전자화폐다. 그러나 많은 관심을 끄는 부분 중 하나는 비트코인 채굴이 계산을 하는데 있어서 많은 물리적인 자원을 낭비한다는 것이다. 비트코인의 마이닝 메커니즘 특성상, 컴퓨팅 퍼즐을 끊임 없이 풀어내야 하기 때문이다. 비트코인에서는 '비트코인’이라고 하는 화폐를 발행하기 위하여 컴퓨팅 자원을 소모하는데, 이는 곧 ‘시간=돈’ 이라는 공식이 성립하게 된다. 이러한 화폐를 발행하는 작업을 마이닝 이라고 한다. 오늘날 비트코인은, 이러한 컴","text":"퍼마코인: 데이터 보존을 위한 비트코인 원문 비트코인은 전세계에서 첫번째로 널리 사용하게 된 전자화폐다. 그러나 많은 관심을 끄는 부분 중 하나는 비트코인 채굴이 계산을 하는데 있어서 많은 물리적인 자원을 낭비한다는 것이다. 비트코인의 마이닝 메커니즘 특성상, 컴퓨팅 퍼즐을 끊임 없이 풀어내야 하기 때문이다. 비트코인에서는 '비트코인’이라고 하는 화폐를 발행하기 위하여 컴퓨팅 자원을 소모하는데, 이는 곧 ‘시간=돈’ 이라는 공식이 성립하게 된다. 이러한 화폐를 발행하는 작업을 마이닝 이라고 한다. 오늘날 비트코인은, 이러한 컴퓨팅 자원을 소모하여 '작업증명’이라고 하는 작업을 처리한다. 이러한 작업을 위해서 비트코인은 $$2^{55}$$ 해쉬 연산을 요구한다. 그리고 약 10분마다 하나의 블록을 채굴할 수 있으며, 이는 곧 전세계적으로 엄청난 양의 전기 등의 낭비가 수반된다. 현재 비트코인 마이닝을 위해 소모되는 자원의 현황은 여기에서 확인할 수 있다. 비트코인 마이닝에 소비되는 전기량은, 칠레 국가 전체 전기소모량과 맞먹는다. 그래서 비트코인의 모델을 변형하여, 채굴하는데 소요되는 자원을 보다 유용하고 광범위한 목표를 달성하기 위해 사용하려고 한다. 그 목표는 바로 분산형 데이터 저장 시스템이다. 그리고 이를 퍼마코인이라고 한다. 비트코인과 다른 기타 암호화폐와는 다르게, 퍼마 코인은 사용자들에게 컴퓨팅 자원을 요구하지 않고, '저장공간’을 요구한다. 그리고 이러한 작업은 기존의 작업 증명이 아닌 Proofs-of-Retrievability (POR) (검색증명) 이라는 방식을 사용한다. 이 시스템하에서, 성공적으로 화폐를 발행하기 위해서는 파일 사본에 대한, 랜덤액세스를 필요로 한다. 연산을 요구하는 비트코인 시스템과는 다르게, 이러한 방식은 탈중앙화 파일 스토리지를 제공하여, 결론적으로는 비트코인에서 발생하는 낭비를 줄일 수 있다. 퍼마코인의 아이디어는, 비트코인의 마이닝을 컴퓨팅 리소스보다 스토리지 리소스에 의지하게 하는 것이다. 그렇게 되면 퍼마 코인은 비트코인 네트워크 상의 스토리지 리소스를 활용할 수 있게 된다. 앞서 언급한 검색증명은 대상 파일 또는 파일을 저장하기 위해 자신의 메모리나 저장 리소스를 투자하고 있다는 것을 증명하는 방식이다. 이러한 POR 방식을 비트코인에 녹임으로써, 매우 대용량의, 그리고 공공의 가치있는 디지털 정보를 저장하기 위한 탈중앙화된, P2P 파일 스토리지 시스템을 구축할 수 있게 되는 것이다. 특히, 이런 방식으로 데이터를 처리하게 되면, 단일점 장애로 인해 데이터를 분실하는 위험도 사라지게 된다. 퍼마코인은 데이터를 저장하기 위해 특별한 신원 등을 요구 하지 않는다. 이러한 복구가능한 파일 시스템은, 참가자들에게 화폐를 줌으로서 참여할 수 있는 인센티브를 제공한다. ¶퍼마 코인의 단점 일반적으로 POR은 하나의 파일에는 최소 한명의 증명 가능한 노드가 필요하다. 그러나 하나의 노드가 담을 수 없을 정도의 큰 용량의 파일의 경우에는, 이를 분산해서 처리해야 한다. 이 경우, 일부 노드가 악의적인 목적을 가지고 행동하게 될 경우 파일 자체에 문제가 생길 수 있다. 이를 해결하기 위해서, 데이터를 가지고 있는 참여자들이 높은 마이닝 효율을 달성하기 위해서 복구 가능한 형태로 데이터를 저장해야 한다는 것을 증명하는 방식을 채택해였다. 클라이언트 노드들이 각자 개인의 로컬 스토리지 디바이스를 사용, 유지할 수 있도록 유인해야 한다. 만약 클라이언트가 각각의 데이터들을 클라우드에 저장한다면, 분산을 통한 데이터 복구 모델이 가져다 주는 이점을 가질 수 없게 된다. ¶퍼마 코인의 장점 비트코인 자원의 재활용: 퍼마 코인의 가장 궁극적인 목적은 비트코인에서 마이닝을 위해 낭비되고 있는 컴퓨팅 및 물리적 자원을 보다 유용하게 사용하여 낭비를 줄이는 것이다. 단순한 연산이 아닌, 저장공간을 제공함으로써, 공공의 이익을 달성할 수 있다. POR(검색증명): 로컬 조장소의 개인키를 인센티브로 제공하고, 스토리지를 아웃소싱(클라우드)에 불이익을 주면, 참가자들은 개인의 이익을 위해 로컬 저장소를 선택할 것이므로, 이는 물리적으로 강력한 파일 분산 시스템을 만들 수 있다.","categories":[],"tags":[]},{"title":"작업 증명이 없는 암호화폐","slug":"cryptocurrencies-without-proof-of-work","date":"2018-06-22T15:00:00.000Z","updated":"2018-06-23T01:13:44.000Z","comments":true,"path":"2018/06/23/cryptocurrencies-without-proof-of-work/","link":"","permalink":"https://www.yceffort.kr/2018/06/23/cryptocurrencies-without-proof-of-work/","excerpt":"작업 증명이 없는 암호화폐 원문 비트코인의 탈중앙화적인 특징은, 누구든 어떤 시점에서 'miner’가 될수 있으며, 이는 비트코인 시스템의 보안성을 유지한다는 것이며, 이 작업을 통해 보상을 받는 다는 것을 의미한다. 채굴자들은 지속적으로 작업증명을 실행하며, 이는 어려운 컴퓨팅 작업을 수행한다는 것을 의미한다. 이런 작업증명은 원장 이력에 대해 합의를 이룰 수 있게 해주며, 이는 거래를 동기화 시키고 사용자르 이중 지불 문제로 부터 보호해 준다. 작업 증명 메커니즘을 통해, 각 마이너들은 전기 및 마이닝 장비에 대한 물리적인","text":"작업 증명이 없는 암호화폐 원문 비트코인의 탈중앙화적인 특징은, 누구든 어떤 시점에서 'miner’가 될수 있으며, 이는 비트코인 시스템의 보안성을 유지한다는 것이며, 이 작업을 통해 보상을 받는 다는 것을 의미한다. 채굴자들은 지속적으로 작업증명을 실행하며, 이는 어려운 컴퓨팅 작업을 수행한다는 것을 의미한다. 이런 작업증명은 원장 이력에 대해 합의를 이룰 수 있게 해주며, 이는 거래를 동기화 시키고 사용자르 이중 지불 문제로 부터 보호해 준다. 작업 증명 메커니즘을 통해, 각 마이너들은 전기 및 마이닝 장비에 대한 물리적인 자원을 고갈 시키고, 비트코인 시스템 내에서 소비할 수 있는 코인형태의 암호화 자원을 얻는다. 하지만, 만약에 탈중앙화된 암호화폐가 물리적인 자원을 소모하지 않고도 비트코인 만큼 안전한 시스템을 만들 수 있을까? 이러한 물리적 자원낭비에 의존하지 않는 암호화폐 프로토콜을 지분증명이라고 한다. 이는 시스템 내에 화폐를 소유한 당사자에게 원장의 이력을 지속 시킬 수 있는 권한을 주는 메커니즘이다. 지분증명은, 시스템의 보안이 침해 당할 때 가치가 하락하므로, 시스템에 지분을 보유한 실체가 보안을 유지하기에 적합한 모델이다. 따라서, 비트코인과 유사한 방식으로, 유통되는 화폐의 $$p$$ 비율 만큼 가지고 있는 노드가 $$p$$ 만큼의 확률로 다음 원장을 만들 수 있는 기회를 가지게 된다. 작업증명을 기반으로 하는 암호화폐의 경우에는, 마이닝 파워가 해킹 등의 공격에 상당부분 포함될 경우 위험해질 가능성이 있다. 반면에, 순수한 지분증명 화폐의 경우에는 대부분의 소유자들이 공격에 참여하게 될 경우 취약해진다. 지분증명 시스템에서 대다수의 참가자들이 공격에 뛰어 들 경우, 이는 시스템이 더이상 유지될 가치가 없다고 보는 것이 맞을 것이다. 그러므로 지분의 과반수가 공격에 가담하지 않을 것이라는 것을 가정할 수 있다. 지분증명 시스템을 구축하기 위해서는 명백한 두 가지 장애물이 있다. 하나는, 초기에 이해 당사자들에게 화폐를 공정하게 분배하는 문제와, 그리고 노드가 이타적이라기 보다는 합리적으로 행동할 경우 발생할 수 있는 네트워크의 취약성 문제다. 작업 증명은 첫번째 장애물에 대해서는 물리적인 컴퓨팅 리소스를 가진 이들에게 화폐를 분배하는 방식의 유연한 해결책을 제시한다. 지분증명 시스템 하에서는, 처음에 화폐를 분배하는 단계에서만 작업증명 방식을 사용한다. 그리고 이 시스템 하에서는, 다음 볼륵을 다음과 같은 방적식을 사용하여 생성할 수 있다. $$hash(\\text{prev_blocks_data}, \\text{time_in_seconds}, txout_A) \\leq d_0 \\cdot \\text{coins}(txout_A) \\cdot \\text{timeweight}(txout_A) $$ 해당 방정식에서, $$\\text{time_in_seconds}$$는 현재시간과 일치해야 하므로, 해시 시도를 초당 1로 제한하고, 다음 블록을 만들 때 작업증명 사용을 방지한다. 왜냐하면 노드는 새 블록의 시간과 로컬 시간의 차이가 어느 선을 벗어나지 않는 한 유효하지 않은 않은 블록으로 간주하기 때문이다. $$\\text{coins}(txout_A)$$는 거래 $${txout_A}$$의 결과 나온 사용하지 않은 양의 코인을 의미한다. 그러므로 이해관계자 A가 $$txout_A$$를 컨트롤 할 수 있는 자신의 개인키 $$sk_A$$를 가지고 있다면, 그는 블록에 $$$sk_A$$를 이용하여 서명을 함으로써 유효한 블록을 만들어 낼 수 있다. 그리고, 이 방정식에 대한 증거로 서명을 첨부하게 된다. 상수 $$d_0$$는 평균 10분 간격으로 블록을 생성하도록 명령하는 프로토콜에 의해 조정될 수 있다. 일례로, 특정 기간 동안 온라인 상태인 이해관계자가 적을경우, $$d_0$$의 값은 증가하게 된다. 여기에서 승리하게 되는 블록체인은 누적지분이 가장 많이 보유하고 있을 것이다. 이러한 지분 블록을 많이 가진 블록체인 일 수록, $$d_0$$의 난이도가 증가할 것이다. 보안의 유지를 위해, 물리적인 자원 사용에 의지 하지 않는 지속가능한 탈중앙화 암호화폐 프로토콜을 만드는 것은 굉장히 어려운 일이다. 그리고 기존 암호화폐의 프로토콜이 보안에 취약한 면면을 보이고 있다. 이러한 지분 증명은 보안의 문제와 더불어, 물리적인 자원을 소모하는 문제 모두를 해결 할 수 있다고 생각한다.","categories":[],"tags":[]},{"title":"스마트 컨트랙트는 비트코인 마이닝 풀을 취약하게 한다.","slug":"Smart-Contracts-Make-Bitcoin-Mining-Pools-Vulnerable","date":"2018-06-22T15:00:00.000Z","updated":"2018-06-22T22:06:24.000Z","comments":true,"path":"2018/06/23/Smart-Contracts-Make-Bitcoin-Mining-Pools-Vulnerable/","link":"","permalink":"https://www.yceffort.kr/2018/06/23/Smart-Contracts-Make-Bitcoin-Mining-Pools-Vulnerable/","excerpt":"스마트 컨트랙트는 비트코인 마이닝풀을 취약하게 한다. 원문 비트코인 및 신흥 암호화폐는 사용자가 분산 응용 프로그램을 처리하고 실행할 수 있는 신뢰할 수 있는 플랫폼을 제공한다. 각 암호화폐는 네트워크에서 발생한 거래를 P2P 분산원장에 저장하여 유지한다.네트워크는 이러한 원장의 상태에 동의하기 위하여 이른바 '나카모토 합의’라고 하는 컨센서스 프로토콜을 실행한다. 각 실행마다, 나카모토 합의는 확률적으로 컴퓨터 퍼즐 (작업증명퍼즐)을 증명해 낼 수 있는 노드를 선출해 낸다. 이를 해결해 낸 사람은 네트워크에 일련의 새로운 거래","text":"스마트 컨트랙트는 비트코인 마이닝풀을 취약하게 한다. 원문 비트코인 및 신흥 암호화폐는 사용자가 분산 응용 프로그램을 처리하고 실행할 수 있는 신뢰할 수 있는 플랫폼을 제공한다. 각 암호화폐는 네트워크에서 발생한 거래를 P2P 분산원장에 저장하여 유지한다.네트워크는 이러한 원장의 상태에 동의하기 위하여 이른바 '나카모토 합의’라고 하는 컨센서스 프로토콜을 실행한다. 각 실행마다, 나카모토 합의는 확률적으로 컴퓨터 퍼즐 (작업증명퍼즐)을 증명해 낼 수 있는 노드를 선출해 낸다. 이를 해결해 낸 사람은 네트워크에 일련의 새로운 거래 내역이 담겨 있는 블록을 브로드 캐스트 하게 된다. 이 블록이 네트워크에 의해 검증되고 승인된다면, 블록을 만들어낸 대가로 보상을 받게 된다. ¶마이닝 풀 작업증명에 유효한 답을 찾아내는 과정은 확률에 기반한 과정이며, 막대한 컴퓨팅 리소스를 필요로 한다. 일반적인 컴퓨팅 파워를 가진 일반적인 채굴자들은 이러한 확률적인 프로세스로 인하여 극심한 변동성을 갖게 된다. 일례로, 가장 최신의 마이닝 하드웨어인 AntMiner S9한대를 사용했을 경우에는, 평균 일년에 한개의 블록을 발굴할 수 있다. 이러한 극심한 변동성을 줄이기 위해서 채굴자들은 이른바 마이닝 풀을 조직하고 보상을 나눠 갖게 된다. 마이닝풀에서는, 풀을 형성한 operator가 채굴자들에게 일반적인 한개의 블록을 채굴하는데 필요한 작업증명 퍼즐보다 쉬운 작업을 miner들에게 배분한다. 각각의 퍼즐에 대한 답은 작업증명 퍼즐을 해결할 수 있는 가능성을 지니게 된다. 결과 적으로, 충분한 수의 채굴자들이 이러한 작업을 처리하게 된다면, 이 중 하나는 블록을 생상하기 위한 답을 가질 수도 있는 것이다. 채굴자가 블록 생성에 필요한 답을 찾았다면, 마이닝 풀 운영자는 이를 네트워크에 제출하고 보상을 받는다. 이 보상은 마이닝풀에 참가한 모든 참석자들에게 컴퓨팅 파워를 기여한 만큼 나눠 받게 된다. ¶마이닝 풀에 보상을 줄 경우의 취약점 마이닝 풀은 일반적인 블록 차단 공격에 취약하다. (block withholding attack은 마이닝 풀 운영자에게 가히즌 공격이다.) 블록 헤더가 마이닝 풀 운영자에 의해 결정되기 때문에, 공격자는 자신이 발견한 블록으로 이득을 얻을 수 없다. 그러나 마이닝 풀 밖에 있는 채굴자 들은 블록을 보유하고 있음으로서 이득을 얻을 수 있다. 블록을 보유하고, 고의로 누락시킴으로서 마이닝 풀 외부에 있는 광부들은 더 많은 블록을 채굴할 수 있게 된다. ¶공격 스마트 컨트랙트는 블록체인 상에서 멈출수 없는 프로그램이다. (비트코인, 이더리움 등) 그리고 내부적으로 실행 코드와 상태값을 가지고 있는데, 이 안에는 정보를 저장하기 위한 공간과 화폐 보유액이 포함되어 있다. 이 논문에서는, 블록을 소유하고 있는 마이닝 풀 채굴자에게 보상을 주는 스마트 컨트랙트에 대해 소개 하려고 한다. 채굴자가 이성적이고, 그들의 단기적인 이득을 극대화 시킬 것이라는 가정하에, 이러한 공격으로 부터 얻을 수 있는 이익을 분석하였다. 공격이 큰 마이닝 풀을 대상으로 할때, 이러한 공격은 단일 하드웨어를 실행하는 공격자에게도 이득이 된다. 더욱이 , 공격자들은 이론적으로 큰 마이닝 풀에서 발생하는 이득을 모두 흡수할 수 있다. 이러한 공격은 마이닝 풀을 형성하는 전략에 치명적인 손상을 가져온다. 블록체인 상에서 스마트 컨트랙트를 사용하는 것은 이러한 공격에 취약하게 된다는 것을 의미한다. 그러나, 광부들이 자신의 몫이 보장되지 않는 한, 이러한 공격을 막는데 협력하지 않을 것 같다. 더욱이, 스마트 컨트랙트를 통해 보상을 주는 모델은 공격자를 익명상태로 있게 하는 것이 가능하며, 공격자를 특정하는 것을 방지하고, 서비스를 마비 시킬 수 있다. 기존 block withholding attack 과 다른점 block withholding attack은 기존 비트코인에서 알려진 공격법이다. 채굴자가 2개의 마이닝 풀에서 채굴하고, 작업증명에 대한 해답을 마이닝 풀 운영자에 알리지 않고 보유함으로써 이득을 취할 수 있다는 것이 밝혀졌다. 출처 그러나 이러한 공격이 가능하기 위해서는, 엄청나게 큰 컴퓨팅 파워 (비트코인 전체 시스템의 1%)가 필요하다는 것이 밝혀졌다. ¶공격 원리 먼저 블록의 보상은, 그 보상을 받는 주체가 마이닝 풀 운영자로 고정되어 있기 때문에, 실제 블록은 공격자에게 별 의미가 없다는 것을 언급했다. 그러므로 공격자는 전체 네트워크에 작용하는 hash rate를 감소시켜야지만 이득을 취할 수 있다. block rate (비트코인의 경우 10분에 한 블록)을 유지하기 위해서는, 네트워킄 정기적으로 네트워크에 참여하는 채굴자를 예상하여 해쉬 퍼즐의 난이도를 조절해야 한다. 비트코인의 경우에는, 2018블록 마다 난이도 조절이 이루어 진다. 이러한 인센티브 분석을 위해, 공격자가 컨트롤하는 네트워크 hash rate를 $$\\alpha$$, 블록 보상을 $$r$$, 채굴자가 작업증명에 대한 답을 제출하여 얻는 값을 $$s \\cdot r$$이라고 하자. 먼저 공격자가 블록의 일부 $$\\beta$$ 를 구매하여 증가시킬 수 있는 순수익을 계산해보자. 공격을 하지 않을 경우, 공격자에게 기대되는 이익은 $$alpha \\cdot r$$ 이다. 만약 $$\\beta$$가 유효한 블록이었고, 이를 보내지 않을 경우, 공격자의 hash rate 는 $$a = \\alpha /(1-\\beta)$$ 가 된다. 그러므로, 공격자가 추가적으로 잠재적인 블록을 구매해서 얻을 수 있는 추가 수익은 $$a \\cdot r - \\alpha \\cdot r = \\frac{\\alpha\\beta \\cdot r}{1-\\beta}$$ 가 된다. 마이닝 풀 참여자가 블록 전송을 보류하기 위해서는, 공격자는 마이닝 풀에서 주는 이익과 상응하는 이익을 주어야 가능할 것이다. $$\\beta$$를 마이너가 네트워크에 전송하지 않는 블록의 비율이라고 보면, 장기적으로 네트워크의 난이도는 $$(1-\\beta)$$ 만큼 감소하게 될 것이다. 그러므로 유효한 블록을 발견하게 될 가능성은 (마이닝 풀 마이너에게 주어야할 보상은) $$\\frac{\\beta \\cdot s \\cdot r}{1-\\beta}$$ 가 된다. 위 두 식을 비교하면, $$\\alpha &gt; s$$ 가 되는 경우에만 공격자와 블록을 발견해도 보내지 않는 mining pool 참가자에게 이익이 될 수 있다. 공격자에게 mining pool 참가자가 자신이 블록을 보유하고 있다는 것을 확신시키기 위해서는, 먼저 1) 유효한 블록을 찾고 2) 네트워크에 그 블록을 알리지 말아야 한다. 블록 검증을 위한 작업, 즉 80바이트 가량의 데이터가 유효한 블록 헤더로 구성되어 있는지 확인 하기 위해, 스마트 컨트랙트 내에 전체 블록체인을 저장해 두어야한다. 이는 이더리움에 경우에는 $76,000 가 넘는 비용이 소모되므로 불가능하다. 작업 중","categories":[],"tags":[]},{"title":"RSCoin) 중앙은행화된 암호화폐","slug":"centrally-banked-cryptocurrencies","date":"2018-06-21T15:00:00.000Z","updated":"2018-06-22T00:46:07.000Z","comments":true,"path":"2018/06/22/centrally-banked-cryptocurrencies/","link":"","permalink":"https://www.yceffort.kr/2018/06/22/centrally-banked-cryptocurrencies/","excerpt":"중앙은행화된 암호화폐, RSCoin 원문 2009년에 소개 된 비트코인은 리플이나 라이트코인 같은 많은 다른 암호화폐에 영감을 주었고, 이들은 금융적으로 많은 성공을 이룩했다. 이러한 성공에 힘입어 최근에는 JPMorgan, Chase, Nasdaq등 도 블록체인 기술을 도입하는 계획을 발표하기도 됐다. 나아가 암호화폐의 이러한 잠재적인 가능성은 정부 기관에도 영향을 미치기 시작헀다. 유럽 중앙은행은 암호화폐가 가져올 통화정책과 가격안정성에 대해 예측하기 시작했고, 미국 연준은 빠르고, 더 안전하며 효율적인 지불 시스템에 대한","text":"중앙은행화된 암호화폐, RSCoin 원문 2009년에 소개 된 비트코인은 리플이나 라이트코인 같은 많은 다른 암호화폐에 영감을 주었고, 이들은 금융적으로 많은 성공을 이룩했다. 이러한 성공에 힘입어 최근에는 JPMorgan, Chase, Nasdaq등 도 블록체인 기술을 도입하는 계획을 발표하기도 됐다. 나아가 암호화폐의 이러한 잠재적인 가능성은 정부 기관에도 영향을 미치기 시작헀다. 유럽 중앙은행은 암호화폐가 가져올 통화정책과 가격안정성에 대해 예측하기 시작했고, 미국 연준은 빠르고, 더 안전하며 효율적인 지불 시스템에 대한 가능성을 보기도 했다. 이러한 성공에도 불구하고, 현존하는 암호화폐는 몇가지 한계에 부딪히고 있다. 그 중에 가장 심각한 것은 바로 낮은 확장성이다. 비트코인 네트워크는 초당 7개의 거래만 처리할 수 있는 반면, 페이팔은 초당 100건을, 비자는 평균 초당 2,000~7,000건을 처리하는 것과는 굉장히 대조적이다. 이러한 확장성의 부재는 거래내역을 알리고, 작업증명을 하기 위해 막대한 컴퓨팅 에너지를 써야하기 때문이다. 라이트코인의 경우 이 비용을 분배하여, 퍼마 코인은 이러한 연산의 용도를 변경하려 하고 있지만, 두 코인 모두 궁극적으로 해당 비용을 제거하지 못헀다는 문제점을 안고 있다. 두번째로 현재 암호화폐가 가지고 있는 한계점은 통과 공급을 컨트롤 할 역량이 부족하다는 것이다. 이는 미시 경제학적 관점에서 봤을 때 적거나 거의 없는 정도의 유연함을 가지고 있는 것이며, 화폐 가치에 극단적인 변동성을 갖고 있다는 것을 의미하기도 한다. 이러한 문제점을 해결하기 위해 제안하는 것이 바로 RSCoin이다. 이 암호화폐는 거래 원장을 유지하는 것으로 부터 통화 공급정책을 완전히 분리 시킨 프레임워크다. 이는 더 많은 확장성을 암호화폐에 부여할 수 있고, 또한 영국은행에서 재기한 문제점 중 하나인 '중앙은행이 스스로 디지털 통화를 발행하기 위해 이 기술을 활용할 수 있는가’에 대한 답변이 될 수 있다. 이는 비트코인이 널리 퍼지면서 비단 영국은행만이 가지는 ㅁ문제가 아닐 것이라고 생각한다. RSCoin 통화 공급을 중앙에서 집중화하여 다룸으로써 전통적인 암호화폐와 근본적인 차이점을 두고 있다. 모든 통화가 특정한 중앙은행에서 발행되며, 이를 기반으로 한 RSCoin은 무엇보다도 중앙정부에 입맛에 맞는 암호화폐가 될 것이다. 이런 중앙화에도 불구하고, RSCoin은 여전히 투명한 거래 원장이 주는 이점을 누릴 수 있고, 분산형 시스템으로 유지할 수 있으며, 전세계적으로 투명한 통화 공급이라는 목적을 달성할 수 있다. 이는 통화공급정책을 더욱 투명하게 할 수 있으며, 지불과 송금에 바로 접근할 수 있고, 익명성을 제공하며, 블록체인과 디지털 화폐를 사용함으로 써 얻을 수 있는 혁신 또한 취할 수 있다. 중앙화된 통화 인증 정책은 또한 RSCoin이 기존에 암호화폐가 가지고 있는 확장성 이슈도 해결할 수 있게 해준다. 특히, 중앙은행은 인증된 다른 많은 기관에 거래를 검증하는 을 위임할 수도 있는데, 이러한 기관을 mintettes라고 한다. mintettes는 저농적인 암호화폐 채굴자들과는 다르게, 잘못된 처리에 대해 책임을 져야할 수도 있으므로, RSCoin은 간단하고 빠른 이중지불을 감지할 수 있는 메커니즘을 제공한다. 그 결과 초당 2,000건의 거래를 처리하며, 이러한 성능 확장은 mintettes가 많아질 수록 선형적으로 증가한다. 많은 거래가 1초이내로 처리되며, 이는 전통적인 암호화폐가 몇 분 씩 걸리는 것과는 대조적이다. 이런 확장성과는 외에도, 비트코인 네트워크가 최근 miner들의 인센티브를 잘못 조정할 수도 있다는 것을 보여주기도 했고, 모든 트랜잭션을 완전히 검증하지 않고도 블록을 생산할 수 있다는 것이 밝혀지기도 했다. 참조 RSCoin은 이를 mintettes에게 정직한 서비스를 운영할 수 있는 정도의 인센티브를 제공하는 모델을 만들었다. 실제 RSCoin의 사용에서는, 이러한 mintettes가 실재로 중앙은행과 기존 관계를 가지고 있는 기관으로 설정되어, 이러한 서비스를 수행하기 위한 인센티브를 얻을 수 있을 것이라고 생각한다. RSCoin의 궁극적인 목적은, 암호화폐의 확장성을 증대시켜 하나의 중앙은행에 의해 실행될 수 있고 통제될 수 있도록 하는 것과 더불어, 모든 종류의 중앙은행이 그들 스스로의 암호화폐를 만들 수 있도록 하는 것이다. ¶RSCoin 개요 그림1) RSCoin의 주요 구조. 각각의 mintettes는 낮은 레벨의 블록을 유지하고 있으며, 다른 mintettes들과 통신할 수 있다. 특정시점에, 각각의 mintettes는 이들의 블록을 중앙은행으로 보내며, 중앙은행은 더 상위의 블록을 만들어 낸다. 이 상위 블록은 체인을 형성하고, 다른 외부 사용자들이 볼 수 있게 된다. 그림2) 거래를 확인하기위한 프로토콜. 각 mintettes $$m_i$$는 주소 $$i$$의 소유자. (1)에서, 사용자는 거래 상에서 각 어드레스를 소유하고 있는 소유자를 알게 된다. (2)에서는, 입력된 주소의 대다수의 mintettes로 부터 거래에 대한 승인을 얻게된다. (3) 에서, 사용자는 거래내역과 소유주로 부터 얻은 거래 승인 내역을 보낸다. (4) 에서는, 이 승인내역을 받은 mintettes 들이 이 거래를 각 블록에 추가한다. 상위 단계에서, RSCoin은 거래원장의 규약과 통화 공급을 발생 시킨다. RSCoin 시스템은 두가지 구조를 가정하고 있다. 중앙은행: 완전히 통화 공급정책을 통제하는 주체 mintettes: 거래원장을 유지할 주체 이 두 기관의 상호작용이 그림1에 나타나 있다. 간단하게 요약하면, mintettes는 거래를 유저로 부터 모으고 이를 블록으로 만들며, 이는 전통적인 암호화폐에서도 동일하게 처리하는 행동이다. 그러나 miner와는 확연하게 다른 점 이 있는데, 컴퓨터적으로 어려운 퍼즐을 풀어 작업증명을 하는 miner와 는 다르게, 각각의 mintettes들은 단지 이러한 거래를 수집하기 위해 단순히 인증만 받으면 된다. RSCoin 에서는 이러한 인증이 PKI-type functionality 으로 이루어 진다. 이는 mintettes의 공개키에 중앙은행이 서명하고, 각각의 저레벨 블록에서 이를 확인하기 위해 서명한 공개키를 담아두면 된다. 이러한 mintettes에 의해 블록이 만들어지는 간격을 epoch라고 한다. 이 epoch의 길이는 mintettes에 따라 달려 있다. 이러한 블록들은 궁극적으로 중앙 블록체인과 연계 된 것이 아니기 때문에, 이를 저레벨 블록이라고 명명한다. mintettes는 이렇게 일관성 있는 원장을 작성하고, 이 과정을 촉진 시키기위한 연대 책임을 지고 있다. 그리고 단순히 그들의 이전 블록을 참조하는 것 뿐만 아니라, 각각의 이전 블록 또한 참조해야 한다. 이는 저레벨 블록이 상호 참조 체인을 구성해야 한다는 것을 의미한다.어느 정도 블록이 작성되고 나면, mintettes는 이 블록들을 중앙은행에 보내야 한다. 그리고 중앙은행은 이러한 저레벨 블록을 일정한 연대순으로 모아 새로운 고레벨 블록을 만들어 내야 한다. 이 고레벨 블록은 궁극적으로 메인 블록체인에 연결되고, RSCoin의 사용자들은 이러한 단계의 블록만을 볼수 있게 된다. RSCoin은 독립화된 암호화폐라기 보다는 하나의 프레임워크로 보는 것이 더 타당하다. 때문에 이러한 목표를 달성하기 위해 현존하는 암호화폐의 다양한 기술을 접목할 수 있다. 예를 들어, 거래의 익명성을 강조하기 위해 ZeroCoin, ZeroCash, Pinocchio Coin등의 기술을 활용할 수 있다. ¶결론 이 논문에서는, 중앙은행이 통화정책을 컨트롤 할 수 있는 RSCoin이라는 개념을 소개했다. 비트코인과 같은 성공적인 암호화폐의 설계에 상대적으로 최소한의 변경을 가하는 블록체인 기반으로 접근하면서, 이러한 중앙 집중화는 탈중앙화를 매력적으로 보이게한 완전한 투명성을 보장할 수 있다. 또한 2PC (중앙은행, mintettes)를 기반으로 하는 새로운 합의 매커니즘을 제안하고, 성능을 척정함으로써 일부 권한의 중앙집중화를 통해, 작업증명 기반 시스템에 필요한 컴퓨팅 파워의 낭비를 방지할 수도 있다.","categories":[],"tags":[]},{"title":"Ethereum) 이더리움으로 구현한 선거 시스템","slug":"A-smart-contract-for-boadroom-voting-with-maximum-voter-privacy","date":"2018-06-20T15:00:00.000Z","updated":"2018-06-20T22:39:57.000Z","comments":true,"path":"2018/06/21/A-smart-contract-for-boadroom-voting-with-maximum-voter-privacy/","link":"","permalink":"https://www.yceffort.kr/2018/06/21/A-smart-contract-for-boadroom-voting-with-maximum-voter-privacy/","excerpt":"유권자의 개인정보보호를 극대화 하는 스마트 컨트랙트를 활용한 이사회 투표 원문 이더리움은 비트코인 다음가는 두번째로 유명한 암호화폐다. 이더리움은 기본적으로 비트코인의 블록체인을 기반으로 하고 있으며, 이 블록체인은 탈중앙화 되고 개방되어 있는 P2P 네트워크를 기반으로 유지 되고 있다. 블록체인은 중앙에서 금융 원장을 관리하는 것을 제거하기 위해 만들어 졌다. 오늘날 많은 연구원들은 블록체인을 IOT, 헬스케어 와 같은 다양한 문제를 해결하는데 적용하고자 노력하고 있다. 이 논문에서는, 블록체인을 활용한 탈중앙화 인터넷 투표","text":"유권자의 개인정보보호를 극대화 하는 스마트 컨트랙트를 활용한 이사회 투표 원문 이더리움은 비트코인 다음가는 두번째로 유명한 암호화폐다. 이더리움은 기본적으로 비트코인의 블록체인을 기반으로 하고 있으며, 이 블록체인은 탈중앙화 되고 개방되어 있는 P2P 네트워크를 기반으로 유지 되고 있다. 블록체인은 중앙에서 금융 원장을 관리하는 것을 제거하기 위해 만들어 졌다. 오늘날 많은 연구원들은 블록체인을 IOT, 헬스케어 와 같은 다양한 문제를 해결하는데 적용하고자 노력하고 있다. 이 논문에서는, 블록체인을 활용한 탈중앙화 인터넷 투표를 구현하려고 한다. 검증 가능성을 제공하는 E-voting 프로토콜은 일반적으로 모든 유권자들에게 일관된 견해를 제공하는 공개 게시판의 존재를 가정한다. 현실적인 예로 International Association of Cryptologic Research(국제 암호학회)에서 하는 선거를 들 수 있다. 이들은 Helois 투표 시스템이라고 하는, 단일 웹서버에 구현된 투표 시스템을 사용한다. 이 서버는 신뢰할 수 있는 정보를 모든 유권자에게 제공한다. 이러한 ‘신뢰를 가정하는’ 것이 아닌, 블록체인에서 실제로 구현가능한 공공 게시판을 구현해보고자 한다. 더 나아가, 유권자들 사이에서 의사 소통을 조정할 책임 이 있는 분산된 선거 환경 또한 고려 해본다. 이를 위해, 블록체인의 기본인 P2P네트워크가 인증된 브로드캐스트 채널로서 적절한지도 탐구하였다. 그러나 현재까지는, 비트코인과 이더리움 모두 확장성 이슈가 발목잡고 있다. 비트코인은 초당 최대 7개의 트랜잭션만 처리가 가능하며, 각 트랜잭션은 임의의 데이터를 저장하는데 80바이트만 사용할 수 있다. 반면에 이더리움은 Gas metric을 사용하여 연산과 저장을 명시적으로 실행하고, 네트워크는 사용자가 사용할 수 있는 가스를 제한해 두었다. 이러한 이유 때문에, 이들 블록체인은 국가적인 크기의 선거를 수행하기에 적합하지 않다. 이러한 이유로, 블록체인을 활용한 작은 그룹의 투표 (40명정도)를 블록체인으로 구현할 수 있는 방안에 대해 연구하였다. 비트코인이 아닌 이더리움이 선택된 이유는 간단하다. 이더리움의 스마트 컨트랙트는 프로그래밍언어를 표현할 수 있으며, 이 코드들은 블록체인에 곧바로 저장될 수 있다. 더욱 중요한 것은, 모든 참가자들이 P2P네트워크 상에서 독립적으로 계약 코드를 실행하고 그 결과를 통해 합의에 도달하게 되는 것이다. 이 뜻은, 유권자가 프로토콜의 정상적인 실행을 확인하기 위해 모든 연산을 각자가 할 필요가 없다는 것이다. 대신 유권자들은 이더리움이 제공하는 합의 컴퓨팅을 신뢰하여 프로토콜의 올바른 실행을 보장받을 수 있는 것이다. ¶이더리움을 활용한 공개 투표 네트워크 이 논문에서 실제로 해당 시스템을 만들어서 깃헙에 공개하였다. 링크 모든 유권자가 접근하여 투표하는 인터페이스를 웹 기반으로 제작하였다. 브라우저는 서버에서 실행중인 이더리움 데몬과 상호작용하며, 이러한 프로토콜은 5가지의 스테이지로 구성되어 있고 유권자는 두개에서 최대 3개의 액션을 취해야 한다. ¶구조 여기에는 두 종류의 스마트 컨트랙트가 있으며 모두 이더리움의 solidity language로 구현되어 있다. 첫번째 컨트랙트는 voting contract다. 이는 투표를 위한 프로토콜로, 투표과정을 컨트롤 하고 Open Vote Network상에 시는 두종류의 영지식증명 을 검증한다. 이는 모든 유권자들에게 동일한 암호화 코드를 주어 이더리움 네트워크과 연결될 필요없이 로컬 환경에서 사용할 수 있게 해준다. 그리고 사용자들에게는 아래의 3가지 페이지가 주어진다 선거 관리자 (admin.html): 여기에는 유권자 목록과 선거에 필요한 질문, 그리고 투표가 제시간에 끝날 수 있도록 설정할 수 있다. 유권자 (voter.html): 선거에 등록하고, 단 한번 투표를 할 수 있다. 관찰자 (livefeed.html): 선거에서 발생하는 일련의 과정을 지켜 볼 수 있음. 이를 위해서는 선거 관리자와 유권자들은 각각 이더리움 어카운트를 갖고 있다는 것을 가정했다. 유저는 자신의 이더리움 어카운트를 자신의 프라이빗 키로 잠금을 해제할 수 있고, 웹브라우저를 통해 바로 인증할 수 있다. 유저는 이더리움 월렛을 활용할 필요가 없고, 이런 이더리움 클라이언트는 데몬에서 백그라운드로 이루어진다. ¶투표단계 ¶SETUP 선거 관리자는 유권자들의 계정을 인증하고, 투표가능한 유권자 정보를 얻기 위해 voting contract를 업데이트 한다. 그리고 투표가 가능한 시간도 설정한다. $$t_{finishRegistration}$$: 모든 유권자들은 그들의 voting key $$g^{x_i}$$를 이 시간내에 등록해야 한다. $$t_{beginElection}$$: 이더리움에 알릴 투표 시작 시간 $$t_{finishCommit}$$: 모든 유권자들은 반드시 그들의 투표 $$H(g^{x_iy_i}g^{v_i})$$ 를 이 시 간내에 커밋해야 한다.(옵션) $$t_{finishVote}$$: 모든 유권자들은 $$g^{x_iy_i}g^{v_i}$$를 이 시간내에 투표해야한다. $$\\pi$$: 유권자에게 투표시간을 주기위해 투표단계가 활성화 되어야 하는 최소 기간 관리자는 또한 투표용 질문인 $$d$$ 를 설정할 수 있으며, 커밋스테이지가 필요한지도 결정할 수 있다. 마지막으로, 이더리움에 SINGUP 스테이지로 넘어감을 알려야한다. ¶SINGUP 모든 가능한 유권자들은 투표용 질문과 관리자가 설정한 파라미터들을 본뒤에 등록을 해야한다. 등록을 위해서는 투표용 키잉ㄴ $$g^{x_i}$$와 $$ZKP(x_i)$$가 필요하다. 이 키와 proof $$d$$와 함께 이더리움으로 보내진다. 이더리움은 $$t_{finishRegistration}$$ 이 지난 뒤에는 이를 허용하지 않는다. 관리자sms COMMIT 이나 VOTE 단계로 넘어감을 이더리움에 알려야 하고, 모든 유권자들의 재생성된 키 $$g^{y_0}, g^{y_1}, g^{y_2} … g^{y_n}$$ 는 이러한 전환 되는 동안 이더리움에서 계산된다. ¶COMMIT (옵션) 모든 유권자들은 이더리움 블록체인에 그들의 해쉬를 $$H(g^{x_iy_i}g^{v_i})$$ 올린다. 블록체인 이 이를 최종적으로 받아드리면, contract는 자동적으로 VOTE stage로 넘어간다. ¶VOTE 모든 유권자들은 그들의 암호화된 투표권 $$g^{x_iy_i}g^{v_i}$$ 를 올리고 이를 영지식증명을 통해 증명한다. 투표가 이더리움에 의해 받아지면 deposit $$d$$가 유권자에게 환불된다. 투표 관리자는 이더리움이 최종적인 투표권이 행사되었음을 알리게 되면 이를 인지하게 된다. ¶TALLY 투표관리자는 이더리움에게 개표를 알린다. 이더리움은 이산대수를 무작위로 대입하여 yes vote의 개수를 구한다. 이전에 언급했듯, Open Vote Network는 모든 유권자들로 하여금 그들의 표에대해 개표연산을 요구한다. 이과정에서 deposit $$d$$는 등록된 유권자들에게 투표를 할 수 있는 경제적인 인센티브를 의미한다. 이는 voting protocol에 정상적으로 투표가 진행되었다면 되돌아오고, 그렇지 않다면 돌려받지 못한다. 이러한 방식을 활용하여 투표를 구현한 결과, 유권자당 최소 약 $0.73이 필요한 것이 밝혀졌다. 이는 유권자에게 최대한의 개인정보보호를 제공함과 동시에 공개적으로 검증가능하다는 것을 보았을때, 충분히 합리적인 비용으로 간주 될 수 있다. 이 논문은 블록체인을 활용한 최초의 탈중앙화된 인터넷 투표 프로토콜을 구현한 것이다. 단순히 이더리움 블록체인을 공공 게시판 성격으로 활용한 것 뿐 만 아니라 투표 프로토콜의 올바른 실행을 보장하는 컨센서스 플랫폼으로 사용한 것에 의의가 있다. 향후 블록체인을 활용하여 국가단위의 선거를 치룰 수 있는 지 또한 알아야할 논제로 남게 되었다. 만약 이것이 가능하다면, 이 구현을 위한 전용 블록체인이 필요해 질 수도 있다. 예를 들어, 오로지 e-voting 스마트 컨트랙트만을 담는 이더리움 스타일의 블록체인이 될 수 도 있다. 이 새로운 블록체인은 더 많은 정보를 담기 위해 큰 블록사이즈가 필요할 것이고, 아마도 RSCoin과 비슷한 중앙 집중형식으로 유지 될 수도 있다. RSCoin은 중앙집중화된 코인으로, 중앙은행에서 완전히 통제할 수 있는 비트코인이라고 볼 수 있습니다. 자세한 내용은 여기를 참조해주세요.","categories":[],"tags":[]},{"title":"Bitcoin) Cold Wallet","slug":"bitcoin-cold-wallet","date":"2018-06-19T15:00:00.000Z","updated":"2018-06-20T02:05:01.000Z","comments":true,"path":"2018/06/20/bitcoin-cold-wallet/","link":"","permalink":"https://www.yceffort.kr/2018/06/20/bitcoin-cold-wallet/","excerpt":"비트코인 - 콜드월렛 오늘은 역사적인 날입니다. 국내 최대 가상화폐거래소인 빗썸 거래소가 해킹으로 350억원이 털렸습니다 관련기사. 기사를 보면 자신의 자산을 콜드 월렛으로 옮겼다고 했는데요. 이 콜드월렛이 무엇인지 알아보겠습니다. 원문 콜드월렛, 또는 콜드스토리지는 비트코인을 오프라인 상태로 보관하는 것을 의미한다. 이는 특히 많은 양의 비트코인을 다룰때, 보안 목적으로 사용된다. 비트코인은 즉각적으로 출금을 할 수 있는 기능을 제공 하고 있다. 그리고 이러한 비트코인이 보한침해로 인해 훔쳐가는 것을 방지하기 위해, 웹사이","text":"비트코인 - 콜드월렛 오늘은 역사적인 날입니다. 국내 최대 가상화폐거래소인 빗썸 거래소가 해킹으로 350억원이 털렸습니다 관련기사. 기사를 보면 자신의 자산을 콜드 월렛으로 옮겼다고 했는데요. 이 콜드월렛이 무엇인지 알아보겠습니다. 원문 콜드월렛, 또는 콜드스토리지는 비트코인을 오프라인 상태로 보관하는 것을 의미한다. 이는 특히 많은 양의 비트코인을 다룰때, 보안 목적으로 사용된다. 비트코인은 즉각적으로 출금을 할 수 있는 기능을 제공 하고 있다. 그리고 이러한 비트코인이 보한침해로 인해 훔쳐가는 것을 방지하기 위해, 웹사이트 운영자는 대다수의 비트코인을 콜드 스토리지에 옮겨놓는 것이 좋은데, 이는 웹서버나 다른 컴퓨터로 부터 비트코인 지갑을 분리시키는 것을 의미한다. 그리고 서버에는 이를 출금하기 위해 필요한 최소한의 금액만 보관해 둔다. 비트코인을 콜드스토리지에 보관하는 방법은 여러가지가 있다. USB 드라이버에 넣어서 금고 같은 안전한 곳에 보관하는 방법 paper wallet. 피지컬 비트코인 Physicial-bitcoin 하드웨어 월렛을 이용한 오프라인 비트코인 Hardware Bitcoin 이와 같이 비밀/개인키를 다양한 매체에 백업하는 방법이 존재한다. 그러나 어쩄건, 이러한 방법들도 위험성이 존재한다. 예를들어 손으로 개인키 등을 작성할 경우 누가 보거나, 훔쳐가거나 손으로 잘못써서 영영 읽을수 없게되거나 잘못 옮겨졌거나 종이를 불태우거나, 찢거나 각 종 종이 자체의 손상 프린트 할 경우 누가 보거나, 훔쳐가거나 레이저 프린트가 아닌경우 젖어서 번지거나 신뢰할 수 없는 프린터로 인하여 프린팅 하는 과정에서 해킹당하거나 종이를 불태우거나, 찢거나 각 종 종이 자체의 손상 등등 사용하는 방법에 따라 각종 위험성이 존재한다. 좀 더 복잡하고 안전한 방법으로는 Deep Cold Storage 가 있다. 이는 더욱더 복잡한 방법을 사용하여 비트코인을 오프라인으로 유지하는 방법이다. 예를 들어 암호화된 월렛 파일이 있는 USB스틱을 안전한 금고에 보관하는 방법이다. 퍼블릭 어드레스를 이용하여 지갑으로 비트코인을 보낼 수느 ㄴ있지만, 비트코인을 소비하기 위해서는 암호화된 USB에 물리적으로 접근해야 한다. 이경우에는 단순히 금고를 보관하는 것을 넘어서 추가적으로 예방조치를 취해야 한다. 금고에 은행직원이나 유지보수인력이 접근할 수 있으므로 단순히 금고를 탈취하는 것 만으로는 지갑에 액세스 할 수 있어서는 안됨 금고가 재난을 맞닥들이거나 도난 당하거나, 저장장치가 손상을 당할 수 있으므로, 백업본이 반드시 존재해야 함. 수탁자가 죽거나 능력을 상실할 가능성. 지갑 보관장치의 물리적 위치를 잊어버리거나, 암호를 잊는 경우 비트코인은 영영 사라지게 된다. 암호화를 하는 것 뿐만 아니라 다른 믿을 수 있는 사람이 접근할 수 있는 규정이 있어야 한다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"}]},{"title":"Ethereum) 이더리움 백서 요약","slug":"ethereum-white-paper","date":"2018-06-19T15:00:00.000Z","updated":"2018-06-20T00:23:27.000Z","comments":true,"path":"2018/06/20/ethereum-white-paper/","link":"","permalink":"https://www.yceffort.kr/2018/06/20/ethereum-white-paper/","excerpt":"이더리움 - 차세대 스마트 컨트랙트와 탈중항화 어플리케이션 플랫폼 정확한 원문 해석은 번역본에서 참고하는 것이 더 좋습니다. 이더리움 백서 원문 ¶이더리움 이더리움의 목적은 스크립팅의 개념과 on-chain-meta-protocols, 그리고 알트코인의 기능을 한데 묶은 것이다. 나아가 개발자로 하여금 임의로 합의기반 어플리케이션을 작성할 수 있게 하여 확장성, 표준성, 기능적 완정성, 개발의 편의성을 제공하고 나아가 이러한 패러다임을 한번에 달성할 수 있게 끔 하는 것이다. 이더리움은 블록체인이라는 근본적인 기반을 제공하여","text":"이더리움 - 차세대 스마트 컨트랙트와 탈중항화 어플리케이션 플랫폼 정확한 원문 해석은 번역본에서 참고하는 것이 더 좋습니다. 이더리움 백서 원문 ¶이더리움 이더리움의 목적은 스크립팅의 개념과 on-chain-meta-protocols, 그리고 알트코인의 기능을 한데 묶은 것이다. 나아가 개발자로 하여금 임의로 합의기반 어플리케이션을 작성할 수 있게 하여 확장성, 표준성, 기능적 완정성, 개발의 편의성을 제공하고 나아가 이러한 패러다임을 한번에 달성할 수 있게 끔 하는 것이다. 이더리움은 블록체인이라는 근본적인 기반을 제공하여 이러한 것을 달성하였다. 누구든지 스마트 컨트랙트, 분산 어플리케이션을 작성하고, 소유권에 대한 임의의 규칙, 트랜잭션형식, 상태변환 함수 등을 생성할 수 있다. 이는 비트코인의 스크립팅 보다 훨씬 더 강력한 기능을 제공하는 것이다. ¶이더리움 어카운트 이더리움에서 상태는 어카운트라고 하는 오브젝트로 구성되어 있다. 어카운트는 다음 네개로 구성되어 있다. Nonce: 각 트랜잭션이 한번만 처리되게 하는 카운터 현재 어카운트의 이더 잔고 어카운트의 계약코드 어카운트 저장공간 (디폴트로 비어있음) 이더는 이더리움의 기본 내부 암호-연료고, 이는 트랜잭션의 수수료를 지불하는데 사용한다. 이런 어카운트는 두가지 종류가 있다. 외부소유 어카운트: 아무런 코드도 없고, 여기서 메시지를 보내기 위해서는 새로운 트랜잭션을 만들고 서명을 해야 한다. 컨트랙트 어카운트: 메시지를 받을 때 마다 자신의 코드를 활성화 시키고, 메시를 읽거나 내부 저장공간에 기록하고, 다른 메시지를 기록하거나 컨트랙트를 차례로 생성하게 된다. 여기서 컨트랙트란 메시지나 트랜잭션이 도착하면 일정한 코드를 실행하고, 자신의 잔고와 변수를 추적하기위해 키/값 저장소를 통제하는 역할을 한다. ¶메시지와 트랜잭션 트랜잭션이란 외부 소유 어카운트가 보낼 메시지를 가지고 있는 서명된 데이터 패키지를 의미한다. 트랜잭션은 아래오 같이 구성되어 있다. 메시지 수신처 발신처를 확인할 수 있는 서명 보내는 이더의 양 옵셔널 데이터 필드 STARTGAS (트랜잭션 실행이 수행되도록 허용된 최대 계산 수) GASPRICE (수수료) 처음 세 항목은 모든 코인에서 표준적으로 사용되는 값이다. STARTGAS와 GASPRICE는 계산낭비 드응 ㄹ방지하기 위해 각각 트랜잭션의 코드 실행 단계를 제한 하는 역살을 한다. 보통 1gas이지만, 더 많이 드는 경우도 있다. 트랜잭션의 모든 데이터는 바이트당 5gas 의 수수료가 든다. ¶메시지 컨트랙트는 다른 컨트랙트에 메시지를 전달 할 수 있다. 메시지는 다음의 것을 포함한다 메시지 발신처 메시지 수신처 메시지와 전달되는 이더 선택적 필드 GASPRICE ¶이더리움의 상태변환 함수 트랜잭션이 형식에 맞는지, 서명이 유효한지, Nonce가 발신자의 Nonce와 같은지 확인한다. 그렇지 않으면, 에러를 반환한다. 거래수수료 STARTGAS * GASPRICE를 계산하고, 서명을 이용하여 발신자의 주소를 결정한다. 발신자의 잔고에서 해당 금액을 제외하고, 발신자의 Nonce를 증가시킨다. 잔고가 충분치 않으면 에러를 반환한다. GAS를 STARTGAS와 일치키기고, 바이트당 특정 가스를 거래의 비용으로 지불한다. 발신자의 어카운트에서 수신자의 어카운트로 거래 비용을 송금한다. 만약 수신자의 계정이 없다면, 만든다. 만약 수신자의 어카운트가 컨트랙트라면, 컨트랙트 코드를 끝까지 또는 GAS 가 다 소모될때 까지 수행한다. 발신자가 잔고가 없거나, 코드 실행을 위한 가스가 부족하면 모든 상태를 원상복귀 시킨다. 여기에서 수수료 지불은 제외되고, 수수료는 채굴자 어카운트에 더해지게 된다. 메시지 실행시 가스가 부족하게 되면 ,실행과 그 실행에 의해 실행된 다른 실행들은 모두 되돌려 지만, 그 부모 실행은 돌려질 필요가 없다. 이는 컨트랙트가 다른 컨트랙트를 호출하는 것은 안전하다는 것을 의미한다. ¶코드 실행 이더리움 컨트랙트는 EVM code라고 불리우는 로우레벨 스택기반 바이트 코드 언어에서 실행된다. 보통 코드 실행은 0부터 현재 카운터를 증가시키면서 반복저긍로 연산을 수행하는 무한루프이고, 코드가 마지막에 도달하거나, 오류, STOP, RETURN 등을 만나면 멈춘다. 연산 수행을 위해서는 데이터를 저장하는 아래 세가지 타입의 공간에 접근 가능해야 한다. 스택: LIFO 컨테이너 메모리: 무한대로 확장가능한 바이트 배열 컨트랙트의 영구 저장소: 키/값 저장소. 계산이 끝나면 스택과 메모리 처럼 리셋 되지 않고 영구적으로 저장된다. ¶블록체인과 채굴 비트코인 블록체인과 유사하지만, 어느정도 차이점이 있다. 이더리움은 비트코인과 다르게 트랜잭션 리스트와 최근 상태 복사본을 가지고 있다는 것이다. 블록넘버와 난이도 또한 블록내에 저장되다. 블록 검증 알고리즘은 아래와 같다. 참조하고 있는 이전 블록이 존재하고 유효한지 확인한다. 현재 타임스탬프가 이전 것보다 크고, 현 시점 기준 15 후보다 작은 값인지 확인한다 블록넘버, 난이도, 트랜잭션 루트, 삼촌루트 (Uncle root?) 가스 제한 등이 유효한지 확인한다. 블록에 포함된 작업증명이 유효한지 확인한다 S[0] 가 이전 블록의 상태 루트라고 가정하자. TX가 n개의 트랜잭션을 가진 블록이라고 하자. 0 부터 n-1에 대해, S[i+1] = APPLY(S[i], TX[i]) 로 설정하자. 어플리케이션이 오류를 뱉거나, 이 시점까지 블록에서 소모된 총 gas가 GASLIMIT를 초과하면 오류를 반환한다. 채굴자에게 지불된 보상블록을 S[n] 덧붙힌 뒤에 이것을 S_FINAL이라고 한다. S_FINAL의 머클 트리 루트가 블록헤더와 같고 있는 최종상태 루트와 같은지 확인한다. 같으면 유효, 다르면 유효하지 않은 것으로 판단한다. ¶어플리케이션 이더리움을 이용하면, 총 세가지 종류의 어플리케이션을 제작할 수 있다. 돈과 직접 연관된 컨트랙트를 계약 참여자로 하여금 강력하게 설정하고 관리하게 끔 하는 금융 어플리케이션 금전이 관여 되어 있지만, 상당부분 비 화폐적인 면이 존재하는 계약을 위한 어플리케이션 온라인투표, 분권형 거버넌스와 같이 금용과 관련성이 아예 없는 어플리케이션 ¶결론 이더리움 프로토콜은 범용적인 프로그래밍 언어를 통해, 블록체인상 에스크로나 인출한도 설정, 금전계약 등의 기능을 제공하는 가상화폐의 업그레이드 버전으로 구성되어 있다. 이더리움 프로토콜은 이런 기능을 직접 제공하는 것이 아니라, 튜링완전 언어를 통해 거의 모든 형태의 이체방식이나 어플리케이션을 만들어낼 수 있도록 지원한다. 이더리움은 단순 화폐 차원을 뛰어 넘는다. 분산저장공간이나, 분산컴퓨팅, 분산예측시장 프로토콜은 이더리움이 할 수있는 많은 응용개념 중 하나에 불과하다. 이러한 새로운 개념들은 이더리움이 컴퓨터 산업의 효율성을 폭발적으로 증강시킬 수 있는 가능성을 가지고 있으며, P2P프로토콜에 경제적인 레이어를 씌워 엄청난 혁신을 가져올 수 있을 것이다. 마지막으로, 컴퓨터나 금융이 관련없는 분야에서도 다양한 어플리케이션이 나올 것이다. 이더리움 프로토콜이 제공하는 임의상태변환이라는 개념은 잠재력을 지닌 플랫폼을 만들 수 있게 해준다. 기존의 하나의 목적에 특화된 폐쇄된 구조와 달리, 이더리움은 자유롭게 조정이 가능한 오픈된 구조다 이더리움이 몇년이내에 다양한 분야에서 많은 분야의 서비스를 설께할 수 있도록 튿화된 기반이 될 수 있을 것이다.","categories":[],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"https://www.yceffort.kr/tags/blockchain/"},{"name":"ethereum","slug":"ethereum","permalink":"https://www.yceffort.kr/tags/ethereum/"}]},{"title":"Bitcoin) 비트코인 마이닝의 취약점","slug":"majority-is-not-enough-bitcoin-mining-is-vulnerable","date":"2018-06-19T15:00:00.000Z","updated":"2018-06-19T22:39:57.000Z","comments":true,"path":"2018/06/20/majority-is-not-enough-bitcoin-mining-is-vulnerable/","link":"","permalink":"https://www.yceffort.kr/2018/06/20/majority-is-not-enough-bitcoin-mining-is-vulnerable/","excerpt":"다수로는 부족하다. 비트코인 마이닝의 취약점 원문 비트코인 프로토콜은 대부분의 Miner들이 정직하게 행동하는 것을 필요로 한다. 이는 비트코인 프로토콜에서 요구되는 사항이다. 만약 일련의 Miner들이 다수의 마이닝 파워를 네트워크에서 형성하게 된다면, 통화는 더 이상 탈중앙화를 할수 없게 되고 이런 다수의 지배를 받게 되고 말 것이다. 이렇게 되면, 이 그룹은 특정 혹은 모든 트랜잭션을 통제할 수 있게 된다. 그러므로, miner들 다수가 조직적으로 움직이는 것에 대해서 인센티브가 없게 끔 설게가 되어야 한다. 이러한 실증","text":"다수로는 부족하다. 비트코인 마이닝의 취약점 원문 비트코인 프로토콜은 대부분의 Miner들이 정직하게 행동하는 것을 필요로 한다. 이는 비트코인 프로토콜에서 요구되는 사항이다. 만약 일련의 Miner들이 다수의 마이닝 파워를 네트워크에서 형성하게 된다면, 통화는 더 이상 탈중앙화를 할수 없게 되고 이런 다수의 지배를 받게 되고 말 것이다. 이렇게 되면, 이 그룹은 특정 혹은 모든 트랜잭션을 통제할 수 있게 된다. 그러므로, miner들 다수가 조직적으로 움직이는 것에 대해서 인센티브가 없게 끔 설게가 되어야 한다. 이러한 실증적인 예로 비트코인 Miner들이 전략적으로 뭉쳐 마이닝 풀을 형성한 것을 들 수 있다. 비트코인 시스템 내에서 보상은 랜덤한 간격으로 드물게 주어지기 때문에, Miner들은 각각의 암호화 퍼즐을 풀기위해 뭉치고, 이로 인해 생성된 보상을 적절하게 나눠갖게 된다. 아직까지, 이러한 마이닝 풀은 프로토콜을 잘 따르며 온건하다. 이러한 전통적인 사실은 비트코인은 인센티브 하에서 경쟁적이라고 이야기 하며, 이성적인 소수의 마이닝 풀은 정직하게 행동하는 것이 최선의 전략이고, 이는 소수의 마이너들이 프로토콜을 어긴다면 이득을 얻을 수 없다는 것다고 말한다. 프로토콜은 마이너들이 그의 채광력의 비례하여 Miner들에게 동일하게 보상을 주는 것으로 믿기 때문에, 큰 마이닝 풀은 작은 마이닝 풀과 같은 비율로 이득을 얻는다고 생각한다. 결과적으로 Miner들을 더 응집시켜 큰 마이닝 풀로 만드는데에 이점이 없다. 따라서 정직하고 합리적인 Miner들의 풀 형성은 시스템에 아무런 위협이 되지 않는다는 결론을 내린다. 그러나 이 논문에서는, 비트코인은 인센티브하에서 경쟁적이지 못하다는 것을 보여준다. 비주류 마이닝 풀이 그들이 가질 수 있는 비율 보다 더 많은 이득을 얻는 것이 가능하며, 이러한 이들은 그들이 가진 컴퓨팅 파워의 이상을 창출해 낼 것이다. 이 전략을 Selfish-mining이라고 한다. Selfish Mining 이란 마이닝 풀이 블록을 발견하면 이를 알리는 것이 아니라 개인적으로 소유하여, 내부 체인에 포킹을 하는 전략을 말한다. 정직한 노드는 퍼블릭 체인에서 계속 채굴할 것이며, 이 동안 Selfish mining에서는 프라이빗 브랜치에서 소유하고 있는다. 그리고 이들은 새로운 프라이빗 블록을 계속해서 채굴하면서 퍼블릭 체인 보다 더 긴 체인을 만든다. 이 과정에서, 퍼블릭 체인이 가짜 체인의 길이와 같아진다면, selfish miner들은 이 블록을 퍼블릭체인에 공개한다. 이 전략은 정직한 비트코인 프로토콜을 따르는 Miner로 하여금 암호화 퍼즐을 푸는데 자원을 낭비하게 함으로써 종국에는 이러한 작업이 아무런 의미가 없게 되어 버린다. 이 논문에서는, 정직하고 selfish한 miner 모두 어느정도 자원을 낭비하지만, selfish 풀의 보상은 네트워크에서 재공할 수 있는 양보다 초과하여 받을 수 있다. 결국 이는 모두 이성적인 Miner들이 모두 selfish mining에 참여하게 되는 유인이 된다. 이는 곧 블록체인 시스템에 치명적인 부분으로 작용할 것이다. Selfish miner들이 일정 한계점에 도달하게 되면, 이성적인 Miner들은 모두 selfish 마이닝 풀에 참여하게 될 것이고, 이들은 곧 비트코인 네트워크에서 주류로 자리잡게 될 것이다. 그리고 이들이 유일한 블록 채굴자들이 되는 순간, 화폐의 탈중앙화 성격은 무너질 것이고 특정 시점에서는 결국 이들이 시스템을 통제하게 될 것이다. 이러한 Selfish miner들이 전체네트워크의 1/3을 차지 하면 이 시스템이 더이상 안전하지 않게 된다. 그렇기 때문에, 이 논문에서는 비트코인 프로토콜이 전체대비 1/4의 threshold를 달성하도록 수정을 제안한다. 이러한 변경은 소급적용 가능하며 점진적이다. 현재 클라이언트에 큰 변화 없이 적용하며, 부분적으로 threshold를 증가시킬 수도 있다. ¶문제점 비트코인 프로토콜은 만약 채굴자들이 같은 길이의 여러 브랜치를 인지하게 되면, 마이너들은 전달받은 마인중 가장 첫번째 브랜치에서 채굴하고 전파하도록 정해져 있다. Selfish Mining 전략은 정직한 채굴자들이 블록 X를 발견했다는 사실을 인지하면, 그둘 중 하나는 미리 발견하고 숨겨놓았던 블록 P를 공개한다. 만약 블록 P 가 다른 마이너들에게 블록 X보다 먼저 도달하게 된다면, 다른 채굴자들은 P를 채굴하기 시작할 것이다. 이렇듯 Selfish mining전략은 다른 정직한 노드가 블록 X를 발견한 뒤에만 반응할 수 있기 때문에 비효율적으로 보일 수 있다. 그러나 이러한 공격자들은 비트코인 채굴 네트워크에 제로파워인 수많은 마이너들을 추가하여 정직한 채굴자들에게 sybil-attack을 가하라 수 있다. 이런 가상의 채굴자들은 데이터를 네트워크에 전송하는 일만 할 뿐, 채굴은 전혀 실행하지 않는다. 이러한 가상의 채굴자들이 블록 X를 발견했다는 사실을 인지하게 되면, 그것을 무시하고 새롭게 블록 P를 전파하기 시작한다. 비트코인 네트워크는 랜덤한 P2P구조를 가지고 있기 때문에, X의 전파속도는 다수의 가짜 채굴자를 보유한 P의 전파속도보다 느릴 수 밖에 없다. 가상의 노드를 추가함으로써, Selfish miner 들은 이득을 취할 수 있게 된다. γ (정직한 노드의 비율) threshold 알파는 프로토콜을 따르는 정직한 노드들을 이기는데 필요한 최소 컴퓨팅 파워를 의미한다. 비트코인의 경우 이에 따른 제한이 없으므로, 항상 selfish mining이 우세할 수 있는 구조를 가지고 있다. 물론 현실적으로 이는 가능하지 않겠지만, (모두가 selfish 채굴자가 되는것) selfish-miner 절반이 이득을 보기 위해서는 1/4의 컴퓨팅 파워만 있으면 된다. ¶해결책 프로토콜단에서 마이너가 데이터를 전파하는 것을 통제함으로써 selfish mining의 능력을 감소시킬 수 있다. 이러한 개선은 다른 채굴자들과의 변화와는 독립적이므로, 별다른 하드포크를 필요로 하지 않는다. 이러한 프로토콜의 변경은 프로토콜에 새로운 취약점을 가져오지 않는다. 현재 길이가 같은 두가지 분기가 있을 경우 miner의 선택은 임의적이며, 이는 네트워크 구조와 레이턴시에 영향을 받는다. 논문에서 제안하는 변화는, 이러한 임의의 선택을 명확하게 무작위화 하므로, 또다른 취약점이 발견 되지 않는다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"}]},{"title":"Bitcoin) 비트코인 백본 프로토콜, 분석과 어플리케이션","slug":"bitcoin-backbone-protocol","date":"2018-06-18T15:00:00.000Z","updated":"2018-06-18T20:05:34.000Z","comments":true,"path":"2018/06/19/bitcoin-backbone-protocol/","link":"","permalink":"https://www.yceffort.kr/2018/06/19/bitcoin-backbone-protocol/","excerpt":"비트코인 백본 프로토콜 출처 비트코인은 분산 환경에서 공공원장 시스템을 유지 하기 위한 탈중앙화 시스템으로 나카시 사카모토에 의해 처음 소개 되었다. 원장은 miner라고 불리우는 익명의 참여자들에 의해 유지되는데, 이들은 블록체인이라고 불리우는 분산 데이터 구조에서의 프로토콜을 실행하는 일을 담당하고 있다. 이 프로토콜은 Miner들로 하여금 'Proof-of-work (aka 암호화된 퍼즐)'을 하게 만드는데, 이 작업은 블록체인에서 새로운 블록을 만들기 위해 SHA-256으로 암호화된 해쉬의 원본 값을 brute-forci","text":"비트코인 백본 프로토콜 출처 비트코인은 분산 환경에서 공공원장 시스템을 유지 하기 위한 탈중앙화 시스템으로 나카시 사카모토에 의해 처음 소개 되었다. 원장은 miner라고 불리우는 익명의 참여자들에 의해 유지되는데, 이들은 블록체인이라고 불리우는 분산 데이터 구조에서의 프로토콜을 실행하는 일을 담당하고 있다. 이 프로토콜은 Miner들로 하여금 'Proof-of-work (aka 암호화된 퍼즐)'을 하게 만드는데, 이 작업은 블록체인에서 새로운 블록을 만들기 위해 SHA-256으로 암호화된 해쉬의 원본 값을 brute-forcing방법을 통해 무작위로 찾아내는 과정이다. 블록은 비트코인 소유자들로 부터 만들어진 일련의 거래내역을 포함하고 있으며, 비트 코인으로 지불을 수락하는 임의의 엔티티를 신용하는 트랜잭션을 발행한다. 지불한사람은 이 거래내역을 브로드 캐스팅하고, Miner는 그들이 발행하는 블록에 이러한 거래내역을 포함시킨다. Miner들은 이렇게 블록체인을 유지시키는 대가로 비트코인을 받게 된다. 비트코인의 가장 중요한 부분은 이중 지불 공격을 막는 것이다. 비트코인의 맥락에서는, 공격자가 최초에 account를 신용하여 account holder에게 상품이나 서비스를 제공받은 다음, 거래원장을 재구성하여 이러한 신용거래를 되돌릴때 이중지불 공격이 가능해진다. 이 경우, 공격자는 서비스를 받을 때까지 비트코인을 소유하게 되므로 다른 곳에다 이 비트코인을 다시 쓸 수 있게 된다. 이를 방지하기위하여, 사토시는 비트코인 시스템에 이중지불공격을 막을 수 있는 방법을 제시하였다. 특히, 수신자 (돈을 받는 사람)가 해당 거래이 포함된 불록이 k개 생성될때 까지 기다린다면, 공격자가 이러한 신용거래가 포함된 다른 블록체인을 만들어 퍼블릭 블록체인을 재구성하는 것이 성공할 확률이 k만큼 기하 급수적으로 떨어진다고 하였다. Nakamoto는 이렇게 k 블록 만큼 기다리는 것이 공격자가 정직한 참여자를 따라잡을 수 있는 확률을 희석시키는데 충분하다고 주장하였다. 그럼에도 불구하고, 이러한 분석은 과하게 생략된 경향이 있다. 특히, 비트코인의 탈중화된 설정이, 공격자가 정직한 Miner들 사이에 불일치를 삽입하여 그들의 hashing power를 감소시킬수도 있다는 사실에 대해 충분히 설명하지 않았다. (올바르지 않은 거래를 삽입하여, miner들이 이러한 거래를 블록으로 만드는데 자원을 낭비하게 할 수 있다는 뜻) 그러나 Bitcoin 시스템의 정확한 보안 특성을 확립하는 철저한 분석은 아직 까지 연구되지 않았다. 이 논문에서는 , 비트코인 백본이라고 불리우는, 공공 거래 원장 관련 문제를 해결하는 것 뿐 만 아니라 다재다능하고 확장가능한 프로토콜을 설명하고 있다. 비트코인백본은 블록체인을 만들기 위해 비트코인 소스 코드 기반을로 실행되며, 일련의 참여자들이 분산화된 환경에서 블록체인을 유지할 수 있게 끔 해준다. 이 프로토콜은 content validation predicate, input contribution function, chain reading function이라고 하는 함수로 구성되어 있다. (V) Content Validation predicate: 블록체인 내에서 정보가 적절한 구조로 저장될 수 있게 하는 역할 (I) Input Contribution Function: 블록의 내용이 어떻게 구성되어 있는지 ® Chain Reading Function: 블록체인이 어플리케이션 단에서 어떻게 보여지는지 참여자들은 서로의 신원을 인증하지 않으므로 메시지의 원출처를 알수가 없다. 대신 참여자들이 상대방에게 전달된 메시지의 원본주소를 &quot;spoof (도용?)&quot;하게 함으로써 메시지가 어디서 부터 배달된지 알 수 있게 해준다. 결국 이러한 메시지가 전달되어 네트워크 내에 모든 당사자들이 이러한 “라운드” 과정에서 동기화 될 수 있다고 가정한다. 이러한 “라운드” 라는 개념은 백본 프로토콜에는 중요하지 않지만, 참여자들이 작업증명을 생산하는 능력을 가정하는데에서 중요하게 작용한다. 작업중…","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"}]},{"title":"Bitcoin) 비트코인과 빨간풍선","slug":"on-bitcoin-and-red-balloons","date":"2018-06-18T15:00:00.000Z","updated":"2018-06-19T03:00:23.000Z","comments":true,"path":"2018/06/19/on-bitcoin-and-red-balloons/","link":"","permalink":"https://www.yceffort.kr/2018/06/19/on-bitcoin-and-red-balloons/","excerpt":"비트코인과 빨간풍선 출처 2009년 국방부는 미국 전역에 흩어진 10개의 빨간 풍선을 10개를 먼저 찾으면, 4만달러를 준다는 이벤트를 한 적이 있다. 이는 방위고등연구계획국(이하 DARPA)에서 인터넷의 정보 확산의 속도와 정확도를 측정하기에 한 실험이었다. 참고로 이곳은 인터넷을 만든 곳이기도 하다. 최초에 DARPA는 모든 풍선을 다 찾는데 9일 정도를 예상헀지만, MIT의 팀은 겨우 9시간만에 모든 풍선의 위치를 찾는데 성공하였다. 그들이 이용한 방법은 아래와 같다. 풍선을 찾은 사람에게는 $2000를, 풍선을 찾","text":"비트코인과 빨간풍선 출처 2009년 국방부는 미국 전역에 흩어진 10개의 빨간 풍선을 10개를 먼저 찾으면, 4만달러를 준다는 이벤트를 한 적이 있다. 이는 방위고등연구계획국(이하 DARPA)에서 인터넷의 정보 확산의 속도와 정확도를 측정하기에 한 실험이었다. 참고로 이곳은 인터넷을 만든 곳이기도 하다. 최초에 DARPA는 모든 풍선을 다 찾는데 9일 정도를 예상헀지만, MIT의 팀은 겨우 9시간만에 모든 풍선의 위치를 찾는데 성공하였다. 그들이 이용한 방법은 아래와 같다. 풍선을 찾은 사람에게는 $2000를, 풍선을 찾은 사실을 전한 다음 사람에게는 $1000을, 그 사실을 전달하는 다음 사람에게는 $500 형식으로, 풍선에 대한 정보가 한단계 씩 넘어 갈 때 마다 2000에서 절반의 보을 준 것이다. 이 방법을 활용할 경우, 최초 보상 n의 두배를 넘지 않는다. 이 전략은 유효했고, MIT팀은 승리할 수 있었다. 비트코인으로 돌아가보자. 비트코인은 P2P네트워크를 사용하므로, 모든 거래내역을 노드가 인지하기 위해서 네트워크로 해당 거래 내역을 전파해야 한다. 그러나 현재 비트코인 구조에서는, 거래내역을 전파한다고 해서 특별한 인센티브가 부여되지 않는다. 오로지 block을 만드는 Miner에게만 인센티브가 제공되는 것이다. 만약 MIT의 빨간 풍선처럼, 해당 정보를 전파한 사람들에게도 인센티브가 부여된다면 보다 효과적으로 블록체인 네트워크가 동작할 수 있지 않을까? 이 논문에서는 이러한 전략을 Sybil-proofness라고 한다. 이 논문에서는 아주작은 payment overhead만 있다면, 반복적으로 우월전략을 제거함으로서 이러한 전략을 달성할 수 있다고 주장한다. 다시 빨간풍선 찾기로 돌아와보자. 만약 빨간풍선이 나타났다라고 속이는 사용자가 있고, 그 속인 사실을 전파하는 사용자가 반복해서 발생한다면 이 전략은 유용하지 않게 된다. 비트코인도 마찬가지이기 때문에 정보를 올바르게 전파하는 노드에게는 인센티브를, 그리고 이러한 경쟁에서 발생하는 인센티브를 상쇄해야 한다. 비트코인은 P2P 네트워크에 의존하여 모든 거래를 확인하고 승인한다. 앨리스가 호텔에 30 비트코인을 지불한다고 가정해보자. 그녀는 암호로 30비트코인을 주는 거래에 사인한다. 네트워크의 노드들은 이 거래 내역을 다른 노드에게 알린다. 트랜잭션을 수신한 노드는 해당 거래가 정말 앨리스가 사인했는지 확인할 것인하고, 실제로 해당 거래에서 그 금액이 그녀의 소유인지 확인한다. 그리고 노드는 그 거래를 승인하기 위하여 컴퓨터 퍼즐을 풀 것이다. (hash function 으로 암호화 되어 있으므로) 만약 이 노드가 성공적으로 거래를 승인했다면 (hash의 원래값을 찾았다면) 다른 모든 노드에 전파할 것이다. 결국 네트워크 상의 모든 노드들은 해당 거래 내역에 대해 동의할 것이다. 이런 거래 승인 과정을 장려하기 위해, 거래를 성공적으로 승인한 노드에게는 미리 주어진 양의 비트코인이 보상으로 주어진다. 그리고 이는 비트코인의 공급으로 작용한다. 그러나 비트코인 프로토콜은 총 비트코인의 양에 제한을 두기위해 화폐 창출속도가 기하급수적으로 감소 하도록 설계하였다. 노드에서 이런 지불이 서서히 작아지기 때문에, 비트코인 소유자들은 이러한 거래를 승인하기 위해서 승인 노드에 수수료를 지불해야 한다. 바로 이 지점이 문제다. 노드는 가장 먼저 이 거래내역을 알아내고 승인함으로써 거래 수수료를 취할 수 있기 때문에, 네트워크에서 전파되는 정보를 알 수 있는 동기가 부여되는 것이다. 그런데 만약, 단하나의 노드가 트랜잭션을 인지하고 있다면, 이 거래를 전파하지 않음으로서 경쟁자들을 제거하는 효과를 가져올 수 있다. 경쟁이 없다면, 해당 노드는 결국 수수료를 챙기는데 성공하게 될 것이다. 그리고 이는 결과적으로 승인에 오랜기간이 소요되게 할 것이다. 이를 해결하기 위해서 첫번째로, 정보를 전파하는 것과 중복이 없는 것에 인센티브를 부여한다. 이렇게 한다면, 노드가 스스로 정보를 복제하지 않고 거래내역을 전파하는 것에 인센티브를 갖게 될 것이고, 또한 거래가 승인이 될때까지 복제하지 않을 동기도 갖게 될 것이다. 두번째로, 거래내역이 전파되는 마지막 단계에서 대부분의 노드가 해당 트랜잭션을 알수 있도록 한다. 마지막으로, 이를 구현하고 initial distribution 단계에서 부담을 줄이기 위해, 작은 양의 reward만을 사용한다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"}]},{"title":"Blockchain) 비트코인과 암호화폐의 연구관점 및 과제","slug":"research-perspectives-and-challenges-for-bitcoin-and-cryptocurrencies","date":"2018-06-17T15:00:00.000Z","updated":"2018-06-18T00:45:00.000Z","comments":true,"path":"2018/06/18/research-perspectives-and-challenges-for-bitcoin-and-cryptocurrencies/","link":"","permalink":"https://www.yceffort.kr/2018/06/18/research-perspectives-and-challenges-for-bitcoin-and-cryptocurrencies/","excerpt":"비트코인과 암호화폐의 연구관점 및 과제 출처 아직 이해가 온전하지 못하다. 일단은 계속해서 작업중인 버전이라는 것을 말씀드리고 싶다. 비트코인 백서가 출간된 이후로, 비트코인을 비롯한 수많은 알트코인이 등장하기 시작했다. 이러한 화폐들 간의 Consensus mechanism, Currency Allocation mechanism, computational puzzles, and key management tools에 대해 비교 분석하였다. 또한 비트코인의 익명성 문제를 조사하고, 다양한 개인 정보 보호를 위한 프레임워크를 소","text":"비트코인과 암호화폐의 연구관점 및 과제 출처 아직 이해가 온전하지 못하다. 일단은 계속해서 작업중인 버전이라는 것을 말씀드리고 싶다. 비트코인 백서가 출간된 이후로, 비트코인을 비롯한 수많은 알트코인이 등장하기 시작했다. 이러한 화폐들 간의 Consensus mechanism, Currency Allocation mechanism, computational puzzles, and key management tools에 대해 비교 분석하였다. 또한 비트코인의 익명성 문제를 조사하고, 다양한 개인 정보 보호를 위한 프레임워크를 소개한다. 마지막으로 disintermediation protocols에 대한 새로운 통찰력을 제공한다. 이는 일련의 과정에서 신뢰할 수 있는 중개자의 필요서을 제거한다. 세가지 일반적인 disintermediation 전략을 확인하고, 이에 대한 상세한 비교를 보여준다. ¶1. 왜 비트코인이 연구 가치가 있는가 첫번째, 비트코인은 현실세계에서 놀랍도록 잘 동작하고 있지만, 왜 가능했는지 정확하게 파악하는데 이 연구가 중요한 역할을 할 것이며, 시스템 초기 제안서 (사토시 나카모토의 백서 같은) 에 제시된 비공식적 주장을 맹목적으로 받아드리는 것 이상의 가치를 지닐 것이다. 두번째, 비트코인은 신뢰 할 수 있는 제3자가 필요 없고, 거래 당사자들 사이에 가상 통화 시스템을 제공하여 중요한 틈새시장을 채우고 있다고 주장한다. 다시 말해, 비트코인을 모델링 하는 것은 쉽지 않지만, 매우 어렵고 중요한 문제들에 실질적인 해결책의 기초를 제공하기 때문에, 상당한 연구가치가 있다고 볼 수 있다. 이 연구의 목표는 이와 같은 새로운 지불 프로토콜에서 사용자 친화적인 키 관리에 이르기까지, 중요한 혁신이 발생한 많은 영역에 대해 강조하고, 비트코인 및 향후 알트코인에 대한 가장 중요한 공개 연구과제를 강조하는 것이다. ¶2. 비트코인 개론 ¶A. 대략적인 역사. 1983년, 암호화된 화폐가 Chaum에 의해 처음으로 제시 됐는데, 이는 '추적 불가능한 지불’을 구현 하기 위함이었다. 상인과 고객 사이화폐거래는 은행이 이전에 이 통화가 상환되지 않았는지 확인한 뒤에야 가능하다. 이를 위해 Blind Signature는 은행이 사용자를 화폐와 관련 지을 수 없게 하여 현금과 비슷한 연결불가능성을 제공하는 것이다. 1990년 대에 이르러 많은 제안이 있었다. 온라인 거래를 위한 은행의 필요성 제거, 화폐를 작은 단위로 송금하는 기술, 일부 스타트업에서는 DigiCash나 Peppercoin등을 내놓기도 했다. 그러나 어떠한 것도 주요한 발전을 이뤄내진 못했다. 비트코인에서 핵심인 요소는 'Proof-of-work’와 'public legder’이 두가지다. 이를 해결 하기 위해 많은 연구들이 이뤄졌다. 그러다 2008년, 사카시 나카모토에 의해 비트코인 백서가 발간되었고 첫번째 비트코인 블록이 2009년 3월에 등장했다. 그 이후로, 비트코인은 급속도로 발전하기 시작했다. ¶B. 기술적인 개론 비트코인을 기술적인 부분 3가지로 나누면 Transaction (script 포함) Consensus protocols Communication Network 정도로 나눌 수 있다. ¶1. Transaction and script 비트코인은 transaction이라고 불리는 일련의 message로 구성되어 있다. 다른 것들 중에서도, 유저와 다른 사람들 간의 송금을 구현하기 위해 거래가 제일 먼저 생성된다. 큰 규모의 (그리고 점점 증가하는) 거래목록이 비트코인의 유일한 상태임에 유의 해야 한다. 유저, 잔고 같은 개념은 존재 하지 않는다. 이러한 개념들은 공개된 거래 목록에서 귀속될수 있는 정도까지만 존재한다. Transaction Format 거래는 입력값의 배열과 출력값의 배열로 구성되어 있다. 거래는 SHA256으로 복호화 되어 있다. 그리고 이는 유니크한 거래 ID로 활용 된다. 각각의 아웃풋은 비트코인 화폐의 가치를 표현하는 숫자로 구성되어 있다. 가장 작은 단위는 사토시다. 10^8 사토시가 보통 하나의 통화 단위다. 또한 scriptPubKey라고 하는 특별한 code snippet을 가지고 있는데, 이는 다음번 거래에 사용될 수 있는 조건을 포함하고 있다. Transaction Script ‘Pay-to-pub-key-hash’ 트랜잭션은 지정된 해시가 있는 키를 사용하여 전체 트랜잭션에 서명한다. 비트코인 거래의 대다수는 이러한 해시를 사용하며, 다른 트랜잭션 유형도 가능하지만, 보통 이 방법이 유일한 가능성이라고 설명한다. 트랜잭션 입력은 해시 및 해당 트랜잭션의 출력 배열내 출력 색인에 의한 이전 트랜잭션을 나타낸다. Conservation of value 각각의 트랜잭션 인풋이 이전 트랜잭션의 아웃풋과 일치해야 하는 것 과 더불어, 모든 트랜잭션의 출력값의 합계는 모든 인풋값의 합계보다 작거나 같아야 한다. From transaction to ownership 비트코인의 소유를 증명하는 identity나 개인 계좌라는 개념 자체는 없다. 소유라고 하는것 은 단순히 특정 아웃풋을 서명할 수 있는 개인 키를 의미한다. 그리고 개개인은 사용할 수 있는 비트코인을 소유할 수 있다. Public Key Hash는 시스템 내에서 ID로 효과적으로 작동하며, 주소라고 명한다. 그리고 실제 이름이나 식별정보는 필요로 하지 않는다. ¶2. Consensus and Mining 비트코인은 이중 지불 공격을 해결하기 위한 간단한 방식을 취한다. 모든 거래는 글로벌 트랜젹선 로그에 게시되어야 하며, 개별 트랜잭션 출력은 한번의 후속 트랜잭션에섬나 사용될 수 있다. 트랜잭션을 확인하기 위해서는 스크립트를 확인하고 성공적으로 게시되었는지 확인해야한다. 이러한 로그는 일련의 블록으로 구현되며, 각각 이전 블록의 해시를 포함하여 이 블록을 유일한 이전 블록으로 커밋한다. 이것이 바로 블록체인이다. 이를 위해서는 글로벌한 합의 절차가 필요하다. Nakamoto Consensus 비트코인은 분산된, 나카모토 합의라고 불리는 유사한 프로토콜을 통해 브록체인에 대한 합의를 확립한다. 누구든 유효한 거래를 모아서 블록을 만들어 추가하는 작업을 시도할 수 있다. 여기서 핵심은 컴퓨터적으로 어려운 퍼즐을 사용하여, 누구의 블록이 다음블록으로 유효한지 결정하게 끔 하는 것이다. 새로운 블록을 선택하는 과정은 간단하다. 어려운 퍼즐에 대한 올바른 답을 첫번째로 알리는 블록이 유효한 블록이 되는 것이다. 그 이후 다른 참가자들은 후속 블록을 찾기위해 노력한다. 만약 이렇게 알려진 블록에 잘못된 트랜잭션이 있거나 잘못 만들어 진다면, 다른 참가자들은 유효한 블록에 대한 해결책을 찾을때 까지 해당 블록을 거부하고 작업을 계속한다. 합의 블록체인은 가장 긴 버전의 체인이다. 두가지 비슷한 버전의 체인이 거의 비슷한 시기에 나타날 수 있다. (네트워크 지연 등) 그러나 컴퓨터 퍼즐의 무작위적 성질 때문에 한 체인이 다른 체인보다 더 길어질 것이고, 다른 사람들도 그 체인을 받아드릴 것이다. block information 이런 특성상, 사용자가 블록이 발견될때 까지 기다려야 블록체인에 트랜잭션이 영구적으로 포함된다는 신뢰를 얻을 수 있다는 것을 의미한다. 그러나 최악의 경우 이중 지출 공격이 가능하게 될 수 있다. 그러나 miner들이 기본 프로토콜을 따른다면, 더 많은 확인 블록이 발견됨에 따라 트랜잭션이 기하급수적으로 증가하여 결국 가장 긴 체인에 도달할 가능성이 높다. 실제로 대부분의 비트코인 클라이언트는 트랜잭션을 수락하기전에 6개의 확인 블록을 필요로 한다. 6개의 블록은 임의로 선택할 수 있다. Incentivizing correct behavior 이 프로토콜의 중요한 요소중 하나는, 블록을 발견한 참여자가 지정된 금액의 통화를 발행하고, 선택한 주소로 전송되는 트랜잭션을 삽입하라 수 있다는 것이다. 참가자들은 금전적 보상과 교환하여 이 계산 퍼즐을 해결하기 위해 노력하고 있다. 블록보상이라고 하는 이 새로운 화폐는 miner 에게 유효한 블록에서만 작동하도록 인센티브를 준다. 이 합의 알고리즘은 금전적 보상에 의존하기 때문에 양도할 수 있는 개념이 없는 시스템에서는 사용될 수 없다. 비트코인내에서는 이 외에 돈을 만들 수 있는 메커니즘은 없다. Mining Details 이런 퍼즐은 암호화 해시 함수인 SHA 256에 대한 pre-image를 찾는 것을 목표로한다. 퍼즐은 연속적인 0 비트로 시작하는 값을 찾는 것으로 묘사된다. 이에 대한 일반적인 전략은 랜덤 nonces를 대입하는 것이다. 이런 무작위성은 굉장히 중요하다. 그렇지 않다면, 가장 강력한 컴퓨팅 파워를 가진 마이너가 모든 블록을 찾아갈 것이기 때문이다. 이런 무작위성은 모든 miner들이 블록을 가져갈 수 있는 확률을 제공한다. 난이도는 평균 10분마다 한번씩 발견될 수 있도록 보정된다. 이를 유지하기 위해, 2016 블록 또는 2주에 한번씩 보정된다. Mining rewards and fee 블록발견 보상의 크기는 고정된 스케쥴에 의해 결정된다. 첫 블록은 50비트코인, 그리고 25비트코인으로 쪼개진 뒤로 2140년까지 절반으로 계속해서 줄어들 것이며, 이 때까지는 새로운 비트코인이 만들어지지는 않을 것이다. 통화가치 하락을 가능하기위해, miner들은 블록보상을 통해 이익을 얻는 것 뿐 만 아니라, 출력값보다 입력값이 큰 블록에서 거래수수료도 가져갈 수 있다. 현재까지 거래수수료는 주로 많은 소규모 거래로 네트워크 과용을 막는데 사용하여 채광 수익의 1~2% 이상을 제공하지 못했다. Mining Pools 일반적으로, miner들은 마이닝 풀을 만들어 함께 채굴하고 그들의 이익을 나눠가졌다. 마이닝 풀은 보통 일정 수수료를 받는 관리자가 유효한 블록을 찾아내서 획득한 보상을 참여자들에게 나눠주는 방식으로 운용된다. 참여자들은 자신이 채굴에 기여한 정도를 확률적으로 증명해야 한다. 이러한 마이닝풀은 기존 프로토콜에서는 예상치 못한 움직임이었지만, 2013년 이후로 이러한 풀을 조직화 하는 것은 일반적인 일이 되었다. Pool에서 생성된 수익을 나누기 위한 많은 종류의 공식이 생겨나기 시작했다. ¶3. Peer to peer Communication Network 비트코인은 탈중앙화 되어 있기 때문에, 새로운 거래와 블록을 네트워크에 알리는 것이 필요하다. 이는 앞서 언급한 3가지 컴포넌트 중 가장 변화가 적고, 다른 알트코인에서도 대부분이 비슷한 방법을 따르고 있다. Impact on consensus 네트워크 성능과 안정성은 합의 프로토콜에 중요한 영향을 미친다. 블록 발견에 대기시간이 길어지면, 일시적인 포크가 많아 질 가능성이 존재한다. 또한 네트워크 상당부분을 장학하는 악의적인 유저는 자신의 블록을 악의적으로 퍼트려 해당 블록이 승리하게 끔 할 수도 있다. 따라서 비트코인은 분산된, 짧은 대기시간과 메시지를 검열하고 지연시키기 어려운 시스템을 갖추는 것이 중요하다. Network topology and discovery 모든 노드는 다른 무작위 노드에 연결하여 네트워크에 가입할 수 있다. 기본적으로 8개의 나가는 연결을 시도하며, 최대 125개의 수신이 가능하다. 네트워크에 처음가입하면, 비트코인은 하드코딩된 전용 디렉토리서버 또는 '시드노드’를 사용한다. 피어는 또한 서로 다른 메커니즘을 통해 정보를 전파한다. 노드가 나가는 연결을 하면, 연결정보를 포함하는 일련의 트레이 메시지를 전달한다. 또한 들어오는 연결을 수신하면 노드는 피어에게 알려진 주소목록에서 샘플을 요청한다. Communication protocol 새로운 블록과 보류중인 트랜잭션은 전체 네트워크로 전해지게 된다. 노드는 새로운 블록과 보류중인 거래 내역을 모든 피어들에게 보낸다. 수신한 피어가 아직 보지 못한 내역이면, 블록이나 트랜잭션의 전체내용을 요청하여 응답할 수 있다. 기본적으로 노드는 새로운 데이터를, 임시포크에서 두 블록이 발견 될때만 브로드캐스팅하며, 보류트랜잭션은 브로드 캐스트 하지 않는다. 이러한 제한은 네트워크 데이터를 제한하도록 성능을 최적화 한 것이다. 비준수 노드는 잘못되거나 충돌하는 데이터를 릴레이 할 수 있으므로, 모든 노드가 수신하는 데이터를 독립적으로 검증해야 한다. Relay Policy 비트코인은 일반적인 트랜잭션 유효성 규칙보다 더 엄격한 규칙을 충족하는 릴레이 트랜잭션과 블록만 전달한다. 이는 다양한 서비스 거부 공격을 방지 하는 것이다. ¶3. 비트코인의 안정성 ¶A. Stability of transaction validity rules 비트코인 생태계의 참가자들이 거래 유효성 규칙에 합의를 얻는 방법에 대한 분석이 부족한 것이 현실이다. 기본 철학은 사토시가 규칙을 정한 것으로, 표준주의라고 불리고 있다. 이는 몇가지 규칙에서의 불일치를 조정한 버전이다. 그러나 새로운 기능을 추가하기 위해 이미 변경된 비트코인의 현재 규칙을 설명할 숭 없다. 일례로 2013년 3월에 유효한 블록 크기를 버그가 제거된 경우가 있다. 이로 인해 새로운 대형 블록이 패치가 적용되지 않은 클라이언트에의해 거부된 경우가 있다.이를 해결하기 위해 업데이트 된 클라이언트는 24블록 포크를 버리고 오래된 클라이언트가 업데이트 할 수 있도록 두달동안 더 큰 블록을 포함하는 작업을 일시 중단했다. 결국 버그는 패치되었고, 패치되지 않는 노드들은 배제되었다. 비트코인 자체적으로 트랜잭션 유효성 검사 규칙을 업데이트하는 프로세스가 따로 존재하지 않는다. 완전히 비트코인이 분산된 시스템으로 인지하고 있지만, 규칙변경이나 모호성 제거를 위해서는 블록체인이 세계적 합의를 유지하기 위해 본질적으로는 어느정도의 지배구조가 필요하다. 현재는 bitcoind를 개발하는 핵심 개발자들이 비트코인 파운데이션과 함께 사실상의 거버넌스를 제공하고 있다. 많은 초기 인터넷 프로토콜과 마찬가지로 합의를 넘어서는 결정을 내리는 공식적인 프로세스는 존재 하지 않는다. ¶B. 합의 프로토콜의 안정성 Eventual consensus: 언제든지 모든 노드는 최종적으로 유효한 블록체인이 되는 것에 동의 한다 Exponential convergence: Fork의 깊이 확률은 O(2^-n)이다. 이는 사용자에게 단순한 규칙이 자신의 트랜잭션이 높은 신뢰도로 영구적으로 포함되도록 보장한단는 신뢰감을 준다. New block: 새로운 블록이 계속 추가되고 적절한 수수료를 가진 유효한 트랜잭션이 유효한 시간 내에 블록체인에 포함된다. Correctness: 가장 긴 체인에 있는 모든 블록들만이 유효한 거래내역을 가질 수 있다. Fairness: 총 컴퓨팅 파워의 a를 가지고 있는 광부는 a만큼의 블록을 채굴할 수 있다. Incentive compatibility and game theory 사토시는 모든 miner가 인센티브를 따르는 한 비트코인은 안정적일 것이라고 헀다. 이러한 인센티브는 비트코인 또는 암호화폐 맥락에서 공식적으로 정의 된적이 없다. 게임이론적인 측면에서 보편적인 준수가 내쉬균형으로 보여지면, 일방적으로 전략을 변경할 인센티브가 없으므로 이러한 비트코인 인센티브의 호환성을 암시한다. 반면에 비 호환 전략이 준수를 지배한다면, 결과적인 전략 균형이 안정성과 연결되는지를 확인해야 한다. Simple majority compliance may not ensure fairness. 채굴전략의 안정성은 본질적으로 통신네트워크에 대한 가정에 의존하고 있다. 만약 일시적인 보류가 발생한다면 (miner가 블록을 발견했음에도 알리지 않는다면) 이것은 공정성을 훼손할 수 있을 것이다. Majority compliance is an equilibrium with perfect information. 대다수가 동의했다는 완벽한 정보라는 것과 같다. Majority compliance implies convergence, consensus, and liveness. 대부분의 규정 준수는 통합, 합의 그리고 liveness를 의미한다. 대다수의 miner들이 프로토콜을 따른다면, 가장 긴 체인이 빠르게 나타난 다는 것을 알 수 있다. 대다수의 miner가 준수하는 전략을 따르고, 통신 지연시간이 블록을 발견하는 시간에 비해 작다면, miner들은 결국 규칙을 따르며 동의할 것이라는 것을 의미한다. 이것은 공정성을 제외한 모든 안정성 관련 속성을 보장하기에 충분하다. With a majority miner, stability is not guaranteed 대부분의 연산능력을 제어하는 miner가 다른사람들이 발견한 블록을 무시하고 자체적으로 체인을 구축하고 모든 보상을 가져갈 수도 있다. 그러나 이는 명목상의 이익을 가져다 줄수 있지만, 이러한 행동은 감지될 수 있기 때문에 합리적인 miner의 장기적인 이익으로는 적절하지 않다. 광부가 단합할 경우, 안정성은 어떻게 되는가? 소규모 miner이 뭉쳐서 대다수의 채굴을 통제하고 단일 miner가 할 수 잇는 전략을 모방하는 카르텔을 형성할 수도 있다. 이런 카르텔이 내부적으로 안정적일지, 카르텔 개개인이 이러한 유혹을 받을지, 또는 제외된 miner가 유리한 조건으로 대체 카르텔을 형성하겠다고 제안할 경우 이를 꺠드릴 수 있는지는 알려지지 않았다. mining pool은 카르텔 형성을 위한 기술적인 메커니즘이다. 이러한 mining pool과 관련된 역학은 아직 연구되지 않았다. 보상이 감소할 경우 안정성은 어떻게 되는가? 이 모든 결과는 각 블록이 일정하고, 고정된 보상수수료를 받는다는 단순화된 모델을 기반으로 하고 있다. 만약 거래수수료가 허용되지 않으면서 채굴 보상이 없는 최종 상태나 중간상태가 안정성에 어떤 영햐을 미칠 것인지에 대한 연구는 존재하지 않는다. 실제로 miner들은 비트코인 획득 뿐만 아니라, 실제 그것이 주는 수익에 대해 더 관심이 있다. 이것을 모델링하려면 얼마나 많은 비트코인을 버는지 , 실제 가치로 얼마나 효과적으로 전환할 수 있는지를 연구해야 한다. 유동성 한계 비트코인을 외부 통화로 거래하는 교환은 일반적으로 유동성이 낮다. 따라서 공격자는 비트코인을 얻을 수 있지만, 모두 외부 화폐로 변환할 수 없거나 크게 감소된 환율 에서만 가능할 것이다. 환율이 공격에 직면할 경우 눈에 띄게 안정성에 악영향을 미치는 전략은 대중의 신뢰를 훼손하고 비트코인에 대한 수요를 약화시킬 수도 있다. 유동성에 한계가 있는 것에 비추어 보았을때, 환율이 반응하기전에 현금화 하는 것은 어려울 수 있다. Long-term stake in bitcoin-denominated mining rewards 대형 miner들은 비트코인의 환율을 유지하는데 추가적인 관심을 가지고 있다. miner가 채굴력을 판매할 수 있는 효과적인 시장이 없다면, 다른 대중들보다 더 빨리 이를 현금화 시키려고 할 것이다. 불행히도 환율은 본질적으로 인간의 판단과 시장의 신뢰에 달려있기 때문에 게임이론 모델에서 포착하기란 쉽지 않다. Goldfinger attacks 대다수의 miner들의 목표가 비트코인의 안정성과 통화로서의 유용성을 파괴하려는 것을 Goldfinger Attacks라고 한다. 이는 성숙한 선물 시장이 생겨나면 방지할 수 있다. ¶C. 마이닝 풀의 안정성 마이닝 풀은 유효한 블록을 찾기 위해 miner에가 의존하며, 보상 대가로 수익을 나눠주지만, 수익을 낮추기위해 유효한 블록을 찾았지만 제출하지 않는 miner에게 취약한 구조를 가지고 있다. 이는 블록을 보유하는 참여자 외에도 자신의 수입을 낮추기 때문에 자멸적인 것으로 보인다. 그러나 이는 대형 miner가 유효한 블록을 보류하고, 다른 마이닝 풀에 침투하여 실제로 이익을 줄 수 있다는 것이 나타났다. 이 전략은 대규모 miner와 마이닝 풀에서 유효하다. 이 게임은 두풀의 내쉬균형이 서로 공격하지만, 페레토 균형은 공격하지 않는다는 것을 보여주었다. 이는 반복적인 죄수의 딜레마로, 마이닝 풀 밖의 의사소통과 보복 위협을 통해 서로 공격하는 것을 피할 수 있다. ¶D. the peer-to-peer layer의 안정 비트코인은 P2P레이어가 정의된대로 기능하며, 일반적으로 참가자의 대다수가 합리적인 시간 내에서 사용 가능한 프로토콜 정보를 거의 모두 학습할 것이라고 가정한다. 하지만 이는 옳지 못하다. 마이닝 풀은 공격에 참여할 인센티브를 가지고 있고, 더 큰 마이닝 풀은 작은 것 보다 더 공격에 유용하다. 마이닝 풀에 대한 서비스 거부 공격은 종종 발생하므로, 연구할 필요가 있다. ¶4. 클라이언트 사이드 보안 ¶A. 단순화된 지불 확인(Simplified Payment Verification (SPV) Security) 비트코인 클라이언트가 전체 블록체인에 유효성있는 사본을 유지하지만 이는 모바일 장치에 부담을 부과한다. 대부분의 노드가 유효한 체인에 있는 노드만 사용한다고 가정한다면, 이런 클라이언트는 작업증명만 확인하면 가장 긴 트랜잭션만 포함시키면 된다. 이러한 SPV검증을 통해, 신뢰할 수 없는 노드가 합의된 기록에 트랜잭션이 포함되어 있다는 것을 경량 고객에에 효율적으로 증명할 수 있게 한다. ¶B. 키 관리 비트코인은 사용자 인증을 위해 공개 키 암호화에 의존하지만, 오늘날 온라인 상거래는 암호 또는 기밀 신용카드 정보에 의지한다. 비트코인 소프트웨어 개발자는 핵심 스토리지및 관리에 다양한 접근방식을 시도하고 있다. 장치에 키 저장 가장 간단한 모델이지만, 악성코드로 인해 도난당할 수 있다. 일부 클라이언트는 현재 키 풀이 고갈될 때마다, 새로운 백업이 필요한 새 비트코인 주소에 변경 사항을 보내고, 다른 클라이언트는 원래 주소로 변경을 보내거나 임의로 모든 키를 가져온다. 별도보관 단일 장애 지점을 피하고, 보안을 향상시키기 위해 n 개의 공개키를 지정하는 k-of-n 다중 서명 스크립트을 사용하여 비트코인을 저장할 수 있다. 스크립트를 다시 사용하려면, n키의 k에서 유효한 서명을 제공해야 한다. 일례로 노트북과 휴대전화를 서명해야하는 지갑으로 볼 수 있다. 암호로 보호되는 지갑 비트코인 클라이언트는 지갑을 사용자가 선택한 암호에서 파생된 키로 암호화 할 수 있다. 암호로 추출된 지갑 이러한 암호를 메모리에 커밋하면 장치를 교차하여 사용할 수 있다. 오프라인 스토리지 종이나 usb드라이브 같은 휴대용 미디어에 저장하면, 악성코드 기반 위협으로 부터 도난을 방지하고 물리적인 보안 모델을 제공한다. 그러나 키풀이 고갈되어 업데이트를 해야하는 경우가 발생할 수 있다. 종이에 QR코드로 프린트 해놓을 경우, 이를 뻇길 위혐도 있다. 마지막으로 그 키를 온라인으로 업로드 하면서 악성코드에 취약해 질 수 있다. 인터넷과 분리된 하드웨어 스토리지 이른바 Air-gapped 방식은 오프라인 저장소의 특별한 경우다. 이는 인터넷에 연결된 장치에 키를 노출시키지 않음으로서 특정유형의 도난을 저지 할 수 있다. Hosted wallet 타사 웹서비스 또는 two-factor 인증과 같은 표준 웹인증 매커니즘을 사용하는 방식이다. 하지만 이역시 호스트를 신뢰해야 한다. ¶V. 비트코인 변경 비트코인을 변경하는데 사용할 수 있는 매커니즘에 대해 알아보자. ¶A. 비트코인 자체를 업데이트 하기 Hard Fork 블록 보상 증가, 고정 블록 크기 제한 변경, 새 opcode 추가 같이 이전에 규칙에 따라 유효하지 않다고 판단되는 트랜잭션 또는 블록을 사용하게 하는 등의 경우엔 하드포크가 필요하다. 새 프로토콜을 업데이트 하면 다른 노드에서 거부되는 블록을 생성할 수 있으므로, 이는 만장일치로 행해져야 한다. Soft Fork 소프트 포크는 기존 클라이언트와 호환되는 변경 항이다. 일반적으로 어떤 블록이나 트랜잭션이 유효하다고 간주되는지 정도의 변화를 의미한다. 이는 miner가 모두 업데이트 해야하는 사항으로, 업그레이드 하지 않으면 나머지 네트워크가 무효로 간주하는 블록을 계속해서 생성하며 자원을 낭비할 수 있다. 하지만 결국 가장 긴 체인에 다시 합류할 것이다. 이것은 하드포크 보다 안정적이다. Relay policy updates 통신 네트워크의 다른 측면을 변경하려면 프로토콜 버전 번호를 광고하는 노드와 역 호환 방식으로 수행할 수 있으므로 최소한의 조정이 필요하다. ¶B. 알트코인 하드 포크 없이는 비트코인에서의 변화는 굉장히 제한적이므로, 알트코인이라고 하는 각자의 방식으로 접근하는 새로운 화폐가 등장하기 시작했다. 대부분은 일부 시스템을 완전히 독립적 디자인했지만, 여전히 비트코인 코드를 기반으로 하고 있다. 사용자가 참여하기 위해서는 초기 통화 할당을 해야 하며, 다음 과 같은 방법으로 달성할 수 있다. 새로운 블록 생성 가장 단순한 방법으로 새롭게 블록체인을 시작하면 된다. 비트코인이 그랬던 것 처럼, 초기 miner들에게 화폐를 할당해주면 된다. 이런 방식은 각종 설립자들이 초기단계에 현금화하려는 목적으로 알트코인을 만들면서, 많은 사람들이 조심스럽게 보고 있다. 비트코인 forking 창립자의 먹튀를 방지하기 위해, 알트코인은 의도적으로 특정 시점에서 비트코인을 포크하여 이전 거래 기록 및 자금 소유권을 수락하게 할 수 있다. 기술적으로도 하드포크와 일치하지만, 이 방법은 별로 선호되는 것 같지 않다. Proof-of-burn 사용자는 일정량의 비트코인을 파괴하는 방식이다. 대게 비트코인 자금을 모든 0의 해시가 있는 키와 같은 개인키를 찾을 수 없는 특수 주소로 전송하여 비트코인을 폐기하는 방식이다. 이 방식은 순환중인 비트코인의 양을 영구히 줄인다는 단점이 있다. Pegged sidechains 최근 가장 영향력있는 비트코인 개발자가 비트코인을 전송하고 구속할 수 있는 사이드 체인을 제안했다. 사이드 체인은 통화를 상환하기 위해 유효성 검사 규칙을 추가하고, 이는 비트코인의 소프트 포크를 필요로 한다. 알트코인은 필연적으로 miner를 확보하기위해 비트코인과 경쟁해야 한다. 이를 위해 mining을 병합하는 방식을 많이 사용하는데, 만약 루트가 유효한 비트코인 블록에 포함되어 있으면, 알트코인이 블록을 허용하므로 miner 들은 추가적인 작업을 수행하지 않아도 알트코인의 블록을 채굴할 수 있다. 이는 miner들이 추가적이 수익을 얻을 수 있기 때문에 bitcoin 전체의 체광력을 신속하게 제공받을 수 있다. 그러나 이것은 알트코인이 비트코인에 종속된다는 단점이 있다. ¶6. 대체 합의 프로토콜 비트코인 합의 프로토콜은 안정성에 대한 이슈, 프로토콜 성능 및 확정성에 대한 우려 및 자원을 낭비한다는 이유로 가장 많이 논의된 요소다. 그 결과로 제안된 다른 대안요소를 소개한다. ¶A. Parameter 변경 비트코인 합의 프로토콜은 초기 추측에 기초해 하드 코딩된 많은 '마법의 상수’를 활용한다. 거의 모든 알트코인은 이러한 요소들에 대해 수정 논란이 있었으며, 어떻게 선택할 것인지에 대한 논란도 있었다. 블록간 시간과 난이도 조절 비트코인은 퍼즐의 난이도를 자동 조정하여 솔루션이 평균 10분 간격으로 발견 되도록 한다. 이 설정은 주로 네트워크 latency에 의해 제한된다. 속도가 빠르면 전파되기전에 중복 블록을 자주 발견할 것이고, 느리다면 트랜잭션 확인에 시간이 소요된다. 비트코인 설정은 모두 보수적으로 접근되어 있다. 그러나 알트코인은 대부분 같거나 더 빠른 속도를 가지고 있다. 블록과 트랜잭션의 크기 가장 논란이 되고 있는 변경 사항중 하나는 블록 크기 제한 1MB를 늘리는 것이다. 거래량이 꾸준히 증가함에 따라, 한도에 계속해서 도달하고 있다. 트랜잭션의 볼륨 상한은 현재 초당 7개이며, visa보다 1000배 더 작은 수준이다. 이 한도에 도달하면, 거래는 희소한 자원에 입찰하기 위해 비용을 효과적으로 사용해야 한다. 이는 비트코인 사용 비용을 증가 시켜 채택을 늦추지만, miner의 수입을 증가시킬 수는 잇다. 또한 사용자가 거래를 집계하고 체인을 벗어난 중개인에 의존하게 할수도 있다. 반면에 트랜잭션 볼륨이 증가하면 대역폭이 제한되어 일부 사용자들의 참여가 제한 될수 있다. 통화정책 비트코인 합의 프로토콜은 새로운 통화가 발행되는 속도와 금리가 변경되는 일정을 통해 통화정책을 컨트롤 한다. 제한된 금액의 통화를 요구함으로써, 비트코인은 디플레이션 정책을 가지고 있어 경제학자들이 비트코인을 꺼려하기도 한다. 이를 알트코인 발행으로 해결하기도 한다. ¶B. 대안 컴퓨터 퍼즐 ASIC-resistant puzzles Useful puzzles. Nonoutsourceable puzzles ¶C. 가상 마이닝과 소유 증명 (Proof-of-stake) 참가자들이 자원을 교환하여 가지는 대신, 단순히 그들이 블록을 선택하는 능력을 위해 부를 교환하는 것이 가능하도록 할 것이다. 무작위 표본을 현재 자원의 할당에 의해 가중 시키는데, 이를 ‘가상 마이닝’ 이라고 한다. 이는 공격자가 충분히 많은 디지털통화를 확보하기 어렵게 하여 공격을 막을 수 있고, 실제 리소스 소비를 방지하는 효과를 가지고 있다. 가상마이닝에는 여러 종류가 있는데, 주로 통화의 양을 소유함으로써 다음 블록을 선택할 수 있는 기준에 따라 달라진다. Proof-of-coin-age Proof-of-deposit Proof-of-burn Proof-of-activity 그러나 일부는 블록체인의 보안을 위해 외부자원을 소비하는 것이 필요하므로, 가상 채굴 계획은 본질적으로 불가능하다는 주장을 제시하기도 한다. 이 처럼 가상 마이닝의 안정성에 대한 의구심은 여전히 문제로 남아 있다. ¶D. 담당 기관 지정 비트코인의 분산된 성격이 가장 중요한 요소이지만, 거래를 순차적으로 주문하고 서명할 수 있는 지정된 기관에 의존한다면 합의는 더욱 간단해질 것이다. 안정성을 한꺼번에 추론하고, 낭비적인 계산에 대한 우려를 순식간에 제거할 수 있을 것이다. 담당 기관이 정직하게 행동하여 작은 수입을 얻는다면, 잘못 행동할 인센티브가 없을 것이다. 리플은 이 모델을 사용하는 몇안되는 알트코인이지만, 여전히 안정성 인수는 본질적으로 증명되지 않았다. ¶7. 익명성과 프라이버 비트코인은 제한된 형태의 연결 불가능성을 제고한다. 사용자는 언제든지 새로운 가명(주소) 를 만들 수 있다. 이는 강력한 프라이버시를 제공하기위해 주장되었지만, 이 특성으로 인해 가명사이의 자금 흐름을 추적하고, 동일한 개인에 의해 통제될 가능성도 존재한다. ¶A. 분산 고객이 여러 주소에서 지불금액을 모아야 하면 어떨까? 이 경우 블록체인에 이 주소들을 연결해야 한다.이를 위해 한번에 18개의 주소와 함께 사용되는 트랜잭션 기록을 블록체인에 연결한다. 링크는 순차적으로 적용하여 주소 클러스터를 생산할 수도 있다. 이는 트랜잭션 그래프 분성의 한 예다. 이와 별개로 새로운 연결기법도 등장할 수 있다. 멀티 서명주소는 변경된 주소의 구조가 변경되어도 송신주소와 일치할 수 있기 때문에, 개인정보보호에 의도치 않게 부정적인 영향을 미칠 수 있다. 네트워크 분산 인구분산의 장점이 미칠 수 있는 곳잉 바로 P2P 네트워크다. 노드는 거래를 브로드 캐슽팅하는 순간 IP를 노출하게 된다.이를 익명의 네트워크를 사용함으로써 이런 개인정보 노출의 위험성을 제거할 수 있다. ¶B. 익명성을 강화하기 위한 제안 Peer to peer P2P혼합 프로토콜에서, 비트코인 보유자들의 집합은 공동으로 일련의 거래를 만들어 비공개로 동전의 소유권을 영구히 유지하는 일련의 거래를 만들어 익명성 설정을 높일 수 있다. 원하는 출력주소가 포함되지 않는 경우, 사용자는 거래서명을 거부하여 도난을 방지할 수 있찌만, 개개인이 DoS에 취약할 수도 있다. 분산 혼합 네트워크 MixCoin에서 사용자들은 표준 크기의 거래를 제3자의 믹스에 보내고, 사용자가 전송한 금액과 동일한 금액을 다시 돌려 받는다. 믹스가 사용자와 아웃풋간의 연결성은 알고 있지만, 다른 사용자는 알지 못하므로 외부 엔티티와 내부 익명성을 제공한다. 다른 사용자도 프로토콜을 중단할 수 없다. 불연결성이 보장되어 있는 알트코인 제로코인은 기본통화와 제로코인이라고 하는 익명의 통화를 사용하여 통합된 연결 불가능성을 가진 알트코인이다. 사용자는 기본통화로 거래하지만, 모든 제로코인과 비교하여 익명으로 기준 통화를 제로코인으로 변환할 수 있다. 이는 다른 문제를 발생시키지 않고 안전하게 연결시킬 수 있다. 피노키오코인의 경우 다른 암호화구조를 사용하지만, 제로코인과 유사하다. 제로캐쉬 트랜잭션은 특별한 유형이 알려지지 않은 증명으로서, 거래수수료를 제외하고는 금액과 수령자에 대한 정보조차 공개되지 않는다. 크립토노트는 여러개의 알트코인을 기본으로 링서명을 사용하는 암호화 혼합 프로토콜이다. 이 경우 성능은 더 좋지만, 익명성은 제로 캐쉬나 코인에 비해 떨어진다. ¶8. 비트코인의 기능성 확장 비트코인은 단순히 디지털 통화지만, 스크립팅 언어는 다른 유형의 상호작용 또한 가능하게 한다. ¶A. 오늘날 비트코인의 중개 확장 가능한 플랫폼으로서의 비트코인은 과장된 면이 있다. 스크립팅 언어는 매우 제한적이다. 그러나 현재 거래의 미로 실현할 수 있는 중개를 위한 많은 프로토콜이 개발되어 있다. 원자성 여러 당사자가 서명할때까지 트랜잭션이 유효하지 않다는 속성을 이용하여, 원하는 보안속성을 직접 실행할 수 있다. 담보 비트코인이 올바른 행동이 실행되는 경우에만 환불되는 예끔 또는 채권을 게시하는 등 구제책을 제공하는 방법도 있다. 감사 비트코인이 부정직한 당사자를 유죄로하는 증거를 제공하는데 중요한 역할을 할 수 있다. ¶B. 데이터 저장을 위한 비트 코인 Secure Timestamping 블록체인은 다양한 보안 프로토콜에 유용한 보안 타임 스탬핑 서비스로 사용할 수 있다. 디지털 토큰: 칼라 코인 데이터가 개별 트랜잭션에 기록 될 수 있기 때문에, 특정 트랜잭션에 색상을 표시할 수 있다. 이를 통해 일련의 규칙을 정의하는 Colored Coin 프로토콜을 사용할 수 있다. 이를 통해 거래 주식이나 재산권가 괕은 많은 응용프로그램에 칼라코인이 제안되었다. 트랜잭션의 색을 검증하려면 모든 부모 트랜잭션에 대해 블록체인을 스캔해야 한다. 일반적으로 컬러 코인은 블록체인의 추적기능을 사용한다. 오버레이 프로토콜: 마스터 코인 비트코인의 합의 매커니즘을 사용하지만, 블록체인에 임의의데이터로 기록될 완전히 다른 트랜잭션 구문을 정의하는 것이다. 이 경우 miner가 새로운 거래유형에 대해 알 수없으므로, 합의 매커니즘이 제공하는 정확성을 담보할 수 없다. 따라서 잘못된 트랙잭션이 있을 수 있고, 이를 오버레이 시스템의 참가자가 무시해야 한다. 사용자 전체가 트랜잭션을 검증해야 하므로 SPV도 불가능하다. ¶C. 비트코인 거래 범위의 확장 비트코인 스크립팅 언어는 의도적으로 제한적이다. 실제로 원본 소스에는 더 많은 것을 할 수 있는 언어가 포함되어 있지만, 대부분의 opcode는 사용할 수 없는 것으로 표시된다. ¶9. 결론 비트코인을 비롯한 암호화폐 혁신은 암호화폐 프로토콜 설계에만 국한되지 않고, 컴퓨터 보안, 분산시스템, 하드웨어 설계, 경제 등 다양한 분야에 영향을 미쳤다. 비트코인은 물론익명성과 같은 몇가지 분야에서 우수한 아이디어가 제안되었지만, 기본적인 안정성과 효율성을 위해 비트코인을 개선할 수 있는 대체 분산형 합의 시스템을 설계하는 것이 가능한 것인지 불확실하다. 이 문헌은 비트 코인자체가 경제적, 사회적으로 안정적으로 유지할 것인지 평가하는 도구도 제공하지 않는다. 마찬가지로, 새로운 특징을 가진 프로토콜을 설계 할때, 안정성을 해치지 않으면서 비트코인을 확장하는 방법은 명확하지 않다. 이처럼 비트코인 공동체의 컴퓨터 과학 연구에 대한 의혹에도 불구하고, 단순히 ‘시장에서 결정하게 놔두는 것’ 대신에 연구가 중요한 역할을 할것이라고 주장한다. 오늘날 비트코인의 성공이 알트코인에 비해 어느정도인지는 평가하기 어렵다. 비트코인은 실제가 이론보다 훨씬 앞서 있는 것 처럼 보이는 드문 경우다. 이 연구공동체가 비트코인에 대한 많은 질문을 해결 할 수 있는 엄청난 기회를 가지고 있다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"cryptocurrency","slug":"cryptocurrency","permalink":"https://www.yceffort.kr/tags/cryptocurrency/"}]},{"title":"Bitcoin) 비트코인 백서 요약","slug":"bitcoin-white-paper-summary","date":"2018-06-16T15:00:00.000Z","updated":"2018-06-17T01:57:05.000Z","comments":true,"path":"2018/06/17/bitcoin-white-paper-summary/","link":"","permalink":"https://www.yceffort.kr/2018/06/17/bitcoin-white-paper-summary/","excerpt":"비트코인 백서 요약 출처 ¶1. 서론 인터넷 상거래는 전자 결제를 처리할 신뢰받는 제3자 역할을 금융기관에 전적으로 의지했다. 중재비용은 거래비용을 높이고, 비실용적이며 당사자에게 많은 개인정보를 제공해야 한다. 신뢰 대신 암호학적인 증명을 바탕으로, 거래 의사가 있는 두 당사자가 신뢰받는 제 3 자를 필요로 하지 않고 서로 직접 거래하게 해주는 전자 화폐 시스템이이다. 거래 시간순서대로 전산적 증명을 생성하는, 개인 대 개인간 분산 타임스탬프 서버를 사용한 이중지불 문제의 솔루션을 제안한다.이 시스템은 정직한 노드가 공격하려고","text":"비트코인 백서 요약 출처 ¶1. 서론 인터넷 상거래는 전자 결제를 처리할 신뢰받는 제3자 역할을 금융기관에 전적으로 의지했다. 중재비용은 거래비용을 높이고, 비실용적이며 당사자에게 많은 개인정보를 제공해야 한다. 신뢰 대신 암호학적인 증명을 바탕으로, 거래 의사가 있는 두 당사자가 신뢰받는 제 3 자를 필요로 하지 않고 서로 직접 거래하게 해주는 전자 화폐 시스템이이다. 거래 시간순서대로 전산적 증명을 생성하는, 개인 대 개인간 분산 타임스탬프 서버를 사용한 이중지불 문제의 솔루션을 제안한다.이 시스템은 정직한 노드가 공격하려고 협력하는 노드보다 더 많은 CPU파워를 통제하는 한 안전하다. ¶2. 거래 이전의 거래내역 및 다음 소유자 공개키의 해시값에 전자서명을 한다. 1에서 생성된 정보를 화폐의 끝에 추가한다. 돈을 받는 사람은 소유권의 사슬 검증하기 위해 해당 서명을 검증할 수 있다. 그러나 이 과정에서는 화폐가 이전에 사용되지 않았는지 (어떤 거래에도 서명하지 않았는지) 수금자가 알 수가 없다. 이 것을 확인하는 유일한 방법은 모든 거래 내역을 인지하는 것 뿐이다. 기존에는 조폐국이 모든 거래내역을 알고 있었다면, 제 3자 없이 이방법을 실현하기 위해서는 거래내역이 공개적으로 알려져야 한다. 노드들이 거래 받는 순서의 단일이력에 합의하는 시스템이 필요하다. 수금자는 매 거래시 그것이 첫 수금이라는 사실에 다수의 노드가 동의 했음을 증명해야 한다. ¶3. 타임스탬프 서버 타임스탬프 서버는 타임스탬프가 찍힌 항목의 블록의 해시를 가져가 널리 배포한다. 이 타임스탬프는 해쉬안에 먼젓번 타임스탬프를 포함하고, 앞선 것을 물고있는 사슬을 형성한다. ¶4. 작업증명 3번의 타임스탬프 서버를 구현하기 위해서는 작업증명시스템을 사용해야 한다. 작업증명은 SHA256 같은 해시된 값 스캐닝을 필요로 한다. 블록의 해시에 필요한 0 비트를 주는 값이 발견될 때 까지 nonce값을 증분 하는 것으로 작업증명을 구현하는 것이다. 이런 재수행 작업뒤 모든 블록을 포함한다. 작업증명은 기본적으로 CPU당 1표다. 다수의사는 최대 작업증명 동작이 투입된 가장 긴 사슬로 대표된다. 다수 CPU파워가 정직한 노드에 의해 통제되면, 가장 정직한 사슬이 빠르게 늘어날 것이다. 과거 블록을 변경하려면 그 블록을 포함한 뒤의 모든 블록 작업증명을 재수행 해야 하고, 정직한 노드의 작업 또한 따라 잡아야 한다. 시간이 지날수록 노드를 구동하는 하드웨어 속도 증가와 관여도를 보상하기 위해, 작업 증명 난이도는 시간당 평균 블록수에 따른 평균 목표치를 조정해 결정된다. 빨리 생성되면, 난이도도 증가한다. ¶5. 네트워크 새로운 거래가 모든 노드들에게 전파된다 각각의 노드들은 새로운 거래를 블록에 집어 넣는다 각각의 노드들은 그 블록에 맞는 난이도의 작업증명을 찾기에 나선다. 노드가 작업증명을 찾으면, 모든 노드에게 그 블록을 알린다. 노드는 모든 거래가 유효하며 아직 지불되지 않았다면 그 블록을 승인한다. 노드는 블록 승인을 알리기 위해 먼저번 해시로 승인된 블록의 해시를 사용해 사슬안에 다음 블록을 생성한다. 노드는 항상 긴 사슬x을 정확한 것으로 판단하고 그것을 잇는다. ¶6. 인센티브 블록의 첫번째 거래는 블록의 작성자가 소유한 코인으로 시작한다. 네트워크를 지원하는 노드가 자신이 생성한 블록의 양만큼 코인으로 보상을 받는다. 새 화폐 일정량을 추가하는 것은, 자원을 발견하도록 자원을 소비하는 것과 유사하다. 이경우에는 CPU와 전기다. 이러한 인센티브는 공격으로 부터 방어하는 수단이 될 수도 있다. 정직한 노드보다 더많은 CPU파워를 모은다면, 다른 모든 사람의 지불금을 훔치는 것보다 더 많은 코인을 생성하게 하면 된다. ¶7. 디스크 공간 회수 화폐 안에 최종 거래가 충분한 블록에 묻히면, 그 이전 거래는 디스크 공간 절약을 위해 폐기 될 수 있다. 블록의 해시를 깨지 않고 이 방법을 실현하기 위해서는, 이 거래를 머클트리로 해시한다. 그리고 그 루트만 블록의 해시에 포함시킨다. ¶8. 간소화된 결제 검증 사용자가 최장 작업증명 사슬을 가졌다고 확신할때까지 네트워크 노드를 조회한다. 얻을 수 있는 가장 긴 사슬의 블록헤더 사본을 유지 한다. 해당 거래를 타임스탬프가 찍힌 블록에 연결한 머클 분기를 얻기만 하면 된다. 비록 자신의 거래는 검사할 수 없지만, 그것을 사본과 연결 버전과, 이 후 그게 받아드려진 뒤 추가된 블록을 비교해 볼 수 있다. ¶9. 나누기와 합치기 모든 송금을 별도의 거래로 만드는 것은 무리이므로, 거래는 복수의 입출금을 포함한다. 이렇게 여러개를 합치게 된다면, 입금은 먼젓번 거래의 단수입금 이나 작은 양을 합친 복수입금이고, 출금은 지불용 출금과 거스름돈 정도가 있을 것이다. ¶10. 프라이버시 네트워크 내에 거래는 공개되 있지만, 신원은 거래와 가치로부터 분리되어 보관된다. 사용자는 작업과 관련된 정보를 피하기 위해 공개키를 가지게 된다. ¶11. 계산 정직한 노드가 사기 노드보다 먼저 블록을 찾을 확률이 더 높다. 사기성 블록을 만들때, 사기성 노드가 정직한 노드를 따라잡을 가능성은 낮다. 이는 노드가 가장 긴 사슬을 올바른 사슬로 인식하므로, 블록체인의 크기를 늘릴 때 중요하다. ¶12. 결론 디지털서명으로 만든 화폐의 프레임워크에서 핵심은 이중지불 방지수단을 만드는 것이다. 이를 해결하기 위해, 정직한 노드가 CPU 파워 대부분을 차지 한다면, 공격자는 전산적으로 변경하기가 어려워지는 작업 증명 방식을 사용했다. 이 네트워크는 조정없이 한번에 동작한다. 어떤 특정 경로로 가는 것이 아니라, 최선의 노력을 통해 전달 되기만 하면 된다. 노드는 네트워크를 떠났다가, 작업증명 사슬을 받아드리고 다시합류할 수도 있다. CPU파워를 사용한 투표로, 유효한 블록을 연장하는 작업을 통해 그것을 승인하고, 유효하지 않은 블록에 대해서는 기각한다. 이러한 것을 Consensus mechanism이라고 한다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"}]},{"title":"GoLang) 구조체와 임베딩","slug":"golang-structure-embedding","date":"2018-05-31T15:00:00.000Z","updated":"2018-06-01T01:57:05.000Z","comments":true,"path":"2018/06/01/golang-structure-embedding/","link":"","permalink":"https://www.yceffort.kr/2018/06/01/golang-structure-embedding/","excerpt":"Golang에는 클래스가 없는 대신, 아래와 같은 구조체가 존재한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import \"fmt\" type work struct { mission string time int boss string salary int } func main() { programming := work{\"잡일\", 5, \"김악덕\", 100} fmt.Println(programming) fmt.Println(programming.time)","text":"Golang에는 클래스가 없는 대신, 아래와 같은 구조체가 존재한다. 12345678910111213141516package main import \"fmt\"type work struct &#123; mission string time int boss string salary int&#125;func main() &#123; programming := work&#123;\"잡일\", 5, \"김악덕\", 100&#125; fmt.Println(programming) fmt.Println(programming.time) programming.time = 100 fmt.Println(programming.time)&#125; 1$ go run GoStructure.go &#123;잡일 5 김악덕 100&#125; 5 100 위에 struct 를 mission, boss String 이런식으로도 쓸 수 있다. 메소드는 어떻게 구현할 수 있을까? 1234567func (total *work) getTotal() int &#123; return total.time * total.salary&#125;func main() &#123; fmt.Println(programming.getTotal())&#125; 이런식으로 할 수 있다. 특별한 건 여기서, work 는 구조체를 total이라는 변수명을 사용해서 (리시버 변수) 접근하고 있고, work에 *을 붙였다는 것아다. *은 모두가 예상한 바로 그것이다. 포인터. *이 지정되지 않으면(주소값을 할당해주지 않으면) 저 메소드는 구조체 내부의 값에 영향을 미치지 않게 된다. 암튼 쓰는건 여타 언어와 크게 다를 바는 없다. 다만 클래스가 없기 때문에 상속이라는 개념도 없다. 그렇다면 GoLang에서 상속을 흉내내려면 어떻게 해야할까? 바로 그것은 임베딩이다. 1234567891011121314151617181920212223242526272829303132333435package main import \"fmt\"type work struct &#123; mission string time int boss string salary int&#125;func (total *work) getTotal() int &#123; return total.time * total.salary&#125;func (total *hardWork) getTotal() int &#123; return total.w.time * total.w.salary - 100000&#125;type hardWork struct &#123; w work level int yaguen bool&#125;func main() &#123; var spring hardWork spring.w.boss = \"김악마\" spring.w.time = 100 spring.w.mission = \"의미없이 스프링 문서를 보고 있을 것\" spring.w.salary = -100 spring.level = 10000 spring.yaguen = true fmt.Println(spring) fmt.Println(spring.w.getTotal()) fmt.Println(spring.getTotal())&#125; 대충 보면 느낌이 올 것이다. hardwork는 work를 임베딩 하고 있으며, 변수명을 w 로 work를 가지고 있다. 변수명은 생략가능하다. 그리고 명칭이 같은 메소드를 오버라이딩하고 있는데, 이 두개에 대한 동작이 다른 것을 볼 수 있다.","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://www.yceffort.kr/tags/development/"},{"name":"GO","slug":"GO","permalink":"https://www.yceffort.kr/tags/GO/"}]},{"title":"두 String의 유사도를 측정해보자 - Levenshtein distance","slug":"Levenshtein-distance","date":"2018-05-30T15:00:00.000Z","updated":"2018-05-31T02:11:51.000Z","comments":true,"path":"2018/05/31/Levenshtein-distance/","link":"","permalink":"https://www.yceffort.kr/2018/05/31/Levenshtein-distance/","excerpt":"두 개의 String이 있을때, 그 두개를 비교하는 작업은 어떻게 할 수 있을까? str.equalsOf(str2) 이런 것이 아니라, 두 단어의 비슷한 정도를 말하는 것이다. 예를 들어보자. 사용자가 Toast라고 말을 했다. 그러면 구글 Voice는 Toast라는 사용자 사운드에 가장 비슷한 단어 몇가지를 추천해준다. 나의 저질 발음으로 인해, 안타깝게도 toast를 인식하지 못하고 저렇게 다섯 개의 후보를 주고 말았다. 그렇다면 나는, 내가 가지고 있는 DB의 데이터 중에서 가장 post와 유사한 단어를 찾아서 돌려줘","text":"두 개의 String이 있을때, 그 두개를 비교하는 작업은 어떻게 할 수 있을까? str.equalsOf(str2) 이런 것이 아니라, 두 단어의 비슷한 정도를 말하는 것이다. 예를 들어보자. 사용자가 Toast라고 말을 했다. 그러면 구글 Voice는 Toast라는 사용자 사운드에 가장 비슷한 단어 몇가지를 추천해준다. 나의 저질 발음으로 인해, 안타깝게도 toast를 인식하지 못하고 저렇게 다섯 개의 후보를 주고 말았다. 그렇다면 나는, 내가 가지고 있는 DB의 데이터 중에서 가장 post와 유사한 단어를 찾아서 돌려줘야 한다. 그렇다면, 내가 가지고 있는 DB의 단어와 구글이 return한 단어는 어떻게 비교할 수 있을까? 정확히 말하면, 두개의 String의 유사도는 어떻게 판단할 수 있을까? Levenshtein Distance : The minimum number of single-character edits required to change one word into the other. Strings do not have to be the same length – 한 글자 글자의 차이(삽입, 삭제, 대체) 를 거리로 계산한다. Hamming Distance : The number of characters that are different in two equal length strings. – 길이가 같은 두 단어에서 몇개를 대체하면 같아지는지 계산한다. 근데 이미 길이가 같아야 한다는 전재가 있으므로 글러먹음. Smith–Waterman : A family of algorithms for computing variable sub-sequence similarities. – 배열들의 가능한 모든 길이로 쪼개서 비교하는 방식 Sørensen–Dice Coefficient : A similarity algorithm that computes difference coefficients of adjacent character pairs. – 배열들의 쌍을 묶어보면서 비교하는 방식 정도가 있다. 그중에서 가장 접근하고 이해하기 쉬운 Levenshtein distance 에 대해 알아보고자 한다. 두 배열을 비교하기위해서는, 두 배열이 같아지는 과정이 얼마나 필요한지 (거리가 어떻게 되는지) 구하는 과정을 거치면 된다. 그 과정은 딱 3개다. 새로운걸 삽입(insertion), 기존의 원소를 삭제(deletion), 기존의 원소를 다른 것으로 대체(substitution) 예를 들어보자. ghost &gt; toast g를 t로 대체한다 (subsitution) thost &gt; toast h를 o로 대체한다 (subsitution) toost &gt; toast o를 a로 대체한다 (subsitution) toast = toast! 이런 과정을 거치면, ghost와 toast의 거리는 3이 되는 것이다. 이제 느낌을 보면 알겠지만, 두 단어의 거리는 둘 중에 가장 긴 단어의 거리가 최대다. (zzz &gt; effoooooooooooort를 비교한다고 생각해보자) 그렇기 때문에, 두단어의 유사도는 return (longerLength - getDistance(longer, shorter)) / (double) longerLength; 이렇게 나올 것이다. 그렇다면 이것을 알고리즘으로 구현하기 위해선 어떻게 해야할까? 이것을 알고리즘으로 구성하기 위한 단계를 다시 한번 생각해보자. 임의로 이렇게 한다고 치자. 두 단어 = s1, s2 길이 = s1.length, s2.length 두 단어 중에 0인게 있다면, 당연한 말이겠지만, 다른 단어의 길이를 리턴한다. 두개 배열의 For문을 같이 돈다. 만약 s1[n] == s2[m] 이라면 변경에 필요한 거리는 0이 된다. 그렇지 않다면, 대체, 삽입, 수정 중에서 가장 최소의 비용이 되는 방법을 고른다. 이렇게 해서 쌓은 코스트를 배열에 저장한다. 맨마지막 값을 리턴한다. 12345678910111213141516171819202122232425public static int getDistance(String s1, String s2) &#123; int longStrLen = s1.length() + 1; int shortStrLen = s2.length() + 1; // 긴 단어 만큼 크기가 나올 것이므로, 가장 긴단어 에 맞춰 Cost를 계산 int[] cost = new int[longStrLen]; int[] newcost = new int[longStrLen]; // 초기 비용을 가장 긴 배열에 맞춰서 초기화 시킨다. for (int i = 0; i &lt; longStrLen; i++) &#123; cost[i] = i; &#125; // 짧은 배열을 한바퀴 돈다. for (int j = 1; j &lt; shortStrLen; j++) &#123; // 초기 Cost는 1, 2, 3, 4... newcost[0] = j; // 긴 배열을 한바퀴 돈다. for (int i = 1; i &lt; longStrLen; i++) &#123; // 원소가 같으면 0, 아니면 1 int match = 0; if (s1.charAt(i - 1) != s2.charAt(j - 1)) &#123; match = 1; &#125; // 대체, 삽입, 삭제의 비용을 계산한다. int replace = cost[i - 1] + match; int insert = cost[i] + 1; int delete = newcost[i - 1] + 1; // 가장 작은 값을 비용에 넣는다. newcost[i] = Math.min(Math.min(insert, delete), replace); &#125; // 기존 코스트 &amp; 새 코스트 스위칭 int[] temp = cost; cost = newcost; newcost = temp; &#125; // 가장 마지막값 리턴 return cost[longStrLen - 1];&#125; 처음에는 무식하게 재귀함수로 계속해서 호출하는 방법을 썼는데, 이 방법이 더 빠르다고 한다. 암튼 이런 방식으로 한다면, 비교가 엄청빠르다. 한건의 단어를 대상으로 350000건의 사전 단어를 비교하는데, 속도는 재보지 않았지만 꽤 눈깜짝 할 새에 비교가 된다. 안드로이드 (갤럭시 s3 기준) 으로도 무식하게 35000줄짜리 text 파일을 일일이 비교해서 가져오는 데도 꽤 빠른 속도로 비교된다. 사실 이게 String 비교에도 쓰이지만, 유전체의 염기서열 등등의 다양한 배열을 비교하는데 더 많이 쓰인 다고 한다.","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://www.yceffort.kr/tags/development/"}]},{"title":"ReactiveX) Subject","slug":"Reactivex-subject","date":"2018-05-30T15:00:00.000Z","updated":"2018-05-31T03:43:40.000Z","comments":true,"path":"2018/05/31/Reactivex-subject/","link":"","permalink":"https://www.yceffort.kr/2018/05/31/Reactivex-subject/","excerpt":"subject는 옵저버나 observable처러 행동하는 일부 ReactiveX구현체에서만 사용가능한 일종의 프록시다. subject는 옵저버이기 때문에 하나이상의 observable을 구독할 수 있으며, 동시에 observable 이기도 하기 때문에 항목을 하나하나 거치면서 다시 push하고 새로운 항목을 push할 수 있다. 총 4종류의 subject가 있다. ¶AsyncSubject Observable이 마지막으로 push한 값만 push 하고, 원 Observable의 동작이 다 끝나면 동작한다. 아무값도 push되지","text":"subject는 옵저버나 observable처러 행동하는 일부 ReactiveX구현체에서만 사용가능한 일종의 프록시다. subject는 옵저버이기 때문에 하나이상의 observable을 구독할 수 있으며, 동시에 observable 이기도 하기 때문에 항목을 하나하나 거치면서 다시 push하고 새로운 항목을 push할 수 있다. 총 4종류의 subject가 있다. ¶AsyncSubject Observable이 마지막으로 push한 값만 push 하고, 원 Observable의 동작이 다 끝나면 동작한다. 아무값도 push되지 않으면, 이 subject 역시 배출하지 않는다. 또한 맨 마지막 값 바로 뒤에 오는 옵저버에도 값을 전달하는데, 만약 오류에 의해 종류될 경우 이 오류를 그냥 전달한다. ¶BehaviorSubject 옵저버가 BehaviorSubject를 구독하면, 옵저버는 Observable 이 가장 최근에 발행한 항목 (또는 값이 없을 경우 맨처음 값이나 기본값) 을 push하며, 이후 Observable 이 push한 값을 push한다. ¶PublishSubject Subscribe 이후에 push한 항목에 대해서 모두 Observable에게 배출한다. 하지만 이 때문에 subject가 생성되는 시점과 구독하는 시점사이에 빈 공간이 생긴다는 단점이 있다. 따라서 모든 push하는 모든 항목을 받기 위해서는 cold observable을 생성하거나, 아래의 subject를 사용해야 한다. ¶RelaySubject PublishSubject 와 다르게, 구독한 시점에 상관없이 Observable이 push한 모든 항목을 받는다. 다만 재생버퍼의 크기가 특정이상으로 증가할 경우에는, 처음 배출후 지정한 시간이 경과하면 오래된 항목을 제거한다. 또한 onNext사용을 주의해야한다. (순서의 모호함이 있기 때문)","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://www.yceffort.kr/tags/development/"}]},{"title":"ReactiveX) Observable","slug":"ReactiveX-Observable","date":"2018-05-30T15:00:00.000Z","updated":"2018-05-31T03:01:45.000Z","comments":true,"path":"2018/05/31/ReactiveX-Observable/","link":"","permalink":"https://www.yceffort.kr/2018/05/31/ReactiveX-Observable/","excerpt":"보통 일반적인 프로그램의 경우에는, 하나씩 작성된 순서에 따라 로직이 실행되고, 완료되면 또다른 로직이 실행되는 등의 순서가 있음을 알수 있다. 그러나 이와 달리 ReactiveX는 \"Observer\"에 의해 임의의 순서에 따라 병렬적으로 실행되고 나중에 결과나 나온다. 즉 메서드를 호출하는 것이 아니라, Observable안의 데이터를 조회하고, 변환 하는 등의 프로세스를 정의한 후, Observable이 이벤트를 발생시키면 옵저버의 관찰자가 그 순간을 감지하고 준비된 연산을 실행하고 결과를 리턴한다. 그래서 Observabl","text":"보통 일반적인 프로그램의 경우에는, 하나씩 작성된 순서에 따라 로직이 실행되고, 완료되면 또다른 로직이 실행되는 등의 순서가 있음을 알수 있다. 그러나 이와 달리 ReactiveX는 &quot;Observer&quot;에 의해 임의의 순서에 따라 병렬적으로 실행되고 나중에 결과나 나온다. 즉 메서드를 호출하는 것이 아니라, Observable안의 데이터를 조회하고, 변환 하는 등의 프로세스를 정의한 후, Observable이 이벤트를 발생시키면 옵저버의 관찰자가 그 순간을 감지하고 준비된 연산을 실행하고 결과를 리턴한다. 그래서 Observable을 Subscribe한다는 표현을 쓴다. 일반적으로 Observable을 구현하기 위해서 다음과 같은 절차를 거친다. 비동기 호출로 결과를 리턴받고, 필요한 동작을 처리하는 메서드를 정의한다. Observable로 비동기 호출을 정의한다. Subscribe를 통해 옵저버를 Observable에 연결 시킨다. 메서드 호출로 결과가 리턴 될 때마다, 옵저버의 메서더는 리턴 값 또는 항목을 사용해서 연산을 한다. onNext Observable은 새로운 항목을 push 할 때 마다 이 메서드를 호출한다. 이 메서드는 Observable 이 배출하는 항목을 parameter 로 전달 받는다. oNError 기대하는 데이터가 생성되지 않았거나, 오류가 발생할 경우 호출된다. 이 경우 onNext, onCompleted는 호출되지 않는다. onCompleted 마지막 onNext가 호출된 뒤에 호출된다. 더이상 구독을 하지 않으려면 unSubscirbe를 호출한다. Observable이 연속된 항목을 push하는 방법에는 두가지가 있는데 바로 hot과 cold다. hot은 생성되자마자 push하고, cold는 옵저버가 구독할때까지 배출하지 않는다. 이러한 Observable은 연산자와 연결하여 사용할 수 있는데, 이런 연산자들은 리턴된 observable을 변경하여 제공할 수 있다.","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://www.yceffort.kr/tags/development/"}]},{"title":"Bitcoin) BTCD와 bitcoin-cli (bitcoin core)의 차이","slug":"bitcoin-btcd-bitcoin-cli","date":"2018-05-30T15:00:00.000Z","updated":"2018-05-31T02:11:51.000Z","comments":true,"path":"2018/05/31/bitcoin-btcd-bitcoin-cli/","link":"","permalink":"https://www.yceffort.kr/2018/05/31/bitcoin-btcd-bitcoin-cli/","excerpt":"얼마전에 구글 컴퓨팅 엔진을 통해서 bitcoin-cli를 돌려봤었다. 그 때는 CPU 4개에, 램 16기가에, ssd 100기가를 활용해서 약 3일에 걸쳐서 작업을 진행했다. 이러한 비슷한 작업을 GoLang으로 구현한 것이 바로 BTCD다. BTCD와 bitcoin core (이제부터는 bitcoincli라고 하겠다)의 가장 큰 차이점이라고 한다면,** wallet 기능의 유무다.** bitcoincli는 지갑의 기능도 함께 겸하고 있지만, BTCD는 그런 거 없이 오로지 bitcoin의 node를 validation","text":"얼마전에 구글 컴퓨팅 엔진을 통해서 bitcoin-cli를 돌려봤었다. 그 때는 CPU 4개에, 램 16기가에, ssd 100기가를 활용해서 약 3일에 걸쳐서 작업을 진행했다. 이러한 비슷한 작업을 GoLang으로 구현한 것이 바로 BTCD다. BTCD와 bitcoin core (이제부터는 bitcoincli라고 하겠다)의 가장 큰 차이점이라고 한다면,** wallet 기능의 유무다.** bitcoincli는 지갑의 기능도 함께 겸하고 있지만, BTCD는 그런 거 없이 오로지 bitcoin의 node를 validation하는 작업만 할 수 있다. (btcwallet이나 btcgui로 지갑기능을 사용할 수 있다.) 이 차이는 태생적으로 어떤 목적을 가지고 개발됐냐의 차이에서 기인한다. 지갑의 기능이 없지만, BTCD는 bitcoincore에 비해 여러가지로 유용한 장점을 가지고 있다. 컴파일 시간이 짧다. bitcoincli를 설치하고 컴파일 하기 위해 우분투에서 나는 다양한 라이브러리를 오랜시간에 걸쳐 설치해야만 했다. 하지만 컴파일이 굉장히 빠르게 된다는 GoLang의 특징 덕분에, 이러한 컴파일이 수초내로 최소화 된다. 성능이 좋다. bitcoincli는 c++ 기반으로 작성되었다. 때문에, RPC Request를 시스템에서 비용을 많이 소모하는 Thread를 열어서 handling 한다. 하지만 BTCD는 GoLang으로 작성되어 있기 때문에 GoLang의 GoRoutines를 활용하여 많은 양의 동시 request를 쉽고 빠르게 처리할 수 있다. 다른 DB를 사용할 수 있다. bitcoincli와 BTCD 모두 google의 key-value storage인 levelDB를 사용하고 있다. 이와 더불어 BTCD는 다른 DB도 처리할 수 있도록 기능을 제공하고 있다. HTTP post 요청과 웹소켓을 모두 지원한다. Go라는 언어가 bitcoin이나 blockchain에서 처리해야하는 작업들을 Goroutine으로 굉장히 손쉽고 효율적으로 처리할 수 있기 때문에 관련 업종에서 Go를 core기능으로 많이 쓰는것으로 알고 있다.","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://www.yceffort.kr/tags/development/"},{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"}]},{"title":"발음 기반으로 String의 유사도를 비교해 보자.","slug":"compare-string-with-voice","date":"2018-05-30T15:00:00.000Z","updated":"2018-05-31T03:01:45.000Z","comments":true,"path":"2018/05/31/compare-string-with-voice/","link":"","permalink":"https://www.yceffort.kr/2018/05/31/compare-string-with-voice/","excerpt":"앞선포스팅을 통해서 두 String을 문자열 기반으로 분석하였을때. 유사도를 어떻게 측정하는지 알아보았다. 그러나 음성인식으로 String을 비교 했을 때, 다음과 같은 문제에 직면하였다. “Eggs”를 말했을때, Android Voice API는 “X” 를 반환하는 것이 아닌가? String의 물리적인 비교를 해보았을때, 두 비교값은 앞선 나의 방식으로 한다면 당연히 0 일 것이다. 그렇다면, 발음 기반으로 비교를 하고 싶으면 어떻게 할 수 있을까? 아파치 코덱 라이브러리가 그 문제의 해결책을 줄 수 있다. 그 중에서도","text":"앞선 포스팅 을 통해서 두 String을 문자열 기반으로 분석하였을때. 유사도를 어떻게 측정하는지 알아보았다. 그러나 음성인식으로 String을 비교 했을 때, 다음과 같은 문제에 직면하였다. “Eggs”를 말했을때, Android Voice API는 “X” 를 반환하는 것이 아닌가? String의 물리적인 비교를 해보았을때, 두 비교값은 앞선 나의 방식으로 한다면 당연히 0 일 것이다. 그렇다면, 발음 기반으로 비교를 하고 싶으면 어떻게 할 수 있을까? 아파치 코덱 라이브러리 가 그 문제의 해결책을 줄 수 있다. 그 중에서도 사용할 것은 SoundEx 다. 사용법은 다음과 같다. 일단 위의 링크에서 관련 라이브러리를 받아서 Import를 한다. 1234567891011 public static double getVoiceSimilarity(String s1, String s2)&#123; Soundex soundex = new Soundex(); double sim = 0; try &#123; sim = soundex.difference(s1, s2); &#125; catch (Exception e) &#123; sim = 0; &#125; return sim;&#125; 대략 원리는 이렇다. The correct value can be found as follows: Retain the first letter of the name and drop all other occurrences of a, e, i, o, u, y, h, w. Replace consonants with digits as follows (after the first letter): - b, f, p, v → 1 c, g, j, k, q, s, x, z → 2 d, t → 3 l → 4 m, n → 5 r → 6 If two or more letters with the same number are adjacent in the original name (before step 1), only retain the first letter; also two letters with the same number separated by ‘h’ or ‘w’ are coded as a single number, whereas such letters separated by a vowel are coded twice. This rule also applies to the first letter. If you have too few letters in your word that you can’t assign three numbers, append with zeros until there are three numbers. If you have more than 3 letters, just retain the first 3 numbers. 영어는 귀찮으니까 delphi라는 단어로 예를 들어보자. 맨 앞글자를 제외하고 나머지 단어는 냄겨둔다. 결과: d??? ‘A’, E’, ‘I’, ‘O’, ‘U’, ‘H’, ‘W’, ‘Y’는 숫자 0으로 바꾼다. 결과: d0??00 나머지단어는 아래처럼 바꾼다. b, f, p, v → 1 c, g, j, k, q, s, x, z → 2 d, t → 3 l → 4 m, n → 5 r → 6 결과: d04100 연속해서 붙어있는 글자들은 하나를 남기고 지운다. 결과: d0410 0을 다 지운다. 결과: d41 4자리를 만드는 대신, 오른쪽 빈 공간을 0으로 채운다. 최종결과: d410 12System.out.println(soundex(“dellfhai”)); System.out.println(soundex(“delphi”)); 를 하게 되면, 동일하게 d410이 나온다. 싱기방기. 영어의 알파벳별 단어발음을 적극적으로 활용 한 것이다. 보면 알겠지만, 하나의 단어에 대해서 무조건 4글자의 규칙적인 발음표(?) 를 만들어서 리턴한다. 어떤 단어든 최초 앞글자 + lenght 3의 String을 리턴하며, 이런 변환 과정에 있어서 비슷한 자음 (b, p 를 같은 것으로 본다던지) 을 같은것으로 가정하여 판단하는 것이다. 123456public static void main(String[] args) &#123; System.out.println(soundex(\"eggs\")); System.out.println(soundex(\"X\")); System.out.println(soundex(\"Soundex\")); System.out.println(soundex(\"Saundthax\"));&#125; 결과 1234E200 X000 S532 S532 꽤비슷한 단어로 추정하는 것을 볼수 있다. eggs, x 는 스펠링 비교를 했을 때 절대로 같거나 비슷한 단어로 볼수 없지만, 이알고리즘을 사용할 경우 비슷한단어라고 추정이 가능하다.","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://www.yceffort.kr/tags/development/"}]},{"title":"Bitcoin) 비트코인 샀던 후기","slug":"i-bought-bitcoin-and","date":"2018-05-30T15:00:00.000Z","updated":"2018-05-31T03:01:45.000Z","comments":true,"path":"2018/05/31/i-bought-bitcoin-and/","link":"","permalink":"https://www.yceffort.kr/2018/05/31/i-bought-bitcoin-and/","excerpt":"2016년 4월 Posting 비트코인을 드디어 샀다. 깔깔깔깔 원래는 코빗 에서 사려고 했는데, 외국사이트를 한번 이용해보고 싶어서 LocalBitcoins 라는 사이트를 이용했다.이용하기 위해서는 가입 뿐만 아니라, 여권 인증도 필요했는데 약간 귀찮긴 했지만 흥미로웠음. 결제방식은 Paypal로 하고, 5달러치를 결제했더니 0.0084 BTC 이 내 수중으로 들어왔다. 내통장에서 나간돈은 5,871원. 코빗에서는 얼마인지 궁금해서 조회해 봤더니 약 0.003 BTC를 손해봤다. ㅋㅋㅋㅋㅋㅋㅋ 그래도 뭐 거래가 목적이라","text":"2016년 4월 Posting 비트코인을 드디어 샀다. 깔깔깔깔 원래는 코빗 에서 사려고 했는데, 외국사이트를 한번 이용해보고 싶어서 LocalBitcoins 라는 사이트를 이용했다. 이용하기 위해서는 가입 뿐만 아니라, 여권 인증도 필요했는데 약간 귀찮긴 했지만 흥미로웠음. 결제방식은 Paypal로 하고, 5달러치를 결제했더니 0.0084 BTC 이 내 수중으로 들어왔다. 내통장에서 나간돈은 5,871원. 코빗에서는 얼마인지 궁금해서 조회해 봤더니 약 0.003 BTC를 손해봤다. ㅋㅋㅋㅋㅋㅋㅋ 그래도 뭐 거래가 목적이라기 보단, 일단 이 비트코인을 활용해보는게 목적이었으니 상관없다. 내가 LocalBitCoins에서 거래한 사람은 뉴질랜드 사람이었는데, 새벽 12시반 (뉴질랜드시간) 에도 친절하게 거래에 응답해주었다. 나의 개인적인 질문에도 답을 해주었다. 123** dr*** : ** I don’t mine bitcoins. I am just doing trading here. I lived in New Zealand, so mining cost can be very expensive- - - - - -**savurself11: ** Do you mine bitcoin yourself or just engage in bitcoin trade? It is just my curiosity.&lt;/div&gt; 예상은 했지만 그렇다고 한다. 지금은 자러갔는지, 거래 목록에 뜨지는 않지만 상당히 재미난 경험이었다. 자 이제 이걸 가지고 무엇을 해볼까… 영수증 1234567891011121314151617Receipt==== LocalBitcoins.com Receipt Contact====Seller: dr***Buyer: savurself110.00840000 BTC sent to buyer on 2016-04-18 12:11:36+00:00LocalBitcoins.com fee BTC: 0.00008400Payment details as shown to buyer:•Paypal payments from Verified Personal Paypal Accounts Only•Upload a Clear and Readable Quality photo of your ID that match your verified paypal shipping address•Only accept PayPal payments through PAYPAL BALANCE•Name in LocalBitcoins must be the same as in Paypal•Paypal Fee needs to be paid from Buyer•One Trade per dayDue to the high risk of accepting Paypal payment I reserve the right to deny your transaction for any reason.Amount: 5.00 USD==== End ==== 2017년 12월… 그것이 알고싶다의 방영과 이 짤이 나돌면서 나는 비트코인을 샀다는 것을 이제서야 기억하게 되는데… 12345678910Receipt==== LocalBitcoins.com Receipt Contact====Seller: savurself11Buyer: ac***0.00582700 BTC sent to buyer on 2017-12-15 07:39:15+00:00LocalBitcoins.com fee BTC: 0.00005827Payment details as shown to buyer:&#123;&#125;Amount: 102207.91 KRW==== End ==== 오천원 주고 산 비트코인이 무려 10만원이 되어 20배가 되었다.","categories":[],"tags":[{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"},{"name":"diary","slug":"diary","permalink":"https://www.yceffort.kr/tags/diary/"}]},{"title":"Delphi) Some tricks","slug":"some-trick-delphi","date":"2018-05-30T15:00:00.000Z","updated":"2018-05-31T02:11:51.000Z","comments":true,"path":"2018/05/31/some-trick-delphi/","link":"","permalink":"https://www.yceffort.kr/2018/05/31/some-trick-delphi/","excerpt":"정보: github page code highlight는 델파이를 지원하지 않는다. ¶checksum 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function GetCheckSum(FileName: string): DWORD; var F: file of DWORD; P: Pointer; Fsize: DWORD; Buffer: array [0..500] of DWORD; begin FileMode := 0; Assi","text":"정보: github page code highlight는 델파이를 지원하지 않는다. ¶checksum 12345678910111213141516171819202122232425262728function GetCheckSum(FileName: string): DWORD;var F: file of DWORD; P: Pointer; Fsize: DWORD; Buffer: array [0..500] of DWORD;begin FileMode := 0; AssignFile(F, FileName); Reset(F); Seek(F, FileSize(F) div 2); Fsize := FileSize(F) - 1 - FilePos(F); if Fsize &gt; 500 then Fsize := 500; BlockRead(F, Buffer, Fsize); Close(F); P := @Buffer; asm xor eax, eax xor ecx, ecx mov edi , p @again: add eax, [edi + 4*ecx] inc ecx cmp ecx, fsize jl @again mov @result, eax end;end; ¶프로세스 실행 중인지 확인 12345678910111213141516171819202122function CheckProcessRunning(exeFileName: string): Boolean;var ContinueLoop: BOOL; FSnapshotHandle: THandle; FProcessEntry32: TProcessEntry32;begin FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); FProcessEntry32.dwSize := SizeOf(FProcessEntry32); ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32); Result := False; while Integer(ContinueLoop) &lt;&gt; 0 do begin if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) = UpperCase(ExeFileName)) or (UpperCase(FProcessEntry32.szExeFile) = UpperCase(ExeFileName))) then begin Result := True; end; ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32); end; CloseHandle(FSnapshotHandle);end; ¶프로세스 죽이기 123456789101112131415161718192021222324252627function StopProcess(ExeFileName: string) : Integer;const PROCESS_TERMINATE = $0001;var ContinueLoop: BOOL; FSnapshotHandle: THandle; FProcessEntry32: TProcessEntry32;begin Result := 0; FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); FProcessEntry32.dwSize := SizeOf(FProcessEntry32); ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32); while Integer(ContinueLoop) &lt;&gt; 0 do begin if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) = UpperCase(ExeFileName)) or (UpperCase(FProcessEntry32.szExeFile) = UpperCase(ExeFileName))) then Result := Integer(TerminateProcess( OpenProcess(PROCESS_TERMINATE, BOOL(0), FProcessEntry32.th32ProcessID), 0)); ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32); end; CloseHandle(FSnapshotHandle);end; ¶string to html (html parsing) 1234567891011121314151617181920procedure TForm2.ParsingHTML;var IdHTTP: TIdHTTP; Stream: TStringStream;begin IdHTTP := TIdHTTP.Create(nil); Stream := TStringStream.Create; try try IdHTTP.Get(edt1.Text, Stream); JenkinsParsingResult := Stream.DataString; except //exception Raise... (올바르지 않은 주소일때) end; finally tmr1.Enabled := True; Stream.Free; IdHTTP.Free; end;end; ¶File Drag &amp; drop (파일 드래그 앤 드랍) in formcreate 1DragAcceptFiles(Handle, True); 12345678910111213141516procedure TForm2.WMDROPFILES(var Msg: TWMDropFiles);var i, amount: Integer; FileName: array[0..MAX_PATH] of Char;begin inherited; try Amount := DragQueryFile(Msg.Drop, $FFFFFFFF, FileName, MAX_PATH); for i := 0 to (Amount - 1) do begin DragQueryFile(Msg.Drop, i, FileName, MAX_PATH); //FileName에 파일/폴더 path가 들어옵니다. finally DragFinish(Msg.Drop); end;end; ¶get md5 1234567891011121314function GetCheckSum(FileName: string): string;var IdMD5: TIdHashMessageDigest5; FS: TFileStream;begin IdMD5 := TIdHashMessageDigest5.Create; FS := TFileStream.Create(FileName, fmOpenRead or fmShareDenyWrite); try Result := IdMD5.HashStreamAsHex(FS); finally FS.Free; IdMD5.Free; end;end; ¶작업표시줄 제어 ¶auto hide를 always show로 변경 1234567var ABData: TAppBarData;begin ABData.cbSize := SizeOf(TAppBarData); ABData.hWnd := FindWindow('SHELL_TRAYWND', nil); ABData.lParam := LParam(0); SHAppBarMessage($0000000a, ABData); ¶작업표시줄 숨기기. 숨기는게 아니고 레알루다가 없앰 12345var hTaskbar: THandle;begin hTaskbar := FindWindow('Shell_TrayWnd', Nil); ShowWindow(hTaskbar, SW_HIDE); ¶작업표시줄 보이기 12345var hTaskbar: THandle;begin hTaskbar := FindWindow('Shell_TrayWnd', Nil); ShowWindow(hTaskbar, SW_SHOWNORMAL); ¶인터넷 연결상태 확인 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061function CheckInternetConnection(): Boolean;const // Local system has a valid connection to the Internet, but it might or might // not be currently connected. INTERNET_CONNECTION_CONFIGURED = $40; // Local system uses a local area network to connect to the Internet. INTERNET_CONNECTION_LAN = $02; // Local system uses a modem to connect to the Internet INTERNET_CONNECTION_MODEM = $01; // Local system is in offline mode. INTERNET_CONNECTION_OFFLINE = $20; // Local system uses a proxy server to connect to the Internet INTERNET_CONNECTION_PROXY = $04; // Local system has RAS installed. INTERNET_RAS_INSTALLED = $10;var InetState: DWORD; hHttpSession, hReqUrl: HInternet;begin Result:= InternetGetConnectedState(@InetState, 0); if ( Result and ( InetState and INTERNET_CONNECTION_CONFIGURED = INTERNET_CONNECTION_CONFIGURED) ) then begin // so far we ONLY know there's a valid connection. See if we can grab some // known URL ... hHttpSession:= InternetOpen( PChar(Application.Title), // this line is the agent string INTERNET_OPEN_TYPE_PRECONFIG, nil, nil, 0 ); try hReqUrl:= InternetOpenURL( hHttpSession, PChar('http://wwww.example.com'&#123; the URL to check &#125;), nil, 0, 0, 0 ); Result := hReqUrl &lt;&gt; nil; InternetCloseHandle(hReqUrl); finally InternetCloseHandle(hHttpSession); end; end else if ( InetState and INTERNET_CONNECTION_OFFLINE = INTERNET_CONNECTION_OFFLINE ) then Result := False; // we know for sure we are offline.end;","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://www.yceffort.kr/tags/development/"},{"name":"delphi","slug":"delphi","permalink":"https://www.yceffort.kr/tags/delphi/"}]},{"title":"Bitcoin) Bitcoin-core의 Sync를 동기화 해보자.","slug":"tracking-bitcoin-core-sync","date":"2018-05-30T15:00:00.000Z","updated":"2018-05-31T03:01:45.000Z","comments":true,"path":"2018/05/31/tracking-bitcoin-core-sync/","link":"","permalink":"https://www.yceffort.kr/2018/05/31/tracking-bitcoin-core-sync/","excerpt":"bitcoin-core를 설치했다면 bitcoind daemon 에서는 모든 block 정보를 동기화 하게 된다. 이는 꽤나 많은 양이기 때문에, 동기화에 하루이틀 이상의 오랜 시간이 소요된다. 지갑주소 공개합니다. 0.00001 BTC있는데 가져가쉴?? 현재 Sync상황을 알기 위해선, 일단 내 bitcoin-core가 얼마나 동기화 는지 확인 해야 한다. 1 bitcoind getinfo bitcoind getblockcount getinfo 명령어는 bitcoin daemon 의 전반적인 상황을 볼 수 있고,","text":"bitcoin-core를 설치했다면 bitcoind daemon 에서는 모든 block 정보를 동기화 하게 된다. 이는 꽤나 많은 양이기 때문에, 동기화에 하루이틀 이상의 오랜 시간이 소요된다. 지갑주소 공개합니다. 0.00001 BTC있는데 가져가쉴?? 현재 Sync상황을 알기 위해선, 일단 내 bitcoin-core가 얼마나 동기화 는지 확인 해야 한다. 1bitcoind getinfo bitcoind getblockcount getinfo 명령어는 bitcoin daemon 의 전반적인 상황을 볼 수 있고, bitcoind getblockcount는 현재 동기화된 block의 count를 볼 수 가 있다. 281205개가 동기화가 되어 있다. 전체 block의 height는 blockchain.info/ko/ 여기에서 확인할 수 있다. 현재 약 408506개가 있는데, 절반정도 동기화되어 있는 걸 볼 수 있다. 이는 약 11시간에 걸쳐서 동기화한 결과다. 스펙은 아래와 같다. Google Cloud Compute n1-standard-2(vCPU 2개, 7.5GB 메모리) Intel Haswell SSD 75 GB CPU 사용량 ( 사용량이 많이 튀는 시간 대는 내가 환경설정을 세팅할 때다.) 용량 30여만개의 정보들은 약 20기가를 차지한다. (core 포함) 12345678savurself11@bitcoin:~/bitcoin$ df -hFilesystem Size Used Avail Use% Mounted on udev 3.7G 8.0K 3.7G 1%/dev tmpfs 749M 340K 748M 1%/run /dev/sda1 74G 20G 52G 28%/ none 4.0K 0 4.0K 0%/sys/fs/cgroup none 5.0M 0 5.0M 0%/run/lock none 3.7G 0 3.7G 0%/run/shm none 100M 0 100M 0% /run/user 음… 아마 8시간이 더 있으면 동기화가 완료 될 것 같다. 동기화가 완료되는 대로 다시 포스팅 해야지. 8시간후 서버를 켜 놓은지 약 20여 시간이 지났다. 그 사이에 컴퓨터 스펙을 업그레이드 헀다. (CPU 4개, Ram 16gb) 실시간으로 프로세서의 상황을 모니터링하고 있었는데, 너무나 과부하가 걸리고 있어서 어쩔 수 없었다. (내돈 ㅠㅠ) 난 그저 내가 보낸 transaction 을 보고 싶었을 뿐인데, 이를 bitcoin-core로 보기위해서는 어마무시한 노력이 필요하다는 것을 알게 됐다. 1savurself11@bitcoin:~$ bitcoin-cli getinfo 1234567891011121314151617&#123; \"version\" : 90500, \"protocolversion\" : 70002, \"walletversion\" : 60000, \"balance\" : 0.00000000, \"blocks\" : 324389, \"timeoffset\" : -1, \"connections\" : 8, \"proxy\" : \"\", \"difficulty\" : 34661425923.97693634, \"testnet\" : false, \"keypoololdest\" : 1461075368, \"keypoolsize\" : 101, \"paytxfee\" : 0.00000000, \"relayfee\" : 0.00001000, \"errors\" : \"\"&#125; 1savurself11@bitcoin:~$ bitcoin-cli getblockcount 324398 savurself11@bitcoin:~$ 전체 블록인 40만 8천여개 중에 이제 32만개를 돌파하고 있다. 이정도 추세라면 내일이 되어서야 완료될 성 싶다. – 정확히 이틀이 지났다. 어제 32만개라고 포스팅했는데, 간밤에 4만개 밖에 동기화 하지 못했다. ㅠㅠ bitcoin-cli 의 현재 sync 상황을 확인해보자. 12savurself11@bitcoin:~$ bitcoin-cli getblockcount364511 364511 번 까지 왔다. 이 블록은 언제적 블록인지 알아보자. 1savurself11@bitcoin:~$ bitcoin-cli getblockhash 364511 000000000000000014136f884dbf60e529a1cd296d3b321bcac22420c97be03d 블록 해쉬 정보만 있으면, 이 블록에 대한 정보를 가져올 수 있다. 1bitcoin-cli getblock &quot;000000000000000014136f884dbf60e529a1cd296d3b321bcac22420c97be03d&quot; transaction정보는 너무 많아서 생략한다. 1234567&#123; \"time\" : 1436418994, \"nonce\" : 2453655801, \"bits\" : \"1816418e\", \"difficulty\" : 49402014931.22746277, \"chainwork\" : \"0000000000000000000000000000000000000000000847c569a240f670fc6820\", \"previousblockhash\" : \"000000000000000006588b7d0aefa8045d5c6822e975b5d37558610f406880ac\", \"nextblockhash\" : \"0000000000000000015b001aca1ba32cfedc54fe3deae0f4b724b321e3b7b425\"&#125; 12savurself11@bitcoin:~$ date -d @1436418994Thu Jul 9 05:16:34 UTC 2015 2015년 7월 정보까지 따라왔다. 이 정도 추세면 내일 모레쯤이면 따라 잡을 수 있을 것 같기도하다. 동기화가 완료되었다 으헝헣ㅎ 그 사이에 google cloud compute engine(이하 gce) 의 쿠폰 유효기간이 다해 (내 300달러 ㅠㅠ) 과금이 되고 있었다. 4월 21 경에 서버를 돌리다가 과부하 되는 cpu 가 안쓰러워 업그레이드를 했고 5시간 전에는 70기가에서 100기가로 업그레이드를 했다. 참고로 디스크 점유율이 90%를 넘어가면 동기화를 정지한다. 이제 내가 보낸 비트코인정보를 내 서버에서 볼 수 있게 되었다. 내 30만원 ^^ 2018년 현재: 거래량이 많아진 지금은 더 오랜 시간이 소요될 것.","categories":[],"tags":[{"name":"development","slug":"development","permalink":"https://www.yceffort.kr/tags/development/"},{"name":"bitcoin","slug":"bitcoin","permalink":"https://www.yceffort.kr/tags/bitcoin/"}]}]}