---
title: 하드포크와 소프트포크
updated: 2018-07-17 11:25:50
layout: post
tags: [blockchain]
---

Hard Fork vs Soft Fork

[원문](https://www.coindesk.com/information/hard-fork-vs-soft-fork/)

프로그래밍 용어로, '포크'는 오픈 소스 코드 수정을 의미한다. 일반적으로 포크는 원본 소스 코드 수정을 위해 이루어지며, 두 개 버전은 각기 따로 공존하게 된다. 때로는 포크가 프로세스를 테스트 하는 데도 사용하지만 (원본 코드에 영향을 미치지 않기 위해) 암호화폐에서는, 근본적인 변경을 만들어내거나, 혹은 원본과 비슷한 (그러나 동일하지 않은) 특성의 새로운 자산을 만드는데 사용한다.

모든 포크가 의도적으로 되는 이루어 지는 것은 아니다. 널리 사용되고 있는 오픈소스 코드 베이스를 사용하다보면, 모든 노드가 동일한 정보를 복제하지 않을 때 실수로 포크가 발생할 수도 있다. 그러나 일반적으로 포크는 식별되며, 대부분의 암호화폐 포크는 내부 특성에 대한 의견 차이로 인해 발생한다. 

포크에서 염두해야 할 정보는 포크가 '원본의 공유된 역사'를 가지고 있다는 것이다. 각 체인의 기록은 분할이전에는 동일하다.

## 하드포크

하드 포크는 이전 버전을 무효로 만드는 프로토콜로 변경하는 것이다. 예를 들어 포크 되기 이전 버전이 계속해서 실행되면, 새로운 프로토콜과는 다른 데이터가 제공된다. 이로 인해 상당한 혼란과 오류가 발생할 수 있다.

비트 코인을 사용하다보면, 블록 크기, 작업증명을 위해 쓰이는 암호 퍼즐의 어려움, 추가 할 수 있는 정보 제한 등과 같은 정의 매개 변수를 변경하기 위해 하드 포크가 필요하다. 이러한 규칙 중 하나를 변경하면, 새로운 프로토콜에 의해 블록이 허용되지만, 이전 버전에서는 거부되어 심각한 문제로 이어질 수 있다. 

예를 들어, 블록 크기 제한을 1MB에서 4MB로 늘린다고 가정해보자. 새로운 버전에서는 4MB 크기의 블록이 허용되지만, 구 버전에서는 거부되어 심각한 문제로 이어질 수 있다.

> 비트코인 블록 크기에 대한 논란은 [여기](https://en.bitcoin.it/wiki/Block_size_limit_controversy)를 참조하자.

이 4MB 블록이 새롭게 포크되어 업데이트 된 노드에 의해 유효성을 검사하고 블록체인에 추가되었다고 가정해 보자. 이 블록이 포크 되기 이전 버전 프로토콜에 의해 유효성 검사를 한다면 어떻게 될까? 블록을 추가하려고 시도하지만 최신 블록이 유효하지 않다고 결론 내릴 것이다. 그래서 해당 블록을 무시하고, 이전 블록에 유요하다고 판단되는 블록을 추가할 것이다. 이렇게 되면 갑자기 구형 버전의 블록과 새로운 버전의 블록체인 총 두가지가 생기게 된다. 이는 두개 이상의 체인이 무기한으로 평행하게 커질 수 있다는 것을 의미한다.

하드포크는 굉장히 어렵고, 잠재적으로 지저분해질 수도 있다. 그리고 새로운 블록에 소비된 비트코인을 오래된 블록에 다시 사용할 수 있기 때문에 위험하다. (이전 코드를 실행하는 사용자는 새로운 코드에 대한 거래를 감지하지 못하므로 사용된 비트코인을 무효로 간주한다.) 이에 대해 유일한 해결책은 포크 된 지점에서 부터 이전 지점을 포기하는 것이며, 이는 일부 채굴자를 잃어버리게 된다. (거래 자체는 손실되지 않고 다시 할당 된다) 이렇게 하거나, 모든 노드들이 동일하게 새롭게 하드 포크된 프로토콜로 동시에 업데이트 하는 방법이 있다.

대표적인 예가 바로, 비트코인 캐시다.

![hard-fork](https://bitcoin.org/img/dev/en-hard-fork.svg)

## 소프트 포크

하드포크와 달리, 소프트 포크는 이전 버전과 호환이 가능하다. 예를 들어 특정 룰을 강화하거나, 구조에 영향을 미치지 않는 기능을 추가하는 방식으로 프로토콜이 변경되면, 새 버전 블록이 이전 버전 노드에서 허용된다.

비트코인의 경우, 오래된 버전의 채굴자들은 자신들의 블록이 거부될 수 도 있다는 사실을 인지하고 업그레이드 할 것이다. 더 많은 채굴자들이 업그레이드 함에 따라서, 새로운 블록들이 체인에서 가장 길어지고, 오래된 버전의 블록은 분리됨에 따라서 채굴자들은 노드를 업그레이드 할 것이고, 결국 시스템 자체적으로 수정이 이뤄지게 된다. 새버전 블록은 이전 노드와 업그레이드 된 노드 모두에서 허용되므로 새 버전 블록이 결국 승리한다.

예를 들어, 블록크기를 줄이기로 결정했다고 가정해보자. 새로운 버전 노드는 큰 블록을 거부하고 이전 블록 (업데이트 된 버전으로 채굴된)에서 빌드되어 임시 포크를 만든다.

소프트 포크는 이미 여러번 일어 났다. 처음에는 비트코인 블록 크기에 제한이 없었다. 새로운 규칙이 이전 규칙 보다 엄격헀으므로, 블록 크기 1MB 를 제한 두는 것은 소프트 포크를 통해 이루어졌다. 구조를 변경하지 않고 코드를 향상시키는 pay-to-script-hash함수도 소프트 포크를 통해 추가되었다. 이러한 수정은 모두가 아닌 대다수만 업그레이드 해도되므로 실현가능하고, 파괴적이지 않다.

그리고 또한 소프트 포크는 오래된 노드를 실행하는 사용자가 새버전 과 이전 버전 블록을 모두 읽을 것이므로 하드포크에서 발생할 수도 있는 이중 지출 문제가 발생하지 않는다.

![soft-fork](https://bitcoin.org/img/dev/en-soft-fork.svg)